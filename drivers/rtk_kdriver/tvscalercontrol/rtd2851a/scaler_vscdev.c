//Kernel Header file
#ifndef BUILD_QUICK_SHOW
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <linux/delay.h>
#include <generated/autoconf.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/platform_device.h>
#include <linux/mtd/mtd.h>
#include <linux/uaccess.h>
#include <asm/cacheflush.h>
#include <asm-generic/ioctl.h>
#include <asm-generic/errno-base.h>
#include <rtk_kdriver/RPCDriver.h>
#include <linux/pageremap.h>
#include <linux/kthread.h>
#include <uapi/linux/const.h>
#include <linux/mm.h>
#include <linux/string.h>/*memset*/
#include <linux/wait.h>//For wake_up and wait
#include <linux/spinlock_types.h>/*For spinlock*/
#include <rbus/dma_vgip_reg.h>
#include <linux/poll.h>
#include <rtk_dc_mt.h>
#include <tvscalercontrol/vip/localcontrast.h>
#include <rbus/ldspi_reg.h>
#include <linux/hrtimer.h>
#include <linux/version.h>
#include <linux/completion.h>
#include <linux/export.h>
#include <mach/platform.h>
#include <mach/rtk_platform.h>
#include <linux/timer.h>
#include <linux/pm_runtime.h>//for runtime PM
#include <linux/suspend.h>
#ifdef CONFIG_RTK_KDRV_PWM
#include <rtk_kdriver/rtk_pwm.h>
#endif
#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
#include <rtk_kdriver/rtk_qos_export.h>
#endif
#ifdef CONFIG_RTK_LOW_POWER_MODE
#include <rtk_kdriver/rtk-kdrv-common.h>
#endif

// FixMe
//#include "../rtk_gdma_export.h"
//#include "../rtk_osdcomp_driver.h"

//#ifndef CONFIG_KDRIVER_USE_NEW_COMMON
//#include <rtk_kdriver/gal/rtk_gdma_export_user.h>
//#endif
#include <tvscalercontrol/scaler/scalerlib.h>
#include <rtk_kdriver/quick_show/quick_show.h>
//#include <tvscalercontrol/i3ddma/i3ddma.h>
//#include <tvscalercontrol/i3ddma/i3ddma_drv.h>

#include <rbus/sub_vgip_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/timer_reg.h>
#include <rbus/hsd_dither_reg.h>
#include <rbus/osdovl_reg.h>
#include <rbus/h3ddma_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/mdomain_cap_reg.h>
#include <rbus/abl_reg.h>
#include <rbus/iedge_smooth_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/sub_vgip_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/ppoverlay_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/mdomain_cap_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/scaleup_reg.h>
#include <rbus/scaledown_reg.h>
//#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/misc_reg.h>
//#include <rbus/rbus_DesignSpec_MISC_GPIOReg.h>
#include <rbus/tvsb2_reg.h>
#include <rbus/sfg_reg.h>
#include <rbus/vdtop_reg.h>
#include <rbus/mdomain_vi_sub_reg.h>
#include <rbus/h3ddma_hsd_reg.h>
#include <rbus/mpegnr_reg.h>
#include <rbus/color_icm_reg.h>
#include <rbus/yuv2rgb_reg.h>

#include <util/rtk_util_tm.h>
#include <tvscalercontrol/io/ioregdrv.h>
#include <tvscalercontrol/scaler/source.h>
#include <tvscalercontrol/scalerdrv/scalerdrv.h>
#include <tvscalercontrol/scalerdrv/scalermemory.h>
#include <tvscalercontrol/scalerdrv/scalerclock.h>
#include <tvscalercontrol/scalerdrv/overscanTable.h>

#include <tvscalercontrol/pcbsource/pcbSource.h>
#include <tvscalercontrol/scalerdrv/scalerdisplay.h>
#include <tvscalercontrol/scalerdrv/syncproc.h>
#include <tvscalercontrol/scalerdrv/auto.h>
#include <tvscalercontrol/scalerdrv/mode.h>
#include <tvscalercontrol/scalerdrv/scalerip.h>
#include <tvscalercontrol/scalerdrv/framesync.h>
#include <tvscalercontrol/panel/panelapi.h>
#include <tvscalercontrol/adcsource/ypbpr.h>
#include <tvscalercontrol/adcsource/vga.h>
#include <tvscalercontrol/adcsource/adcctrl.h>
#include <tvscalercontrol/hdmirx/hdmifun.h>
#include <tvscalercontrol/vip/ultrazoom.h>
#include <tvscalercontrol/vip/di_ma.h>
#include <tvscalercontrol/vip/scalerColor.h>
#include <tvscalercontrol/vip/st2094.h>
#include <rtk_kdriver/tvscalercontrol/hdmirx/hdmi_vfe.h>
#include <rtk_kdriver/rtk_crt.h>
#include <tvscalercontrol/scaler/scalercolorlib.h>
#include <tvscalercontrol/scalerdrv/adjust.h>
#include <tvscalercontrol/scalerdrv/scaler_2dcvt3d_ctrl.h>
#include <tvscalercontrol/vo/rtk_vo.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle_lib.h>
#include <tvscalercontrol/scalerdrv/pipmp.h>
#include <tvscalercontrol/scalerdrv/power.h>
#include <tvscalercontrol/scalerdrv/inprocvideo.h>
#include <tvscalercontrol/scalerdrv/scaler_i2rnd.h>
#include <tvscalercontrol/scalerdrv/scaler_pst.h>
#ifdef CONFIG_KDRIVER_USE_NEW_COMMON
	#include <VideoRPC_System.h>
#else
	#include <rpc/VideoRPC_System.h>
#endif
#include <vgip_isr/scalerAI.h>
#include <tvscalercontrol/vip/scalerColor_tv006.h>
#include <tvscalercontrol/i3ddma/i3ddma.h>
#include <tvscalercontrol/i3ddma/i3ddma_drv.h>
#include <tvscalercontrol/scaler_drv_verify/scaler_verify_common.h>

#include "scaler_vfedev.h"
#include "scaler_vscdev.h"
#include "scaler_vbedev.h"
#include "scaler_vtdev.h"
#include <tvscalercontrol/avd/avdctrl.h>
#include <rbus/vgip_reg.h>
#include "scaler_vpqmemcdev.h"
#include <linux/freezer.h>
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
#include <tvscalercontrol/scaler/scalervideo.h>
#include <tvscalercontrol/avd/avdctrl.h>
#include "scaler_vfedev.h"
static UINT8 read_buffer_first_flag = 0;
#ifdef CONFIG_DUAL_CHANNEL
static UINT8 sub_read_buffer_first_flag = 0;
#endif
#endif

#if 1//(defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)||defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT))
#include <tvscalercontrol/scalerdrv/scaler_hdr_ctrl.h>
#endif

#ifdef CONFIG_RTK_KDRV_DV
#ifndef	CONFIG_DOLBY_IDK_1_6_1_1
#include "../dolbyvision_edr/dolbyvisionEDR_export.h"
#include "../dolbyvision_edr/dolby_flowCtrl.h"
#endif
#endif

#include <tvscalercontrol/vdc/video.h>
#include <rbus/abl_reg.h>
#include <scaler/vipRPCCommon.h>	/* in common*/

#include <rtd_log/rtd_module_log.h>

#ifdef CONFIG_COMPAT
#include <linux/compat.h>
#define to_user_ptr(x)          compat_ptr((unsigned int)x)
#else
#define to_user_ptr(x)          ((void* __user)(x)) // convert 32 bit value to user pointer
#endif
#else //BUILD_QUICK_SHOW
#include <no_os/printk.h>
#include <no_os/semaphore.h>
#include <no_os/spinlock.h>
#include <no_os/spinlock_types.h>
#include <rtd_log/rtd_module_log.h>
#include <tvscalercontrol/vip/localcontrast.h>
#include <rbus/dma_vgip_reg.h>
#include "vby1/panel_api.h"
#include <rbus/ldspi_reg.h>

#include <tvscalercontrol/scalerdrv/auto.h>

#ifdef CONFIG_RTK_KDRV_PWM
#include <rtk_kdriver/rtk_pwm.h>
#endif
#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
#include <rtk_kdriver/rtk_qos_export.h>
#endif

// FixMe
//#include "../rtk_gdma_export.h"
//#include "../rtk_osdcomp_driver.h"

//#ifndef CONFIG_KDRIVER_USE_NEW_COMMON
//#include <rtk_kdriver/gal/rtk_gdma_export_user.h>
//#endif
#include <tvscalercontrol/scaler/scalerlib.h>
//#include <tvscalercontrol/i3ddma/i3ddma.h>
//#include <tvscalercontrol/i3ddma/i3ddma_drv.h>

#include <rbus/sub_vgip_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/timer_reg.h>
#include <rbus/hsd_dither_reg.h>
#include <rbus/osdovl_reg.h>
#include <rbus/h3ddma_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/mdomain_cap_reg.h>
#include <rbus/abl_reg.h>
#include <rbus/iedge_smooth_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/sub_vgip_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/ppoverlay_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/mdomain_cap_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/scaleup_reg.h>
#include <rbus/scaledown_reg.h>
//#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/misc_reg.h>
//#include <rbus/rbus_DesignSpec_MISC_GPIOReg.h>
#include <rbus/tvsb2_reg.h>
#include <rbus/sfg_reg.h>
#include <rbus/vdtop_reg.h>
#include <rbus/mdomain_vi_sub_reg.h>
#include <rbus/h3ddma_hsd_reg.h>
#include <rbus/mpegnr_reg.h>
#include <rbus/color_icm_reg.h>
#include <rbus/yuv2rgb_reg.h>


#include <tvscalercontrol/io/ioregdrv.h>
#include <tvscalercontrol/scaler/source.h>
#include <tvscalercontrol/scalerdrv/scalerdrv.h>
#include <tvscalercontrol/scalerdrv/scalermemory.h>
#include <tvscalercontrol/scalerdrv/scalerclock.h>

#include <tvscalercontrol/pcbsource/pcbSource.h>
#include <tvscalercontrol/scalerdrv/scalerdisplay.h>
#include <tvscalercontrol/scalerdrv/syncproc.h>
#include <tvscalercontrol/scalerdrv/mode.h>
#include <tvscalercontrol/scalerdrv/scalerip.h>
#include <tvscalercontrol/scalerdrv/framesync.h>
#include <tvscalercontrol/panel/panelapi.h>
#include <tvscalercontrol/adcsource/ypbpr.h>
#include <tvscalercontrol/adcsource/vga.h>
#include <tvscalercontrol/adcsource/adcctrl.h>
#include <tvscalercontrol/hdmirx/hdmifun.h>
#include <tvscalercontrol/vip/ultrazoom.h>
#include <tvscalercontrol/vip/di_ma.h>
#include <tvscalercontrol/vip/scalerColor.h>
#include <tvscalercontrol/vip/st2094.h>
#include <rtk_kdriver/tvscalercontrol/hdmirx/hdmi_vfe.h>
#include <tvscalercontrol/scaler/scalercolorlib.h>
#include <tvscalercontrol/scalerdrv/adjust.h>
#include <tvscalercontrol/scalerdrv/scaler_2dcvt3d_ctrl.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle_lib.h>
#include <tvscalercontrol/scalerdrv/pipmp.h>
#include <tvscalercontrol/scalerdrv/power.h>
#include <tvscalercontrol/scalerdrv/inprocvideo.h>
#include <tvscalercontrol/scalerdrv/scaler_i2rnd.h>
#include <tvscalercontrol/scalerdrv/scaler_pst.h>

#include <tvscalercontrol/vip/scalerColor_tv006.h>
#include <tvscalercontrol/i3ddma/i3ddma_drv.h>
#include <tvscalercontrol/i3ddma/i3ddma.h>
#include "scaler_vfedev.h"
#include "scaler_vscdev.h"

#include "scaler_vbedev.h"
#include "scaler_vtdev.h"
#include <rbus/vgip_reg.h>
#include <rbus/abl_reg.h>
#include <scaler/vipRPCCommon.h>	/* in common*/

bool is_QS_pc_mode(void);
#endif
DECLARE_COMPLETION(vsc_scaler_tsk_completion);
//#define ENABLE_FORCE_PC_MODE 1
extern unsigned char get_MEMC_bypass_status_refer_platform_model(void);
extern void drv_memory_Set_multibuffer_number_pre(UINT8 number);
extern void drv_memory_Set_multibuffer_flag(UINT8 enable);
extern void drv_memory_send_multibuffer_number_to_smoothtoogh(void);
extern void drv_memory_Set_multibuffer_number(UINT8 number);
extern void drvif_I3DDMA_Reset_Vgip_Source_Sel(void);
extern void h3ddma_set_capture_enable(unsigned char chanel,unsigned char enable);
extern enum PANEL_RES_TYPE get_panel_res(void);
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
#ifndef BUILD_QUICK_SHOW

  // VO frame CRC dump
  #ifdef CONFIG_KDRIVER_USE_NEW_COMMON
	#include <VideoRPC_System.h>
  #else
	#include <rpc/VideoRPC_System.h>
  #endif
  #include <linux/kthread.h>
  extern I3DDMA_3DDMA_CTRL_T i3ddmaCtrl;

#endif
  #include <tvscalercontrol/vdc/yc_separation_vpq.h>
#include <rtk_kdriver/rtk_qos_export.h>

extern void scaler_SendDispSize(StructSrcRect outregion);
extern HDMI_COLOR_SPACE_T drvif_Hdmi_GetRawColorSpace(void);
extern unsigned char drvif_Hdmi_GetFrlMode(void);
extern HDMI_bool drvif_Hdmi_SetClkPixelMode(unsigned char pixel_mode);
extern bool Scaler_AVD_GetHalVscConnect(unsigned char a_ucChannel);
extern HDMI_bool drvif_Hdmi_EnableBypassYUV420Engine(unsigned char enable);
extern void vsc_adaptivestream_save_region(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion);


//extern unsigned char get_vdec_securestatus(void);
//extern void set_vdec_securestatus(unsigned char value);
//extern void set_dtv_securestatus(unsigned char status);
/*--------start---------------Sub NN use------------------------------------------------*/
#ifdef CONFIG_ENABLE_SUB_NN

#include <tvscalercontrol/vip/color.h>

#define MAX_SUB_NN_WIDTH 1920
#define MAX_SUB_NN_HEIGHT 1080
#define SUB_NN_CAP_BUF_NUM 3
#define SUB_NN_RAW_DATA_SIZE 3110400
#define _ALIGN(val, align) (((val) + ((align) - 1)) & ~((align) - 1))
#define __4KPAGE  0x1000

typedef struct{
	unsigned char *uncache;
	void *cache;
	unsigned int phyaddr;
	unsigned int size;
	unsigned int getsize;
}SUB_NN_CAPTURE_T;

SUB_NN_CAPTURE_T gt_SubNN_Cap_Buffer[SUB_NN_CAP_BUF_NUM];
static unsigned char sub_vi_bFreezed = FALSE;
static unsigned int  sub_vi_FreezeRegAddr = 0;
static unsigned char sub_NN_freeze_buffer_idx = 0;

extern unsigned short tRGB2YUV_COEF[RGB2YUV_COEF_MATRIX_MODE_Max][RGB2YUV_COEF_MATRIX_ITEMS_Max];

unsigned char sub_path_allocate_nv12_memory(UINT32 width,UINT32 height,unsigned char buffernub);
void sub_path_free_nv12_memory(unsigned int buffernum);
void config_sub_vgip_for_NN_capture(unsigned char src, unsigned char mode);
void config_sub_rgb2yuv_for_NN_capture(void);
extern void drvif_vt_color_ultrazoom_set_scale_down(SIZE *ptInSize, SIZE *ptOutSize);
void config_sub_uzd_for_NN_capture(SIZE* pin_Size, SIZE* pout_Size);
void config_sub_mdomain_vi_for_NN_capture(unsigned int capWid, unsigned int capLen);
void sub_set_NN_buffer_freeze(unsigned char enable);
void sub_get_NN_buffer_addr(unsigned int *pYAddr, unsigned int *pCAddr);
int sub_NN_dump_data_to_file(unsigned int bufferindex, unsigned int size);
void sub_mdomain_vi_for_NN_cap_isr(void);
void sub_path_capture_nv12_for_nn_data_config(unsigned int capWid, unsigned int capLen);
void exit_sub_path_NN_capture(void);
#endif

unsigned char CheckAVDandWebOSInfo_impl(unsigned char display);
unsigned char (*CheckAVDandWebOSInfo)(unsigned char) = CheckAVDandWebOSInfo_impl;//replace function pointer for UT function

unsigned char scaler_force_run_idma_impl(unsigned char display, VSC_INPUT_TYPE_T inputSrctype);
unsigned char (*scaler_force_run_idma)(unsigned char, VSC_INPUT_TYPE_T) = scaler_force_run_idma_impl;//replace function pointer for UT function


unsigned char wait_atv_stable_for_bg_impl(unsigned char display);
unsigned char (*wait_atv_stable_for_bg)(unsigned char) = wait_atv_stable_for_bg_impl;//replace function pointer for UT function

unsigned char rtk_hal_vsc_SetAdaptiveStream(unsigned char bOnOff);
extern int rtk_pwm_set_scaler_source( int h_total, int v_total, int ifold, unsigned char bEnableDB);
#ifdef CONFIG_RTK_SRE_AATS_UCT_AT
//AT V6.2 Patch 2022/03/31 - START
extern unsigned int g_ScalerApplyPQLinear;
extern unsigned int g_vGipChn1_Act_Hsta_Width ;
extern unsigned int g_vGipChn1_Act_Vsta_Length;
extern char         g_ActiveAATS_UCT_GD_On;
extern unsigned long volatile jiffies;
extern unsigned char Scaler_apply_PQ_Linear(unsigned char);
//Required misc/rtd2851a/rtd_logger.c and emcu/rtk_kdv_emcu.c
#if defined(CONFIG_TRACEPOINTS) && defined(CONFIG_ANDROID_VENDOR_HOOKS) && (IS_ENABLED(CONFIG_REALTEK_LOGBUF))
extern unsigned int str_status;
#else
extern void get_local_time(unsigned int* ,unsigned int* , unsigned int* , unsigned int*);
#endif
//AT V6.2 Patch 2022/03/31 - END
#endif
#ifndef UT_flag
/*-------end----------------Sub NN use------------------------------------------------*/
#ifndef BUILD_QUICK_SHOW
#if 0
  extern struct file *file_open(const char *path, int flags, int rights);
  extern int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size);
  extern void file_close(struct file *file);
#else
static struct file * file_open(const char *path, int flags, int rights)
{
    struct file* filp = NULL;
    mm_segment_t oldfs;
    int err = 0;

    oldfs = get_fs();
    set_fs(KERNEL_DS);
    filp = filp_open(path, flags, rights);
    set_fs(oldfs);
    if(IS_ERR(filp)) {
        err = PTR_ERR(filp);
        return NULL;
    }
    return filp;
}

static void file_close(struct file *file)
{
    filp_close(file, NULL);
}

#ifdef CONFIG_ENABLE_SUB_NN

static int file_sync(struct file* file) {
	vfs_fsync(file, 0);
	return 0;
}

#endif
static int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size)
{
#ifndef DISABLE_FILE_RW
    mm_segment_t oldfs;
    int ret;

    oldfs = get_fs();
    set_fs(KERNEL_DS);

    ret = vfs_write(file, data, size, &offset);

    set_fs(oldfs);
    return ret;
#else
	return 0;
#endif
}
#endif
  static void rtkscaler_dump_init(void);
#endif
#endif

#endif

enum{
	NOT_EQUAL = 0,
	ALL_EQUAL,
	ONLY_SHIFT_XY,
	ONLY_SHIFT_X,
	ONLY_SHIFT_Y,
};
void trigger_mute_off(unsigned char display, unsigned char no_delay);

static KADP_VSC_HDR_TYPE_T MAIN_VSC_HDRTYPE = KADP_VSC_HDR_MAXN;//KADP_VSC_HDR_MAXN is SDR //AP set the hdr type

static void Set_Val_main_vsc_hdrtype(KADP_VSC_HDR_TYPE_T hdrtype)
{
	MAIN_VSC_HDRTYPE = hdrtype;
}

KADP_VSC_HDR_TYPE_T Get_Val_main_vsc_hdrtype(void)
{
    return MAIN_VSC_HDRTYPE;
}

void scaler_set_I2D_tracking_in_slow_mode(unsigned char bEnable);//True for fll use old flow

//#include <rtk_kdriver/rtk_platform.h>
void reset_any_srcrect(StructSrcRect *p_srcrect);

#ifndef UT_flag
//#define _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
static struct semaphore GameMode_SCALER_SYNC_Semaphore;//for game mode and scaler sync Semaphore
struct semaphore VSC_Semaphore;
static struct semaphore DM_HDR_Semaphore;
static struct semaphore Force_Run_Idma_Semaphore;
static struct semaphore Low_Delay_Semaphore;
static struct semaphore Double_buffer_Semaphore;
static struct semaphore GameMode_Check_Semaphore;
static struct semaphore set_vsc_film_mode_semaphore;
extern struct semaphore VBE_LowDelay_Semaphore;

static DEFINE_SPINLOCK(muteoff_main_ctrl_flag_Spinlock);/* This spinlock is for DbgSclrFlgTkr.Main_Request_ForceBG_ctrl for */
#ifdef CONFIG_DUAL_CHANNEL
static DEFINE_SPINLOCK(muteoff_sub_ctrl_flag_Spinlock);/* This spinlock is for DbgSclrFlgTkr.Main_Request_ForceBG_ctrl for */
#endif

#ifdef CONFIG_HDR_SDR_SEAMLESS
void dynamic_change_hdr_setting(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format);
void dynamic_change_hdr_setting_hdmi_position(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type);
void dynamic_change_hdr_setting_hdmi_finish(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type);

unsigned char rtk_hal_vsc_SetRGB444Mode(bool bonoff);
#endif
#endif
static struct semaphore HDR_Setting_Semaphore;//this is for HDR V top setting Semaphore
#ifndef UT_flag
static struct semaphore VIDEO_DELAY_Semaphore;//For video delay protection

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
extern void reset_pst_sharemem_buffer(unsigned char display);//set pst sharememocry buffer data for chnage source
extern void set_pst_active_state(unsigned char display, unsigned short state);//set pst active state
#endif


#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
static struct semaphore Orbit_algo_Semaphore;
#endif
#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
static unsigned int cost_time;
#endif
#endif

unsigned char vdo0_connect = FALSE;//means connect vo0 //add by will for live zoom
unsigned char vdo1_connect = FALSE;//means connect vo1 //add by will for live zoom

struct semaphore SetMainOutPutRegion_Semaphore;/*For main set output region Semaphore*/
#ifndef UT_flag
static struct semaphore Main_ResetMode_Semaphore;/*For main reset mode Semaphore*/
#endif
#ifdef CONFIG_DUAL_CHANNEL
struct semaphore SetSubOutPutRegion_Semaphore;/*For sub set output region Semaphore*/
#ifndef UT_flag
static struct semaphore Sub_ResetMode_Semaphore;/*For sub reset mode Semaphore*/
#endif
#endif
#ifndef UT_flag
unsigned char data_access_enable = FALSE;
unsigned char data_access_print_count = 5;//around 100 ms
static struct semaphore DATA_ACCESS_DEBUG_Semaphore;/*For data access Semaphore*/
#endif
void output_data_access_data(void);//print data access data

extern DEBUG_SCALER_VSC_STRUCT DbgSclrFlgTkr; // debug scaler flag tracker
unsigned int rotatedisconnecten = 0;
extern StructSrcRect Scaler_intputRegion_base_scalerTiming[MAX_DISP_CHANNEL_NUM];
extern void drvif_color_Set_DRV_SNR_Clock(SCALER_DISP_CHANNEL display, unsigned char En_flag);
extern void Scaler_AVD_SetHalVscConnect(unsigned char a_ucChannel,bool AvdVscConnect);

//int sub_window_type = 0;
//int subWin_LGowner = 0;
int ATV_forcei3ddma = 0;


//These are for mute on to wait memc already blck video
#define MAX_MEMC_DELAY_BUFFER 45//4.4 frame buffer
unsigned char sync_memc_ready = FALSE;//if TRUE. when mute on to wait memc buffer
int main_InputRegion_0000 = 0;

#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
//unsigned char vsc_video_latency_pattern_enable = 0;
//KADP_VIDEO_RECT_T video_latency_pattern_size = {0, 0, 0, 0};
VSC_VIDEO_LATENCY_PATTERN_T hal_video_latency_pattern_info = {0, 0, {0, 0, 0 ,0}};//record hal info
unsigned char latency_pattern_change = FALSE;//record paramter is change or not
unsigned char latency_pattern_self_test = FALSE;//record paramter is change or not
static DEFINE_SPINLOCK(latency_pattern_spinlock);/*Spin lock no context switch. for control lenterncy info*/
spinlock_t* get_latency_pattern_spinlock(void)
{//this is for  latency_pattern control protection
	return &latency_pattern_spinlock;
}
#endif
#ifndef UT_flag
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
#include <dolby_idk_1_6_1_1/dolby_adapter.h>
#else
extern volatile unsigned int g_picModeUpdateFlag;
#endif
#endif
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
  /* dump VO CRC info to file */
  SCALER_MALLOC_STRUCT scaler_g_pDumpCRC_Send ;
  SCALER_MALLOC_STRUCT scaler_g_pDumpCRC ;
  SCALER_DUMP_STRUCT scaler_DumpCRC_Config;
#endif
#ifndef UT_flag
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
  struct file *scalerfile_DumpCRC = 0 ;
  static struct task_struct *rtkscaler_dumpcrc_tsk;
  static int data;
  static int rtkscaler_dumpcrc_thread(void *arg);
  static unsigned long long f_offset_dumpcrc = 0 ;
  static int rtkscaler_dumpCRC_enable(const char *pattern, int length);
  static void rtkscaler_dumpCRC_disable(void);
#endif
#endif
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
  #define SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX 30
  #define SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX 0
#endif
#ifndef UT_flag
//static unsigned char VSC_Device_Init_Done = FALSE;
//static unsigned char LivezoomMainRerunFlag = FALSE;
//unsigned char DataFramesynclivezoom = FALSE;
//static unsigned char check_only_xy_shift_same_region = FALSE;
//static unsigned char LivezoomOffKeepMainForceBG = FALSE;
//static unsigned char multiview_sub_interlace_flag = 0;//add HDMI sub channel field control @Crixus 20151203

//static unsigned short main_inputregion_x_pre = 0;
//static unsigned short main_inputregion_w_pre = 0;
//static unsigned short main_inputregion_x_ori_pre = 0;
//static unsigned short main_inputregion_w_ori_pre = 0;
//static unsigned char main_check_pre_flag = 0;

//static unsigned char DI_low_delay_flag = FALSE;

//static unsigned char g_ucCheckAVDandWebOSInfoCount = 0xff;

//unsigned char g_ucVSCCheckATVChanelChange;
//unsigned char g_ucVSCATVChanelChangeStart;
//unsigned char g_ucVSCATVSetWinBlankCount;
//unsigned char g_ucVDCDetectStage;

//#define CONFIG_FIXED_VD_27MHZ_960_TO_UZU 1
//#define CONFIG_MDOMAIN_COMPRESSION_ENBLE 1

#define VSC_PROFILE 0
#define _RGB2YUV_m11				0x00
#define _RGB2YUV_m12				0x01
#define _RGB2YUV_m13				0x02
#define _RGB2YUV_m21				0x03
#define _RGB2YUV_m22				0x04
#define _RGB2YUV_m23				0x05
#define _RGB2YUV_m31				0x06
#define _RGB2YUV_m32				0x07
#define _RGB2YUV_m33				0x08
#define _RGB2YUV_Yo_even			0x09
#define _RGB2YUV_Yo_odd			0x0a
#define _RGB2YUV_Y_gain				0x0b
#define _RGB2YUV_sel_RGB			0x0c
#define _RGB2YUV_set_Yin_offset		0x0d
#define _RGB2YUV_set_UV_out_offset	0x0e
#define _RGB2YUV_sel_UV_off			0x0f
#define _RGB2YUV_Matrix_bypass		0x10
#define _RGB2YUV_Enable_Y_gain		0x11


#endif
#define REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD 	1920//960//1440
#define CHECK_AVD_WEBOS_INFO_TIMEOUT (30)

#define MSPG_AUTO_TEST
#define MSPG_AUTO_TEST_REGISTER 0xB8022700
#define MSPG_AUTO_TEST_START 0x00000001
#define MSPG_AUTO_TEST_SUCCESS 0x00000003
#define MSPG_AUTO_TEST_FAIL 0x00000007

#define FILM_DETECT_TO 30 // set film mode detect timeout to 600ms, for as avsync video latency

//#define  _Mantis_74135
//#define  _Mantis_80057
//#define  _Mantis_72744
#define CONFIG_COMPRESSION_MODE_TEST
#ifndef UT_flag
//#define WIN_DELAY_CALLBACK_PROFILE 1


int drivf_I3DDMA_3D_config(void);

void drvif_I3DDMA_Init(void);

#endif
extern void I3DDMA_Parse_HDMI3D_pattern(void);

static void set_default_mcap_format(unsigned char display, VSC_INPUT_TYPE_T inputSrctype);//M Cap 444 or 422
#ifndef UT_flag
//unsigned char Scaler_Set3DMode(unsigned char message, bool muteAudio);

#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
unsigned char rtk_hal_vsc_SetHdr10IdmaEnable(unsigned char bEnable);
#endif

#endif //UT_Flag

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
static void update_arc_cmd_to_ring_buffer_sharemem(unsigned char display, KADP_VIDEO_RECT_T inregion, KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion);

DECLARE_WAIT_QUEUE_HEAD(ARC_CONTROL_WAIT_QUEUE);
static unsigned char main_arc_change_flag = FALSE;//main path arc change run scaler
DEFINE_SPINLOCK(Main_ARC_Parm_Spinlock);/*Spin lock no context switch. This is for copy paramter*/
#ifdef CONFIG_DUAL_CHANNEL
DEFINE_SPINLOCK(Sub_ARC_Parm_Spinlock);/*Spin lock no context switch. This is for copy paramter*/
static unsigned char sub_arc_change_flag = FALSE;//sub path arc change run scaler
#endif
#endif//#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG


#ifndef BUILD_QUICK_SHOW
static DECLARE_WAIT_QUEUE_HEAD(HDMI_4K120_SE_WAIT_QUEUE);
static unsigned char hdmi_4k120_se_trigger_flag = FALSE;
static DECLARE_WAIT_QUEUE_HEAD(VIDEO_DELAY_WAIT_QUEUE);
static unsigned char video_delay_trigger_flag = FALSE;
#endif
KADP_VSC_ROTATE_T ap_main_rotate_type_parm;//for new input output. ap parameter from new hal //for main path
KADP_VIDEO_RECT_T ap_main_inregion_parm;//for new input output. main path ap parameter  from new hal
KADP_VIDEO_RECT_T ap_main_originalInput_parm;//for new input output. main path ap input resolution parameter from new hal
KADP_VIDEO_RECT_T ap_main_outregion_parm;//for new input output. main path ap input resolution parameter from new hal
struct semaphore new_input_output_main_sem;//for main path new input out ap parameter semaphore

#ifdef CONFIG_DUAL_CHANNEL
KADP_VIDEO_RECT_T ap_sub_inregion_parm;//for new input output sub path ap parameter from new hal
KADP_VIDEO_RECT_T ap_sub_originalInput_parm;//for new input output. sub path ap input resolution parameter from new hal
KADP_VIDEO_RECT_T ap_sub_outregion_parm;//for new input output. sub path ap input resolution parameter from new hal
struct semaphore new_input_output_sub_sem;//for sub path new input out ap parameter semaphore
#endif//#ifdef CONFIG_DUAL_CHANNEL

KADP_VIDEO_RECT_T air_mode_save_outregion_parm[MAX_DISP_CHANNEL_NUM];//for air mode save origin output.
unsigned char sub_hidden = FALSE;//for output = 0 sub hidden

//static void apvr_request_run_main_path(void);//This api is for apvr need to run main path again
int sub_shape_type = KADP_VSC_MGF_TYPE_RECTANGLE;
static int sub_mode_type = KADP_VSC_SUB_MODE_PIP;//PIP: Live zoom, magnifire //PBP: Multiview


unsigned char Scaler_CalWindowZoominForAVD(SCALER_DISP_CHANNEL display,VIDEO_RECT_T *inregion, VIDEO_RECT_T *outregion);
unsigned char Scaler_DispWindowZoominForAVD(SCALER_DISP_CHANNEL display, VIDEO_RECT_T inputwin, VIDEO_RECT_T outputwin, unsigned char changetomain);
extern unsigned char check_ott_dolby_update_run(void);
extern void Set_Reply_Zero_Timing_Flag(unsigned char src, unsigned char flag);
extern void modestate_set_display_timing(unsigned char dclk_is_max);
extern unsigned char modestate_decide_display_timing(void);
extern void memc_setting_displayDtiming_framerate(void);

#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
extern void Scaler_AVD_EnableVD27MMode(VD_27M_OVERSAMPLING_MODE mode);
#endif
//===Test NN =================
#ifdef CONFIG_ENABLE_HDMI_NN
extern unsigned char h3ddma_get_NN_read_buffer(unsigned int *a_pulYAddr, unsigned int *a_pulCAddr);
extern void h3ddma_get_NN_read_buffer_test(unsigned int *a_pulYAddr, unsigned int *a_pulCAddr);
extern void I3DDMA_ResetCap0(void);
extern void I3DDMA_ResetCap1(void);
extern int i3ddma_dump_data_to_file(unsigned int bufferindex);
unsigned char g_bNNDumped = FALSE;
#endif
//====End of Test NN=========================

void vsc_adaptivestream_calc_outregion(unsigned char display);

unsigned char scaler_atv_force_run_idma(void);
#ifndef BUILD_QUICK_SHOW
#ifndef UT_flag
static dev_t vsc_devno = 0;//vsc device number
static struct cdev vsc_cdev;
#endif
#endif
//Eric@0809
unsigned char VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
unsigned short virtual_x=0,virtual_y=0,virtual_w=0,virtual_h=0;
unsigned short true_wide=0,true_high=0;
unsigned short shape_wide=0,shape_high=0;


//Game mode cmd checking flow @Cixus 20161204
unsigned int game_mode_cmd_check = 0;

VIDEO_WID_T BLK_WID = 0;
unsigned char bQsmode = FALSE;
static unsigned char game_mode_ignore_cmd_check = 0;

unsigned int smooth_toggle_game_mode_timeout_trigger_flag = 0;
unsigned int smooth_toggle_game_mode_check_cnt = 0;

#ifndef UT_flag
extern unsigned int disp_smooth_variable_setting_flag;
#endif //UT_flag
KADP_SCALER_WIN_CALLBACK_DELAY_INFO g_scaler_win_delay_cb_info;
unsigned int mdomain_input_fast_flag = 0;
UINT8 g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 0;
struct vsc_film_mode_parameter_t film_mode_parameter = {0,0,0};

unsigned int game_mode_cmd_pre = 0;
unsigned int st_game_mode_cmd_pre = 0;
unsigned int idomain_vfreq_pre = 0;
unsigned char scaler_RGB444Mode_pre = 0;
unsigned char vsc_force_rerun_main_scaler = 0;
#ifndef UT_flag
#ifdef WIN_DELAY_CALLBACK_PROFILE
typedef struct _SCALER_WIN_CALLBACK_GLOBAL_PROFILE {//for scaler to check av sync
	UINT32 _90k_cnt;
	KADP_VIDEO_RECT_T  OutputRegion;
	UINT32 uzulcnt;
} _SCALER_WIN_CALLBACK_GLOBAL_PROFILE;

_SCALER_WIN_CALLBACK_GLOBAL_PROFILE gCallback_profile = {0};
#endif
#endif
//unsigned int main_opensourceID = _UNKNOWN_INPUT;
//#ifdef CONFIG_DUAL_CHANNEL
//unsigned int sub_opensourceID = _UNKNOWN_INPUT;
//#endif
//static unsigned char main_VO_smoothtoggle_need_presetting = FALSE;

DECLARE_WAIT_QUEUE_HEAD(FORCEBG_WAIT_QUEUE);
DECLARE_WAIT_QUEUE_HEAD(DEBUGTSK_WAIT_QUEUE);//for runtime pm use wakeup tsk to pending
static unsigned char cur_main_vsc_src_num = 0;//currently run scaler main path vsc source num
static unsigned char cur_sub_vsc_src_num = 0;//currently run scaler sub path vsc source num
//Below is used to check run scaler source already change or not
struct semaphore vsc_src_verify_num_ctrl_sem;
static unsigned char source_connect_verify_num[MAX_DISP_CHANNEL_NUM] =
{//record vsc connect number. verify used. confirm vsc source connect numebt
	0,
#ifdef CONFIG_DUAL_CHANNEL
	0
#endif
};
#ifndef BUILD_QUICK_SHOW
#ifdef CONFIG_ENABLE_SUB_NN
void decide_do_sub_capture_path_for_nn_data(void)
{//hdmi user change edid will disbalee hdmi output sometimes watchdog is not realtime. So change free run before hdmi disable outbput call at vsc task
#ifndef UT_flag
	if((IoReg_Read32(MDOMAIN_VI_SUB_SUB_DMACTL_reg) & MDOMAIN_VI_SUB_SUB_DMACTL_dummy_30_9_mask) == _BIT9)
	{
		//debug_HAL_VT_GetVideoFrameBufferIndex(KADP_VT_VIDEO_WINDOW_0, &vtindex);
		sub_path_capture_nv12_for_nn_data_config(1920,1080);
		IoReg_ClearBits(MDOMAIN_VI_SUB_SUB_DMACTL_reg, _BIT9);
	}
	if((IoReg_Read32(MDOMAIN_VI_SUB_SUB_DMACTL_reg) & MDOMAIN_VI_SUB_SUB_DMACTL_dummy_30_9_mask) == _BIT10)
	{
		sub_get_NN_buffer_addr(&sub_nn_YAddr, &sub_nn_CAddr);
		IoReg_ClearBits(MDOMAIN_VI_SUB_SUB_DMACTL_reg, _BIT10);
	}

	if((IoReg_Read32(MDOMAIN_VI_SUB_SUB_DMACTL_reg) & MDOMAIN_VI_SUB_SUB_DMACTL_dummy_30_9_mask) == _BIT11)
	{
		exit_sub_path_NN_capture();
		IoReg_ClearBits(MDOMAIN_VI_SUB_SUB_DMACTL_reg, _BIT11);
	}

#endif
}
#endif

void decide_to_change_timing_freerun(void)
{//hdmi user change edid will disbalee hdmi output sometimes watchdog is not realtime. So change free run before hdmi disable outbput call at vsc task
#ifndef UT_flag
	if(Get_Vsc_Force_Timing_Freerun())//hdmi trigger free run before avoutput disable
	{
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
		{
			down(&VSC_Semaphore);
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG*/
				drivf_scaler_reset_freerun();//set free run
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				Set_Vsc_Force_Timing_Freerun(FALSE);
				rtd_pr_vsc_info("### vsc free run before hdmi av output disable ###\r\n");
			}
			up(&VSC_Semaphore);
		}
		else
			Set_Vsc_Force_Timing_Freerun(FALSE);
	}
#endif
}



void check_bdb_vgip_driver_request(unsigned char display);
unsigned char decide_do_reset_mode_impl(unsigned char display)
{//vsc task to decide need to do reset mode or not. This is triggered by disconnect return TRUE: means run reset mode
    if(display == SLR_MAIN_DISPLAY)
    {
        if(DbgSclrFlgTkr.Main_Reset_Mode_flag)
        {
            down(&Main_ResetMode_Semaphore);
            DbgSclrFlgTkr.Main_Reset_Mode_flag = FALSE;
            up(&Main_ResetMode_Semaphore);
            down(&VSC_Semaphore);
            drvif_mode_resetmode(SLR_MAIN_DISPLAY);//Reset Mode for Main
#ifndef CONFIG_MEMC_BYPASS
            vbe_disp_game_mode_memc_bypass(0);
#endif
            fw_set_vsc_GameMode(0);
            up(&VSC_Semaphore);
            rtd_pr_vsc_info("\r\n#####func:%s DO Main reset mode#####\r\n", __FUNCTION__);
            return TRUE;
        }
        else
        {
            check_bdb_vgip_driver_request(SLR_MAIN_DISPLAY);//check to enable vgip to support bbd
        }
    }
    else
    {
#ifdef CONFIG_DUAL_CHANNEL
        if(DbgSclrFlgTkr.Sub_Reset_Mode_flag)
        {
            down(&Sub_ResetMode_Semaphore);
            DbgSclrFlgTkr.Sub_Reset_Mode_flag = FALSE;
            up(&Sub_ResetMode_Semaphore);
            down(&VSC_Semaphore);
            drvif_mode_resetmode(SLR_SUB_DISPLAY);//Reset Mode for sub
            up(&VSC_Semaphore);
            rtd_pr_vsc_info("\r\n#####func:%s DO Sub reset mode#####\r\n", __FUNCTION__);
            return TRUE;
        }
        else
        {
            check_bdb_vgip_driver_request(SLR_SUB_DISPLAY);//check to enable vgip to support bbd
        }
#endif
    }
    return FALSE;
}

unsigned char (*decide_do_reset_mode)(unsigned char) = decide_do_reset_mode_impl;



#ifdef MSPG_AUTO_TEST
void decide_do_mspg_auto_test(void)
{
	if(MSPG_AUTO_TEST_START == IoReg_Read32(MSPG_AUTO_TEST_REGISTER))
	{
		#ifdef CONFIG_HW_SUPPORT_DC2H
		if(TRUE == Check_DisplayFrame_isRightColorbar())
		{
			IoReg_Write32(MSPG_AUTO_TEST_REGISTER, MSPG_AUTO_TEST_SUCCESS);
		}else{
			IoReg_Write32(MSPG_AUTO_TEST_REGISTER, MSPG_AUTO_TEST_FAIL);
		}
		#else
		IoReg_Write32(MSPG_AUTO_TEST_REGISTER, MSPG_AUTO_TEST_SUCCESS);
		#endif

	}
}
#endif


void set_latency_pattern_info(VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern)
{
#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
	if(memcmp(&hal_video_latency_pattern_info, &set_video_latency_pattern, sizeof(VSC_VIDEO_LATENCY_PATTERN_T)))
	{//different parameter
		unsigned long flags=0;//for spin_lock_irqsave
		//Eric@20180626 vdec source no need enable dma vgip isr
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_VDEC){
			dma_vgip_dma_vgip_ctrl_RBUS dma_vgip_chn1_ctrl_reg;
			dma_vgip_chn1_ctrl_reg.regValue = IoReg_Read32(DMA_VGIP_DMA_VGIP_CTRL_reg);
			if(!dma_vgip_chn1_ctrl_reg.dma_vact_start_ie)
			{
				dma_vgip_chn1_ctrl_reg.dma_vact_start_ie = 1;
				IoReg_Write32(DMA_VGIP_DMA_VGIP_CTRL_reg, dma_vgip_chn1_ctrl_reg.regValue);
			}
		}
		spin_lock_irqsave(&latency_pattern_spinlock, flags);
		memcpy(&hal_video_latency_pattern_info, &set_video_latency_pattern, sizeof(VSC_VIDEO_LATENCY_PATTERN_T));
		latency_pattern_change = TRUE;
		spin_unlock_irqrestore(&latency_pattern_spinlock, flags);
	}
#endif
}

void set_latency_pattern_self_test(unsigned char b_On)
{
#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
	latency_pattern_self_test = b_On;
#endif
}

void latency_pattern_self_test_run(void)
{
#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
	static unsigned char latency_pattern_self_test_pre = 0;
	static unsigned char pattern_type = KADP_VSC_PATTERN_BLACK;
	VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern;

	if(latency_pattern_self_test_pre != latency_pattern_self_test){
		if(latency_pattern_self_test==0){
			set_video_latency_pattern.bOnOff = 0;
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_BLACK;
			set_video_latency_pattern.overlayWindow.x = 0;
			set_video_latency_pattern.overlayWindow.y = 0;
			set_video_latency_pattern.overlayWindow.w = 3840;
			set_video_latency_pattern.overlayWindow.h = 2160;
			set_latency_pattern_info(set_video_latency_pattern);
			pattern_type = set_video_latency_pattern.bPatternType;
		}
		latency_pattern_self_test_pre = latency_pattern_self_test;
	}

	if(latency_pattern_self_test){
		set_video_latency_pattern.bOnOff = 1;
		if(pattern_type == KADP_VSC_PATTERN_BLACK){
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_WHITE;
			rtd_pr_vsc_emerg("videolatency white\n");
		}else{
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_BLACK;
			rtd_pr_vsc_emerg("videolatency black\n");
		}
		set_video_latency_pattern.overlayWindow.x = 0;
		set_video_latency_pattern.overlayWindow.y = 0;
		set_video_latency_pattern.overlayWindow.w = 3840;
		set_video_latency_pattern.overlayWindow.h = 2160;
		set_latency_pattern_info(set_video_latency_pattern);
		pattern_type = set_video_latency_pattern.bPatternType;
		msleep(1000);
	}
#endif
}
#else
pc_mode_sync_info qs_pc_mode_info = {0,0};
#endif

void sync_pc_mode_info(void)
{//currently only decide yuv422 and enable pc mode or not
#ifndef BUILD_QUICK_SHOW
	pc_mode_sync_info* pc_mode_info = NULL;

	rtd_pr_vsc_debug("src=%x, color space=%x, Get_Val_vsc_run_pc_mode=%x\n", Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE), Get_Val_vsc_run_pc_mode());
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);
	if(pc_mode_info)
	{
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && Get_Val_vsc_run_pc_mode())
		{
			if((drvif_Hdmi_GetColorSpace() == COLOR_RGB) || (drvif_Hdmi_GetColorSpace() == COLOR_YUV444))
			{
				pc_mode_info->input444_pc_mode = 1;
				pc_mode_info->input422_pc_mode = 0;
			}
			else
			{
				pc_mode_info->input444_pc_mode = 0;
				pc_mode_info->input422_pc_mode = 1;
			}
		}
		else
		{
			pc_mode_info->input444_pc_mode = 0;
			pc_mode_info->input422_pc_mode = 0;
		}
	}

#ifdef ENABLE_FORCE_PC_MODE
	// Test PC mode
	rtd_pr_vsc_info("force input444_pc_mode = 1\n");
	pc_mode_info->input444_pc_mode = 1;
#endif
#else
    if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && Get_Val_vsc_run_pc_mode())
    {
        if((drvif_Hdmi_GetColorSpace() == COLOR_RGB) || (drvif_Hdmi_GetColorSpace() == COLOR_YUV444))
        {
            qs_pc_mode_info.input444_pc_mode = 1;
            qs_pc_mode_info.input422_pc_mode = 0;
        }
        else
        {
            qs_pc_mode_info.input444_pc_mode = 0;
            qs_pc_mode_info.input422_pc_mode = 1;
        }
    }
    else
    {
        qs_pc_mode_info.input444_pc_mode = 0;
        qs_pc_mode_info.input422_pc_mode = 0;
    }

#endif
}

#ifndef UT_flag

unsigned char pc_mode_run_422(void)
{
#ifndef BUILD_QUICK_SHOW

	pc_mode_sync_info* pc_mode_info = NULL;
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);
	if(pc_mode_info)
	{
		return pc_mode_info->input422_pc_mode;
	}

    return 0;
#else
    return qs_pc_mode_info.input422_pc_mode;
#endif

}

unsigned char pc_mode_run_444(void)
{
#ifndef BUILD_QUICK_SHOW
	pc_mode_sync_info* pc_mode_info = NULL;
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);


#ifdef ENABLE_FORCE_PC_MODE
	pc_mode_info->input444_pc_mode = 1;
	return 1;
#else
	if(pc_mode_info)
	{
		return pc_mode_info->input444_pc_mode;
	}
	return 0;
#endif

    return 0;
#else
    return qs_pc_mode_info.input444_pc_mode;
#endif

}
#endif
unsigned char get_source_connect_verify_num(unsigned char display)
{
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n get_source_connect_verify_num display(%d) error", display);
		return 0;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n get_source_connect_verify_num display(%d) error", display);
		return 0;
	}
#endif
		return source_connect_verify_num[display];
}

void increase_source_connect_verify_num(unsigned char display)
{
	#define max_source_verify_num 200
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n increase_source_connect_verify_num display(%d) error", display);
		return;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n increase_source_connect_verify_num display(%d) error", display);
		return;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(source_connect_verify_num[display] == max_source_verify_num)
		source_connect_verify_num[display] = 0;
	else
		source_connect_verify_num[display] =  source_connect_verify_num[display] + 1;
	up(&vsc_src_verify_num_ctrl_sem);
}

void set_current_scaler_source_num(unsigned char display)
{//set cur_vsc_src_num form get_source_connect_verify_num
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(display == SLR_MAIN_DISPLAY)
		cur_main_vsc_src_num = source_connect_verify_num[display];
	else
		cur_sub_vsc_src_num = source_connect_verify_num[display];
	up(&vsc_src_verify_num_ctrl_sem);

}

unsigned char compare_rerify_vsc_source_num_result(unsigned char display)
{//return TRUE: source not change.  return false: source change
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n rerify_vsc_source_num_result display(%d) error", display);
		return TRUE;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return TRUE;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(display == SLR_MAIN_DISPLAY)
	{
		if(cur_main_vsc_src_num == source_connect_verify_num[display])
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return TRUE;
		}
		else
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return FALSE;
		}
	}
	else
	{
		if(cur_sub_vsc_src_num == source_connect_verify_num[display])
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return TRUE;
		}
		else
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return FALSE;
		}
	}
}
//Above is used to check run scaler source already change or not


unsigned char rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * poutregion);

static SCALER_VSC_INPUT_REGION_TYPE hal_main_InputRegionType =  INPUT_BASE_ON_TIMING;
StructSrcRect main_dispwin;//Temp record main output info
StructSrcRect main_input_size;
StructSrcRect main_input_timing;
static StructSrcRect main_dispwin_pre = {0, 0, 0, 0};//Record previous main output info
static StructSrcRect main_input_size_pre = {0, 0, 0, 0};//Record previous main output info
static StructSrcRect main_input_timing_pre = {0, 0, 0, 0};//Record previous main input timing info
static StructSrcRect main_dispwin_for_only_xy = {0, 0, 0, 0};//Record previous main output info for apply_only_xy_shift

static KADP_VSC_INPUT_SRC_INFO_T DisplayModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T VencModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T MemoryModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T AveModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};

static DIRECT_VO_FRAME_ORIENTATION main_rotate_mode = DIRECT_VO_FRAME_ORIENTATION_DEFAULT; //this is the current rotate mode from webos
static DIRECT_VO_FRAME_ORIENTATION main_rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT; //this is the last rotate mode from webos

//static unsigned char OuputDisplayMode = FALSE;
//static unsigned char OutputVencMode = FALSE;
//static unsigned char OutputMemoryMode = FALSE;
//static unsigned char OutputAveMode = FALSE;
//static unsigned char RGB444Mode = TRUE;
//static unsigned char VscMuteStatus = FALSE;
unsigned char OutpuLocalDimmingPatMode = FALSE;
unsigned char LocalDimmingDemoCtrlMode = FALSE;
unsigned char LocalDimmingDemoCtrlType = 0;


//static unsigned char Main_AutoRunScaler = FALSE;//Mean when running scaler and set output again. let it auto run scaler. For ATV
//static char Main_Run_Scaler_flag = FALSE;//Mean that Scaler task to run main scaler
//static char Main_Output_Set_flag = FALSE;//Mean that set main setoutput region
//static char Main_force_frc_flag = FALSE;
//static char Main_force_frc_fs_flag = FALSE;
//static char Main_Scaler_Stop_flag = FALSE;//Mean that don't let task run main scaler. Because disconnet
//static char Main_ATV_Go_Smooth_Toggle_flag = FALSE;//Mean ATV current no mute, so can run smooth toggle
//static char Main_smooth_toggle_set_flag = FALSE;//Mean that Scaler task to run smooth toggle
//static char Main_ATV_PassThrought_output_flag = FALSE;//Mean ATV pass throught set output region. Let set winblank off work directly
//static char Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;//Mean that wait mute off to set Main_smooth_toggle_set_flag
//static char Main_Request_ForceBG_ctrl = FALSE;//Mean webos call set main winblank on/off
//static char Main_Reset_Mode_flag = FALSE;//Run Mode Reset mode
//static unsigned char Main_Reset_Mode_flag = FALSE;//Record during runing scaler. Can not mute off
#ifdef CONFIG_DUAL_CHANNEL
static SCALER_VSC_INPUT_REGION_TYPE hal_sub_InputRegionType;
static StructSrcRect sub_dispwin;//Temp record sub output info
static StructSrcRect sub_input_size;
static StructSrcRect sub_input_timing = {0, 0, 0, 0};
static StructSrcRect sub_dispwin_pre = {0, 0, 0, 0};//Record previour sub output info
static StructSrcRect sub_input_size_pre = {0, 0, 0, 0};//Record previour sub output info
#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
static StructSrcRect sub_input_timing_pre = {0, 0, 0, 0};//Record previour sub input timing info
#endif

static KADP_VSC_INPUT_SRC_INFO_T Sub_DisplayModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_VencModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_MemoryModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_AveModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };

//static unsigned char Sub_OuputDisplayMode = FALSE;
//static unsigned char Sub_OutputVencMode = FALSE;
//static unsigned char Sub_OutputMemoryMode = FALSE;
//static unsigned char Sub_OutputAveMode = FALSE;
//static char Sub_Run_Scaler_flag = FALSE;//Mean that Scaler task to run Sub scaler
//static char Sub_Output_Set_flag = FALSE;//Mean that set sub setoutput region
//static char Sub_Scaler_Stop_flag = FALSE;//Mean that don't let task run sub scaler. Because disconnet
//static unsigned char Sub_AutoRunScaler = FALSE;//Mean when running scaler and set output again. let it auto run scaler. For ATV
//static char Sub_ATV_Go_Smooth_Toggle_flag = FALSE;//Mean ATV current no mute, so can run smooth toggle
//static char Sub_Request_ForceBG_ctrl = FALSE;//Mean webos call set sub winblank on/off
//static char Sub_Reset_Mode_flag = FALSE;//Run SUB Reset mode

#endif

extern unsigned short Main_InputRegion_x;
extern unsigned short Main_InputRegion_y;
extern unsigned short Main_InputRegion_w;
extern unsigned short Main_InputRegion_h;
#ifdef CONFIG_DUAL_CHANNEL
extern unsigned short Sub_InputRegion_x;
extern unsigned short Sub_InputRegion_y;
extern unsigned short Sub_InputRegion_w;
extern unsigned short Sub_InputRegion_h;
#endif

extern StructSrcRect Scaler_intputRegion[MAX_DISP_CHANNEL_NUM];
extern StructSrcRect Scaler_intputTiming[MAX_DISP_CHANNEL_NUM];


//unsigned short Main_ATV_InputRegion_x_pre;
//unsigned short Main_ATV_InputRegion_y_pre;
//unsigned short Main_ATV_InputRegion_w_pre;
//unsigned short Main_ATV_InputRegion_h_pre;
#ifdef CONFIG_DUAL_CHANNEL
//unsigned short Sub_ATV_InputRegion_x_pre;
//unsigned short Sub_ATV_InputRegion_y_pre;
//unsigned short Sub_ATV_InputRegion_w_pre;
//unsigned short Sub_ATV_InputRegion_h_pre;
#endif


//unsigned short Main_ATV_OutputRegion_x_pre;
//unsigned short Main_ATV_OutputRegion_y_pre;
//unsigned short Main_ATV_OutputRegion_w_pre;
//unsigned short Main_ATV_OutputRegion_h_pre;
#ifdef CONFIG_DUAL_CHANNEL
//unsigned short Sub_ATV_OutputRegion_x_pre;
//unsigned short Sub_ATV_OutputRegion_y_pre;
//unsigned short Sub_ATV_OutputRegion_w_pre;
//unsigned short Sub_ATV_OutputRegion_h_pre;
#endif

//unsigned char main_winfreeze;
extern struct semaphore *get_setsource_semaphore(void);
extern struct semaphore *get_hdmi_detectsemaphore(void);
#ifndef BUILD_QUICK_SHOW
//unsigned char JPEG_Scaler_SM;
extern void ADC_set_detect_flag(unsigned char enable);
extern void VDC_set_detect_flag(unsigned char enable);
extern unsigned char VDC_get_detect_flag(void);
extern void HDMI_set_detect_flag(unsigned char enable);
#ifndef UT_flag
extern struct semaphore* get_adc_adjustsemaphore(void);
extern struct semaphore *get_adc_detectsemaphore(void);
extern struct semaphore *get_vdc_detectsemaphore(void);
#endif

extern struct semaphore* get_scaler_fll_running_semaphore(void);
#ifndef UT_flag
extern StructDisplayInfo * Get_ADC_Dispinfo(void);
extern StructDisplayInfo * Get_AVD_ScalerDispinfo(void);
extern ModeInformationType *Get_AVD_ScalerTiminginfo(void);
extern StructDisplayInfo * Get_VO_Dispinfo(unsigned char);
#endif
extern struct semaphore* get_vo_infosemaphore(void);
extern unsigned char get_vo_change_flag(unsigned char);
extern void set_vo_change_flag(unsigned char, unsigned char);
extern unsigned char ADC_Check_VSC_VFE_ConnectSrc_Match(unsigned int vsc_src);
#ifndef UT_flag
#ifdef CONFIG_HW_SUPPORT_DC2H
extern unsigned char Check_DisplayFrame_isRightColorbar(void);
#endif
#endif
extern void memc_realcinema_framerate(void);
static UINT8 enable_VSC_GameMode = _DISABLE;
void wait_game_mode_frame_delay_done(void);

#ifndef UT_flag
//void set_vsc_SetCircle_OutputRegion(VIDEO_RECT_T outregion, unsigned short W, unsigned short H, UINT32 num);

//unsigned int  sub_zoom_disp_hpos = 0;//For Scaler use
//unsigned int  sub_zoom_disp_vpos = 0;//For Scaler use
//unsigned int  sub_zoom_disp_hsize = 0;//For Scaler use
//unsigned int  sub_zoom_disp_vsize = 0;//For Scaler use
//static unsigned char sub_wind0000 = FALSE;
//static unsigned char main_wind0000 = FALSE;

//static unsigned char adaptive_stream;
//static unsigned char adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
//static unsigned char line_cnt_no_run_hdmi_check = 0;

//unsigned char hdmi_dolby_vision_flag = FALSE; //for dm function to adjust hdmi dolby vision detect result

struct semaphore Memc_Realcinema_Semaphore;/*For adaptive streaming info Semaphore*/
//char memc_realcinema_run_flag = FALSE;//Run memc mode

struct semaphore Iv2dv_Slow_Tuning_Semaphore;
//char run_iv2dv_slow_tuning_flag = FALSE;//Run iv2dv slow tuning flag

struct semaphore VPQ_DeXC_MEM_Semaphore;/*For Dexc MEM*/

//I2RND semaphore
struct semaphore I2RND_display_Semaphore;
struct semaphore I2RND_Semaphore;
#if 0
#ifdef CONFIG_I2RND_ENABLE
static unsigned char run_i2rnd_flag = 0;
#endif
#endif
#endif //UT_flag


extern unsigned char  fwif_color_get_black_detection_info_tv006(VIP_BlackDetectionInfo* BlackDetectionInfo);
extern unsigned char modestate_decide_display_timing(void);

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
struct timer_list OrbitTimerList;
void Scaler_Orbit_Timer_Init(void);
static unsigned char g_ucTimerInitCount = 0;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
void OrbitTimer(struct timer_list *t);
DEFINE_TIMER(OrbitTimerList, OrbitTimer);
#else
void OrbitTimer(unsigned long data);
DEFINE_TIMER(OrbitTimerList, OrbitTimer, 0, 0);
#endif
#endif

#ifndef UT_flag
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
//struct timer_list OrbitTimerList;
void Scaler_Orbit_Timer_Delete(void);

/* timer init*/
/* init_timer(&OrbitTimerList); */
/* OrbitTimerList.data = ((unsigned long) 0); */
/* OrbitTimerList.function = (void *)OrbitTimer; */
/* OrbitTimerList.expires = jiffies + ORBIT_TIME*HZ; */

#endif

#ifndef CONFIG_DOLBY_IDK_1_6_1_1
// For Dolby letter box DTG change
extern spinlock_t* dolby_letter_box_spinlock(void);
extern unsigned int dolby_proverlay_background_h_start_end;//For letter box use.Record h start and end
extern unsigned int dolby_proverlay_background_v_start_end;//For letter box use. Record V start and end
extern unsigned char letter_box_black_flag;//For letter box use. Need force BG black
extern unsigned char request_letter_dtg_change;//For letter box use. Requesttsk to run
#endif
//
#ifdef CONFIG_I2RND_ENABLE
unsigned char vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
unsigned char vsc_i2rnd_sub_output_mode = 0;
unsigned char vsc_i2rnd_sub_input_type = 0;
unsigned char vsc_i2rnd_sub_input_port = 0;
static unsigned char vsc_i2rnd_initial_done = _DISABLE;
unsigned char vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE; //for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
unsigned char vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_DISABLE;
extern SLR_VOINFO i2rnd_main_voinfo;
extern SLR_VOINFO i2rnd_sub_voinfo;
extern SLR_VOINFO i2rnd_empty_voinfo;
extern unsigned char vo_timing_change_for_adaptive;
//unsigned char i2r_main_pre_resourceIndex = 0;
//unsigned char i2r_sub_pre_resourceIndex = 0;
#ifdef CONFIG_PST_ENABLE
static unsigned char vsc_pst_initial_done = _DISABLE;
#endif
#endif
#endif
#endif
//k4lp new hal api - mute off callback. When mute off to callback api
unsigned char main_muteoff_cb_trigger = FALSE;
unsigned char sub_muteoff_cb_trigger = FALSE;
struct semaphore muteoff_cb_sem;
DEFINE_SPINLOCK(delay_info_cb_spinlock);

unsigned char delay_info_cb_trigger = FALSE;
#ifndef BUILD_QUICK_SHOW
static DECLARE_WAIT_QUEUE_HEAD(MUTEOFF_CB_WAIT_QUEUE);
static DECLARE_WAIT_QUEUE_HEAD(WIN_DELAY_CB_WAIT_QUEUE);
#endif

StructSrcRect get_main_dispwin(void)
{
	return main_dispwin;
}

StructSrcRect get_main_input_size(void)
{
	return main_input_size;
}
StructSrcRect Get_Val_main_dispwin_pre(void)
{
	return main_dispwin_pre;
}
void Set_Val_main_dispwin_pre(StructSrcRect m_disp)
{
	main_dispwin_pre = m_disp;
}
void set_shiftxy_main_inputpre(StructSrcRect input_size )
{
	main_input_size_pre = input_size;
}

void set_shiftxy_main_dispwinpre(StructSrcRect out_size )
{
	main_dispwin_for_only_xy = out_size;
}

DIRECT_VO_FRAME_ORIENTATION Get_Val_ap_roate_mode(void)
{
	return main_rotate_mode;
}
void Set_Val_ap_rotate_mode(DIRECT_VO_FRAME_ORIENTATION mode)
{
	main_rotate_mode = mode;
}

void Set_Val_rotatedisconnecten(unsigned int value)
{
	rotatedisconnecten = value;
}

unsigned int Get_Val_rotatedisconnecten(void)
{
	return rotatedisconnecten;
}
#ifndef BUILD_QUICK_SHOW


#ifdef CONFIG_DUAL_CHANNEL
StructSrcRect Get_Val_sub_dispwin(void)
{
	return sub_dispwin;
}
void Set_Val_sub_dispwin_pre(StructSrcRect m_disp)
{
	sub_dispwin_pre = m_disp;
}
void Set_Val_sub_input_pre(StructSrcRect m_disp)
{
	sub_input_size_pre = m_disp;
}
StructSrcRect Get_Val_sub_input_size(void)
{
    return sub_input_size;
}
void Set_Val_sub_input_size(StructSrcRect m_disp)
{
	sub_input_size = m_disp;
}
#endif

void check_bdb_vgip_driver_request(unsigned char display)
{//request to set vgip to enable bbd
	static unsigned short wait_vo1_timeout = 0;
	static unsigned short wait_vo2_timeout = 0;
	if (display == SLR_MAIN_DISPLAY)
	{
		if(check_bbd_condition_complete(SLR_MAIN_DISPLAY) == FALSE)
		{
			if(Get_Val_BBD_STAGE(SLR_MAIN_DISPLAY) == BBD_FUNCTION_REQ_ENABLE)
			{
				wait_vo1_timeout = 300;//6 second
				Set_Val_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_REQ_VGIP_DRIVER);
			}
			if(Get_Val_BBD_STAGE(SLR_MAIN_DISPLAY) == BBD_FUNCTION_REQ_VGIP_DRIVER)
			{
				if(get_vo_change_flag(0) || (wait_vo1_timeout == 0))
				{//main
					if(wait_vo1_timeout == 0)
					{
						Set_Val_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_DONE);
						rtd_pr_vsc_err("\r### error func:%s main wait vo timeout ###\r\n", __FUNCTION__);
						return;
					}
					down(&VSC_Semaphore);
					drvif_mode_resetmode(display);
					Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FAILURECOUNT, 0);
					down(get_vo_infosemaphore());
					set_bbd_vgip_driver(display,  Get_VO_Dispinfo(0));
					up(get_vo_infosemaphore());
					up(&VSC_Semaphore);
					Set_Val_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_DONE);
				}
				else
				{
					wait_vo1_timeout--;
				}
			}
		}
	}
	else
	{
		if(check_bbd_condition_complete(SLR_SUB_DISPLAY) == FALSE)
		{
			if(Get_Val_BBD_STAGE(SLR_SUB_DISPLAY) == BBD_FUNCTION_REQ_ENABLE)
			{
				wait_vo2_timeout = 300;//6 second
				Set_Val_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_REQ_VGIP_DRIVER);
			}
			if(Get_Val_BBD_STAGE(SLR_SUB_DISPLAY) == BBD_FUNCTION_REQ_VGIP_DRIVER)
			{
				if(get_vo_change_flag(1) || (wait_vo2_timeout == 0))
				{//sub
					if(wait_vo2_timeout == 0)
					{
						Set_Val_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_DONE);
						rtd_pr_vsc_err("\r### error func:%s sub wait vo timeout ###\r\n", __FUNCTION__);
						return;
					}
					down(&VSC_Semaphore);
					drvif_mode_resetmode(display);
					Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_FAILURECOUNT, 0);
					down(get_vo_infosemaphore());
					set_bbd_vgip_driver(display,  Get_VO_Dispinfo(1));
					up(get_vo_infosemaphore());
					up(&VSC_Semaphore);
					Set_Val_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_DONE);
				}
				else
				{
					wait_vo2_timeout--;
				}
			}
		}
	}

}

/****************************Low Power start***********************************/
static struct platform_device *vsc_platform_devs = NULL;//move her for runtime PM
extern unsigned char power_on_enable_dtg_ie2_interrupt(void);//for std and str //enable dtg_ie2 interrupt
extern unsigned char power_on_resume_dtg_ie_interrupt(void);//for str use
static unsigned char video_runtime_pm_enable = 1;//default enable
#ifndef UT_flag
static DEFINE_MUTEX(scaler_pm_rumtime_ctrl);
#endif
int rtk_video_pm_rumtime_suspend(struct device *dev);//rnutime pm close case
int rtk_video_pm_rumtime_resume(struct device *dev);//rnutime pm open case

#define RUNTIME_DEV_NAME "runtime_vscdev"

#define _USE_CHRDEV_
#define REFCNT(pdev) (atomic_read(&pdev->power.usage_count))
#define VIDEO_RUNTIME_PM_STATUS (vsc_platform_devs->dev.power.runtime_status)
#define VIDEO_RUNTIME_PM_AUTO (vsc_platform_devs->dev.power.runtime_auto)
#define VSC_PM_LOG(LEVEL, GROUP, DEV, TYPE, RESULT, VENDOR, MESSAGE) \
    do { \
        rtd_pr_vsc_info("LowPower::%s::%s::%d::%s-%s::%s::%s::%s::%s::status:%d::auto:%d\n", \
                LEVEL, GROUP, REFCNT(DEV), \
                (current->group_leader?current->group_leader->comm:"-"), current->comm, \
                TYPE, RESULT, VENDOR, MESSAGE, VIDEO_RUNTIME_PM_STATUS, VIDEO_RUNTIME_PM_AUTO); \
    } while(0)

unsigned char game_mode_tsk_pending = _low_power_tsk_no_pending; //new_game_mode_tsk
unsigned char game_mode_unmute_tsk_pending = _low_power_tsk_no_pending;//game_mode_unmute_tsk
unsigned char vsc_scaler_tsk_pending = _low_power_tsk_no_pending;//vsc_scaler_tsk
//unsigned char variable_refresh_rate_tsk_pending = _low_power_tsk_no_pending;//variable_refresh_rate_tsk
unsigned char video_muteoff_tsk_pending = _low_power_tsk_no_pending;//video_muteoff_tsk
unsigned char fixlast_line_tsk_pending = _low_power_tsk_no_pending;//fixlast_line_tsk
unsigned char localDimmingDemoCtrl_tsk_pending = _low_power_tsk_no_pending;//localDimmingDemoCtrl_tsk
unsigned char video_debug_tsk_pending = _low_power_tsk_no_pending;//vsc_status_debug_tsk
//unsigned char videoLatency_tsk_pending = _low_power_tsk_no_pending;//videoLatencyCallback_tsk

unsigned char Get_Val_Scaler_Tsk_Status(unsigned char tsk_name)
{
    switch(tsk_name)
    {
        case TSK_NAME_VSC:
            return vsc_scaler_tsk_pending;
            break;

        case TSK_NAME_GAME_MODE:
            return game_mode_tsk_pending;
            break;

        case TSK_NAME_GAME_MODE_UNMUTE:
            return game_mode_unmute_tsk_pending;
            break;

        case TSK_NAME_MUTE_OFF:
            return video_muteoff_tsk_pending;
            break;

        case TSK_NAME_FIX_LAST_LINE:
            return fixlast_line_tsk_pending;
            break;

        case TSK_NAME_LOCAL_DIMMING:
            return localDimmingDemoCtrl_tsk_pending;
            break;

        case TSK_NAME_VIDEO_DEBUG:
            return video_debug_tsk_pending;
            break;

        case TSK_NAME_MAX_DUMMY:
        default:
            return _low_power_tsk_no_pending;
            break;
    }
}

unsigned char (*p_Get_Val_Tsk_Status)(unsigned char) = Get_Val_Scaler_Tsk_Status;//replace Get_Val_Tsk_Status

void Set_Val_Scaler_Tsk_Status(unsigned char tsk_name, unsigned char status)
{
    switch(tsk_name)
    {
        case TSK_NAME_VSC:
            vsc_scaler_tsk_pending = status;
            break;

        case TSK_NAME_GAME_MODE:
            game_mode_tsk_pending = status;
            break;

        case TSK_NAME_GAME_MODE_UNMUTE:
            game_mode_unmute_tsk_pending = status;
            break;

        case TSK_NAME_MUTE_OFF:
            video_muteoff_tsk_pending = status;
            break;

        case TSK_NAME_FIX_LAST_LINE:
            fixlast_line_tsk_pending = status;
            break;

        case TSK_NAME_LOCAL_DIMMING:
            localDimmingDemoCtrl_tsk_pending = status;
            break;

        case TSK_NAME_VIDEO_DEBUG:
            video_debug_tsk_pending = status;
            break;

        case TSK_NAME_MAX_DUMMY:
        default:
            break;
    }
}
void (*p_Set_Val_Tsk_Status)(unsigned char, unsigned char) = Set_Val_Scaler_Tsk_Status;//replace Set_Val_Tsk_Status

void low_power_videofw_ctrl(unsigned int enable)
{//if enable = 1  enable original vo clock.   if enable = 0  disable vo clock.
	int ret = 0;
	unsigned int *pulDataTemp = NULL;
	pulDataTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_LOW_POWER_CONTROL_VIDEOFW);
	if(pulDataTemp)
	{
		*pulDataTemp = htonl(enable);
		if (0 != (ret = Scaler_SendRPC(SCALERIOC_LOW_POWER_CONTROL_VIDEOFW,0,0)))
		{
			rtd_pr_vsc_err("ret=%d, send SCALERIOC_LOW_POWER_CONTROL_VIDEOFW to driver fail !!!\n", ret);
		}
	}
	rtd_pr_vsc_info("### func:%s enable:%d ###\r\n",__FUNCTION__, enable);
}

void video_runtime_pm_memc_suspend(void)
{//mac has no memc 
	//vpq_memc_runtime_suspend_flow();//suspedn memc setting //not ready by will
	//Scaler_MEMC_MEMC_CLK_OnOff(0,0,1);//disable memc clock //not ready by will
}

void disable_imd_isr(void)
{//disable related isr
	//extern void disable_pif_isr(void);//not ready by will


	ppoverlay_dtg_ie_2_RBUS ppoverlay_dtg_ie_2_reg;
	ppoverlay_dtg_ie_RBUS	dtg_ie_reg;
	vgip_int_ctl_RBUS int_ctl_reg;
	h3ddma_interrupt_enable_RBUS h3ddma_interrupt_enable_reg;

	//IoReg_ClearBits(PPOVERLAY_Display_Timing_CTRL1_reg, PPOVERLAY_Display_Timing_CTRL1_disp_en_mask);//disable d domain enable
	//disable_pif_isr();//not ready by will

	ppoverlay_dtg_ie_2_reg.dtg_ie_2 = 0;
	IoReg_Write32(PPOVERLAY_DTG_ie_2_reg, ppoverlay_dtg_ie_2_reg.regValue);//disable d domain isr

	dtg_ie_reg.dtg_ie = 0;
	IoReg_Write32(PPOVERLAY_DTG_ie_reg, dtg_ie_reg.regValue);//disable d domain isr

	int_ctl_reg.regValue = 0;
	IoReg_Write32(VGIP_INT_CTL_reg, int_ctl_reg.regValue);//disable i doamin ie

	h3ddma_interrupt_enable_reg.regValue = 0;
	IoReg_Write32(H3DDMA_Interrupt_Enable_reg, h3ddma_interrupt_enable_reg.regValue);//disable i3 capture ie

	//msleep(30);//wait isr disable ready

}



void resume_imd_isr(void)
{
	//void enable_pif_isr(void);//not ready by will

	vgip_int_ctl_RBUS int_ctl_reg;
	int_ctl_reg.regValue = IoReg_Read32(VGIP_INT_CTL_reg);
	int_ctl_reg.dispi_int_ie = 1;
	int_ctl_reg.vgip_int_ie = 1;
	IoReg_Write32(VGIP_INT_CTL_reg, int_ctl_reg.regValue);//enabe i doamin ie
	low_power_videofw_ctrl(1);//enable video fw ctrl
    //Scaler_MEMC_MEMC_CLK_OnOff(1,1,1);//enable memc clock
	//vpq_memc_runtime_resume_flow();//resume memc setting //not ready by will

	//enable_pif_isr();//not ready by will
#ifdef CONFIG_PM
    power_on_enable_dtg_ie2_interrupt();//for std and str //enable dtg_ie2 interrupt
    power_on_resume_dtg_ie_interrupt();//for str use
#endif
}


void low_power_pending_vsc_task(void)
{//let vsc related task to pending. enter low power mode using
	p_Set_Val_Tsk_Status(TSK_NAME_MUTE_OFF, _low_power_tsk_request_pending);//video_muteoff_tsk
	wake_up(&FORCEBG_WAIT_QUEUE);
    p_Set_Val_Tsk_Status(TSK_NAME_VIDEO_DEBUG, _low_power_tsk_request_pending);//vsc_status_debug_tsk
	wake_up(&DEBUGTSK_WAIT_QUEUE);
	p_Set_Val_Tsk_Status(TSK_NAME_GAME_MODE, _low_power_tsk_request_pending);//new_game_mode_tsk
	p_Set_Val_Tsk_Status(TSK_NAME_GAME_MODE_UNMUTE, _low_power_tsk_request_pending);//game_mode_unmute_tsk
	p_Set_Val_Tsk_Status(TSK_NAME_VSC, _low_power_tsk_request_pending);//vsc_scaler_tsk
	//variable_refresh_rate_tsk_pending = _low_power_tsk_request_pending;//variable_refresh_rate_tsk
	p_Set_Val_Tsk_Status(TSK_NAME_FIX_LAST_LINE, _low_power_tsk_request_pending);//fixlast_line_tsk
	p_Set_Val_Tsk_Status(TSK_NAME_LOCAL_DIMMING, _low_power_tsk_request_pending);//localDimmingDemoCtrl_tsk
	//videoLatency_tsk_pending = _low_power_tsk_request_pending;//videoLatencyCallback_tsk
}

unsigned char low_power_wait_vsc_task_pending_finish_impl(void)
{//wait all task pending
	unsigned int wait_counte = 500;
	while(wait_counte && ((p_Get_Val_Tsk_Status(TSK_NAME_GAME_MODE) !=  _low_power_tsk_pending_finish) || (p_Get_Val_Tsk_Status(TSK_NAME_GAME_MODE_UNMUTE) !=  _low_power_tsk_pending_finish)
        || (p_Get_Val_Tsk_Status(TSK_NAME_VSC) !=  _low_power_tsk_pending_finish) || (p_Get_Val_Tsk_Status(TSK_NAME_MUTE_OFF) !=  _low_power_tsk_pending_finish) || (p_Get_Val_Tsk_Status(TSK_NAME_VIDEO_DEBUG) !=  _low_power_tsk_pending_finish)
        || (p_Get_Val_Tsk_Status(TSK_NAME_FIX_LAST_LINE) !=  _low_power_tsk_pending_finish) || (p_Get_Val_Tsk_Status(TSK_NAME_LOCAL_DIMMING) !=  _low_power_tsk_pending_finish)))
	{
        msleep(1);
        wait_counte--;
	}
    if(!wait_counte)
    {
        rtd_pr_vsc_err("### {err] %s wait timeout (%d %d %d %d %d %d)###\r\n",__FUNCTION__,
            game_mode_tsk_pending, game_mode_unmute_tsk_pending, vsc_scaler_tsk_pending,
            video_muteoff_tsk_pending, fixlast_line_tsk_pending, localDimmingDemoCtrl_tsk_pending);
        return 0;
    }
    return 1;
}

unsigned char (*low_power_wait_vsc_task_pending_finish)(void) = low_power_wait_vsc_task_pending_finish_impl;

void low_power_resume_vsc_task(void)
{//recover related task to work. Exit low power using
    p_Set_Val_Tsk_Status(TSK_NAME_MUTE_OFF, _low_power_tsk_no_pending);//video_muteoff_tsk
    p_Set_Val_Tsk_Status(TSK_NAME_GAME_MODE, _low_power_tsk_no_pending);//new_game_mode_tsk
    p_Set_Val_Tsk_Status(TSK_NAME_GAME_MODE_UNMUTE, _low_power_tsk_no_pending);//game_mode_unmute_tsk
    p_Set_Val_Tsk_Status(TSK_NAME_VSC, _low_power_tsk_no_pending);//vsc_scaler_tsk
    p_Set_Val_Tsk_Status(TSK_NAME_VIDEO_DEBUG, _low_power_tsk_no_pending);//vsc_status_debug_tsk
    //variable_refresh_rate_tsk_pending = _low_power_tsk_request_pending;//variable_refresh_rate_tsk
    p_Set_Val_Tsk_Status(TSK_NAME_FIX_LAST_LINE, _low_power_tsk_no_pending);//fixlast_line_tsk
    p_Set_Val_Tsk_Status(TSK_NAME_LOCAL_DIMMING, _low_power_tsk_no_pending);//localDimmingDemoCtrl_tsk
}


void low_power_scaler_control_clock(unsigned char enable)
{//if enable = 1  recover crt clock.   if enable = 0  disable crt clock
    static unsigned char enter_low_power = 0;//recore finally is low poer or not
    static sys_reg_sys_clken3_RBUS backup_sys_reg_sys_clken3_reg;
    static sys_reg_sys_clken1_RBUS backup_sys_clken1_reg;
    static sys_reg_sys_srst1_RBUS backup_sys_srst1_reg;
    static sys_reg_sys_srst3_RBUS backup_sys_reg_sys_srst3_reg;
    static sys_reg_sys_clken2_RBUS backup_sys_reg_sys_clken2_reg;
    static sys_reg_sys_srst2_RBUS backup_sys_reg_sys_srst2_reg;

    if(enable)
    {//enable  1. enable reset 2.enable  clock
        if(enter_low_power)
        {
            IoReg_Write32(SYS_REG_SYS_SRST3_reg, (backup_sys_reg_sys_srst3_reg.regValue & (SYS_REG_SYS_SRST3_rstn_dispi1_mask | SYS_REG_SYS_SRST3_rstn_dispi2_mask | SYS_REG_SYS_SRST3_rstn_dispi3_mask)) | SYS_REG_SYS_SRST3_write_data_mask);//enable CLKEN_disp_i
            IoReg_Write32(SYS_REG_SYS_SRST1_reg, (backup_sys_srst1_reg.regValue & SYS_REG_SYS_SRST1_rstn_dispd_mask) | SYS_REG_SYS_SRST1_write_data_mask);// enable CLKEN_DISPD
            IoReg_Write32(SYS_REG_SYS_SRST2_reg, (backup_sys_reg_sys_srst2_reg.regValue & (SYS_REG_SYS_SRST2_rstn_dispm_cap_mask)) | SYS_REG_SYS_SRST2_write_data_mask);//enable CLKEN_DISPM_CAP CLKEN_DISPM_CAP
            //IoReg_Write32(SYS_REG_SYS_SRST3_reg, (backup_sys_reg_sys_srst3_reg.regValue & SYS_REG_SYS_SRST3_rstn_disp_lg_pod_mask) | SYS_REG_SYS_SRST3_write_data_mask);//enable CLKEN_disp_lg_pod
            //IoReg_Write32(SYS_REG_SYS_SRST2_reg, (backup_sys_reg_sys_srst2_reg.regValue & (SYS_REG_SYS_SRST2_rstn_dispm_disp_mask | SYS_REG_SYS_SRST2_rstn_dispm_cap_mask)) | SYS_REG_SYS_SRST2_write_data_mask);//enable CLKEN_DISPM_CAP CLKEN_DISPM_DISP

            mdelay(1);
            IoReg_Write32(SYS_REG_SYS_CLKEN3_reg, (backup_sys_reg_sys_clken3_reg.regValue & SYS_REG_SYS_CLKEN3_clken_dispi_mask) | SYS_REG_SYS_CLKEN3_write_data_mask);//enable  CLKEN_DISPI
            IoReg_Write32(SYS_REG_SYS_CLKEN1_reg, (backup_sys_clken1_reg.regValue & SYS_REG_SYS_CLKEN1_clken_dispd_mask) | SYS_REG_SYS_CLKEN1_write_data_mask);// enable CLKEN_DISPD
            //IoReg_Write32(SYS_REG_SYS_CLKEN3_reg, (backup_sys_reg_sys_clken3_reg.regValue & SYS_REG_SYS_CLKEN3_clken_disp_lg_pod_mask) | SYS_REG_SYS_CLKEN3_write_data_mask);//enable CLKEN_disp_lg_pod
            //IoReg_Write32(SYS_REG_SYS_CLKEN2_reg, (backup_sys_reg_sys_clken2_reg.regValue & (SYS_REG_SYS_CLKEN2_clken_dispm_disp_mask | SYS_REG_SYS_CLKEN2_clken_dispm_cap_mask)) | SYS_REG_SYS_CLKEN2_write_data_mask);//enable CLKEN_DISPM_CAP CLKEN_DISPM_DISP
            IoReg_Write32(SYS_REG_SYS_CLKEN2_reg, (backup_sys_reg_sys_clken2_reg.regValue & (SYS_REG_SYS_CLKEN2_clken_dispm_cap_mask)) | SYS_REG_SYS_CLKEN2_write_data_mask);//enable CLKEN_DISPM_CAP CLKEN_DISPM_CAP

            enter_low_power = 0;
        }
    }
    else
    {//disable 1.disable  clock 2. 1. disable reset
        if(enter_low_power == 0)
        {
            backup_sys_reg_sys_clken3_reg.regValue =  IoReg_Read32(SYS_REG_SYS_CLKEN3_reg);
            backup_sys_clken1_reg.regValue =  IoReg_Read32(SYS_REG_SYS_CLKEN1_reg);
            backup_sys_srst1_reg.regValue =  IoReg_Read32(SYS_REG_SYS_SRST1_reg);
            backup_sys_reg_sys_srst3_reg.regValue =  IoReg_Read32(SYS_REG_SYS_SRST3_reg);
            backup_sys_reg_sys_clken2_reg.regValue =  IoReg_Read32(SYS_REG_SYS_CLKEN2_reg);
            backup_sys_reg_sys_srst2_reg.regValue =  IoReg_Read32(SYS_REG_SYS_SRST2_reg);


            IoReg_Write32(SYS_REG_SYS_CLKEN3_reg, SYS_REG_SYS_CLKEN3_clken_dispi_mask);//disable  CLKEN_DISPI

            IoReg_Write32(SYS_REG_SYS_CLKEN1_reg, SYS_REG_SYS_CLKEN1_clken_dispd_mask);// disable CLKEN_DISPD
            IoReg_Write32(SYS_REG_SYS_SRST1_reg, SYS_REG_SYS_SRST1_rstn_dispd_mask);// disable CLKEN_DISPD

            //IoReg_Write32(SYS_REG_SYS_CLKEN3_reg, SYS_REG_SYS_CLKEN3_clken_disp_lg_pod_mask);//disable CLKEN_disp_lg_pod
            //IoReg_Write32(SYS_REG_SYS_SRST3_reg, SYS_REG_SYS_SRST3_rstn_disp_lg_pod_mask);//disable CLKEN_disp_lg_pod

            IoReg_Write32(SYS_REG_SYS_SRST3_reg, SYS_REG_SYS_SRST3_rstn_dispi1_mask | SYS_REG_SYS_SRST3_rstn_dispi2_mask | SYS_REG_SYS_SRST3_rstn_dispi3_mask);//disable CLKEN_disp_i

            //IoReg_Write32(SYS_REG_SYS_CLKEN2_reg, SYS_REG_SYS_CLKEN2_clken_dispm_disp_mask | SYS_REG_SYS_CLKEN2_clken_dispm_cap_mask);//disable CLKEN_DISPM_CAP CLKEN_DISPM_DISP
            //IoReg_Write32(SYS_REG_SYS_SRST2_reg, SYS_REG_SYS_SRST2_rstn_dispm_disp_mask | SYS_REG_SYS_SRST2_rstn_dispm_cap_mask);//disable CLKEN_DISPM_CAP CLKEN_DISPM_DISP
            IoReg_Write32(SYS_REG_SYS_CLKEN2_reg,  SYS_REG_SYS_CLKEN2_clken_dispm_cap_mask);//disable  CLKEN_DISPM_CAP  does not disable m disp for offline
            IoReg_Write32(SYS_REG_SYS_SRST2_reg,  SYS_REG_SYS_SRST2_rstn_dispm_cap_mask);//disable CLKEN_DISPM_CAP does not disable m disp for offline
            enter_low_power = 1;//save low power status
        }
    }

}

//extern void vpq_vbe_low_power_mode_suspend(void); //not ready by will
//extern void vpq_vbe_low_power_mode_resume(void); //not ready by will 
extern unsigned char vpq_set_VPQ_TSK_Stop(unsigned char stop_en); //low power not ready
static void set_hdr_dm_clk(bool enable)
{
	enum CRT_CLK clken = enable ? CLK_ON : CLK_OFF;
	unsigned int src_type = 0;

	CRT_CLK_OnOff(DOLBY_HDR, clken, &src_type);
}

int rtk_video_pm_rumtime_suspend(struct device *dev)
{//rnutime pm close case
    extern void vbe_disp_suspend(void);
    extern int GAL_Runtime_Suspend(void);
    extern unsigned char vpq_get_VPQ_TSK_Stop(void); //low power not ready
    unsigned int cur_time1 = 0, cur_time2 = 0;
    unsigned int cost_time1 = 0, cost_time2 = 0, cost_vpq_time = 0;
    unsigned char vsc_pending_result = 0;
	if(video_runtime_pm_enable)
    {
#ifndef UT_flag
        mutex_lock(&scaler_pm_rumtime_ctrl);
#endif
        Set_Val_scaler_low_power_mode(1);//enter low power mode
        rtd_pr_vsc_notice("debug @(%s:%d) disable video data path clock\n", __FUNCTION__, __LINE__);
        cur_time1 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
        vpq_set_VPQ_TSK_Stop(1);//freeze pa task //low power not ready
        low_power_pending_vsc_task();//pending all task
        GAL_Runtime_Suspend();//disable update osd //low power not ready
        vsc_pending_result = low_power_wait_vsc_task_pending_finish();
        cost_time1 = drvif_report_cost_time_by_counter(cur_time1);
        //rtd_pr_vsc_notice("debug %s wait vsc task pending time 0x%x ms\n", __FUNCTION__, drvif_report_cost_time_by_counter(cur_time));
        if(vsc_pending_result)
        {//vsc realted task pending success
            IoReg_ClearBits(MDOMAIN_DISP_Disp_main_enable_reg, MDOMAIN_DISP_Disp_main_enable_main_disp_en_mask);//disable MAIN_Disp_En to avoid M-disp reading data from DDR
            IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, MDOMAIN_DISP_DDR_MainSubCtrl_disp1_double_apply_mask);//apply doublue buffer

            vbe_disp_suspend();//save d domain register
            //fwif_color_set_LD_RPM_suspend(0);	// LD suspend //not ready by will
            video_runtime_pm_memc_suspend();//memc suspend
            disable_imd_isr();//disable isr
            cur_time2 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
            low_power_videofw_ctrl(0);//disable vodma
            while(!vpq_get_VPQ_TSK_Stop())//low power not ready
            {//wait vpq freeze
                udelay(50);
                if(drvif_wait_timeout_check_by_counter(cur_time2, 1000))
                {
                    rtd_pr_vsc_err("### [err] wait VPQ related task pending fail ###\r\n");
#ifndef UT_flag
                    mutex_unlock(&scaler_pm_rumtime_ctrl);
#endif
                    return -1;
                }
            }
            cost_vpq_time = drvif_report_cost_time_by_counter(cur_time1);//calculate vpq time

            while(!drvif_wait_time_by_counter(cur_time2, 42))
            {//wait at least 24hz one frame
                udelay(50);
                if(drvif_wait_timeout_check_by_counter(cur_time2, 1000))
                {
                    rtd_pr_vsc_err("### [err] wait isr disable timeout fail###\r\n");
#ifndef UT_flag
                    mutex_unlock(&scaler_pm_rumtime_ctrl);
#endif
                    return -1;
                }
            }
            cost_time2 = drvif_report_cost_time_by_counter(cur_time2);

            IoReg_ClearBits(PPOVERLAY_Display_Timing_CTRL1_reg, PPOVERLAY_Display_Timing_CTRL1_disp_en_mask);//disable d domain enable
            //vpq_vbe_low_power_mode_suspend(); // VPQ VBE suspend //not ready by will
            low_power_scaler_control_clock(0);//disable video path clock
            set_hdr_dm_clk(0);//disable dm and composer clk
        }
        else
        {
            rtd_pr_vsc_err("### [err] scaler related task pending fail###\r\n");
        }
#ifndef UT_flag
        mutex_unlock(&scaler_pm_rumtime_ctrl);
#endif
        rtd_pr_vsc_notice("debug %s cost time vpq_fre:(0x%x ms) vsc_fre:(0x%x ms) isr:(0x%x ms) total:(0x%x ms)\n", __FUNCTION__, cost_vpq_time, cost_time1, cost_time2, drvif_report_cost_time_by_counter(cur_time1));
    }
    else
    {
        rtd_pr_vsc_notice("debug @(%s:%d) force not run \n", __FUNCTION__, __LINE__);
    }

    VSC_PM_LOG("info", "video", dev, "suspend", "ok", "realtek", "system pm suspend");
    return 0;
}

void check_to_run_rtk_video_pm_rumtime_resume_driver(unsigned char CallByDevice)
{//check need to run video_pm_rumtime_resume  driver control or not
	if(Get_Val_scaler_low_power_mode())
	{
		extern unsigned char low_power_lane_power_resume(void);//only for runtime PM low power
		extern int GAL_Runtime_Resume(void);//osd upadate //low power not ready
		extern void vbe_disp_first_resume(void);//vbe resume
		extern void vbe_disp_resume(void);//vbe resume
#ifndef UT_flag
		mutex_lock(&scaler_pm_rumtime_ctrl);
#endif
		if(Get_Val_scaler_low_power_mode())
		{
			rtd_pr_vsc_notice("debug @(%s) CallByDevice:%d enable video data path clock\n", __FUNCTION__, CallByDevice);
			set_hdr_dm_clk(1);//enable dm and composer clk
			low_power_scaler_control_clock(1);//enable video path clock
			//vpq_vbe_low_power_mode_resume(); // VPQ VBE resume //not ready by will
#ifdef CONFIG_PM
			vbe_disp_first_resume();//d domain resume
			vbe_disp_resume();//d domain resume
			low_power_lane_power_resume();//only for runtime PM low power
#endif
			GAL_Runtime_Resume();//osd resume //low power not ready
			enable_clock_mux_new_mode();//recover new mode
			resume_imd_isr();//isr resume
			vpq_set_VPQ_TSK_Stop(0);//unfreeze pa task //low power not ready
			low_power_resume_vsc_task();//task resume
			//fwif_color_set_LD_RPM_resume(0);	// LD resume //not ready by will
			Set_Val_scaler_low_power_mode(0);//exit low power mode
		}
#ifndef UT_flag
		mutex_unlock(&scaler_pm_rumtime_ctrl);
#endif
	}
}

int rtk_video_pm_rumtime_resume(struct device *dev)
{//rnutime pm open case

	if(video_runtime_pm_enable)
	{
		check_to_run_rtk_video_pm_rumtime_resume_driver(1);//check need to run driver or not
	}
	else
	{
		rtd_pr_vsc_notice("debug @(%s:%d) force not run \n", __FUNCTION__, __LINE__);
	}
	VSC_PM_LOG("info", "video", dev, "resume", "ok", "realtek", "system pm resume");
	return 0;
}

void vsc_runtime_pm_get(void)
{//for device open
	pm_runtime_get_sync(&vsc_platform_devs->dev);
	VSC_PM_LOG("info", "video", (&vsc_platform_devs->dev), "open", "ok", "realtek", "device opened PM");
}

void vsc_runtime_pm_put(void)
{//for device close
	pm_runtime_put(&vsc_platform_devs->dev);
	VSC_PM_LOG("info", "video", (&vsc_platform_devs->dev), "close", "ok", "realtek", "device close PM");
}



/****************************Low Power end***********************************/
unsigned int Get_Val_smooth_toggle_game_mode_timeout_trigger_flag_impl(void)
{
    return smooth_toggle_game_mode_timeout_trigger_flag;
}

unsigned int (*Get_Val_smooth_toggle_game_mode_timeout_trigger_flag)(void) = Get_Val_smooth_toggle_game_mode_timeout_trigger_flag_impl;

void Set_Val_smooth_toggle_game_mode_timeout_trigger_flag(unsigned int flag)
{
    smooth_toggle_game_mode_timeout_trigger_flag = flag;
}

//static unsigned char vpq_ld_first_boot = FALSE; //dc off/on condition, set at resume
static void vpq_led_ld_ctrl(void);
extern struct semaphore *Get_Val_VPQ_ld_running_Semaphore(void);
extern unsigned char Get_Val_vpq_ld_running_flag(void);//get vpq_ld_running_flag value
extern void Set_Val_vpq_ld_running_flag(unsigned char flag);//control vpq_ld_running_flag value
//extern unsigned int ld_time_tick;
extern unsigned char Get_Val_vpq_led_LDEnable(void);//vpq_led_LDEnable
extern void drvif_HAL_VPQ_LED_LDEnable(unsigned char bCtrl);

#ifdef CONFIG_RTK_KDRV_PWM
static void vpq_led_ld_ctrl(void)
{//led ld control
#ifndef UT_flag//need PQ to confirm

	static unsigned int ld_debug_cnt = 0;
	if(Get_Val_vpq_ld_running_flag() == TRUE){

		if(DbgSclrFlgTkr.vpq_ld_first_boot == FALSE /*||(((IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - ld_time_tick)/90) > 1100)*/){

			if(DbgSclrFlgTkr.vpq_ld_first_boot == TRUE){ // protect first enter after resume 1.1sec, otherwise no need to check time
				//rtd_pr_vsc_notice("[%s] ld tick time = %d (cnt:%d)\n", __FUNCTION__, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - ld_time_tick)/90,
				//	ld_debug_cnt);
			}
			DbgSclrFlgTkr.vpq_ld_first_boot = FALSE;
			down(Get_Val_VPQ_ld_running_Semaphore());
			drvif_HAL_VPQ_LED_LDEnable(Get_Val_vpq_led_LDEnable());
			Set_Val_vpq_ld_running_flag(FALSE);
			up(Get_Val_VPQ_ld_running_Semaphore());
			ld_debug_cnt = 0;
		}else{
			ld_debug_cnt++;
		}
	}
#endif
}
#endif


#ifndef UT_flag
unsigned int vsc_poll(struct file *filp, struct poll_table_struct *wait){
/*
       poll_wait(filp, &mute_off_callback, wait);
       return POLLIN | POLLRDNORM;
*/
		return 0;
}

spinlock_t* get_delay_info_cb_spin_lock(void)
{//this is for delay_info_cb_trigger flag protection
	return &delay_info_cb_spinlock;
}
#endif //UT_flag

void update_win_apply_delay_info_for_cb(unsigned char display, KADP_SCALER_WIN_CALLBACK_DELAY_INFO *p_scaler_win_delay_cb_info)
{
	if(display == SLR_MAIN_DISPLAY)
	{
		if(g_scalerForceUpdate_CB_by_InputOutput_Region_Flag){
			memcpy((void*) p_scaler_win_delay_cb_info, (void*) &g_scaler_win_delay_cb_info, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO));
			Scaler_Reset_ForceUpdate_Callback_Delay_Info();
		}else{
			Scaler_Fulfill_Callback_Delay_Info(p_scaler_win_delay_cb_info);
		}
		if(p_scaler_win_delay_cb_info->delayTime > 200)
			p_scaler_win_delay_cb_info->delayTime = 16;


#ifdef WIN_DELAY_CALLBACK_PROFILE
		if((p_scaler_win_delay_cb_info->OutputRegion.x == gCallback_profile.OutputRegion.x) &&
			(p_scaler_win_delay_cb_info->OutputRegion.y == gCallback_profile.OutputRegion.y) &&
			(p_scaler_win_delay_cb_info->OutputRegion.w == gCallback_profile.OutputRegion.w) &&
			(p_scaler_win_delay_cb_info->OutputRegion.h == gCallback_profile.OutputRegion.h))
		{
			unsigned int current_90K=0;

			current_90K = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);

			rtd_pr_vsc_err("[PROFILE_CALLBACK] c90k=%x. 90k=%x, diff=%d, (%d.%d.%d.%d)(line:%d) \n", current_90K, gCallback_profile._90k_cnt, (current_90K-gCallback_profile._90k_cnt)/90,
				gCallback_profile.OutputRegion.x, gCallback_profile.OutputRegion.y, gCallback_profile.OutputRegion.w, gCallback_profile.OutputRegion.h,
				gCallback_profile.uzulcnt);
		}else{
			rtd_pr_vsc_err("[PROFILE_CALLBACK] Cannot Match!! (%d.%d.%d.%d) / (%d.%d.%d.%d)\n",
				p_scaler_win_delay_cb_info->OutputRegion.x, p_scaler_win_delay_cb_info.->OutputRegion.y, p_scaler_win_delay_cb_info->OutputRegion.w, p_scaler_win_delay_cb_info->OutputRegion.h,
				gCallback_profile.OutputRegion.x, gCallback_profile.OutputRegion.y, gCallback_profile.OutputRegion.w, gCallback_profile.OutputRegion.h);
		}
#endif
	}
}


void wakeup_mute_off_callback(unsigned char display)
{//this is wake up to call webos callback function to notice mute off
#ifdef CONFIG_SCALER_ENABLE_V4L2
	extern void vsc_v4l2_muteoff_event_wakeup(unsigned char display);
	vsc_v4l2_muteoff_event_wakeup(display);//mute off event wake up
#endif
	if(display == SLR_MAIN_DISPLAY)
	{
		down(&muteoff_cb_sem);
		main_muteoff_cb_trigger = TRUE;
		up(&muteoff_cb_sem);
	}
	else
	{
		down(&muteoff_cb_sem);
		sub_muteoff_cb_trigger = TRUE;
		up(&muteoff_cb_sem);
	}
	wake_up(&MUTEOFF_CB_WAIT_QUEUE);
}


void wakeup_window_delay_info_callback(unsigned char display, unsigned char call_by_isr)
{//this is wake up to call webos callback function to notice mute off
#ifdef CONFIG_SCALER_ENABLE_V4L2
	extern void vsc_v4l2_win_apply_done_event_wakeup(unsigned char display);
	if(display == SLR_MAIN_DISPLAY)
	{
		vsc_v4l2_win_apply_done_event_wakeup(display);
	}
#endif
#if 0
	unsigned long flags;
	if(display == SLR_MAIN_DISPLAY)
	{
		//if call by isr, need use spin_lock/spin_unlock
		//if call by task, need use spin_lock_irqsave/spin_unlock_irqrestore
		if(call_by_isr){
			spin_lock(get_delay_info_cb_spin_lock());//lock delay_info_cb_trigger spinlock
			delay_info_cb_trigger = TRUE;
			spin_unlock(get_delay_info_cb_spin_lock());//unlock delay_info_cb_trigger spinlock
		}
		else{
			spin_lock_irqsave(get_delay_info_cb_spin_lock(), flags);//lock delay_info_cb_trigger spinlock
			delay_info_cb_trigger = TRUE;
			spin_unlock_irqrestore(get_delay_info_cb_spin_lock(), flags);//unlock delay_info_cb_trigger spinlock
		}
	}
	wake_up(&WIN_DELAY_CB_WAIT_QUEUE);
#endif
}

#ifndef UT_flag
struct semaphore* get_gamemode_check_semaphore(void)
{
	return &GameMode_Check_Semaphore;
}
#endif
#endif
unsigned char force_i3ddma_enable = false;

void set_force_i3ddma_enable(unsigned char enable)
{
	force_i3ddma_enable = enable;
}

unsigned char get_force_i3ddma_enable_impl(unsigned char display)
{
	#if 0//defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if((Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)&& (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI))
		return 1;
	#endif
	if(display == SLR_MAIN_DISPLAY)
		return force_i3ddma_enable;
	else
		return 0;
}
unsigned char (*get_force_i3ddma_enable)(unsigned char) = get_force_i3ddma_enable_impl;

unsigned char force_hdmi_hdr_flow_enable = false;

void set_force_hdmi_hdr_flow_enable(UINT8 enable)
{
   /**
    hdr interlace run hdmi->i3->vo->hdr->vgio
    hdr progressive run hdmi->hdr->vgip
    */
    if(hdmi_source_is_interlace())
    {
        force_hdmi_hdr_flow_enable = FALSE;
    }
    else
    {
        force_hdmi_hdr_flow_enable = enable;
    }
}

UINT8 get_force_hdmi_hdr_flow_enable(unsigned char display)
{
	if(display == SLR_MAIN_DISPLAY)
		return force_hdmi_hdr_flow_enable;
	else
		return 0;
}
#ifndef BUILD_QUICK_SHOW
void wait_memc_ready_impl(void)
{
#ifndef UT_flag
	unsigned int sleep_time = 0;
	unsigned int output_framerate = 0;

	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) &&  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO)
		&& Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO))
		output_framerate = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) * Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) / (10 * Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO));
	else
		output_framerate = 60;


	sleep_time = MAX_MEMC_DELAY_BUFFER * 100 / output_framerate;
	msleep(sleep_time);
	rtd_pr_vsc_notice("\r\n#### func:%s wait_time:%d framerate:(%d %d %d)####\r\n",__FUNCTION__, sleep_time, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ),  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO));
#endif
}
void (*wait_memc_ready)(void) = wait_memc_ready_impl;


void wait_game_mode_finish(void)
{//if game mode switch. scaler need to wait finish
	unsigned char count = 100;//1000 ms
	down(&GameMode_SCALER_SYNC_Semaphore);
	while(count && DbgSclrFlgTkr.game_mode_dynamic_flag)
	{
		count--;
		msleep(0);//wait 10ms
	}
	up(&GameMode_SCALER_SYNC_Semaphore);
	if(count != 100)
	{
		rtd_pr_vsc_notice("\r\n## func:%s count:%d####\r\n",__FUNCTION__, count);
	}
}


KADP_VSC_SUB_MODE_T get_sub_mode(void)
{
//Get sub current mode
//PIP: Live zoom, magnifire
//PBP: Multiview
//default mode is pip
	return (KADP_VSC_SUB_MODE_T)sub_mode_type;
}

StructSrcRect Scaler_SubDispWindowGet(void)
{
	StructSrcRect subWindow;
	subWindow.srcx = DbgSclrFlgTkr.sub_zoom_disp_hpos;
	subWindow.srcy = DbgSclrFlgTkr.sub_zoom_disp_vpos;
	subWindow.src_wid = DbgSclrFlgTkr.sub_zoom_disp_hsize;
	subWindow.src_height = DbgSclrFlgTkr.sub_zoom_disp_vsize;
	return subWindow;
}

void Scaler_SubDispWindowSet(StructSrcRect subWindow)
{
	DbgSclrFlgTkr.sub_zoom_disp_hpos = subWindow.srcx;
	DbgSclrFlgTkr.sub_zoom_disp_vpos = subWindow.srcy;
	DbgSclrFlgTkr.sub_zoom_disp_hsize = subWindow.src_wid;
	DbgSclrFlgTkr.sub_zoom_disp_vsize = subWindow.src_height;
}

unsigned char get_sub_OutputVencMode(void)
{
	return DbgSclrFlgTkr.Sub_OutputVencMode;
}

unsigned char get_main_OutputVencMode(void)
{
	return DbgSclrFlgTkr.OutputVencMode;
}

void set_atv_go_smooth_toggle_flag(unsigned char display, unsigned char flag)
{
	if (display == SLR_MAIN_DISPLAY)
		DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = flag;
#ifdef CONFIG_DUAL_CHANNEL
	else
		DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag = flag;
#endif
}

unsigned char rtk_rerun_scaler(SCALER_DISP_CHANNEL channel);
#endif

void Set_vsc_input_src_info(unsigned char display,KADP_VSC_OUTPUT_MODE_T vsc_output_mode, KADP_VSC_INPUT_SRC_INFO_T source_info)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if (KADP_VSC_OUTPUT_DISPLAY_MODE  == vsc_output_mode) {
			DisplayModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_VENC_MODE  == vsc_output_mode) {
			VencModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_MEMORY_MODE  == vsc_output_mode) {
			MemoryModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_AVE_MODE  == vsc_output_mode) {
			AveModeInputInfo = source_info;
		}
	} else if (display == SLR_SUB_DISPLAY) {
		if (KADP_VSC_OUTPUT_DISPLAY_MODE  == vsc_output_mode) {
			Sub_DisplayModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_VENC_MODE  == vsc_output_mode) {
			Sub_VencModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_MEMORY_MODE  == vsc_output_mode) {
			Sub_MemoryModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_AVE_MODE  == vsc_output_mode) {
			Sub_AveModeInputInfo = source_info;
		}
	}
#else
	if (display == SLR_MAIN_DISPLAY) {
		if (KADP_VSC_OUTPUT_DISPLAY_MODE  == vsc_output_mode) {
			DisplayModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_VENC_MODE  == vsc_output_mode) {
			VencModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_MEMORY_MODE  == vsc_output_mode) {
			MemoryModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_AVE_MODE  == vsc_output_mode) {
			AveModeInputInfo = source_info;
		}
	}
#endif
    if(source_info.type == KADP_VSC_INPUTSRC_DP)
    {
        Set_Val_dp_input_source(display, (source_info.attr == KADP_VSC_DP_SRC_MINIDP) ? _SRC_MINI_DP :  _SRC_TYPEC);
    }
}

void Set_Val_DisplayMode_info(unsigned char display, KADP_VSC_INPUT_SRC_INFO_T info)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY)
		DisplayModeInputInfo = info;
	else
		Sub_DisplayModeInputInfo = info;
#else
	if (display == SLR_MAIN_DISPLAY)
		DisplayModeInputInfo = info;
#endif
}

VSC_INPUT_TYPE_T Get_DisplayMode_Src(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN){
#ifdef CONFIG_I2RND_ENABLE
			if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				return Sub_DisplayModeInputInfo.type; //i2r sub re-run main case need to use sub src
			}
#endif
			return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
		}
		else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)VencModeInputInfo.type;
		else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  (VSC_INPUT_TYPE_T)MemoryModeInputInfo.type;
		else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)AveModeInputInfo.type;
		else{
#ifdef CONFIG_I2RND_ENABLE
			if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				return (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type; //i2r sub re-run main case need to use sub src
			}
#endif
			return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
		}
	} else {
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type;
		else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)Sub_VencModeInputInfo.type;
		else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)Sub_MemoryModeInputInfo.type;
		else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)Sub_AveModeInputInfo.type;
		else
			return (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type;
}
#else
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
	else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return (VSC_INPUT_TYPE_T)VencModeInputInfo.type;
	else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return  (VSC_INPUT_TYPE_T)MemoryModeInputInfo.type;
	else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return (VSC_INPUT_TYPE_T)AveModeInputInfo.type;
	else
		return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
#endif
}

unsigned char Get_DisplayMode_Port(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
#ifdef CONFIG_FORCE_RUN_I3DDMA
			if((DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_VDEC) && (DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_JPEG))
			{
				return 0;//Vo port is always 0 for all source go i3ddma
			}
#else
			if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
			{
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA))
				{
					return 0;//Vo port is always 0 for hdmi hdr case
				}
			}
#endif
			return DisplayModeInputInfo.resourceIndex;
		}
		else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return VencModeInputInfo.resourceIndex;
		else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  MemoryModeInputInfo.resourceIndex;
		else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return AveModeInputInfo.resourceIndex;
		else{
			return DisplayModeInputInfo.resourceIndex;
		}
	} else {
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_DisplayModeInputInfo.resourceIndex;
		else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_VencModeInputInfo.resourceIndex;
		else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  Sub_MemoryModeInputInfo.resourceIndex;
		else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_AveModeInputInfo.resourceIndex;
		else
			return Sub_DisplayModeInputInfo.resourceIndex;
}
#else
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if((DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_VDEC) && (DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_JPEG))
		{
			return 0;//Vo port is always 0 for all source go i3ddma
		}
#else
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
		{
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA))
			{
				return 0;//Vo port is always 0 for hdmi hdr case
			}
		}
#endif
		return DisplayModeInputInfo.resourceIndex;
	}
	else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return VencModeInputInfo.resourceIndex;
	else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return  MemoryModeInputInfo.resourceIndex;
	else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return AveModeInputInfo.resourceIndex;
	else
		return DisplayModeInputInfo.resourceIndex;
#endif
}

unsigned char get_output_set_flag(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	return ((display == SLR_MAIN_DISPLAY) ? DbgSclrFlgTkr.Main_Output_Set_flag : DbgSclrFlgTkr.Sub_Output_Set_flag);
#else
	return DbgSclrFlgTkr.Main_Output_Set_flag;
#endif
}

unsigned char get_scaler_stop_flag(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	return ((display == SLR_MAIN_DISPLAY) ? get_main_scaler_stop_flag() : DbgSclrFlgTkr.Sub_Scaler_Stop_flag);
#else
	return get_main_scaler_stop_flag();
#endif
}
#ifndef BUILD_QUICK_SHOW
void reset_support_vo_force_v_top(void)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	if (vo_force_v_top)
		vo_force_v_top->vo_force_v_top_enable = 0;
}


void set_support_vo_force_v_top(bool enable, unsigned int func_flag)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	if (vo_force_v_top) {
		if (enable)
			vo_force_v_top->vo_force_v_top_enable |= func_flag;
		else
			vo_force_v_top->vo_force_v_top_enable &= ~func_flag;
	}
}

bool get_support_vo_force_v_top(unsigned int func_flag)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	return vo_force_v_top ? (vo_force_v_top->vo_force_v_top_enable) & func_flag : false;
}

static void reset_all_top_dolby_mode(void)
{
	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	hdr_all_top_top_d_buf_RBUS top_d_buf_reg;

	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);

	if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
		hdr_all_top_top_ctl_reg.dolby_mode = 1;
	} else {
		hdr_all_top_top_ctl_reg.dolby_mode = 0;
	}

	top_d_buf_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_D_BUF_reg);
	top_d_buf_reg.dolby_double_en = 1;
	rtd_outl(HDR_ALL_TOP_TOP_D_BUF_reg, top_d_buf_reg.regValue);//enable double buffer

	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue);//Disable dolby mode
}

void reset_ARC_cmd(unsigned char display)
{//clear arc command // for unstable use
	if(display == SLR_MAIN_DISPLAY)
	{
		down(&SetMainOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
		DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
		up(&SetMainOutPutRegion_Semaphore);
	}
}
void scaler_overscan_vertical_size(unsigned char display,unsigned int progressive,unsigned int source_height,unsigned int *height,unsigned int *v_start)
{
	*v_start =0;
	*height = 0;
	if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {
		down(&SetMainOutPutRegion_Semaphore);
		if (DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_Output_Set_flag || (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
			if (((0 == progressive) && (main_dispwin.src_height <  _DISP_LEN)) ||
				((1 == progressive) && (main_dispwin.src_height <  _DISP_LEN))) {

			} else {
				*height = (source_height *main_input_size.src_height * 100/main_input_timing.src_height + 50)/100;
				*v_start = (source_height *main_input_size.srcy * 100/main_input_timing.src_height + 50)/100;
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
}

void check_ARC_status(unsigned char display, KADP_VSC_INPUT_TYPE_T source)
{
	StructSrcRect outdispwin = {0, 0, _DISP_WID, _DISP_LEN};
	StructSrcRect indispwin = {0, 0, 0, 0};
	unsigned char isatv = FALSE;
	isatv = ((source ==KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) ? TRUE : FALSE;

	if(display == SLR_MAIN_DISPLAY)
	{
		down(&SetMainOutPutRegion_Semaphore);
		if((DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.rotate_run_scaler_flag || DbgSclrFlgTkr.rotate_muteoff_request_flag || (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
			&& !isatv)
		{
			DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
			DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
			DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
			DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
                    vsc_force_rerun_main_scaler = FALSE;
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);

			Scaler_DispWindowSet(main_dispwin);


#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE

			set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode(SLR_MAIN_DISPLAY));
			set_rotate_mode(SLR_MAIN_DISPLAY, Get_Val_ap_roate_mode());

            if((display == SLR_MAIN_DISPLAY)
            	&&((get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)
            	||(get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
				||(get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270)
				))
            {
				Set_rotate_function(SLR_MAIN_DISPLAY, TRUE);
            }
			#if 0
			else if ((display == SLR_MAIN_DISPLAY)
                && (get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
	            && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
            {
				Set_rotate_function(SLR_MAIN_DISPLAY, TRUE);
            }
            else
            {
				Set_rotate_function(SLR_MAIN_DISPLAY, FALSE);
            }
			#endif
			//set_ori_rotate_mode(get_rotate_mode());
#endif
			//Fixed ATV all direction zoom non-working issue. @Crixus 20160829
			if(!((source == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
				//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(display,main_input_size, main_input_timing, main_dispwin);
			}
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
			rtd_pr_vsc_notice("\r\n### func:%s apply ARC size (%d %d %d %d)#####\r\n",__FUNCTION__, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid,  main_input_size.src_height);

		}
		else
		{//no over scan and full panel size
//fill size condition
			StructSrcRect inputTiming ;
			reset_any_srcrect(&main_dispwin_for_only_xy);
                    vsc_force_rerun_main_scaler = FALSE;
			indispwin.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
			if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
			{
				indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
				set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2);
			}
			else
			{
				indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
				set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
			}
			inputTiming = indispwin;
			set_input_for_crop(SLR_MAIN_DISPLAY, inputTiming);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, inputTiming);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
#if 0//this is for debug new flow
			set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)/2, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)/2);
			indispwin.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)/2;
			indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)/2;
#endif
			Scaler_DispWindowSet(outdispwin);
			if(!((source == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
				//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(SLR_MAIN_DISPLAY, indispwin, inputTiming,outdispwin);//for smooth toggle use
			}
			rtd_pr_vsc_notice("\r\n### func:%s apply full size w:%d h:%d#####\r\n",__FUNCTION__, indispwin.src_wid, indispwin.src_height);
		}

        if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) == ADAPTIVE_AIR_MODE)
		{
			vsc_adaptivestream_calc_outregion(SLR_MAIN_DISPLAY);
		}
        
		up(&SetMainOutPutRegion_Semaphore);
	}

}

unsigned char check_input_and_output_the_same(unsigned char display)
{//True: The same. False: The different
	unsigned char result = TRUE;
	if(display == SLR_MAIN_DISPLAY) {
		if((main_input_size_pre.srcx != main_input_size.srcx) || (main_input_size_pre.srcy != main_input_size.srcy) ||
			(main_input_size_pre.src_height != main_input_size.src_height) || (main_input_size_pre.src_wid != main_input_size.src_wid)) {
			result = FALSE;
			main_input_size_pre.srcx = main_input_size.srcx;
			main_input_size_pre.srcy = main_input_size.srcy;
			main_input_size_pre.src_height = main_input_size.src_height;
			main_input_size_pre.src_wid = main_input_size.src_wid;
		}
		#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if((main_input_timing_pre.srcx != main_input_timing.srcx) || (main_input_timing_pre.srcy != main_input_timing.srcy) ||
			(main_input_timing_pre.src_height != main_input_timing.src_height) || (main_input_timing_pre.src_wid != main_input_timing.src_wid)) {
			result = FALSE;
			main_input_timing_pre.srcx = main_input_timing.srcx;
			main_input_timing_pre.srcy = main_input_timing.srcy;
			main_input_timing_pre.src_height = main_input_timing.src_height;
			main_input_timing_pre.src_wid = main_input_timing.src_wid;
		}
		#endif
		if((main_dispwin_pre.srcx != main_dispwin.srcx) || (main_dispwin_pre.srcy != main_dispwin.srcy) ||
			(main_dispwin_pre.src_height != main_dispwin.src_height) || (main_dispwin_pre.src_wid != main_dispwin.src_wid)) {
			result = FALSE;
			main_dispwin_pre.srcx = main_dispwin.srcx;
			main_dispwin_pre.srcy = main_dispwin.srcy;
			main_dispwin_pre.src_height = main_dispwin.src_height;
			main_dispwin_pre.src_wid = main_dispwin.src_wid;
		}
	}

#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		if((sub_input_size_pre.srcx != sub_input_size.srcx) || (sub_input_size_pre.srcy != sub_input_size.srcy) ||
			(sub_input_size_pre.src_height != sub_input_size.src_height) || (sub_input_size_pre.src_wid != sub_input_size.src_wid)) {
			result = FALSE;
			sub_input_size_pre.srcx = sub_input_size.srcx;
			sub_input_size_pre.srcy = sub_input_size.srcy;
			sub_input_size_pre.src_height = sub_input_size.src_height;
			sub_input_size_pre.src_wid = sub_input_size.src_wid;
		}
		#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if((sub_input_timing_pre.srcx != sub_input_timing.srcx) || (sub_input_timing_pre.srcy != sub_input_timing.srcy) ||
			(sub_input_timing_pre.src_height != sub_input_timing.src_height) || (sub_input_timing_pre.src_wid != sub_input_timing.src_wid)) {
			result = FALSE;
			sub_input_timing_pre.srcx = sub_input_timing.srcx;
			sub_input_timing_pre.srcy = sub_input_timing.srcy;
			sub_input_timing_pre.src_height = sub_input_timing.src_height;
			sub_input_timing_pre.src_wid = sub_input_timing.src_wid;
		}
		#endif
		if((sub_dispwin_pre.srcx != sub_dispwin.srcx) || (sub_dispwin_pre.srcy != sub_dispwin.srcy) ||
			(sub_dispwin_pre.src_height != sub_dispwin.src_height) || (sub_dispwin_pre.src_wid != sub_dispwin.src_wid)) {
			result = FALSE;
			sub_dispwin_pre.srcx = sub_dispwin.srcx;
			sub_dispwin_pre.srcy = sub_dispwin.srcy;
			sub_dispwin_pre.src_height = sub_dispwin.src_height;
			sub_dispwin_pre.src_wid = sub_dispwin.src_wid;
		}
	}
#else
	result = FALSE;
#endif

	return result;
}

void source_disconnect_reset_input(unsigned char display)
{//for issue WOSQRTK-11401
	unsigned long flags = 0;//for spin_lock_irqsave
	if (display == SLR_MAIN_DISPLAY) {
		down(&new_input_output_main_sem);//lock semaphore
		spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
		//copy input region
		ap_main_inregion_parm.x = 0;
		ap_main_inregion_parm.y = 0;
		ap_main_inregion_parm.w = 0;
		ap_main_inregion_parm.h = 0;

		//copy original input region
		ap_main_originalInput_parm.x = 0;
		ap_main_originalInput_parm.y = 0;
		ap_main_originalInput_parm.w = 0;
		ap_main_originalInput_parm.h = 0;
		spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
		up(&new_input_output_main_sem);//lock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(display == SLR_SUB_DISPLAY)
	{
		down(&new_input_output_sub_sem);//lock semaphore
		spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
		//copy input region
		ap_sub_inregion_parm.x = 0;
		ap_sub_inregion_parm.y = 0;
		ap_sub_inregion_parm.w = 0;
		ap_sub_inregion_parm.h = 0;

		//copy original input region
		ap_sub_originalInput_parm.x = 0;
		ap_sub_originalInput_parm.y = 0;
		ap_sub_originalInput_parm.w = 0;
		ap_sub_originalInput_parm.h = 0;
		spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
		up(&new_input_output_sub_sem);//unlock semaphore
	}
#endif
}
#endif
void reset_any_srcrect(StructSrcRect *p_srcrect)
{
	if(p_srcrect) {
		p_srcrect->srcx = 0;
		p_srcrect->srcy = 0;
		p_srcrect->src_height = 0;
		p_srcrect->src_wid = 0;
	}
}

void set_source_info_forPQ(unsigned char display)
{
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
//	KADP_VSC_OUTPUT_MODE_T outputMode;
	unsigned char inputPort = 0;

	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
//			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = DisplayModeInputInfo.type;
			inputPort = DisplayModeInputInfo.resourceIndex;
		}
		else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
//			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
		}
		else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
//			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = MemoryModeInputInfo.type;
			inputPort = MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return;
		}
		//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//No need
		if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_MAIN_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort) == FALSE) {
				rtd_pr_vsc_debug("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				return;
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
//			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
//			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
//			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return;
		}

		//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);//No need
		if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_SUB_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort) == FALSE) {
				rtd_pr_vsc_debug("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.sub_opensourceID = _UNKNOWN_INPUT;
				return;
			}
		}
	}
#endif
}

void Set_Val_cur_main_vsc_src_num(unsigned char val)
{
    cur_main_vsc_src_num = val;
}

void Set_Val_cur_sub_vsc_src_num(unsigned char val)
{
    cur_sub_vsc_src_num = val;
}

void Set_Val_source_connect_verify_num(unsigned char dispaly, unsigned char val)
{
    source_connect_verify_num[dispaly] = val;
}
#ifndef BUILD_QUICK_SHOW
unsigned judge_scaler_break_case(unsigned char display)
{//Return True: break. False:No break
	unsigned char src;
	KADP_VSC_INPUT_TYPE_T webos_src;

#ifdef CONFIG_DUAL_CHANNEL
    if(display > SLR_SUB_DISPLAY || display < SLR_MAIN_DISPLAY){
        rtd_pr_vsc_info("display source is error!! %d\n", display);
        return true;
    }
#else
   if(display != SLR_MAIN_DISPLAY){
        rtd_pr_vsc_info("display source is error!! %d\n", display);
        return true;
    }
#endif

	webos_src = (KADP_VSC_INPUT_TYPE_T)Get_DisplayMode_Src(display);
	src = Scaler_InputSrcGetType(display);
	if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_ADC))
	{
		if(check_verify_mode_enable())//adc verify mode
			return FALSE;
	}
	if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
	{
		if(vbe_disp_get_VRR_timingMode_flag() != drvif_Hdmi_GetVRREnable())
		{
			rtd_pr_vsc_notice("\r HDMI VRR (%d %d) not match so break !!!####\r\n", vbe_disp_get_VRR_timingMode_flag(), drvif_Hdmi_GetVRREnable());
			return TRUE;
		}
		if(vbe_disp_get_freesync_mode_flag() != drvif_Hdmi_GetAMDFreeSyncEnable())
		{
			rtd_pr_vsc_notice("\r HDMI freesync (%d %d) not match so break !!!####\r\n", vbe_disp_get_freesync_mode_flag(), drvif_Hdmi_GetAMDFreeSyncEnable());
			return TRUE;
		}
	}

#ifdef CONFIG_I2RND_ENABLE
	//Eric@20170817 do not break in dual vo sub rerun case
	if(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
	&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
	{
		if (get_scaler_stop_flag(display))
		{
			rtd_pr_vsc_notice("\r\n####channel:%d vsc already disconnect !!!####\r\n", display);
			return TRUE;
		}
		else if(!compare_rerify_vsc_source_num_result(display))
		{
			rtd_pr_vsc_notice("### judge_scaler_break_case source(%d) already change###\r\n", display);
			return TRUE;
		}

	}
#else
	if (get_scaler_stop_flag(display)) {
		rtd_pr_vsc_notice("\r\n####channel:%d vsc already disconnect !!!####\r\n", display);
		return TRUE;
	}
	else if(!compare_rerify_vsc_source_num_result(display))
	{
		rtd_pr_vsc_notice("### judge_scaler_break_case source(%d) already change###\r\n", display);
		return TRUE;
	}
	else if((webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
	{
		return FALSE;//ATV don't check online status
	}
#endif
	else if((display == SLR_MAIN_DISPLAY) &&
		(webos_src == KADP_VSC_INPUTSRC_HDMI) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == true))
	)
	{
		if(drvif_mode_check_onlinemeasure_status(display) == FALSE) {
			rtd_pr_vsc_notice("\r\n####channel:%d online error status:%08x!!!####\r\n", display, IoReg_Read32(ONMS_onms1_status_reg));
			return TRUE;
		}

	}
#ifdef CONFIG_FORCE_RUN_I3DDMA
	else if((display == SLR_MAIN_DISPLAY) &&
		((webos_src == KADP_VSC_INPUTSRC_ADC) ||(webos_src == KADP_VSC_INPUTSRC_AVD) || (webos_src == KADP_VSC_INPUTSRC_HDMI))
	)
	{
		if((webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
		{
			return FALSE;//ATV don't check dma online status
		}
		else if(drvif_mode_check_dma_onlinemeasure_status() == FALSE) {
			rtd_pr_vsc_notice("\r\n####dma online error status:%08x!!!####\r\n", IoReg_Read32(ONMS_onms3_status_reg));
			return TRUE;
		}
		else if(webos_src == KADP_VSC_INPUTSRC_HDMI)
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
                rtd_pr_vsc_notice("\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
			    return TRUE;
            }
    		if(vsc_force_rerun_main_scaler == TRUE){
		rtd_pr_vsc_notice("\r\nCondition changed, force re-run scaler so break !!!####\r\n");
		return TRUE;
	     }
        }
	}
#endif
	else if(src == _SRC_VO) {
#ifdef CONFIG_I2RND_ENABLE
		//Eric@20170817 do not break in dual vo sub rerun case
		if(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
		&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
		{
			if(get_vo_change_flag(Get_DisplayMode_Port(display))) {
				rtd_pr_vsc_debug("\r\n####channel:%d vo already update !!!####\r\n", display);
				return TRUE;
			}
		}
#ifndef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
                rtd_pr_vsc_notice("\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
			    return TRUE;
            }
        }
#endif
	} else {
#ifdef CONFIG_I2RND_ENABLE
		if((display == SLR_SUB_DISPLAY) &&(webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
		{
			return FALSE;//ATV don't check dma online status
		}
#endif
		if(drvif_mode_check_onlinemeasure_status(display) == FALSE) {
			rtd_pr_vsc_notice("\r\n####channel:%d online error status:%08x!!!####\r\n", display, IoReg_Read32(ONMS_onms1_status_reg));
			return TRUE;
		}
#ifndef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
                rtd_pr_vsc_notice("\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
			    return TRUE;
            }
        }
#endif
	}
	return FALSE;
}

#ifndef UT_flag

void Scaler_Dolby_HDR_reset(void){
	//Reset DM control
	drvif_Dolby_HDR_disable_DM_LUT();//disable DM LUT @Crixus 20160313
}

#endif

void reset_hdr_mode_impl(unsigned char display)
{
	if(display == SLR_MAIN_DISPLAY)
	{
		hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	//Disable v top setting
		hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
		//top_ctl_reg.dolby_v_read_sel = 1;
		if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
			hdr_all_top_top_ctl_reg.dolby_mode = 1;
		} else {
			hdr_all_top_top_ctl_reg.dolby_mode = 0;
		}
		hdr_all_top_top_ctl_reg.hdr1_in_sel = 0;//0: vo case  1: hdmi
		//hdr_all_top_top_ctl_reg.hdr_yuv444_en = 0;//reset yuv 444 enable
		IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue);//Disable dolby mode
		IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//Enable doublue buffer

		//reset HDR RGB swap
		drvif_color_set_HDR_RGB_swap(0);

#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
		//skip qos reset mode
		rtd_pr_vsc_debug("[QoS] %s:skip qos reset\n", __FUNCTION__);
		//rtk_qos_set_mode(RTK_QOS_NORMAL_MODE);
#endif
	}
	else
	{//sub case
	}

}
void (*reset_hdr_mode)(unsigned char display)=reset_hdr_mode_impl;

static void decide_qos_mode(void)
{
#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800) // 4K
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
#if 0 // Use same QoS for all 2K video now, add/change mode only if we find 2K60 or 2K120 needs different QoS setting
		else if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) >= 490) // 2K freq > 50, apply 4k qos
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
#endif
		else
			rtk_qos_set_mode(RTK_QOS_DECODER_2K_MODE);
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800)
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
		else
			rtk_qos_set_mode(RTK_QOS_DECODER_2K_MODE);
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800)
			rtk_qos_set_mode(RTK_QOS_HDMI_4K_MODE);
		else
			rtk_qos_set_mode(RTK_QOS_HDMI_2K_MODE);
	}
	else
	{
		rtk_qos_set_mode(RTK_QOS_NORMAL_MODE);
	}
#endif
}

#ifndef UT_flag
void qos_mode_switch(unsigned int is_bad_edit)
{
#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
	if (is_bad_edit) {
		rtk_qos_set_bad_edit(TRUE);
		rtk_qos_set_mode(RTK_QOS_DECODER_BAD_EDIT_MODE);
	}
	else {
		rtk_qos_set_bad_edit(FALSE);
		decide_qos_mode();
	}
#endif
}

#ifdef CONFIG_HDR_SDR_SEAMLESS
void dynamic_change_hdr_setting(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format)
{//This is for vgip isr setting //vdec source
	bool sdr_force_vtop = FALSE;
	unsigned char decide_final_hdr_enable;//decide final hdr enable or disable
	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	sdr_force_vtop = get_support_vo_force_v_top(support_sdr_max_rgb);
	decide_final_hdr_enable = (hdr_enable || sdr_force_vtop);

	IoReg_ClearBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT0);		//disable double buffer

	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
	if(hdr_enable || decide_final_hdr_enable)
	{
		hdr_all_top_top_ctl_reg.en_422to444_1 = 0;//hdr don't enable 422 to 444
	}
	else
	{
		if(color_format == I3DDMA_COLOR_YUV422)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 1;
		else if(color_format == I3DDMA_COLOR_YUV444)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 0;
	}
	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue); //Set vtop setting
	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//apply doublue buffer

	Scaler_hdr_setting_SEAMLESS(hdr_enable || decide_final_hdr_enable);

	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT0);			//enable double buffer
}

void dynamic_change_hdr_setting_hdmi_position(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type)
{//This is for vgip isr setting. hdr type is from PQ_HDR_TYPE

	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
	if(hdr_enable)
	{
		hdr_all_top_top_ctl_reg.en_422to444_1 = 0;//hdr don't enable 422 to 444
	}
	else
	{
		if(color_format == I3DDMA_COLOR_YUV422)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 1;
		else if(color_format == I3DDMA_COLOR_YUV444)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 0;
	}
	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue); //Set vtop setting
	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//apply doublue buffer

	Scaler_hdr_setting_SEAMLESS_hdmi_position(hdr_enable, hdr_type);

}

void dynamic_change_hdr_setting_hdmi_finish(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type)
{//This is for vgip isr setting. PQ_HDR_TYPE

	Scaler_hdr_setting_SEAMLESS_hdmi_finish(hdr_enable, hdr_type);
}


void reset_seamless_trigger_flag(void)
{//reset HDMI and vdec seamless trigger related flag. This is for run scaler
	extern unsigned char hdmi_position_seamless;//for hdr sdr seamless condition for vgip start
   	extern unsigned char hdmi_finish_seamless;//for hdr sdr seamless condition for vgip end
	unsigned long flags;//for spin_lock_irqsave
    seamless_change_sync_info *seamless_info_sharememory = NULL;
    seamless_info_sharememory = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);
	if(seamless_info_sharememory)
	{
	    seamless_info_sharememory->hdmi_trigger_vo_change_flag = Scaler_ChangeUINT32Endian(0);
		seamless_info_sharememory->hdmi_not_ready = 0;
	}
    spin_lock_irqsave(get_i3ddma_change_spinlock(), flags);//lock i3ddma change spinlock
    set_i3ddma_change_format_flag(FALSE);
	hdmi_position_seamless = FALSE;
	hdmi_finish_seamless = FALSE;
    spin_unlock_irqrestore(get_i3ddma_change_spinlock(), flags);//unlock i3ddma change  spinlock
    spin_lock_irqsave(get_vdec_seamless_change_spinlock(), flags);//lock vdec semaless change spinlock
    set_vdec_seamless_change_flag(FALSE);
    spin_unlock_irqrestore(get_vdec_seamless_change_spinlock(), flags);//unlock vdec semaless change  spinlock
    set_hdr_semaless_active(FALSE);
}

#endif
#if 0
static void apvr_request_run_main_path(void)
{//This api is for apvr need to run main path again

	//reset i2rnd and pst write point when rerun scaler flow @Crixus 20180819
#ifdef CONFIG_I2RND_ENABLE
	//enable I2rnd
	if (Scaler_I2rnd_get_enable()) {
		Scaler_i2rnd_write_default_cmd_num();
		Scaler_I2rnd_set_read_cmd_num(0);
	}
#endif
#ifdef CONFIG_PST_ENABLE
	//enable pst
	if (Scaler_main_md_pst_get_enable()) {
		Scaler_pst_main_md_write_default_cmd_num();
		Scaler_pst_main_md_set_read_cmd_num(0);
	}
#endif

	if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)
	{
		mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
	}
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
	down(&SetMainOutPutRegion_Semaphore);
	DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Let main path run scaler again
	up(&SetMainOutPutRegion_Semaphore);
}
#endif
unsigned char get_vsc_mutestatus(void)
{
	return DbgSclrFlgTkr.VscMuteStatus;
}
#endif
#endif
void Scaler_SET_VSCDispinfo_WithVFEHMDI(unsigned char display, vfe_hdmi_timing_info_t vfehdmitiminginfo)
{
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE, vfehdmitiminginfo.active.h);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE, vfehdmitiminginfo.active.y+vfehdmitiminginfo.y_offset);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_WID_PRE, vfehdmitiminginfo.active.w);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE, vfehdmitiminginfo.active.x+vfehdmitiminginfo.x_offset);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_HSYNC, vfehdmitiminginfo.hsync);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_VSYNC, vfehdmitiminginfo.vsync);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_CURR, vfehdmitiminginfo.mode_id);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_TABLE_INDEX, vfehdmitiminginfo.mode_table_index);

	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_POLARITY, vfehdmitiminginfo.polarity);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_FREQ, vfehdmitiminginfo.h_freq);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_FREQ, vfehdmitiminginfo.v_freq);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_LEN, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_LEN, vfehdmitiminginfo.v_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_COUNT, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_COUNT, vfehdmitiminginfo.v_total);
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);
	if((display == SLR_MAIN_DISPLAY) && (vfehdmitiminginfo.color_space==VFE_HDMI_COLOR_YUV422)
		&& ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == true)))
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, VFE_HDMI_COLOR_YUV444);//two pixel mode force vtop, so scaler is yuv 444
		Scaler_DispSetStatus(display, SLR_DISP_422, 0);
	}
	else
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, vfehdmitiminginfo.color_space);
		Scaler_DispSetStatus(display, SLR_DISP_422, (vfehdmitiminginfo.color_space==VFE_HDMI_COLOR_YUV422) ? 1 : 0);
	}
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_DEPTH, vfehdmitiminginfo.color_depth);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_IMETRY, vfehdmitiminginfo.color_imetry);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IVSYNCPULSECOUNT, vfehdmitiminginfo.IVSyncPulseCount);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_SYNC_HIGH_PERIOD, vfehdmitiminginfo.polarity);

	Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,  (!vfehdmitiminginfo.scan_type));
	//Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,FALSE);

#if 0//frank@20141103 mark below code to reduce time
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_ADC_CLOCK));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_HSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_VSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_TABLE_INDEX));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_AFD));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_POLARITY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_SPACE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_DEPTH));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_IMETRY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE));
#endif
}

void Scaler_SET_VSCSubDispinfo_Withmain(void)
{
	//Scaler_DispSetInputInfo(SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE));

	Scaler_DispSetInputInfo(SLR_INPUT_HSYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC));
	Scaler_DispSetInputInfo(SLR_INPUT_VSYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC));

	Scaler_DispSetInputInfo(SLR_INPUT_MODE_CURR, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR));
	Scaler_DispSetInputInfo(SLR_INPUT_MODE_TABLE_INDEX, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX));

	//Scaler_DispSetInputInfo(SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfo(SLR_INPUT_POLARITY, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY));
	Scaler_DispSetInputInfo(SLR_INPUT_H_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ));
	Scaler_DispSetInputInfo(SLR_INPUT_V_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	Scaler_DispSetInputInfo(SLR_INPUT_H_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN));
	Scaler_DispSetInputInfo(SLR_INPUT_V_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN));
	Scaler_DispSetInputInfo(SLR_INPUT_H_COUNT, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT));
	Scaler_DispSetInputInfo(SLR_INPUT_V_COUNT, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT));
	//Scaler_DispSetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);

	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_SPACE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE));
	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_DEPTH, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH));
	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_IMETRY, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY));

	Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,FALSE);

#if 0//frank@20141103 mark below code to reduce time
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_ADC_CLOCK));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_HSYNC));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_VSYNC));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_TABLE_INDEX));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_AFD));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_POLARITY));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_FREQ));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_LEN));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_LEN));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_COUNT));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_COUNT));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_SPACE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_DEPTH));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_IMETRY));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE));
#endif
}
#ifndef BUILD_QUICK_SHOW
#ifndef UT_flag
void Scaler_SET_VSCDispinfo_WithVFEHMDIHDR( vfe_hdmi_timing_info_t vfehdmitiminginfo)
{
	//Scaler_DispSetInputInfo(SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE, vfehdmitiminginfo.active.h);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE, vfehdmitiminginfo.active.y+vfehdmitiminginfo.y_offset);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE, vfehdmitiminginfo.active.w);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE, vfehdmitiminginfo.active.x+vfehdmitiminginfo.x_offset);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC, vfehdmitiminginfo.hsync);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC, vfehdmitiminginfo.vsync);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR, vfehdmitiminginfo.mode_id);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX, vfehdmitiminginfo.mode_table_index);

	//Scaler_DispSetInputInfo(SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY, vfehdmitiminginfo.polarity);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ, vfehdmitiminginfo.h_freq);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ, vfehdmitiminginfo.v_freq);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN, vfehdmitiminginfo.v_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT, vfehdmitiminginfo.v_total);
	//Scaler_DispSetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE, vfehdmitiminginfo.color_space);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH, vfehdmitiminginfo.color_depth);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY, vfehdmitiminginfo.color_imetry);

	Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422, (vfehdmitiminginfo.color_space == VFE_HDMI_COLOR_YUV422) ? 1 : 0);
	Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE,  (!vfehdmitiminginfo.scan_type));
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE,FALSE);

#if 0//frank@20141103 mark below code to reduce time
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_ADC_CLOCK));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_AFD));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
#endif
}

unsigned char VSC_Check_Signal_Lock(unsigned char display)
{
	KADP_VSC_INPUT_TYPE_T src_type;
	unsigned char port;
#ifndef CONFIG_DUAL_CHANNEL
	display = SLR_MAIN_DISPLAY;
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
		src_type = DisplayModeInputInfo.type;
		port = DisplayModeInputInfo.resourceIndex;
	} else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
		src_type = VencModeInputInfo.type;
		port = VencModeInputInfo.resourceIndex;
	} else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
		src_type =  MemoryModeInputInfo.type;
		port = MemoryModeInputInfo.resourceIndex;
	} else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
		src_type = AveModeInputInfo.type;
		port = AveModeInputInfo.resourceIndex;
	} else {
		src_type = DisplayModeInputInfo.type;
		port = DisplayModeInputInfo.resourceIndex;
	}
#else
	if (display == SLR_MAIN_DISPLAY)
	{
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = DisplayModeInputInfo.type;
			port = DisplayModeInputInfo.resourceIndex;
		} else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = VencModeInputInfo.type;
			port = VencModeInputInfo.resourceIndex;
		} else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type =	MemoryModeInputInfo.type;
			port = MemoryModeInputInfo.resourceIndex;
		} else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = AveModeInputInfo.type;
			port = AveModeInputInfo.resourceIndex;
		} else {
			src_type = DisplayModeInputInfo.type;
			port = DisplayModeInputInfo.resourceIndex;
		}
	}
	else
	{
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = Sub_DisplayModeInputInfo.type;
			port = Sub_DisplayModeInputInfo.resourceIndex;
		} else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = Sub_VencModeInputInfo.type;
			port = Sub_VencModeInputInfo.resourceIndex;
		} else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type =  Sub_MemoryModeInputInfo.type;
			port = Sub_MemoryModeInputInfo.resourceIndex;
		} else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = Sub_AveModeInputInfo.type;
			port = Sub_AveModeInputInfo.resourceIndex;
		} else {
			src_type = Sub_DisplayModeInputInfo.type;
			port = Sub_DisplayModeInputInfo.resourceIndex;
		}
	}
#endif

	switch(src_type)
	{
		case KADP_VSC_INPUTSRC_ADC:
		case KADP_VSC_INPUTSRC_AVD:
		case KADP_VSC_INPUTSRC_HDMI:
			 if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && drvif_mode_check_onlinemeasure_status(display))
			 	return TRUE;
			 else
			 	return FALSE;

		case KADP_VSC_INPUTSRC_VDEC:
		case KADP_VSC_INPUTSRC_JPEG:
			if(get_vo_change_flag(port) == FALSE && Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}

		default:
			return FALSE;

	}
}
#endif
#endif
unsigned char Scaler_get_data_framesync_impl(unsigned char display)
{
#ifndef BUILD_QUICK_SHOW
	//unsigned int len_temp=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE);
	SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	if (Scaler_InputSrcGetType(display)==_SRC_VO) {
		if(pVOInfo == NULL)
		{
			rtd_pr_vsc_emerg("Scaler_get_data_framesync get vo timinginfo error\n");
			return FALSE;
		}
	}
	if (display == SLR_MAIN_DISPLAY) {
		if((get_panel_res() == PANEL_RES_FHD)||(get_panel_res() == PANEL_RES_HD)||(Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_eDP))
		{
			rtd_pr_vsc_notice(" 2k panel,go frc\n");
			return FALSE;
		}
		else{
			if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {
				if ((srctype != VSC_INPUTSRC_VDEC) && (srctype != VSC_INPUTSRC_JPEG) && (Scaler_InputSrcGetType(display)!=_SRC_VO)) {
					rtd_pr_vsc_notice("==== External src GO data frc ====\n");
					return FALSE;
				}
				else if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (pVOInfo->progressive== 0)) {
					rtd_pr_vsc_notice("=== adaptive interlace go data frc====\n");
					return FALSE;
				}
				if (Get_rotate_function(SLR_MAIN_DISPLAY) && (get_rotate_mode(SLR_MAIN_DISPLAY)!=(DIRECT_VO_FRAME_ORIENTATION)ROTATE_MODE_0)) {
					rtd_pr_vsc_notice("====rotate go data frc ====\n");
					return FALSE;
				}
		#ifndef ENABLE_VBY1_TO_HDMI_4K2K_DATA_FS
				if (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI ||
					Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI ||
			    		Get_DISPLAY_PANEL_TYPE() == P_LVDS_TO_HDMI) {
			    		rtd_pr_vsc_notice("====converter hdmi board go data frc ====\n");
					return FALSE;
				}
		#endif
				if (Scaler_DispWindowGet().src_height < (_DISP_LEN)) {
					rtd_pr_vsc_notice("====display len<source go data frc====\n");
					return FALSE;
				}
				else{
					rtd_pr_vsc_notice("====display len>=source or full size go data fs====\n");
					return TRUE;
				}
			} else {
				return FALSE;
			}
		}
	} else {
		return FALSE;
	}
#else
        return FALSE;
#endif
}
unsigned char (*Scaler_get_data_framesync)(unsigned char display) = Scaler_get_data_framesync_impl;
#ifndef BUILD_QUICK_SHOW

unsigned char judge_main_hdrtype(void);
unsigned char get_displayinfo_proc_impl(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)//This is for driver base implement open source
{
	unsigned int *p_sourceID = NULL;
	SLR_VOINFO* pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

	extern unsigned int get_current_driver_pattern(DRIVER_LIST_INFO info);
#ifndef CONFIG_DUAL_CHANNEL
        if(display != SLR_MAIN_DISPLAY)
        {
            rtd_pr_vsc_err("####get_displayinfo_proc no sub channel####\r\n");
            return FALSE;
        }
#endif


#ifdef CONFIG_DUAL_CHANNEL
	if(display == SLR_SUB_DISPLAY) {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	} else
#endif
    {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
	if(
		((inputSrctype != VSC_INPUTSRC_VDEC) && (inputSrctype != VSC_INPUTSRC_JPEG) && (display == SLR_MAIN_DISPLAY) && (get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1)
		&& (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == false) &&
		(
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT) ||
		#endif
			get_force_i3ddma_enable(SLR_MAIN_DISPLAY))) /*&& inputSrctype == KADP_VSC_INPUTSRC_HDMI*/
	)
	{
		fw_scaler_set_vgip(display, VGIP_SRC_HDR1, VGIP_MODE_ANALOG);
	}
	else if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
	{
		if(ADC_Check_VSC_VFE_ConnectSrc_Match(*p_sourceID) == FALSE)
		{
			return FALSE;
		}
		down(get_adc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_ADC_Dispinfo());//now for test, only for ypp timing info
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_adc_detectsemaphore());
			rtd_pr_vsc_err("#####[%s(%d)] adc vsc_timinginfo_check no signal error\n",__func__,__LINE__);
			return FALSE;
		}
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 2000)//mean 4095 no support
		{
			up(get_adc_detectsemaphore());
			rtd_pr_vsc_err("#####[%s(%d)] adc vsc_timinginfo_check no support error\n",__func__,__LINE__);
			return FALSE;
		}
		ADC_set_detect_flag(FALSE);
		up(get_adc_detectsemaphore());

		// Scart RGB
		if(get_ADC_Input_Source() == _SRC_SCART_RGB)
		{
			fw_scaler_set_vgip(display, VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		}
		// YPP and VGA
		else
		{
			fw_scaler_set_vgip(display, VGIP_SRC_ADC, VGIP_MODE_ANALOG);
			fw_scaler_set_sample(display, _ENABLE);
		}

		rtd_pr_vsc_notice("#####[%s(%d)] call ADC_VSC_Setting\n",__func__,__LINE__);
		ADC_VSC_Setting(get_ADC_Input_Source());
		fw_scaler_adc_nolock_wdg_ctrl(display, FALSE);//Disable adc_nolock_wdg
		drvif_mode_enableonlinemeasure(display);//Enable online measure
#ifdef CONFIG_SUPPORT_SRC_VGA
		if(get_ADC_Input_Source() == _SRC_VGA){
			if(drvif_mode_online_result_check(Get_ADC_Dispinfo()) == false){
				reset_adc_timing_ready();
				ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
				return FALSE;
			}
		}
#endif
	}
	else if(inputSrctype == VSC_INPUTSRC_AVD)
	{
		down(get_vdc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_AVD_ScalerDispinfo());
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_vdc_detectsemaphore());
			return FALSE;
		}
		up(get_vdc_detectsemaphore());
		fw_scaler_set_vgip(display, VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		drvif_mode_enableonlinemeasure(display);//Enable online measure
	}
	else if(inputSrctype == VSC_INPUTSRC_HDMI)
	{
		vfe_hdmi_timing_info_t vfehdmitiminginfo;
		down(get_hdmi_detectsemaphore());
		if(0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, display))
		{
			up(get_hdmi_detectsemaphore());
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_WithVFEHMDI(display, vfehdmitiminginfo);

		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_hdmi_detectsemaphore());
			return FALSE;
		}

		HDMI_set_detect_flag(FALSE);
		if(display == SLR_MAIN_DISPLAY)
		{
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			{//enable hdmi two pixel mode
				drvif_Hdmi_SetClkPixelMode(1);
			}
			else
			{//disable hdmi two pixel mode
				drvif_Hdmi_SetClkPixelMode(0);
			}
		}
		up(get_hdmi_detectsemaphore());
		if (get_force_hdmi_hdr_flow_enable(display) == true)
		{
			unsigned char hdrtype;
			down(&HDR_Setting_Semaphore);
			hdrtype = judge_main_hdrtype();
			up(&HDR_Setting_Semaphore);
			scaler_vtop_dolby_mode_setting(hdrtype);
			scaler_hdr_mode_setting(SLR_MAIN_DISPLAY, hdrtype);
		}
		fw_scaler_set_vgip(display, ((display == SLR_MAIN_DISPLAY) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == true)))? VGIP_SRC_HDR1 : VGIP_SRC_TMDS, VGIP_MODE_ANALOG);
		drvif_mode_enableonlinemeasure(display);//Enable online measure
		save_online_enable_time(display);//save online enable time
	}
	else if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG)) {

		if (Scaler_Get_CurVoInfo_VoVideoPlane(display) == VO_VIDEO_PLANE_V2)
			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_HDR2, VGIP_MODE_ANALOG);
		else
			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_HDR1, VGIP_MODE_ANALOG);
	} else {
		return FALSE;
	}
//	if(((inputSrctype == VSC_INPUTSRC_ADC) || (inputSrctype == VSC_INPUTSRC_HDMI) || (inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG) ||
//		(inputSrctype == VSC_INPUTSRC_AVD)
//		)
//	)
	{
		if(display == SLR_MAIN_DISPLAY)
		{//active state mean already run scaler
			check_ARC_status(display, (KADP_VSC_INPUT_TYPE_T)inputSrctype);
		}
	}

    //calc sub airplay output region
    if((display == SLR_SUB_DISPLAY) && (vsc_get_adaptivestream_flag(SLR_SUB_DISPLAY) == ADAPTIVE_AIR_MODE))
    {
    	vsc_adaptivestream_calc_outregion(SLR_SUB_DISPLAY);
    }

#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((((inputSrctype == VSC_INPUTSRC_VDEC)||(inputSrctype == VSC_INPUTSRC_JPEG)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		|| get_force_i3ddma_enable(display))&&(SLR_MAIN_DISPLAY == display))
#ifdef CONFIG_I2RND_ENABLE
		||((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
		)
#else
	if(((inputSrctype == VSC_INPUTSRC_VDEC)||(inputSrctype == VSC_INPUTSRC_JPEG)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		)&&(SLR_MAIN_DISPLAY == display))
#endif
	{
		//unsigned char smooth_toggle_mode=SLR_DISPLAY_DEFAULT;
		unsigned char plane=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
		if (Scaler_get_data_framesync(display)) {
			Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, TRUE);
		} else {
			Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		}
        if ((get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) && (inputSrctype == VSC_INPUTSRC_VDEC))
            scaler_SendDispSize(Scaler_DispWindowGet());
		rtd_pr_vsc_emerg( "data FS/FRC@%d\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC));
		plane = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
		if (inputSrctype == VSC_INPUTSRC_VDEC) {
			if (get_vo_open_smooth_toggle_enable(display) && (!Get_vo_smoothtoggle_timingchange_flag(display))
				&&((get_rotate_mode(SLR_MAIN_DISPLAY)==get_ori_rotate_mode(SLR_MAIN_DISPLAY))|| (get_ori_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				/*&& (display == SLR_MAIN_DISPLAY)*/) {
					Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			} else if (Get_vo_smoothtoggle_timingchange_flag(display)) {
				set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
				//vo_force_data_mode_set_enable(smooth_toggle_mode, display);
			} else if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)){
				Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
    else if(SLR_SUB_DISPLAY == display)
	{
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		if (inputSrctype == VSC_INPUTSRC_VDEC) {
			unsigned char plane=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
			if (get_vo_open_smooth_toggle_enable(display) && (!Get_vo_smoothtoggle_timingchange_flag(display))
				&&((get_rotate_mode(SLR_MAIN_DISPLAY)==get_ori_rotate_mode(SLR_MAIN_DISPLAY))|| (get_ori_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				/*&& (display == SLR_MAIN_DISPLAY)*/) {
					Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			} else if (Get_vo_smoothtoggle_timingchange_flag(display)) {
				set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
				//vo_force_data_mode_set_enable(smooth_toggle_mode, display);
			} else if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)){
				Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			}
		}
	}
#endif
	else
	{
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		//vo_force_data_mode_set_enable(SLR_DISPLAY_DATA_FRC, display);
	}

	if(get_hdmi_4k_hfr_mode() != HDMI_NON_4K120)
	{//hmdi 4k2k 120 application force go data frc
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
	}

		//Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);//temp to go data frc. sync is not ready



#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		|| get_force_i3ddma_enable(display)
#ifdef CONFIG_I2RND_ENABLE
		|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
		)
#else
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		)
#endif
	{
		Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, FALSE);

	}
	else
	{
		if (Get_PANEL_VFLIP_ENABLE())
			Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, TRUE);
		else
			Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, FALSE);
	}

	set_default_mcap_format(display, inputSrctype);//Set default m cap 422 or 444

	#ifdef HDMI_NO_PQDC_TEST
		Set_Val_vsc_run_pc_mode(TRUE);
		rtd_pr_vsc_emerg(" HDMI_NO_PQDC_TEST  rtk_hal_vsc_SetRGB444Mode(TRUE);\n");
	#endif
#ifdef CONFIG_DUAL_CHANNEL
	if ((get_sub_OutputVencMode() && (display == SLR_SUB_DISPLAY)) || (get_main_OutputVencMode() && (display == SLR_MAIN_DISPLAY))) {
		rtd_pr_vsc_debug("\r\n######DbgSclrFlgTkr.OutputVencMode force to 422capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	}
#endif
#ifdef CONFIG_DUAL_CHANNEL
    else if((Get_Val_vsc_run_pc_mode() == TRUE) && ((inputSrctype == VSC_INPUTSRC_ADC) || (inputSrctype == VSC_INPUTSRC_HDMI) || (inputSrctype == VSC_INPUTSRC_JPEG)))
#else
    if((Get_Val_vsc_run_pc_mode() == TRUE) && ((inputSrctype == VSC_INPUTSRC_ADC) || (inputSrctype == VSC_INPUTSRC_HDMI) || (inputSrctype == VSC_INPUTSRC_JPEG)))
#endif
     {
		rtd_pr_vsc_debug("\r\n######Get_Val_vsc_run_pc_mode() is true force to 444capture######\r\n");
#ifdef CONFIG_DUAL_CHANNEL
        if(display == SLR_SUB_DISPLAY)
			Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);//sub only run 422 format
		else
#endif
			Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
	}

	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
		rtd_pr_vsc_debug("\r\n######framesync is true force to 422capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#else
		rtd_pr_vsc_debug("\r\n######framesync is true force to 444capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#endif
	}
#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(display == SLR_MAIN_DISPLAY)
		Scaler_DispSetStatus(display, SLR_DISP_INTERLACE, FALSE);//force to set no interlace
#endif

	if (Get_tv006_wb_pattern() == 0)
		IoReg_ClearBits(SCALEUP_D_UZU_Globle_Ctrl_reg, _BIT0|_BIT1);//clear uzu pattern gen
	// FixMe
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),SLR_DISP_10BIT,FALSE);//let all source go 10bit mode
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (get_vo_vp9_flag(Get_DisplayMode_Port(display)))) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);//VP9 case use 8 bits setting @ Crixus 20160407
	} else if (display == SLR_MAIN_DISPLAY) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, TRUE);//let all source go 10bit mode
	} else { //else if(display == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, TRUE);// sub go 10 bit
	}

	if (display == SLR_MAIN_DISPLAY)
	{
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		if (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
			Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
#endif
		if(Get_Factory_SelfDiagnosis_Mode() == TRUE)
			Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
	}

	//Eric@20181016 check direct vdec low latency mode
	if((inputSrctype == VSC_INPUTSRC_VDEC)&&(SLR_MAIN_DISPLAY == display) && vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (pVOInfo->lowdelay == _ENABLE)){
		drv_memory_set_vdec_direct_low_latency_mode(_ENABLE);
		rtd_pr_vsc_emerg("[vo low delay][%s]enable vdec direct low delay mode\n", __FUNCTION__);
	}
	else{
		drv_memory_set_vdec_direct_low_latency_mode(_DISABLE);
		rtd_pr_vsc_emerg("[vo low delay][%s]Disable vdec direct low delay mode\n", __FUNCTION__);
	}

	if((inputSrctype == VSC_INPUTSRC_VDEC)&&(SLR_MAIN_DISPLAY == display) && !vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
		drvif_Hdmi_OutputDisable(1); //willychou fixed KTASKWBS-9866

#ifdef CONFIG_COMPRESSION_MODE_TEST

    if(SLR_SUB_DISPLAY == display)
	{
#ifdef CONFIG_DUAL_CHANNEL
		if(get_sub_OutputVencMode())
		{
			dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, FALSE);//disable compress
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, FALSE);// disable compress sub go 8 bit
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, TRUE);
		}
		else
		{
			dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, FALSE);//disable compress
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, FALSE);// disable compress sub go 8 bit
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, TRUE);
		}
#endif
	}
	//self-dianosis need disable compression, rzhen@2016-09-01
	else if (/*(SLR_MAIN_DISPLAY == display)	&&(drv_memory_get_game_mode() == _DISABLE)*/ //keep compression in game mode @Crixus 20170527
		(Get_Factory_SelfDiagnosis_Mode() == FALSE)
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		&&(FALSE == Get_rotate_function(SLR_MAIN_DISPLAY))
#endif
		)
	{
		#ifdef ENABLE_DE_CONTOUR_I2R // TEST -- de-contour test
            if(rtd_inl(0xb8022288) & _BIT20){
                // IDMA source chroma is 422 (encfmt = 2, 3)
                Scaler_DispSetStatus(display, SLR_DISP_422CAP, VODMA_VODMA_V1CHROMA_FMT_get_encfmt(rtd_inl(VODMA_VODMA_V1CHROMA_FMT_reg)) < 4? TRUE: FALSE);

                rtd_pr_vsc_emerg("[COMP] IDMA source 10bit/emcf=%d/%d\n", VODMA_VODMA_V1_DCFG_get_seq_data_width(rtd_inl(VODMA_VODMA_V1_DCFG_reg)),
                    VODMA_VODMA_V1CHROMA_FMT_get_encfmt(rtd_inl(VODMA_VODMA_V1CHROMA_FMT_reg)));

                dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);
        	   dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_NONE_MODE);
            }else
#endif
            {
		//Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);//compress force 422. need to check

		#ifdef HDMI_NO_PQDC_TEST
			rtd_pr_vsc_emerg(" HDMI_NO_PQDC_TEST  dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);\n");
			dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);
		#else
			dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, TRUE);
		#endif

		if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) && (!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))) {
			dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_16_BITS); //K5X M-domain + DI = 51M, so only can use 16bit for PQC //444 go 20 bit for K4 PQC @Crixus 20170718
			//rtd_pr_vsc_emerg("[crixus]M-domain Compression RGB444 20bits Enable!!\n");
		}
		else{
			if(inputSrctype == VSC_INPUTSRC_VDEC){
				dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_10_BITS);//VDEC go 10 bits @crixus 20170724
			}
			else{
				dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_12_BITS);//422 go 12 bits
			}
			//rtd_pr_vsc_emerg("[crixus]M-domain Compression Enable!!\n");
		}
		//vflip need to use line mode @Crixus 20171102
		//Eric@20181016 direct vdec low latency mode use compression line mode
		//VRR need to use line mode @ Eric 20181107
		if (Get_PANEL_VFLIP_ENABLE() || drv_memory_get_vdec_direct_low_latency_mode()|| ((vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)))
			dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);
		else
			dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);
	}
		//rtd_pr_vsc_emerg("[crixus]M-domain Compression Enable!!\n");
	}
	else
	{
		dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);

		//rtd_pr_vsc_emerg("[crixus]M-domain Compression Disable!!\n");
	}

	if(inputSrctype == VSC_INPUTSRC_HDMI)
	{
        rtd_pr_vsc_emerg( "###Finally fsync:%d 422:%d comp(%d %d) disp(%d) hfr:%d vrr:%d freesync:%d ###\r\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC), Scaler_DispGetStatus(display, SLR_DISP_422CAP), dvrif_memory_compression_get_enable(display), dvrif_memory_get_compression_bits(display), display, get_hdmi_4k_hfr_mode(), vbe_disp_get_VRR_timingMode_flag(), vbe_disp_get_freesync_mode_flag());
    }
	else
	{
		rtd_pr_vsc_emerg( "###Finally fsync:%d 422:%d comp(%d %d) disp(%d)###\r\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC), Scaler_DispGetStatus(display, SLR_DISP_422CAP), dvrif_memory_compression_get_enable(display), dvrif_memory_get_compression_bits(display), display);
	}
	//re-run sclar flow, reset game mode status.
	if(display == SLR_MAIN_DISPLAY){
		drv_memory_set_game_mode(_DISABLE);
		game_mode_set_ignore_cmd_check(_ENABLE);//run scaler case, do not check game mode cmd to reduce the mute time.
		Set_Val_smooth_toggle_game_mode_timeout_trigger_flag(_DISABLE);//reset smooth_toggle_game_mode_timeout_trigger_flag
		game_mode_cmd_pre = Get_Val_game_mode_cmd_check();//update game_mode_cmd_pre
		Set_Val_st_game_mode_cmd_pre(Get_Val_smooth_toggle_game_mode_check_cnt());//update st_game_mode_cmd_pre flag
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);//reset game mode fbg mask
		rtd_pr_new_game_mode_emerg("reset game mode status when run scaler flow!!\n");
	}

	//limit mode setting
	if(drv_memory_Get_multibuffer_flag())
		drv_memory_set_limit_boundary_mode(display, _DISABLE);
	else
		drv_memory_set_limit_boundary_mode(display, _ENABLE);


	if((SLR_MAIN_DISPLAY == display) && (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1))
	{//copy from main for sub m domain
		dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY));
		dvrif_memory_set_compression_bits(SLR_SUB_DISPLAY, dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));
		dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, dvrif_memory_get_compression_mode(SLR_MAIN_DISPLAY));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_VFLIP3, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_VFLIP3));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_FRAMESYNC, 0);
		drv_memory_set_limit_boundary_mode(SLR_SUB_DISPLAY, _ENABLE);
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_V_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	}

#ifdef CONFIG_I2RND_ENABLE
	if(Scaler_I2rnd_get_display() == I2RND_MAIN_S0_TABLE)
#endif
	drvif_memory_compression_rpc(display);

#endif
	return TRUE;
}
#endif
unsigned char init_source_proc_impl(unsigned char display, VSC_INPUT_TYPE_T sourcetype, unsigned char sourceport)
{
	unsigned short vfesource;
	unsigned int *p_sourceID = NULL;

	int i= 0, size;
	//unsigned int srcid = MainOpenSourceID;
	StructSourceInput *srcinput_pt = NULL;
	rtd_pr_vsc_info("%s.%d sourcetype:%d\n", __FUNCTION__, __LINE__, sourcetype);

#ifndef BUILD_QUICK_SHOW

	if(get_zoom_reset_double_state(display) == _ENABLE){
		set_zoom_reset_double_state(_DISABLE,display);
 	}
#endif
#ifdef CONFIG_DUAL_CHANNEL
		if (display == SLR_MAIN_DISPLAY) {
			p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
		} else {
			p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
		}
#else
		if (display == SLR_MAIN_DISPLAY) {
			p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
		} else {
			return FALSE;
		}

#endif

	switch(sourcetype)
	{
		case KADP_VSC_INPUTSRC_AVD:
		{
			down(get_setsource_semaphore());
			vfesource = get_AVD_Input_Source();
			up(get_setsource_semaphore());
			switch (vfesource) {
			case _SRC_TV://atv
			{
				if(sourceport == 0) {
					*p_sourceID = _TV_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _TV_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _TV_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc AVD ATV port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				if (display == SLR_MAIN_DISPLAY) {
					DbgSclrFlgTkr.Main_AutoRunScaler = TRUE;
				}
#ifdef CONFIG_DUAL_CHANNEL
				else {
					DbgSclrFlgTkr.Sub_AutoRunScaler = TRUE;
				}
#endif
				break;
			}
			case _SRC_CVBS://cvbs
			{
				if(sourceport == 0) {
					*p_sourceID = _AV_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _AV_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _AV_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc AVD CVBS port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}

				break;
			}
			case _SRC_SCART://SCART
			{
				if(sourceport == 0) {
					*p_sourceID = _SCART_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _SCART_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _SCART_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc AVD SCART RGB port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}

			default:
				rtd_pr_vsc_debug("init_source_proc AVD VFE not connect!!!!!!!!!!!!!!!1\n");
				return FALSE;
			}
			break;
		}
		case KADP_VSC_INPUTSRC_ADC:
		{
			down(get_setsource_semaphore());
			vfesource = get_ADC_Input_Source();
			up(get_setsource_semaphore());
			switch (vfesource) {
			case _SRC_YPBPR://ypp
			{
				if (sourceport == 0) {
					*p_sourceID = _YPBPR_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _YPBPR_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _YPBPR_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc ADC YPP port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}

				break;
			}
			case _SRC_VGA://VGA
			{
				if (sourceport == 0) {
					*p_sourceID = _VGA_INPUT1;
				} else if(sourceport == 1) {
					*p_sourceID = _VGA_INPUT2;
				} else if(sourceport == 2) {
					*p_sourceID = _VGA_INPUT3;
				} else {
					rtd_pr_vsc_info("init_source_proc ADC VGA port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}
			case _SRC_SCART_RGB://SCARTRGB
			{
				if (sourceport == 0) {
					*p_sourceID = _SCART_RGB_INPUT1;
				} else if(sourceport == 1) {
					*p_sourceID = _SCART_RGB_INPUT2;
				} else if(sourceport == 2) {
					*p_sourceID = _SCART_RGB_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc ADC SCART_RGB port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}
			default:
				rtd_pr_vsc_debug("init_source_proc ADC VFE not connect!!!!!!!!!!!!!!!1\n");
				return FALSE;
			}
			break;
		}
		case KADP_VSC_INPUTSRC_HDMI:
		{

			if (sourceport == 0) {
				*p_sourceID = _HDMI_INPUT1;
			} else if(sourceport == 1) {
				*p_sourceID = _HDMI_INPUT2;
			} else if(sourceport == 2) {
				*p_sourceID = _HDMI_INPUT3;
			} else if(sourceport == 3) {
				*p_sourceID = _HDMI_INPUT4;
			} else {
				rtd_pr_vsc_debug("init_source_proc HDMI port%d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
				return FALSE;
			}
			break;
		}

        case VSC_INPUTSRC_VDEC:
        {
            *p_sourceID = _VO_INPUT1;
            break;
        }
        case VSC_INPUTSRC_JPEG:
        {
            *p_sourceID = _VO_INPUT1;
            break;
        }
        case VSC_INPUTSRC_HDD:
        {//does not support
            return FALSE;
            break;
        }
        case VSC_INPUTSRC_VBY1RX:
        {//does not support
            return FALSE;
            break;
        }
        case VSC_INPUTSRC_DP:
        {//does not support
            return FALSE;
            break;
        }
        case VSC_INPUTSRC_MAXN:
        {
            return FALSE;
            break;
        }
        default:
        {
            return FALSE;
            break;
        }
	}
	if((get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1) && (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == false))
	{
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY)/* && (sourcetype != KADP_VSC_INPUTSRC_AVD || vfesource != _SRC_TV)*/)
#else
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			|| (get_force_i3ddma_enable(display) == true)
			)
#endif
		{
			  *p_sourceID = _VO_INPUT1;
		}
	}

#ifdef CONFIG_I2RND_ENABLE
	//i2r case, sub will force to use port 1, need to use TV1. @Crixus 20171208
	if((display == SLR_SUB_DISPLAY) && (sourcetype == VSC_INPUTSRC_AVD) && (vfesource == _SRC_TV)){
		*p_sourceID = _TV_INPUT1;
	}
#endif

	size = PcbSource_GetTableSize();
	srcinput_pt = Scaler_InputSrc(0);

	for(i = 0; i < size; i++)
	{
		if(srcinput_pt->src_index == *p_sourceID) break;
		srcinput_pt++;
	}
	if(i == size)
	{
		rtd_pr_vsc_err("\r\n###### source not found#######\r\n");
		return FALSE;
	}
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_INPUT_SRC, i);
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_DATA_ARRAY_IDX, i);//For m_screenModeCurrInfo table
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_OSD_INPUT_SRC, i);
	Scaler_SetUserInputSrc((SCALER_DISP_CHANNEL)display, i);
	return TRUE;

}

unsigned char (*init_source_proc)(unsigned char display, VSC_INPUT_TYPE_T sourcetype, unsigned char sourceport) = init_source_proc_impl;

static void set_default_mcap_format(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)
{//Set M Cap 444 or 422
#ifndef CONFIG_DUAL_CHANNEL
	display = SLR_MAIN_DISPLAY;
#endif
	switch(inputSrctype) {
	case KADP_VSC_INPUTSRC_ADC:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

	case KADP_VSC_INPUTSRC_HDMI:
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#else
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#endif
	break;

	case KADP_VSC_INPUTSRC_AVD:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

	case VSC_INPUTSRC_VDEC:
	case VSC_INPUTSRC_JPEG:
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#else
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#endif

	break;

    case KADP_VSC_INPUTSRC_HDD:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

    case KADP_VSC_INPUTSRC_VBY1RX:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

    case KADP_VSC_INPUTSRC_DP:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

    case VSC_INPUTSRC_MAXN:
	default:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;
	}
}

 unsigned char modestate_set_vgip(StructDisplayInfo* info)
{

	unsigned char result = TRUE;
#if 0
	// restore original signa's info
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
	IoReg_WriteByte0(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_DELAY_reg : VGIP_VGIP_CHN1_DELAY_reg, Scaler_DispGetInputInfo(SLR_INPUT_IPV_DLY_PRE));
#else
	IoReg_WriteByte0(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_DELAY_reg : */VGIP_VGIP_CHN1_DELAY_reg, Scaler_DispGetInputInfo(SLR_INPUT_IPV_DLY_PRE));
#endif
#endif

#ifdef CONFIG_ENABLE_3D_SETTING
	modestate_decide3D_for_vdc();
#endif

	//If source is FR, handle display ratio at movie or caption
	if(!fw_scaler_cal_vgip_capture(info->display))
		return FALSE;

#ifdef CONFIG_DUAL_CHANNEL
	if ((Get_sub_from_DI_mux_path()) && (info->display== SLR_SUB_DISPLAY)) {
		//tmp code
		return result;
	}
#endif
	/* setup capture window */
	fw_scaler_set_vgip_capture(info->display);

	// Attention: This bit may be set as enable again in memory_3ddma_control()
	fw_scaler_set_vgip_3d_mode(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _DISABLE);

#if 1
	//USER:Lewis DTAE:2015/09/29
	//PIP no 3D
	if(SLR_MAIN_DISPLAY == info->display)
	{
#ifdef CONFIG_DUAL_CHANNEL
		if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
		{
			fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
		else// if(((FALSE == DbgSclrFlgTkr.Sub_OuputDisplayMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputVencMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputMemoryMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputAveMode)))
#endif
        {
			if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
				if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING)
					fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
				else
					fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
			}
#ifdef ENABLE_SG_3D_SUPPORT_ALL_SOURCE_3D_MODE // [SG] HDMI FP video in M-domain frame sequence 3D output mode
			else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
				&& (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING) && (drvif_scaler3d_decide_3d_SG_Disable_IDMA(SLR_3D_FRAME_PACKING) == TRUE))
				fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
#endif // [SG] MVC 3D data FRC path (M-domain data FRC sequence 3D output)
#ifndef BUILD_QUICK_SHOW
			else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && modestate_get_vo3d_in_framePacking_FRC_mode())
				fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
#endif
			else
				fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
	}
	else// if(SLR_SUB_DISPLAY == info->display)
	{
		fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
	}
#else //#if 1
	if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
		if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING)
			fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
		else
			fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
#ifdef ENABLE_SG_3D_SUPPORT_ALL_SOURCE_3D_MODE // [SG] HDMI FP video in M-domain frame sequence 3D output mode
	else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
		&& (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING) && (drvif_scaler3d_decide_3d_SG_Disable_IDMA(SLR_3D_FRAME_PACKING) == TRUE))
		fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
#endif // [SG] MVC 3D data FRC path (M-domain data FRC sequence 3D output)
	else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && modestate_get_vo3d_in_framePacking_FRC_mode())
		fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
	else
		fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
#endif //#if 1

	return result;
}

#if 0
// move to fw_scalerip_set_di
static void modestate_check_prtnr(void)
{
	di_im_di_rtnr_new_control_RBUS rtnr_new_Ctrl;
	rtnr_new_Ctrl.regValue = IoReg_Read32(DI_IM_DI_RTNR_NEW_CONTROL_reg);
	if(Scaler_DispGetInputInfo(SLR_INPUT_DI_WID)>1920){
		rtnr_new_Ctrl.prtnr_4k2k = 0x1;		//4K2K support
	}else{
		rtnr_new_Ctrl.prtnr_4k2k = 0x0;
	}
	IoReg_Write32(DI_IM_DI_RTNR_NEW_CONTROL_reg, rtnr_new_Ctrl.regValue);
}
#endif
void modestate_decide_rtnr(void)
{
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
        {
                Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
		return;
        }
#endif

	//SLR_VOINFO* pVOInfo;

#ifdef HDMI_NO_PQDC_TEST
	return;
#endif
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	//Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
	//return;
#endif

#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
	return;
#endif

	if(get_hdmi_4k_hfr_mode() != HDMI_NON_4K120)
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
		return;
	}

		//RGB444 & 4k2k disable RTNR @Crixus 20160902
	if((Get_Val_vsc_run_pc_mode()) &&
         ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)))
    {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_pr_vsc_emerg("[crixus]RGB444 disable RTNR\n");
		return;
	}
	

	/* in Main channel, RTNR is controlled by AP , AP controlled table priority is higher than others*/
	if (get_current_driver_pattern(DRIVER_RTNR_PATTERN) == DI_RTNR_OFF) {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_pr_vsc_info("Decide RTNR, RTNR OFF by AP table\n");
	} else {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
		rtd_pr_vsc_info("Decide RTNR, RTNR ON by AP table\n");
	}

	return;

}

static void modestate_decide_DI(void)
{
	//unsigned char source = fwif_vip_source_check(3, 0);
	UINT32 picWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE);
	//unsigned char display_mode = Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);
	UINT32 timingMode;
	// Elsie 20131106: playback always does not use RTNR 10-bit mode.
	// 20131210 sync from Mac2
	unsigned int modeByAP_table;
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY)
	{
		//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		/*warning: sub could not set main di 10bit or 8bit flag*/
		//fw_scalerip_set_DI_chroma_10bits(FALSE);
#ifdef CONFIG_I2RND_ENABLE
	}else if((Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
		rtd_pr_vsc_emerg("[%s]I2rnd go 8bits!!!!!!\n", __FUNCTION__);
#endif
	}
	else if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (Scaler_InputSrcGetMainChType() == _SRC_VO) ){
		//if <1080, di10bit , >1080 di 8bit
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);

		if(Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080){
			fw_scalerip_set_DI_chroma_10bits(TRUE);
			rtd_pr_vsc_notice("_rk adaptive >2k1k force 8bit\n");

		}
		else{
			fw_scalerip_set_DI_chroma_10bits(TRUE);
			rtd_pr_vsc_notice("_rk adaptive 2k1k force 10bit\n");
		}
	} else if (Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() && get_3D_overscan_enable() &&
		((Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_SIDE_BY_SIDE_HALF) || (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_TOP_AND_BOTTOM) || (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING))) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(FALSE);
	}
	else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) && (Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()) == SOURCE_VIDEO)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 3000) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) >= 480)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE) && (Get_DISPLAY_PANEL_OLED_TYPE() == TRUE))
	{ // [OLED panel] data FRC force in 8bit capture mode
		Scaler_DispSetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL) , SLR_DISP_10BIT, FALSE);
	} else if ((Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080) && (Scaler_InputSrcGetMainChType() == _SRC_VO)) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
	}
#ifdef ENABLE_DE_CONTOUR_I2R // TEST -- de-contour
    else if(rtd_inl(0xb8022288) & _BIT20){
        // IDMA source pixel width is 8 bit (0: 8bit, 1: 10bit)
        unsigned char bIdma10bitMode = VODMA_VODMA_V1_DCFG_get_seq_data_width(rtd_inl(VODMA_VODMA_V1_DCFG_reg));
        Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, bIdma10bitMode);
	  fw_scalerip_set_DI_chroma_10bits(bIdma10bitMode);
    }
#endif

	else {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
	}
#ifndef BUILD_QUICK_SHOW
	//VP9 case use 8 bits setting @Crixus 20160407	2192
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (get_vo_vp9_flag(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY))))) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(FALSE);
	}
#endif
	if(Get_Factory_SelfDiagnosis_Mode() == TRUE)
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);


	rtd_pr_vsc_debug("[VSC] src/vdec/wid/freq, fs/10/olde=%d/%d/%d/%d, %d/%d/%d\n",
		Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()),
		Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ), Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC),
		Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT), Get_DISPLAY_PANEL_OLED_TYPE());


#if 1//def REDUCE_DIBW_ENABLE
//	UINT32 picWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE);

	// [XF112HAICNRTK1-88] linmc@20120712, reduce di bandwidth to resolve flicker picture screen happened
	//if (setManualReduceDIBW != NULL)
	//	setManualReduceDIBW();
	//else
	{
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
		//USER:LewisLee DATE:2012/12/20
		//fix VDC 27MHz mode, picture abnormal
		if(VD_27M_OFF != fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
		{
			picWidth = picWidth>>1;
		}
#endif //#ifdef CONFIG_ENABLE_VD_27MHZ_MODE

		// for playback source memory/bandwidth issue (24bit DI only for SD video--480i/576i)
		timingMode =  Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);

		//Elsie 20131210: Enable BTR mode when source is 1080i. 20140211: Always disable BTR when source is playback.
		if((Scaler_InputSrcGetMainChType() != _SRC_VO) && (timingMode == _MODE_1080I25 || timingMode==_MODE_1080I30))
		{
			drv_memory_set_ip_Btr_mode(_ENABLE);
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		}
		else if (picWidth > REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD)
		{
			drv_memory_set_ip_Btr_mode(_DISABLE);
			if(Scaler_InputSrcGetMainChType() == _SRC_VO){
				if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){		// 4k2k
					drv_memory_set_ip_DMA420_mode(SLR_DMA_400_mode);
				} else {
					drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
				}
			}
	                //frank@0904 add below code to avoid DI memory trash
			else if(Get_PANEL_VFLIP_ENABLE()){
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			}
			else if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)
			&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);				/*WOSQRTK-2096*/
			}
			else
			{
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
			}
			rtd_pr_vsc_debug("[DI] DI BTR/420[%d/%d], width=%d!\n", drv_memory_get_ip_Btr_mode(), drv_memory_get_ip_DMA420_mode(), picWidth);
		}
		else{
		#if 0
			if(Scaler_InputSrcGetMainChType() == _SRC_VO) {
				drv_memory_set_ip_Btr_mode(_DISABLE);
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			} else {
		#endif
				drv_memory_set_ip_Btr_mode(_ENABLE);
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		//	}
		}
	}
#else

#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
	//USER:LewisLee DATE:2012/12/20
	//fix VDC 27MHz mode, picture abnormal
	if(VD_27M_OFF != fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
	{
		picWidth = picWidth>>1;
	}
#endif //#ifdef CONFIG_ENABLE_VD_27MHZ_MODE


	if (picWidth > REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD){
		if((Scaler_InputSrcGetMainChType() == _SRC_HDMI)&&((_MODE_1080I25 == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR))||(_MODE_1080I30 == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR))) )
		{
			drv_memory_set_ip_Btr_mode(_ENABLE);//for 1080i video book Di 1 #chapter_10
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		}
		else
		{
			drv_memory_set_ip_Btr_mode(_DISABLE);
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
  #if 0 // [IDMA] IDMA 3D reduce bandwidth issue (Sensio 3D mode)
			if((Scaler_InputSrcGetMainChType() == _SRC_VO) && modestate_I3DDMA_get_In3dMode() && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) >= REDUCE_DI_BW_VFREQ_THRESHOLD))
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			else
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);

			rtd_pr_vsc_debug("[DBG] V_Freq=%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
  #endif
		}
		rtd_pr_vsc_debug("[DI] DI BTR/420[%d/%d], width=%d!!\n", drv_memory_get_ip_Btr_mode(), drv_memory_get_ip_DMA420_mode(), picWidth);
	}
	else{
		drv_memory_set_ip_Btr_mode(_ENABLE);
		drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
	}
#endif

#ifdef CONFIG_DUAL_CHANNEL
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
#if 0//frank@1008 simple the PIP flow
		// main need DI, just return
		if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_THRIP) ||		// use DI's IP
			Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE) ||	// interlace source
			Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_RTNR))	{		// RTNR (because RTNR and DI uses the same IP)
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP,FALSE);
				return;
		}

		// main don't need DI, if sub need, sub get it!
		if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, TRUE);
		return;
#else
		//add HDMI sub channel field control @Crixus 20151203
		if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
			DbgSclrFlgTkr.multiview_sub_interlace_flag = TRUE;
		else
			DbgSclrFlgTkr.multiview_sub_interlace_flag = FALSE;

		//sub always don't go DI
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
		return;
#endif
	}
#endif

	// now handle main display
	//if(Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE)) {
	if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
#ifdef CONFIG_DUAL_CHANNEL
		if (Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP) || Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR)) {
			/*Scaler_ForceBg(SLR_SUB_DISPLAY, SLR_FORCE_BG_SYSTEM, TRUE);*/
			fw_scalerip_disable_ip(SLR_SUB_DISPLAY);
			//frank@0528 Sove QCBUG10151 push below to set sub channel i,m,d domain to avoid sub set display but DI disable by main channel
			/*flow_message_push(_MODE_MSG_SUB_SET_VGIP_AFTER_FOUND_MODE_SIGNAL);
			flow_message_clearallType(_MODE_MSG_SUB_SETUP_BEFORE_SHOW_SIGNAL);*/
			//mark by frank@0528 flow_message_push(_MODE_MSG_SUB_SETUP_AFTER_FOUND_MODE_SIGNAL);
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		}
#endif
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, TRUE);
	}
	else
	{
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, FALSE);
	}

	/* in Main channel, DI is controlled by AP , AP controlled table priority is higher than others*/
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) {
		modeByAP_table = get_current_driver_pattern(DRIVER_RTNR_PATTERN);
		if (modeByAP_table == DI_RTNR_422) {
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		} else if (modeByAP_table == DI_RTNR_420) {
			drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
		} else if (modeByAP_table == DI_RTNR_400) {
			if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == 0)
				drv_memory_set_ip_DMA420_mode(SLR_DMA_400_mode);
			else
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		} else {
			//rtd_pr_vsc_info("Decide DI by AP, NO RTNR, table value = %d\n", modeByAP_table);
		}
		rtd_pr_vsc_info("Decide DI, AP Val=%d, isInterlace=%d,\n", modeByAP_table, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
	}

}

static void modestate_decide_nr_path(void)
{
	/* select bypass, NR or VUZD */
	if(Scaler_DispGetScaleStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_SCALE_V_DOWN)){  // go vuzd path
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_VUZD_MODE);
	}else{
		if (Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL))   //sub channal no NR path
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_BYPASS_MODE);
		else
		{
			if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {//WOSQRTK-6131 Patch
				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_FRAMESYNC_MODE);
			} else {
				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_BYPASS_MODE);
			}
		}
	}
}
#if 0
static void modestate_setup_vgip_even_odd_toggle(void)
{
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
	unsigned short channel = Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL);
#endif

	//CSW+ 0970710 Sub Channel(480i or 576i or 1080i50 or 1080i60) interlace mode by video compensation
	if(Scaler_InputSrcGetMainChType() == _SRC_YPBPR || Scaler_InputSrcGetMainChType() == _SRC_VGA) {
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP))	//video comp
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			else										//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18);			//odd signal inverted enable
		}
#endif
	}
	else if((Scaler_InputSrcGetMainChType() == _SRC_TV) || (Scaler_InputSrcGetMainChType() == _SRC_CVBS) || (Scaler_InputSrcGetMainChType() == _SRC_SV)){
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP))	//video comp
			{
				if ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_AVD) && (!get_sub_OutputVencMode()))
				{
					// AVD display in sub channel.
					IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x0);			//odd signal inverted disable
				}
				else
				{
					// APVR recording by sub channel
					IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18);			//odd signal inverted enable
				}
			}
			else
			{
				//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			}
		}
#endif
	}
	else if(Scaler_InputSrcGetMainChType() == _SRC_HDMI){
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
		{
			IoReg_Mask32(VGIP_VGIP_CHN1_CTRL_reg, ~(_BIT16|_BIT18), (_BIT16|_BIT18));
		}
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		//add HDMI sub channel field control @Crixus 20151203
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!DbgSclrFlgTkr.multiview_sub_interlace_flag){//(!Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE)){//!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP)){	//video comp
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			}
			else{										//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18); 		//odd signal inverted enable
			}
		}
#endif
	}
}
#endif

static void modestate_EnableVGIPInt(unsigned char a_bEnable)
{
	// I-domain VGIP Int Ctl
	vgip_int_ctl_RBUS tVGIPIntCtl;

	tVGIPIntCtl.regValue = IoReg_Read32(VGIP_INT_CTL_reg);// Read value

	if (TRUE == a_bEnable){
		tVGIPIntCtl.vgip_int_ie = 1; // Enable VGIP Interrupt
	}else{
		tVGIPIntCtl.vgip_int_ie = 0; // Disable VGIP interrupt
	}

	IoReg_Write32(VGIP_INT_CTL_reg, tVGIPIntCtl.regValue); // Update value
}

#ifndef UT_flag
#ifdef CONFIG_SCALER_BRING_UP
static void modestate_EnableDispInt(unsigned char a_bEnable)
{
	// Display I Domain Interrupt Enable Ctrl
	vgip_int_ctl_RBUS tVGIPIntCtl;

	tVGIPIntCtl.regValue = IoReg_Read32(VGIP_INT_CTL_reg); // Read value

	if (a_bEnable){
		tVGIPIntCtl.dispi_int_ie = 1; // Enable Disp Interrupt
	}else{
		tVGIPIntCtl.dispi_int_ie = 0; // Disable Disp interrupt
	}

	IoReg_Write32(VGIP_INT_CTL_reg, tVGIPIntCtl.regValue); // Update value
}
#endif

#endif
static void modestate_set_SDNR(unsigned char channel)
{
	VIDEO_RECT_T  outregion;
	outregion.x = Scaler_DispGetInputInfo(SLR_INPUT_SDNRH_ACT_STA);
	outregion.y = Scaler_DispGetInputInfo(SLR_INPUT_SDNRV_ACT_STA);
	outregion.w = Scaler_DispGetInputInfo(SLR_INPUT_SDNRH_ACT_WID);
	outregion.h = Scaler_DispGetInputInfo(SLR_INPUT_SDNRV_ACT_LEN);

	if (channel == SLR_MAIN_DISPLAY)
	{
		scaledown_ich1_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
		scaledown_ich1_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
		//scaledown_ich1_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
		scaledown_ich1_uzd_ctrl0_RBUS 	ich1_uzd_Ctrl0_REG;

		ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg);
		ich1_sdnr_cutout_range_hor_reg.hor_front= outregion.x;
		ich1_sdnr_cutout_range_hor_reg.hor_back= outregion.x + outregion.w + 1; // chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front= outregion.y;
		ich1_sdnr_cutout_range_ver0_reg.ver_back= outregion.y + outregion.h + 1;	// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);

		//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg);
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top=0;	// inregion.y;
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot=0;	// inregion.y;
		//IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);

#if 0
		rtd_pr_vsc_emerg( "******************reg_hor_front = %d \n", outregion.x);
		rtd_pr_vsc_emerg( "******************reg_ver_front = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_top = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_bot = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_hor_back = %d \n", outregion.x+outregion.w);
		rtd_pr_vsc_emerg( "******************reg_ver_back = %d \n", outregion.y+outregion.h);
#endif
		ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_Ctrl0_reg);
		ich1_uzd_Ctrl0_REG.cutout_en = 1;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_Ctrl0_reg, ich1_uzd_Ctrl0_REG.regValue);
	}
	else
	{
		scaledown_ich2_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
		scaledown_ich2_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
		//scaledown_ich2_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
		scaledown_ich2_uzd_ctrl0_RBUS scaledown_ich2_uzd_ctrl0_reg;

		ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg);
		ich1_sdnr_cutout_range_hor_reg.hor_front= outregion.x;
		ich1_sdnr_cutout_range_hor_reg.hor_back= outregion.x + outregion.w + 1; // chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front= outregion.y;
		ich1_sdnr_cutout_range_ver0_reg.ver_back= outregion.y + outregion.h + 1;	// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);

		//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg);
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top=0;	// inregion.y;
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot=0;	// inregion.y;
		//IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);
#if 0
		rtd_pr_vsc_emerg( "******************reg_hor_front = %d \n", outregion.x);
		rtd_pr_vsc_emerg( "******************reg_ver_front = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_top = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_bot = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_hor_back = %d \n", outregion.x+outregion.w);
		rtd_pr_vsc_emerg( "******************reg_ver_back = %d \n", outregion.y+outregion.h);
#endif
		scaledown_ich2_uzd_ctrl0_reg.regValue = IoReg_Read32(SCALEDOWN_ICH2_UZD_Ctrl0_reg);
		scaledown_ich2_uzd_ctrl0_reg.cutout_en = 1;
		IoReg_Write32(SCALEDOWN_ICH2_UZD_Ctrl0_reg, scaledown_ich2_uzd_ctrl0_reg.regValue);
	}
}

#define VGIP_INTERRUPT (_BIT24|_BIT25)

void modestate_setup_idomain(StructDisplayInfo* info)
{


	idomain_vfreq_pre = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);
	modestate_decide_pixel_mode();

	modestate_decide_dtg_m_mode();

	modestate_decide_fractional_framesync();

	//  decide which channel to use DI
	modestate_decide_DI();
	// Calculate main or sub display width and display height and set it to info
	// remember main's display width/height may change later if display ratio is
	// pointer to pointer
	fw_scalerdisplay_get_display_size(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	/* Decide RTNR flag */
	modestate_decide_rtnr();


	//for HSD enable

	//Scaler_AdjustPathAndInfo();/*Will add. decide Uzd path*/
	Scaler_AdjustPathAndInfo_HW_SNR();	// Include patch for SNR issue
	// Calculate Overscan
	fw_scaler_cal_sdnr_capture(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
	modestate_set_SDNR(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	// Calculate the output size of scale down
	fw_scaler_cal_scale_down_size();

	/*Decide NR buffer mode,move from fw_scaler_cal_scale_down_size to support new NR path limit*/
	modestate_decide_nr_path();
	// Set in the scale up&down
	drvif_color_ultrazoom_config_scaling_down(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));


#if 0//remove in k4lp
	//DI game mode checking & setting in scaler flow @Crixus 20161217
	if(fw_scalerip_get_di_gamemode() == _ENABLE){
		fw_scalerip_set_di_gamemode_setting(_ENABLE);
		//rtd_pr_vsc_emerg("[Game Mode]Enter DI game mode\n");
	}
	else{
		fw_scalerip_set_di_gamemode_setting(_DISABLE);
		//rtd_pr_vsc_emerg("[Game Mode]Exit DI game mode\n");
	}
#endif

#ifdef CONFIG_DUAL_CHANNEL
	if(((get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)) && get_ori_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)) {
		rtd_pr_vsc_emerg("[rotate] no run vgip&di\n");
		/*no need run vgip to di for livezoom main*/
	} else
#endif
    {
		// Disable VGIP Interrupt and let DI can be enabled.
#ifdef CONFIG_DUAL_CHANNEL
		if(get_sub_OutputVencMode() == TRUE)
			IoReg_ClearBits(VGIP_VGIP_CHN1_CTRL_reg, VGIP_INTERRUPT);
		else
#endif
			modestate_EnableVGIPInt(FALSE);

#if defined(CONFIG_RTK_AI_DRV)
		fw_scalerip_reset_NN();
#endif
		//DI control setting
		down(get_DI_semaphore());
		fw_scalerip_set_di();
		up(get_DI_semaphore());

		//De-XCXL
		fw_scalerip_set_deXC_XL();

		// set i-edge smooth
		fw_scalerip_set_IEGSM();

		// Enable VGIP Interrupt
#ifdef CONFIG_DUAL_CHANNEL
		if(get_sub_OutputVencMode() == TRUE)
			IoReg_SetBits(VGIP_VGIP_CHN1_CTRL_reg, VGIP_INTERRUPT);
		else
#endif
			modestate_EnableVGIPInt(TRUE);
	}

#ifdef CONFIG_VGA_AUTO_MA_ENABLE
	// enable AutoMA in VGA source

	if ( Scaler_InputSrcGetType(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_VGA ) {
		drvif_scaler_vactive_end_irq(_ENABLE, info->display); // enable automa ISR
		drvif_scaler_vactive_sta_irq(_ENABLE, info->display); // enable automa ISR
	}
#endif
#if 0/*Framesync also need to enable VGIP ISR*/
    if((_FALSE == Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) /*&& (_ENABLE == drvif_memory_sw_buffer_swap_Enable((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))*/)
#endif
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY){

		#ifdef CONFIG_SUPPORT_DOLBY_VSIF
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
		    vfe_hdmi_drv_set_infoframe_thread_stop(_TRUE);
		#endif

		drvif_scaler_vactive_end_irq(_ENABLE, SLR_MAIN_DISPLAY);
		drvif_scaler_vactive_sta_irq(_ENABLE, SLR_MAIN_DISPLAY);
	} else {
#ifdef  CONFIG_I2RND_ENABLE
#else
		drvif_scaler_vactive_end_irq(_ENABLE, SLR_SUB_DISPLAY);
		drvif_scaler_vactive_sta_irq(_ENABLE, SLR_SUB_DISPLAY);
#endif
	}
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			twopixel_2_oneline_ctrl(1);//control two pixel mode
		else
			twopixel_2_oneline_ctrl(0);//control two pixel mode
	}

	#ifndef CONFIG_FORCE_RUN_I3DDMA	//not define
	//CSW+ 0970710 Sub Channel(480i or 576i or 1080i50 or 1080i60) interlace mode by video compensation
	//modestate_setup_vgip_even_odd_toggle();
	#endif
}

void modestate_set_imd_domain(StructDisplayInfo* info)
{
	//rtd_pr_vsc_debug("\n Setup State: display:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	modestate_setup_idomain(info);

	force_enable_datapath_clock();//Force enable Xcdi_clock 0xb8022284 bit3
#ifdef CONFIG_DUAL_CHANNEL
	//when change PIP type to speed up sub channel setting
	/*modestate_set_sub_domain(msg);*/
#endif

}

unsigned char modestate_set_framesync(StructDisplayInfo* info)
{
//	unsigned char result=0;
//	SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());;
#ifdef CONFIG_DCLK_CHECK
	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC))
	{
		if (Scaler_OpenVOGating())
		{
		//if((GET_HDMI_3DTYPE() == HDMI3D_FRAMESEQUENCE) &&  Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()
		//&& (((Scaler_InputSrcGetMainChType() == _SRC_VO) && (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_NON_ACTIVE)) || (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_VO_GO)))

			check_dclk2_is_underflow();
		}
		else
		{
			check_dclk_is_underflow();
		}

	}
#endif
// move to vbe_disp_set_dtgM2uzu_lowdelay_mode(1)
//	if(info->display == SLR_MAIN_DISPLAY)
//		update_dtgm2uzu_delay();//update master to uzu dtg delay; //need to set before 0xb802850c bi30
	if(info->display == SLR_MAIN_DISPLAY)
		vbe_disp_set_dtgM2uzu_lowdelay_mode(2); //mac7p has no memc



	//frank@1011 FRC with frame sync timing so must do calculation IVS2DVS
	fw_scalerdisplay_handler(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	// Set in the scale up&down
	drvif_color_ultrazoom_config_scaling_up(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));
#ifndef BUILD_QUICK_SHOW
	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
	//	if(Scaler_InputSrcGetMainChType() != _SRC_VO){
		if((get_panel_res() != PANEL_RES_FHD)||(get_panel_res() != PANEL_RES_HD)) {
			dvrif_memory_setting_for_data_fs();
		}
		// Enter FrameSync Setup
		if(Scaler_InputSrcGetMainChType() == _SRC_VGA) {	// weihao 960308
			fw_scaler_update_mode_para(); //update mode parameters after adjust IVS2DVSDelay
		}


		// set display FIFO for Frame sync
		drvif_memory_set_fs_display_fifo();

		//data fs need to disable compression clock @Crixus 20171227
		dvrif_memory_comp_setting(FALSE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN), dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));
#if 0 //gamemode fix later
#ifdef CONFIG_FORCE_RUN_I3DDMA
				if(drv_memory_get_game_mode()){
					if(drvif_i3ddma_triplebuf_flag())
						drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
					else
						drv_I3ddmaVodma_SingleBuffer_GameMode(_ENABLE);
					}
				else{

					drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
				}

				/*qiangzhou:all i3ddma source go vodma timing sync i3ddma,all i3ddma source should setting iv2pv delay*/
				if(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_ADC)
					|| (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
					||((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)	&& (get_AVD_Input_Source() != _SRC_TV)))
#ifdef CONFIG_ALL_SOURCE_DATA_FS
					//don't care 3 buffer case
					/*&&(!drvif_i3ddma_triplebuf_flag())*/){
#else
					&&(!drvif_i3ddma_triplebuf_flag())){
#endif
					drv_I3ddmaVodma_GameMode_iv2pv_delay(TRUE);
				} else {
					drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
				}
#endif
#endif

#if 0

		if(Scaler_OpenVOGating()){
/*
			if(Get_PANEL_TYPE_IS_MILLET3_4K2K_SERIES() ==1){
				//move framesync_gating to disp on
			}else if(Get_DISPLAY_PANEL_TYPE() == P_VBY1_4K2K){
				scaler_dtg_reconfig();
				drvif_framesync_gatting_do();
			}
			else
*/
			{
				scaler_dtg_reconfig();
				drvif_framesync_gatting_do();
				/*WaitFor_EN_STOP_MAIN_Done();*/
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting(_ENABLE);
				/*WaitFor_EN_STOP_MAIN_Done();*/
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
			}
		}else{
			rtd_pr_vsc_debug(KERN_INFO "\r\n[%s][line:%d] Error! Data FS without open gating!!\r\n", __FUNCTION__, __LINE__);
#if 0
				drvif_scaler_set_display_mode_frc2fsync_by_hw(_TRUE);
				result = drvif_framesync_do();

			if(Scaler_InputSrcGetMainChType()==_SRC_VO && (result != 0)){
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting_do();
				msleep(50);
				drvif_framesync_gatting(_ENABLE);
				result = 0;
			}else if(Scaler_InputSrcGetMainChType()==_SRC_VO){//frank@0920 open VO gating function to solve mantis#5011
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting(_ENABLE);
			}

			if (result != 0) {// frame sync fail
#if 0
				drvif_scaler_set_display_mode(DISPLAY_MODE_FRC);
				if(Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT) > 0) {
					//drvif_mode_resetmode();
					//Scaler_ForceBg((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_FORCE_BG_SYSTEM, TRUE);
					drvif_mode_disablechannelproc(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
					drvif_mode_disablevgip(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
					#if 0
					if(Scaler_InputSrcGetMainChType()==_SRC_VO) { // hsliao 20090311, VO source requests VO info again
						CVoRequestVoInfo(Scaler_Get_CurVoInfo_plane());
					}
					#endif
					Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH); // hsliao 20090311, from active state or search state to search state

#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH
					if(_FALSE == modestate_send_ypbpr_and_av_same_path_init_msg())
						flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT : _FL2FL_MAIN_STATE_PERIODIC_EVENT);
#else //#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH
					flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT : _FL2FL_MAIN_STATE_PERIODIC_EVENT);
#endif //#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH

					Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,0);
				} else {
					flow_message_push(_FL2FL_MAIN_SET_FRAMESYNC_SIGNAL);
					Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT)+1);
				}
#endif
				// while frame sync fail, must return fail
				// then try again, if frame sync still fail, goto search-state to re-detect signal.
				return FALSE;
			}else{
#ifdef CONFIG_FS_HS_BIAS
				if(drvif_framesync_hs_bias() == FALSE)
					return FALSE;
#endif
				// for gatting debug
				/*if(Scaler_InputSrcGetMainChType()==_SRC_VO){
					drvif_framesync_gatting(_ENABLE);
				}*/

			//	fw_dvi_framesync_setting();

			}
#endif
		}
#endif
#if 0
		if((GET_HDMI_3DTYPE() == HDMI3D_FRAMESEQUENCE) &&  Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()
		&& (((Scaler_InputSrcGetMainChType() == _SRC_VO) && (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_NON_ACTIVE)) || (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_VO_GO)))
		{
			memory_3ddma_control();
			drvif_3ddma_DVTotal_Set(2);
		}
#endif

		//Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,0);
		if(Get_DISPLAY_PANEL_TYPE() != P_VBY1_4K2K){
			if(!(Scaler_InputSrcGetMainChType() == _SRC_TV && Scaler_GetTvBlueScreen() == FALSE))	// weihao 960308
				fw_scaler_enable_fs_wdg(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), TRUE);
			else
				fw_scaler_enable_fs_wdg(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), FALSE);
		}
#if 0
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			&&(!drvif_i3ddma_triplebuf_flag())
			&&(get_HDMI_HDR_mode() != HDR_DOLBY_HDMI)
			//&&(pVOInfo->src_v_len>2000)
			){
			drv_I3ddmaVodma_GameMode_iv2pv_delay(TRUE);
		} else {
			drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
		}
#endif
		//drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
	} else 
#endif
    {
#if 0 //frank@0903 mark redundent code
		if(Scaler_InputSrcGetMainChType() == _SRC_VGA) {	// weihao 960308
			fw_scaler_update_mode_para(); //update mode status after set capture window
		}
#endif

		//Set M-domain setting
		dvrif_memory_handler();
#if 0
		//USER:LewisLee DATE:2012/06/21
		//for SW buffer swap, need some IVS2DVS delay
		//to prevent DVS swap buffer too close IVS
		if(SLR_MAIN_DISPLAY == Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY))
		{
			if(TRUE == framesync_get_enterlastline_at_frc_mode_flg())
			{
				//it have set ivs2dvs Value
			}
			else// if(FALSE == framesync_get_enterlastline_at_frc_mode_flg())
			{
				//frank@0617 mark below code to speed up,below code will setting by memory_set_input_format
#if 0

				drvif_set_frc_ivs2dvsdelay_line(_FRC_MODE_IVS2DVS_LINE_1, _FRC_MODE_IVS2DVS_LINE_2, 0);
				drvif_set_frc_ivs2dvsdelay_pixel(_FRC_MODE_IVS2DVS_PIXEL_1, _FRC_MODE_IVS2DVS_PIXEL_2, 0);
#endif
			}
		}
//#else //#if 1
		if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
			drvif_clear_ivs2dvsdelay();

		modestate_set_FRC_fix_last_line();
#endif //#if 1
	}

//USER : LewusLee DATE:2012/11/30
//move position
#if 0
//USER : LewusLee DATE:2012/08/30
//for novatek Tcon IC, too easy to enter burn in mode
//sw we need to set FRC -> Framesync moer smooth
	framesync_adjust_dvtotal_at_framesync_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif

 	return TRUE;

}
unsigned char (*fp_modestate_set_framesync)(StructDisplayInfo* info) = modestate_set_framesync;
#ifndef BUILD_QUICK_SHOW
void state_update_disp_info(void)	// updated by hsliao 20090515
{
	SCALER_DISPINFO_PKG info_pkg;
	unsigned char i;
	int ret;
	unsigned int ulIPKGItemCount = 0;
	unsigned int *pulTemp;
	for ( i=0 ; i<MAX_DISP_CHANNEL_NUM ; ++i )
    {
        info_pkg.disp_info[i].input_src = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_INPUT_SRC);
        info_pkg.disp_info[i].state = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_STATE);
        info_pkg.disp_info[i].disp_status = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_STATUS);
        info_pkg.disp_info[i].display = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISPLAY);
        info_pkg.disp_info[i].MEM_ACT_WID = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_WID);
        info_pkg.disp_info[i].MEM_ACT_LEN = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_LEN);
        info_pkg.disp_info[i].MEM_ACT_HSTA = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_HSTA);
        info_pkg.disp_info[i].MEM_ACT_VSTA = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_VSTA);
        info_pkg.disp_info[i].ucMode_Curr = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MODE_CURR);
        info_pkg.disp_info[i].DispWid = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_WID);
        info_pkg.disp_info[i].DispLen = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_LEN);
        info_pkg.disp_info[i].IVFreq = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_V_FREQ);
        info_pkg.disp_info[i].CapWid = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_CAP_WID);
        info_pkg.disp_info[i].CapLen = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_CAP_LEN);
        info_pkg.disp_info[i].IphActWid_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_WID_PRE);
        info_pkg.disp_info[i].IpvActLen_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_LEN_PRE);


        info_pkg.disp_info[i].IpvActSTA_H = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_STA);
        info_pkg.disp_info[i].IpvActSTA_V = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_STA);
        info_pkg.disp_info[i].IphActWid_H = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_WID);
        info_pkg.disp_info[i].IpvActLen_V = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_LEN);
        info_pkg.disp_info[i].Iph_STA_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_STA_PRE);
        info_pkg.disp_info[i].Ipv_STA_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_STA_PRE);

        info_pkg.disp_info[i].src_h_total = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_H_LEN);
        info_pkg.disp_info[i].src_v_total = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_V_LEN);
        info_pkg.disp_info[i].scaler_source_type = Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)i);
        if (i==0) {
            info_pkg.disp_info[i].input_2_pixel_mode = get_hdmi_4k_hfr_mode();
        } else {
            info_pkg.disp_info[i].input_2_pixel_mode = 0;
        }
        switch(Get_DisplayMode_Src(i))
        {//get adn set ui real src input
            case KADP_VSC_INPUTSRC_AVD:
                info_pkg.disp_info[i].ui_select_src = get_AVD_Input_Source();
                break;

            case KADP_VSC_INPUTSRC_ADC:
                info_pkg.disp_info[i].ui_select_src = get_ADC_Input_Source();
                break;

            case KADP_VSC_INPUTSRC_HDMI:
                info_pkg.disp_info[i].ui_select_src = _SRC_HDMI;
                break;

            case KADP_VSC_INPUTSRC_VDEC:
            case KADP_VSC_INPUTSRC_JPEG:
                info_pkg.disp_info[i].ui_select_src = _SRC_VO;
                break;

            case KADP_VSC_INPUTSRC_DP:
                info_pkg.disp_info[i].ui_select_src = _SRC_MINI_DP;//need provide from driver team
                break;

            case KADP_VSC_INPUTSRC_MAXN:
                info_pkg.disp_info[i].ui_select_src = _SRC_MAX;
                default:

            case KADP_VSC_INPUTSRC_HDD:
            case KADP_VSC_INPUTSRC_VBY1RX:
                info_pkg.disp_info[i].ui_select_src = _SRC_MAX;
                break;
        }
    }

    pulTemp = (unsigned int *)(&info_pkg);

    ulIPKGItemCount = sizeof(SCALER_DISPINFO_PKG) / sizeof(unsigned int);

    // change endian
    for (i = 0; i < ulIPKGItemCount; i++)
        pulTemp[i] = htonl(pulTemp[i]);

    //frank@0801 compare Disp_info is the same of video firmware,when the result is the same then return to speed up the code
    if (memcmp((unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_SETDISPINFO), pulTemp, sizeof(SCALER_DISPINFO_PKG)) == 0) //compare equal or not
        return;
    // copy from RPC share memory
    memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_SETDISPINFO), pulTemp, sizeof(SCALER_DISPINFO_PKG));

    if ((ret = Scaler_SendRPC(SCALERIOC_SETDISPINFO,0,0)) < 0)
    {
        rtd_pr_vsc_debug("ret = %d, set disp_info to driver fail !!!\n", ret );
        return;
    }

}

static struct vsc_film_mode_parameter_t vsc_film_mode_parameter = {0, 0, 60};

int vsc_get_film_mode_enable(void)
{
	return vsc_film_mode_parameter.enable;
}

int vsc_get_film_mode_type(void)
{
	return vsc_film_mode_parameter.type;
}

/*
int vsc_get_film_mode_type(void)
{
	return vsc_film_mode_parameter.type;
}
*/
#ifndef UT_flag
struct vsc_film_mode_parameter_t vsc_set_film_mode_param(int film_mode_enable, int film_mode_type, int v_freq)
{
	struct vsc_film_mode_parameter_t cur_film_mode_parameter = {vsc_film_mode_parameter.enable, vsc_film_mode_parameter.type, vsc_film_mode_parameter.v_freq};

	if(!((film_mode_type == VO_FILM_TYPE_NONE) && (vsc_film_mode_parameter.type == 0))){
		rtd_pr_vsc_notice("[FILM] vsc_set_film_mode_param=%d/%d/%d\n", film_mode_enable, film_mode_type, v_freq);
		down(&set_vsc_film_mode_semaphore);
		//if new film type is NONE and current is 0, no need to run type change
		vsc_film_mode_parameter.enable = film_mode_enable;
		vsc_film_mode_parameter.type = film_mode_type;
		vsc_film_mode_parameter.v_freq = v_freq;
		up(&set_vsc_film_mode_semaphore);
	}

	return cur_film_mode_parameter;
}

#if 0 //mac7p remove
extern void drivf_scaler_change_film_mode_type(int enable, int type, int v_freq);
// FixMe, 20190925
extern void MEMC_Lib_set_memc_enable_to_bypass_flag(unsigned char u1_enable);
static int film_mode_change_task_flag = FALSE;
struct task_struct *p_film_mode_change_task = NULL;
#ifndef CONFIG_MEMC_BYPASS
unsigned int memc_me_clock_set_off = 0;
#endif
static int film_mode_change_task(void *data)
{
	struct vsc_film_mode_parameter_t cur_film_mode_parameter;
#ifndef CONFIG_MEMC_BYPASS
	unsigned int memc_me_clock = 0;
#endif
	while (1) {
#ifndef CONFIG_MEMC_BYPASS
		//Eric@20180913 check memc_me_clock_off status
		memc_me_clock = (IoReg_Read32(0xb800011c) & _BIT30) >> 30;
		if (Scaler_get_memc_me_clock_off() && memc_me_clock && !memc_me_clock_set_off &&
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) &&
			(Get_DISPLAY_REFRESH_RATE() != 120)
			/* && !modestate_get_fll_running_flag()*/	//Eric@20180926 do not check but break fll task.
			)
		{
			memc_me_clock_set_off = 1;
			rtd_pr_vsc_info("[FILM][%s] memc_me_clock_off = %d, memc_me_clock = %d, set ME clock off!!!\n", __func__,Scaler_get_memc_me_clock_off(),memc_me_clock);
			// FixMe, 20190925
			//MEMC_Lib_set_memc_enable_to_bypass_flag(1);
			Scaler_MEMC_MEMC_CLK_OnOff(0, 1, 0);
			memc_me_clock = (IoReg_Read32(0xb800011c) & _BIT30) >> 30;
			rtd_pr_vsc_info("[FILM][%s] memc_me_clock_off = %d, memc_me_clock = %d, set ME clock off done!!!\n", __func__,Scaler_get_memc_me_clock_off(),memc_me_clock);
		}
		if((memc_me_clock == 0) && (memc_me_clock_set_off == 1))
			memc_me_clock_set_off = 0;
#endif
		if (vsc_get_film_mode_enable() &&
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			/* && !modestate_get_fll_running_flag()*/	//Eric@20180926 do not check but break fll task.
			)
		{
			rtd_pr_vsc_info("FILM_MODE %s, start\n", __func__);
			cur_film_mode_parameter = vsc_set_film_mode_param(0, 0, 0);
			film_mode_parameter = cur_film_mode_parameter;
			drivf_scaler_change_film_mode_type(1, cur_film_mode_parameter.type, cur_film_mode_parameter.v_freq);
			rtd_pr_vsc_info("FILM_MODE %s, end\n", __func__);
		}
		//Eric@20180926 do not check but break fll task.
		/* else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && modestate_get_fll_running_flag()){
			if(Scaler_get_film_mode_change_type() != 2){
			    rtd_pr_vsc_info("FILM_MODE FLL Running...\n");
			    Scaler_set_film_mode_change_type(2);
			}
		}*/
		else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
			if(Scaler_get_film_mode_change_type() != 3){
			    rtd_pr_vsc_info("FILM_MODE scaler state(%d) not in ACTIVE!!\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE));
			    Scaler_set_film_mode_change_type(3);
			}
		}else if(Scaler_get_film_mode_change_type()){
			rtd_pr_vsc_info("FILM_MODE running state[%d] reset\n", Scaler_get_film_mode_change_type());
			Scaler_set_film_mode_change_type(0);
		}

		if (freezing(current)) {
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}

		msleep(10);
	}
	rtd_pr_vsc_debug("\n%s exit\n", __func__);
	do_exit(0);
	return 0;
}
#endif


struct vsc_film_mode_parameter_t get_film_mode_parameter(void){
	return film_mode_parameter;
}

#if 0 //mac7p remove
static void create_film_mode_change_task(void)
{
	if (film_mode_change_task_flag == FALSE) {
		p_film_mode_change_task = kthread_run(film_mode_change_task, NULL, "init film_mode_change_task");

		if (IS_ERR(p_film_mode_change_task)) {
			rtd_pr_vsc_err("create film mode change task failed\n");
		} else {
			rtd_pr_vsc_notice("create film mode change task OK\n");
			film_mode_change_task_flag = TRUE;
		}
	}
}


static void delete_film_mode_change_task(void)
{
	int ret;
	if (film_mode_change_task_flag == TRUE) {
		ret = kthread_stop(p_film_mode_change_task);
		if (!ret) {
			p_film_mode_change_task = NULL;
			film_mode_change_task_flag = FALSE;
		}
	}
}
#endif
#if 1
//static bool hdmi_4k120_se_task_flag = FALSE;
//static struct task_struct *p_hdmi_4k120_se_tsk = NULL;
//extern unsigned int i3ddma_cap_isr_cnt;
//extern void scaler_hdmi_4k120_UV_interleave(void);
//int i3ddma_dump_cap0cap2_to_file(unsigned int bufferindex);

void hdmi_4k120_se_wakeup(void)
{
	hdmi_4k120_se_trigger_flag = TRUE;
	wake_up(&HDMI_4K120_SE_WAIT_QUEUE);
}
#if 0//mac7p remove
static int hdmi_4k120_se_task(void *p)//This task run se proc
{
	static unsigned int vgip_isr_cnt_pre = 0;

	rtd_pr_vsc_debug("hdmi_4k120_se_task()\n");

	current->flags &= ~PF_NOFREEZE;

	while (1)
	{
		wait_event_freezable(HDMI_4K120_SE_WAIT_QUEUE, hdmi_4k120_se_trigger_flag);

		if(hdmi_4k120_se_trigger_flag)
		{
			hdmi_4k120_se_trigger_flag = FALSE;

			if((i3ddma_cap_isr_cnt != vgip_isr_cnt_pre))
			{
				vgip_isr_cnt_pre = i3ddma_cap_isr_cnt;

				if(get_i3ddma_4k120_flag() == TRUE)
				{
					//rtd_pr_vsc_emerg("se_task:i3ddma_cap_isr_cnt=%d\n",i3ddma_cap_isr_cnt);
					scaler_hdmi_4k120_UV_interleave();
				}
			}
		}
		#ifdef CONFIG_FORCE_RUN_I3DDMA
		//dump 4k120 data
		if(get_i3ddma_4k120_flag() == TRUE)
		{
			if(IoReg_Read32(0xb802020c)& _BIT20)
			{
				IoReg_ClearBits(0xb802020c, _BIT20);
				i3ddma_dump_cap0cap2_to_file(0);
			}
		}
		#endif
		// to prevent STR/Snapshot fail
		if (freezing(current))
		{
			try_to_freeze();
		}

		if (kthread_should_stop()){
			rtd_pr_vsc_debug("hdmi_4k120_se_task stop!!\n");
			break;
		}



	}

    rtd_pr_vsc_debug("\r\n####hdmi_4k120_se_task: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_hdmi_4k120_se_task(void)
{
	int err;
	if (hdmi_4k120_se_task_flag == FALSE) {
		p_hdmi_4k120_se_tsk = kthread_create(hdmi_4k120_se_task, NULL, "hdmi_4k120_se_task");

		if (p_hdmi_4k120_se_tsk) {
			wake_up_process(p_hdmi_4k120_se_tsk);
			hdmi_4k120_se_task_flag = TRUE;
		} else {
			err = PTR_ERR(p_hdmi_4k120_se_tsk);
			rtd_pr_vsc_debug("Unable to start create_hdmi_4k120_se_task (err_id = %d)./n", err);
		}
	}
}


static void delete_hdmi_4k120_se_task(void)
{
	int ret;
	if (hdmi_4k120_se_task_flag) {
		ret = kthread_stop(p_hdmi_4k120_se_tsk);
		if (!ret) {
			p_hdmi_4k120_se_tsk = NULL;
			hdmi_4k120_se_task_flag = FALSE;
			rtd_pr_vsc_debug("hdmi_4k120_se_task thread stopped\n");
		}
	}
}
#endif
#endif

unsigned char Scaler_get_vdec_2k120hz(void){
	if(!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) &&
		(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE) == 1920) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE) == 1080) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_VO_SRC_FRAMERATE) >= 1195))
		return 1;
	else
		return 0;
}
#endif
#endif
#ifndef UT_flag
unsigned int scaler_get_idomain_vfreq_pre(void)
{
	return idomain_vfreq_pre;
}
#endif
#ifndef BUILD_QUICK_SHOW

extern void drv_memory_display_set_input_fast(void);
#ifndef UT_flag
extern void drvif_color_rtnr_progressive_check(unsigned char interlace_flag, unsigned char channel, unsigned char db_apply);
extern void scalerVIP_Write_s1_RGB2YUV(unsigned long arg);
extern void i2rnd_s1_default_memory_tag(void);

#endif
extern int Scaler_MEMC_DTV_ME_CLK_OnOff(unsigned char enable, unsigned char bMute);
#ifndef UT_flag
extern int vbe_dtg_memec_bypass_switch(void);
extern void vbe_dtg_memec_bypass_switch_set(int mode);
extern unsigned int vbe_get_HDMI_dynamic_film_mode_flag(void);
// FixMe, 20190925
//extern void MEMC_Lib_set_INPUT_COLOR_SPACE_Mode(unsigned char u1_mode);

#endif
static unsigned int record_Setup_IMD_timer_counter = 0;// record TIMER_SCPU_CLK90K_LO_reg after Setup_IMD

unsigned char judge_main_hdrtype(void)
{
	unsigned char  hdrtype = HDR_DM_MODE_NONE;
	VSC_INPUT_TYPE_T src_type = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	seamless_change_sync_info *seamless_info = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);

	if(src_type == VSC_INPUTSRC_VDEC) {
		/* 20170908, pinyen add dolby hdr case */
		if (get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER) {
			hdrtype = HDR_DM_DOLBY;
		} else if (seamless_info) {
			/* cp case and webos call dm connect and vo don't know har type. Currently this is youtube case */
			if (ntohl(seamless_info->vdec_cur_hdr_type) == HDR_DM_MODE_NONE) {
				if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (get_OTT_HDR_mode() == HDR_HDR10_VDEC)) {
					if(MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HLG) {
						/* according tha AP type */
						hdrtype = HDR_DM_HLG;
					} else {
						/* according tha AP type */
						hdrtype = HDR_DM_HDR10;
					}
				} else if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
					hdrtype = HDR_DM_SDR_MAX_RGB;
				}
			} else if ((ntohl(seamless_info->vdec_cur_hdr_type)) == HDR_DM_HDR10) {
				hdrtype = HDR_DM_HDR10;
			} else if ((ntohl(seamless_info->vdec_cur_hdr_type)) == HDR_DM_HLG) {
				hdrtype = HDR_DM_HLG;
			} else if ((ntohl(seamless_info->vdec_cur_hdr_type)) == HDR_DM_TECHNICOLOR) {
				hdrtype = HDR_DM_TECHNICOLOR;
			} else if ((ntohl(seamless_info->vdec_cur_hdr_type)) == HDR_DM_ST2094) {
				/* hdrtype = HDR_DM_ST2094 */
				if (drvif_Get_ST2094_EFuse_Status() == 0) {
					hdrtype = HDR_DM_ST2094;
				} else {
					hdrtype = HDR_DM_HDR10;
				}
			} else if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
				hdrtype = HDR_DM_SDR_MAX_RGB;
			}
		}
	} else if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) {
#ifdef CONFIG_RTK_KDRV_DV
		/*20170908, pinyen add dolby hdr case*/
		if (get_HDMI_HDR_mode() == HDR_DOLBY_HDMI) {
			dolby_adapter_set_g_picModeUpdateFlag(3);
			hdrtype = HDR_DM_DOLBY;
		} else
#endif
		if (get_HDMI_HDR_mode() == HDR_HDR10_HDMI) {
			/*HLG case from LG*/
			if (MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HLG) {
				hdrtype = HDR_DM_HLG;
			} else if (MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HDR10_PLUS) {
				/* hdrtype = HDR_DM_ST2094 */
				if (drvif_Get_ST2094_EFuse_Status() == 0) {
					hdrtype = HDR_DM_ST2094;
				} else {
					hdrtype = HDR_DM_HDR10;
				}

			} else {
				hdrtype = HDR_DM_HDR10;
			}
		} else if ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)) {
			/*hdmi2.0 4k2k120 mode can not do hdr */
			hdrtype = HDR_DM_MODE_NONE;
		} else if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
			hdrtype = HDR_DM_SDR_MAX_RGB;
		} else if (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) {
			/* if two pixel mode sdr also need to go vtop */
			hdrtype = HDR_DM_SDR_MAX_RGB;
		}
	} else if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
		hdrtype = HDR_DM_SDR_MAX_RGB;
	}

	return hdrtype;
}
static DECLARE_WAIT_QUEUE_HEAD(hdr_type_apply_wq);
static bool hdr_type_setting_finish = false;
static int setup_imd_hdr_type_thread(void *data)
{
	unsigned long hdrtype = (unsigned long)data;

	down(&HDR_Setting_Semaphore);
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	down(get_dolby_vision_dm_path_sem());
#endif

	Scaler_color_set_HDR_Type(hdrtype);
	scaler_vtop_dolby_mode_setting(hdrtype);
	if(Scaler_color_Get_HDR_AutoRun())
		Scaler_color_HDRIP_AutoRun(hdrtype);
	scaler_hdr_mode_setting(SLR_MAIN_DISPLAY, hdrtype);
	if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
		scaler_hdr_mode_setting(SLR_SUB_DISPLAY, HDR_DM_MODE_NONE);//set sub hdr off for 4k120 hdmi2.0
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	up(get_dolby_vision_dm_path_sem());
#endif

	down(&SetMainOutPutRegion_Semaphore);
	if(!get_main_scaler_stop_flag())
		set_hdr_semaless_active(TRUE);
	up(&SetMainOutPutRegion_Semaphore);

	Scaler_SetDataFormatHandler();
	up(&HDR_Setting_Semaphore);

	hdr_type_setting_finish = true;
	wake_up(&hdr_type_apply_wq);

	return 0;
}

void setup_imd_hdr_impl(unsigned int hdrtype)
{
	unsigned int *hdrtype_t = (unsigned int *)(long)hdrtype;


	hdr_type_setting_finish = false;

	if (hdrtype == HDR_DM_DOLBY) {
		setup_imd_hdr_type_thread(hdrtype_t);
	} else {
		kthread_run(setup_imd_hdr_type_thread, hdrtype_t, "set_hdr_type_thread");
	}
}
void (*setup_imd_hdr)(unsigned int hdrtype)=setup_imd_hdr_impl;

static void setup_imd_wait_hdr_type_finish(void)
{
	long time_left = wait_event_freezable_timeout(hdr_type_apply_wq, hdr_type_setting_finish, 2 * HZ);
	rtd_pr_vsc_info("[%s:%d] wait hdr type set finish result = %d (%ld)\n", __func__, __LINE__, hdr_type_setting_finish, time_left);
}

static void disable_vsc_force_timing_freerun(void)
{
	/* hdmi trigger free run */
	if(Get_Vsc_Force_Timing_Freerun()) {
		/* reset forcefree run flag */
		Set_Vsc_Force_Timing_Freerun(FALSE);
	}
}

static void wait_m_cap_last_write_done(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY) {
		/* add main double buffer apply @Crixus 20160126 */
		imd_smooth_main_double_buffer_all_apply();
		if (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE) {
			/* Update the M-domain last done @Crixus 20161013 */
			if ((TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
					&& (get_rotate_mode(SLR_MAIN_DISPLAY) != DIRECT_VO_FRAME_ORIENTATION_DEFAULT)) {
				/* triple buf for rotate */
				drv_memory_wait_mdom_vi_last_write_done(SLR_MAIN_DISPLAY, 3);
			} else if (drv_memory_Get_multibuffer_flag()) {
				drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, drv_memory_Get_multibuffer_number() - 1, FALSE);
			} else if (drv_memory_Get_multibuffer_changed()) {
				drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, drv_memory_Get_multibuffer_number_pre() - 1, FALSE);
			} else {
				if (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) >=3840
						&& Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >=2160
						&&  Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<=310) {
					drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, 2, FALSE);
				} else {
					drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, 1, FALSE);
				}
			}

			if (drv_memory_Get_multibuffer_changed()) {
				drv_memory_Set_multibuffer_changed(false);
			}
		}
	} else {
		/* add sub double buffer apply @Crixus 20160126 */
		imd_smooth_sub_double_buffer_all_apply();
		if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE){
			if (!get_sub_OutputVencMode()) {
				/* sub m domain iterrupt open so don't need wait lastwrite @qing_liu --s4ap */
				/* Update the M-domain last done @Crixus 20161013  */
				drv_memory_wait_cap_last_write_done(SLR_SUB_DISPLAY, 1, FALSE);
			}
		}
	}
}

static void check_and_set_mdomain_input_fast(unsigned char display)
{
	if ((display == SLR_MAIN_DISPLAY)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)) {

		/* if input fast case, it need to wait capture done
		 * , then set FRC style.
		 */
		if (mdomain_input_fast_flag) {
			drv_memory_display_set_input_fast();
			mdomain_input_fast_flag = 0;
		}
	}
}

static bool check_online(unsigned char display)
{
	bool flag_check_online_result = true;;

	if (display == SLR_MAIN_DISPLAY) {
		if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
				|| (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == true)) {
			if (!check_online_result(SLR_MAIN_DISPLAY, _MAIN_VGIP_PATH))
				flag_check_online_result = false;
		} else {
			if (get_force_i3ddma_enable(SLR_MAIN_DISPLAY)) {
				if(!check_online_result(SLR_MAIN_DISPLAY, _DAM_VGIP_PATH))
					flag_check_online_result = false;
			} else {
				if(!check_online_result(SLR_MAIN_DISPLAY, _MAIN_VGIP_PATH))
					flag_check_online_result = false;
			}
		}
	} else {
		if(!check_online_result(SLR_SUB_DISPLAY, _SUB_VGIP_PATH))
			flag_check_online_result = false;
	}

	return flag_check_online_result;
}

static void set_vgip_v1_v3_swap(void)
{
	if ((Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_TV
				|| Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_CVBS
				|| Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_SV)
			&& (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422) == TRUE)) {
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		IoReg_Mask32(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_MISC_reg : VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _BIT0);
#else
		IoReg_Mask32(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)?SUB_VGIP_VGIP_CHN2_MISC_reg:*/VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _BIT0);
#endif
	} else {
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		IoReg_Mask32(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_MISC_reg : VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _ZERO);
#else
		IoReg_Mask32(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)?SUB_VGIP_VGIP_CHN2_MISC_reg:*/VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _ZERO);
#endif
	}
}

extern unsigned int DI_SW_Detection_90k;
unsigned char DI_SW_Detection_set_check = 0;
void Set_DI_SW_Detection_in_IMD(unsigned char display)
{
	extern unsigned char DI_SW_Reset_INIT_Flag;
	int timeout_cnt = 500;
	unsigned int t0, t1, t2;
	_RPC_system_setting_info *RPC_vipSysInfo = NULL;

	RPC_vipSysInfo = (_RPC_system_setting_info *)Scaler_GetShareMemVirAddr(SCALERIOC_VIP_RPC_system_info_structure);

	if(display == SLR_MAIN_DISPLAY) {
		t0 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
		//DI_SW_Reset_INIT_CNT = 0;
		if((DI_IM_DI_CONTROL_get_ip_enable(IoReg_Read32(DI_IM_DI_CONTROL_reg)) ==1 ) &&
			(DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 0) &&
			(VGIP_Data_Path_Select_get_xcdi_clk_en(IoReg_Read32(VGIP_Data_Path_Select_reg)) == 1)) {

			IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1
			DI_SW_Detection_set_check = 1;
			rtd_pr_vsc_info("DI_Enable, DI reset En, t0=%d, DI_SW_Reset_INIT_Flag=%d,\n", t0, DI_SW_Reset_INIT_Flag);

			if ((DI_SW_Reset_INIT_Flag == 1) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) &&
				(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ==1) /*&& (get_platform() == PLATFORM_KXLP)*/) {
				timeout_cnt = 500;
				while ((DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 1) && (timeout_cnt>0)) {
					usleep_range(100, 200);
					timeout_cnt--;
				}

				t1 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
				if (timeout_cnt<=0) {
					IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
					DI_SW_Detection_set_check = 0;
					rtd_pr_vsc_emerg( "DI_Enable, DI reset En timeout, t0=%d,t1=%d, timeout_cnt=%d,\n", t0, t1, timeout_cnt);
				}
				//DI_SW_Reset_INIT_CNT = 2;
				//DI_SW_Reset_INIT_CNT = 0;
				usleep_range(42000, 43000);

				t2 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
				IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1
				DI_SW_Detection_set_check = 1;

				rtd_pr_vsc_info("DI_Enable, DI reset En 2, t0=%d,t1=%d, t2=%d, timeout_cnt=%d,\n", t0, t1,t2,  timeout_cnt);
			}

		}else{
			IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
			DI_SW_Detection_set_check = 0;
			t1 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
			if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_THRIP) || Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_RTNR)) {
				rtd_pr_vsc_emerg( "DI_Enable, DI should be reset,ip_en=%d, sw_detect_en=%d,xcdi_clk=%d,DISP_THRIP=%d,DISP_RTNR=%d,t0=%d,\n",
					DI_IM_DI_CONTROL_get_ip_enable(IoReg_Read32(DI_IM_DI_CONTROL_reg)),
					DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)),
					VGIP_Data_Path_Select_get_xcdi_clk_en(IoReg_Read32(VGIP_Data_Path_Select_reg)),
					Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_THRIP), Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_RTNR), t0);

					usleep_range(42000, 43000);

					t2 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
					IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1
					DI_SW_Detection_set_check = 1;

					rtd_pr_vsc_info("DI_Enable, DI should be reset, t0=%d,t1=%d, t2=%d, timeout_cnt=%d,\n", t0, t1,t2,  timeout_cnt);
			} else {
				rtd_pr_vsc_info("DI_Enable, DI reset Disable, t0=%d,\n", t0);
			}
		}
		DI_SW_Reset_INIT_Flag = 0;
		DI_SW_Detection_90k = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);

		if (RPC_vipSysInfo != NULL)
			RPC_vipSysInfo->PQ_IP_Enable_Monitor_2.DI_RTNR_SW_Detection_90k = Scaler_ChangeUINT32Endian(DI_SW_Detection_90k);

		rtd_pr_vsc_info("DI_Enable, DI reset DI_SW_Detection_in_VPQ_TSK_Stable_CNT=%d,\n", DI_SW_Detection_90k);
	}
}

void scaler_data_frame_sync_enable_gatting(unsigned char webos_src)
{
		//VDEC 2k1k use original flow, framesync with gatting
		if(((webos_src == VSC_INPUTSRC_VDEC)
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
			&& !((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > DATAFS_DISABLE_GATTING_WIDTH) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > DATAFS_DISABLE_GATTING_HEIGHT))
#endif
                )
			||(webos_src == VSC_INPUTSRC_HDMI) || (webos_src == VSC_INPUTSRC_JPEG))
		{
    			unsigned int frame_delay = 0;
    			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 0)
    				frame_delay = (10000/Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ));
    			//Scaler_wait_for_frc2fs_hw_lock_done(SLR_MAIN_DISPLAY);
    			Scaler_wait_for_LCM_done();
    			scaler_set_full_gatting_rpc(true);
    			rtd_pr_vbe_notice("Enable gatting delay to input timing change\n");
    			//delay 1 frame
    			usleep_range(frame_delay * 1000, frame_delay * 1000);
			framesync_clear_ibuffer_err_status();
			MODE_CLEAR_ONMS_FLAG();

			if((webos_src == VSC_INPUTSRC_VDEC) || (webos_src == VSC_INPUTSRC_JPEG))//vo smooth toggle don't need onlinemeasure
			{
				//Real Vo case
				drvif_mode_enableonlinemeasure(SLR_MAIN_DISPLAY);//Enable online measure
				drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_VO, TRUE, FALSE);
				rtd_pr_vbe_notice("Data FS enable ONMS!\n");
			}
		}
}

unsigned (*fp_judge_scaler_break_case)(unsigned char display) = judge_scaler_break_case;
#define CHECK_JUDGE_BREAK(...)						\
	do {								\
		if (fp_judge_scaler_break_case(display)) {			\
			rtd_pr_vsc_debug(__VA_ARGS__);				\
			goto error_setup_imd_check_i2d;			\
		}							\
	} while (0);

unsigned char Setup_IMD_impl(StructDisplayInfo* info)
{
	//extern void two_pixel_mode_edge_smooth_update(void);//two pixel mode edge smooth setting force update//mac7p pq compile fix
	unsigned char srcType_2d;
	unsigned char phase_result = 0;
	unsigned char display;
#ifndef ADC_UP_DOWN_CLAMP
	int count;
#endif
//	mdomain_cap_cap_ddr_fifostatus_RBUS cap_ddr_fifostatus_reg;
//	unsigned char game_mode_wait_frame = 0;
//	unsigned int plane=0;
	VSC_INPUT_TYPE_T webos_src;
	unsigned char hdrtype = HDR_DM_MODE_NONE;
	unsigned int src_type = 0;
    unsigned int *setup_di_done_flag = NULL;
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			ROTATE_MODE_LIST rotatemode;
#endif

		display = info->display;

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if ((display == SLR_MAIN_DISPLAY) && (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY)))
	{
		rotatemode = (ROTATE_MODE_LIST)get_rotate_mode(SLR_MAIN_DISPLAY);
		rtd_pr_vsc_emerg("rotatemode=%d\n",rotatemode);
		Scaler_HDMI_Rotate(TRUE, rotatemode, 0);
	}

#endif

#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif

	Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT, 0);
#if(VSC_PROFILE == 1)
	unsigned int before_time = 0;
	unsigned int after_time = 0;
	before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif
	set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, FALSE);//disable hdmi av mute mask

	if(display == SLR_MAIN_DISPLAY)
	{
		set_mdomain_driver_status(false);//m domain driver not ready
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DTV_CHANNEL_CHANGE_HDR_SEAMLESS, 0);//diable DTV switch seamless mask
		disable_vsc_force_timing_freerun();

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
        if(TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
        {
            scaler_set_I2D_tracking_in_slow_mode(1);//disable speedup locking flow
        }
        else
#endif
        {
            scaler_set_I2D_tracking_in_slow_mode(0);//keep speedup locking flow
        }
		if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			two_pixel_mode_ctrl(1);
		else
			two_pixel_mode_ctrl(0);

    }

	set_di_wait_frame_num(0);//reset DI wait number
#ifdef ENABLE_AV1_AUTOSWITCH2SV1
		StructSourceInput *srcinput_pt = Scaler_InputSrc(Scaler_DispGetInputInfo(SLR_INPUT_INPUT_SRC));
		srcinput_pt->srcAutoSwitchAVSV_DB = 10;
#endif

		//Scaler_Set_Dynamic_Display_HV_total_Value((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

#ifdef ENABLE_DRIVER_I3DDMA
		// [I3DDMA] VO source I3DDMA enable/disable control
		modestate_I3DDMA_update_VO_3D_enable();
		srcType_2d = modestate_I3DDMA_get_In3dMode() ? drvif_I3DDMA_Get_Input_Info_Vaule(I3DDMA_INFO_INPUT_SRC_TYPE):
#else
		srcType_2d = Scaler_InputSrcGetType(display);
#endif
		webos_src = Get_DisplayMode_Src(display);

		if(fp_judge_scaler_break_case(display)) {
			rtd_pr_vsc_notice("####channel:%d scaler need to break 1!!!####\r\n", display);
			goto error_setup_imd;
		}

		if(display == SLR_MAIN_DISPLAY)
		{
				if(get_force_hdmi_hdr_flow_enable(display) == FALSE)
					reset_hdr_mode(SLR_MAIN_DISPLAY);//disable dolby mode
				decide_qos_mode();//for kernel team to decide BW mode

				down(&HDR_Setting_Semaphore);
				hdrtype = judge_main_hdrtype();
				up(&HDR_Setting_Semaphore);

				setup_imd_hdr(hdrtype);
				rtd_pr_vsc_info("[%s][%d] hdrtype=%d \n", __FUNCTION__, __LINE__,hdrtype);

		} else {	/* for sub*/
			src_type = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
			Scaler_SetDataFormatHandler();
			if(src_type == VSC_INPUTSRC_VDEC)
			{
				hdrtype = HDR_DM_MODE_NONE;
				scaler_hdr_mode_setting(SLR_SUB_DISPLAY, hdrtype);
			}
		}

		if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR) && (auto_phase_flow_bypass() == FALSE)){// Start YPbPr auto phase
			//rtd_pr_vsc_notice("%s(line: %d)####display=%d(0:main, 1:sub)####\r\n", __func__, __LINE__, display);
		#if 1 //enable auto phase flow, rzhen@2016-08-15
			rtd_pr_vsc_info("start drvif_ypbpr_auto_phasedo_start\n");
			phase_result = drvif_ypbpr_auto_phasedo_start(SLR_MAIN_DISPLAY);
			//rtd_pr_vsc_notice("drvif_ypbpr_auto_phasedo_start  result = %x\n", phase_result);
			if(phase_result != ERROR_SUCCEED){//Phase start setting fail
				rtd_pr_vsc_info("###########drvif_ypbpr_auto_phasedo_start fail#############\r\n");
				goto error_setup_imd;
			}else{
				rtd_pr_vsc_info("###########drvif_ypbpr_auto_phasedo_start success#############\r\n");
			}
		#else
			SyncProc_SetMinDiff(display);
		#endif
			drvif_scaler_check_vgip_data_dclk(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL));
		} else {
			if ((Get_sub_from_DI_mux_path()) && (display == SLR_SUB_DISPLAY)) {
				//tmp code
			}
			else
			{
				fw_scaler_set_sample(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _ENABLE);
				drvif_scaler_check_vgip_data_dclk(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL));
			}
			if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR))
				rtd_pr_vsc_notice("\r\n####YPP no need to run autophase again####\r\n");
		}

		set_vgip_v1_v3_swap();

		Scaler_SetDataFormatHandler();

		/* we have to remember the original iv2dvs delay and other parameters */
#ifdef CONFIG_DUAL_CHANNEL
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_DLY_PRE, Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? IoReg_ReadByte0(SUB_VGIP_VGIP_CHN2_DELAY_reg) : IoReg_ReadByte0(VGIP_VGIP_CHN1_DELAY_reg));
#else
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_DLY_PRE, IoReg_ReadByte0(VGIP_VGIP_CHN1_DELAY_reg));
#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD initial time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif

		if(!modestate_set_vgip(info)){//set VGIP fail for vo source return detect state
			//flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT: _FL2FL_MAIN_STATE_PERIODIC_EVENT);
			goto error_setup_imd;
		}

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set VGIP time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif

#ifdef CONFIG_I2RND_ENABLE
		//check s0 still run idomain stage before refine vo1 clock, vgip hporch and DI h_blk size @Crixus 20180119
		if((display == SLR_MAIN_DISPLAY) && !((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
			if((get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S1_REFINE_VO1) && (webos_src == VSC_INPUTSRC_VDEC)){
				Scaler_I2rnd_wait_timing_enable();
			}
			set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_START);
			rtd_pr_vsc_emerg("[I2RND]I2RND_S0_IDOMAIN_STAGE_START!!\n");
		}
#endif
#ifndef CONFIG_MEMC_BYPASS
		//IF HFR case, need bypass MEMC earlier, to avoid MEMC garbage
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && ((get_hdmi_4k_hfr_mode() != HDMI_NON_4K120) || force_enable_two_step_uzu())){
			//MEMC bypass
			Scaler_MEMC_MEMC_CLK_OnOff(0, 0, 1);
			//set MEMC mux disable
			Scaler_MEMC_Bypass_On(1);
	//		vbe_dtg_memec_bypass_switch_set(0);
			rtd_pr_vsc_notice("HFR bypass MEMC!!\n");
		}
#endif
		modestate_set_imd_domain(info);

		scaler_disp_dtg_pre_i_domain_setting(display);
		if(idomain_vfreq_pre != Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)){
			rtd_pr_vsc_emerg("input vfreq has changed, force return to re-run scaler!!!\n");
			goto error_setup_imd_check_i2d;
		}

		if(_ENABLE == Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)){
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				rtd_pr_vsc_emerg(" data fs go vbe_disp_decide_frc2fsync_using_I2D!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
				Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(FALSE);
				Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(TRUE);
			}else{
				rtd_pr_vsc_emerg(" data fs go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
				Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
				Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
			}
		}else{
			rtd_pr_vsc_emerg(" data frc go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
			Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
			Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
		}

#ifdef CONFIG_I2RND_ENABLE
		//check s0 still run idomain stage before refine vo1 clock, vgip hporch and DI h_blk size @Crixus 20180119
		if((display == SLR_MAIN_DISPLAY) && !((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
			set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_DONE);
			rtd_pr_vsc_emerg("[I2RND]I2RND_S0_IDOMAIN_STAGE_DONE!!\n");
		}
#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set imd time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif

		//modestate_arbitration_setup();

		//rtd_pr_vsc_emerg("Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_GameMode) = %d\n", Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_GameMode));


#ifdef CONFIG_WSS_ENABLE
		check_wss(_TRUE,0); // move here by linmc, need to wait wss stable
#endif
		//IoReg_SetBits(/*Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL) ? SYNCPROCESSOR_SP_MS2STUS_VADDR : */ONMS_onms1_status_reg, (_BIT14|_BIT15|_BIT8|_BIT9));//clear online ms error flag
		CHECK_JUDGE_BREAK("####channel:%d scaler need to break 2!!!\n", display)

//move her to let semaless work early
		if(display == SLR_MAIN_DISPLAY)
		{
			if(webos_src == VSC_INPUTSRC_HDMI)
			{
#ifdef CONFIG_HDR_SDR_SEAMLESS
#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
				i3ddma_cap1_interrupt_ctrl(TRUE);//enable i3ddma cap1 interrupt
#endif
#endif
			}
		}

		if(display == SLR_MAIN_DISPLAY)
		{
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			{
				//two_pixel_mode_edge_smooth_update();//force update//mac7p pq compile fix
			}
		}

#ifdef CONFIG_DUAL_CHANNEL
    if (((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode()) || ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode()))
#else
    if ((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode())
#endif
    {
		mdomain_handler_onlycap();
	}
	else {
		if (!fp_modestate_set_framesync(info))  // if fs fail, keep in fs state
		{
			goto error_setup_imd_check_i2d;
		}
	}
#if 0//remove in k4lp
		//run scaler IM-domain flow to sync timing info after running smooth toggle@Crixus 20160919
		if((DbgSclrFlgTkr.game_mode_dynamic_flag == TRUE)&&(display == SLR_MAIN_DISPLAY))
		{
			rtd_pr_vsc_notice("[GameMode][break for not setting d domain timing]Main re run scaler flow!!\n");
			//When enter or exit game mode, need to wait buffer write done @Crixus 20161005
			if(drv_memory_get_game_mode() == _ENABLE)
				game_mode_wait_frame = 1;//triple-buffer => single buffer, need to wait least 1 frame done.
			else
				game_mode_wait_frame = 3;//single-buffer => triple buffer, need to wait least 3 frame done.

			//Update the M-domain last done @Crixus 20161013
			drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, game_mode_wait_frame, FALSE);
			state_update_disp_info();//send scaler info to smoothtoggle ,for issue KTASKWBS-6453
			return TRUE;
		}
#endif
#ifdef CONFIG_I2RND_ENABLE
		//update s1 memory tag info before send memory in fo video fw @Crixus 20171223
		if(display == SLR_MAIN_DISPLAY)
			i2rnd_s1_default_memory_tag();
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
		//enable I2rnd_b05
         if (Scaler_I2rnd_b05_get_enable()) {
		 //	 Scaler_i2rnd_b05_buffer_copy();
             Scaler_I2rnd_b05_handler();
         }


#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set Mdomain time=%d ms",(after_time-before_time));
		before_time = after_time;
#endif

		setup_imd_wait_hdr_type_finish();
#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD online measure enable time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif
#ifdef CONFIG_DUAL_CHANNEL
		if (((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode())
        || ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode()))
#else
        if ((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode())
#endif
            {
			/*not open disp*/
			//in VENC mode, apvr need to enable d-domain den start irq @Crixus 20161014
			drvif_scaler_ddomain_switch_irq(_ENABLE);
#ifdef CONFIG_DUAL_CHANNEL
			if (display == SLR_SUB_DISPLAY)
				drvif_scaler_sub_mdomain_switch_irq(_ENABLE);
#endif
		} else {
			Scaler_disp_setting(display);
		}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	//rtd_setbits(TVSB2_TV_SB2_DCU1_ARB_CR1_reg,_BIT2|_BIT3);
	//if(DisplayModeInputInfo.type == VSC_INPUTSRC_VDEC || VencModeInputInfo.type ==VSC_INPUTSRC_VDEC || MemoryModeInputInfo.type ==VSC_INPUTSRC_VDEC)
			//if((rotatemode == ROTATE_MODE_90) || (rotatemode == ROTATE_MODE_180) || (rotatemode == ROTATE_MODE_270))
			if (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
				scaler_Rotate_VI_init_send_rpc();
#endif

		CHECK_JUDGE_BREAK("####channel:%d scaler need to break 3!!!\n", display)

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set display time=%d ms",(after_time-before_time));
		before_time = after_time;
#endif
	//Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT, 0);

#ifndef CONFIG_MEMC_BYPASS
	if(Get_MEMC_Enable_Dynamic() == 1){
		//run MEMC setting
		Scaler_MEMC_Handler();
	}

	// FixMe, 20190925
	//MEMC_Lib_set_INPUT_COLOR_SPACE_Mode(pc_mode_run_422());//I3DDMA_COLOR_SPACE_T

	if(0){//k-task8503 patch avoid set memc clk onoff(1) will mute main path
//	if(display == SLR_MAIN_DISPLAY){//k-task8503 patch avoid set memc clk onoff(1) will mute main path
		if(vbe_get_HDMI_dynamic_film_mode_flag()!= 1){
			if (vbe_dtg_memec_bypass_switch()) {
				rtd_pr_vsc_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_GGG][%d,%x]\n", ((rtd_inl(0xb8028100)>>13)&0x1), rtd_inl(0xb802e800));
				//Scaler_MEMC_Bypass_CLK(0);
				//Scaler_MEMC_Bypass_CLK_OnOff(0);
		#if 1
				Scaler_MEMC_DTV_ME_CLK_OnOff(0, 1);
		#endif
			} else {
				rtd_pr_vsc_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_HHH][%d,%x]\n", ((rtd_inl(0xb8028100)>>13)&0x1), rtd_inl(0xb802e800));
				//Scaler_MEMC_Bypass_CLK(1);
				//Scaler_MEMC_Bypass_CLK_OnOff(1);
		#if 1
				Scaler_MEMC_DTV_ME_CLK_OnOff(1, 1);
		#endif
			}
		}
	}
#else
rtd_pr_vsc_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_III]\n");
//	Scaler_MEMC_Bypass_CLK(0);
//	Scaler_MEMC_Bypass_CLK_OnOff(0);
#ifndef CONFIG_MEMC_BYPASS
	vbe_dtg_memec_bypass_switch_set(1);
#endif
	#if 1
		Scaler_MEMC_DTV_ME_CLK_OnOff(0, 1);
	#endif
#endif
	if(display == SLR_MAIN_DISPLAY)
	{
		check_di_buffer_mode();//Check DI buffer mode right or not. If wrong, recover it.
		Set_DI_SW_Detection_in_IMD(display);
		/*if((DI_IM_DI_CONTROL_get_ip_enable(IoReg_Read32(DI_IM_DI_CONTROL_reg)) ==1 ) &&
			(DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 0) &&
			(VGIP_Data_Path_Select_get_xcdi_clk_en(IoReg_Read32(VGIP_Data_Path_Select_reg)) == 1)) {
			IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1
			set_di_record_timer_counter(IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)); //sw reset, recount timer
		}else{
			IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
		}*/
	}

	setup_di_done_flag = (unsigned int *)Scaler_GetShareMemVirAddr(SCALERIOC_SETUP_DI_DONE);
	if(setup_di_done_flag)
    {
        *setup_di_done_flag = Scaler_ChangeUINT32Endian(1);
    }

	if(Scaler_InputSrcGetType(display) == _SRC_VO)
	{
		MODE_CLEAR_ONMS_FLAG();
		if(!Get_vo_smoothtoggle_timingchange_flag(display))  //vo smooth toggle don't need onlinemeasure
		{
			if(!((display == SLR_MAIN_DISPLAY) && (_ENABLE == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))) {	//data fs mode move to after gatting enable
				if((webos_src == VSC_INPUTSRC_VDEC) || (webos_src == VSC_INPUTSRC_JPEG)){
					//Real Vo case
					drvif_mode_enableonlinemeasure(display);//Enable online measure
					drvif_mode_onlinemeasure_setting(display, _SRC_VO, TRUE, FALSE);
				}
			}
		}

		if (get_scaler_stop_flag(display)) {
			rtd_pr_vsc_debug("\r\n####channel:%d vsc already disconnet !!!####\r\n", display);
			goto error_setup_imd_check_i2d;
		} else if(get_vo_change_flag(Get_DisplayMode_Port(display))){
			rtd_pr_vsc_debug("\r\n####channel:%d vo change!!!####\r\n", display);
			goto error_setup_imd_check_i2d;
		}
		down(get_vo_infosemaphore()); /* lock VO Semaphore */
#ifdef CONFIG_HDR_SDR_SEAMLESS
		if(display == SLR_MAIN_DISPLAY)
		{
			down(&HDR_Setting_Semaphore);
			if(!get_vo_change_flag(0)) {//main
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
			}
			up(&HDR_Setting_Semaphore);
		}
		else
		{
			if(!get_vo_change_flag(1))//sub
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
#else
		if(display == SLR_MAIN_DISPLAY)
		{
			if(!get_vo_change_flag(0))//main
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
		else
		{
			if(!get_vo_change_flag(1))//sub
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
#endif
		up(get_vo_infosemaphore()); /* Release VO Semaphore */
		state_update_disp_info();//Update the active state
		if(((Get_vo_smoothtoggle_timingchange_flag(display)) && (get_vo_smoothtoggle_state(display) == SLR_SMOOTH_TOGGLE_INIT) && (Scaler_DispGetInputInfo(SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)))
		{
			smooth_toggle_preset_info(display);
			rtd_pr_vsc_notice("enter SLR_SMOOTH_TOGGLE_ACTIVE state\n");
		}
	}
	else
	{
		CHECK_JUDGE_BREAK("#### Online measure status error\n")

		if (get_scaler_stop_flag(display)) {
			rtd_pr_vsc_debug("\r\n####channel:%d vsc already disconnet !!!####\r\n", display);
			goto error_setup_imd_check_i2d;
		}

		if(Scaler_InputSrcGetType(display) == _SRC_TV) {
#ifdef CONFIG_DUAL_CHANNEL
			if (display == SLR_SUB_DISPLAY) {
				down(&SetSubOutPutRegion_Semaphore);
				if(DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) {
					up(&SetSubOutPutRegion_Semaphore);
					rtd_pr_vsc_debug("\r\n####Sub Output change can not active!!!####\r\n");
					goto error_setup_imd_check_i2d;
				}
				up(&SetSubOutPutRegion_Semaphore);
			}
#endif
		}
		Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		state_update_disp_info();//Update the active state
	}

	//rtd_pr_vsc_notice("%s(line: %d)####display=%d(0:main, 1:sub)####\r\n", __func__, __LINE__, display);
	if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR) && (auto_phase_flow_bypass() == FALSE)){

		//rtd_pr_vsc_info("YPbPr auto phase---wait\n");
		drvif_ypbpr_auto_phasedo_WaitFinish(SLR_MAIN_DISPLAY);
		rtd_pr_vsc_info("YPbPr auto phase---done\n");
		SyncProc_SetMinDiff(display);

		CHECK_JUDGE_BREAK("#### after auto phase need to break!!!####\n")
	}


#ifdef ADC_UP_DOWN_CLAMP
	if(webos_src == VSC_INPUTSRC_ADC){
		SyncProc_Check_UpDn_Stable(display);
	}
#else
	if(webos_src == VSC_INPUTSRC_ADC)
	{
		 abl_abl_status_RBUS abl_status_reg;
		 abl_abl_mgn_b_RBUS abl_mgn_b_reg;
		 abl_abl_mgn_rg_RBUS abl_mgn_rg_reg;
		 count = 50;
		 while(count > 0)	/* wait abl status ready */
		 {
			abl_status_reg.regValue = IoReg_Read32(ABL_ABL_STATUS_reg);
			if(abl_status_reg.abl_red_equal & abl_status_reg.abl_grn_equal & abl_status_reg.abl_blu_equal)
			{
				CHECK_JUDGE_BREAK("")
				abl_mgn_rg_reg.regValue = IoReg_Read32(ABL_ABL_MGN_RG_reg);
				abl_mgn_rg_reg.abl_l_mgn_red = YPBPR_ABL_UV_LARGE_MARGIN;
				IoReg_Write32(ABL_ABL_MGN_RG_reg, abl_mgn_rg_reg.regValue);

				abl_mgn_b_reg.regValue = IoReg_Read32(ABL_ABL_MGN_B_reg);
				abl_mgn_b_reg.abl_l_mgn_blu = YPBPR_ABL_UV_LARGE_MARGIN;
				IoReg_Write32(ABL_ABL_MGN_B_reg, abl_mgn_b_reg.regValue);
				break;
			}
			else
			{
				count--;
				if((count%10) == 0)
					CHECK_JUDGE_BREAK("")

				if(count == 0)
				{
					abl_mgn_rg_reg.regValue = IoReg_Read32(ABL_ABL_MGN_RG_reg);
					abl_mgn_rg_reg.abl_l_mgn_red = YPBPR_ABL_UV_LARGE_MARGIN;
					IoReg_Write32(ABL_ABL_MGN_RG_reg, abl_mgn_rg_reg.regValue);

					abl_mgn_b_reg.regValue = IoReg_Read32(ABL_ABL_MGN_B_reg);
					abl_mgn_b_reg.abl_l_mgn_blu = YPBPR_ABL_UV_LARGE_MARGIN;
					IoReg_Write32(ABL_ABL_MGN_B_reg, abl_mgn_b_reg.regValue);

					rtd_pr_vsc_info("ABLStatus_Reg Count Time out!\n");
				}
				msleep(5);
			}
		 }
		//rtd_pr_vsc_debug("%s(%d)-%s:  ABLStatus_Reg Count Time =%d !\n", __FILE__,__LINE__,__FUNCTION__, count);
	}
#endif
	if(webos_src == VSC_INPUTSRC_HDMI)
	{
		bool check_framerate_result = true;
		if (_FALSE == drvif_Hdmi_CheckStableBeforeDisplay())
			goto error_setup_imd_check_i2d;

		check_framerate_result = check_online(display);
		if (check_framerate_result == false) {
			reset_hdmi_timing_ready();
			vfe_hdmi_drv_handle_on_line_measure_error(0);
			goto error_setup_imd_check_i2d;
		}
	}
        if((display == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
            scaler_data_frame_sync_enable_gatting(webos_src);
        }
	wait_m_cap_last_write_done(display);
	check_and_set_mdomain_input_fast(display);

	if (display == SLR_MAIN_DISPLAY) {
		/* m domain driver ready */
		set_mdomain_driver_status(TRUE);
	}



	CHECK_JUDGE_BREAK("####channel:%d scaler need to break 4!!!####\n", display)
	wait_DI_ready();//wait DI ready

	CHECK_JUDGE_BREAK("####channel:%d scaler need to break 5!!!####\n", display)

	record_Setup_IMD_timer_counter = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);//record current 90k counter
#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif
	return true;

error_setup_imd_check_i2d:
	if (vbe_disp_decide_frc2fsync_using_I2D() == TRUE)
		drvif_scaler_set_display_mode_frc2fsync_I2D_disable();

error_setup_imd:
	Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH);

	return false;
}

void drvif_vodma_di_freeze(unsigned char bFreeze)
{
	int ret;
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_SET_VODMADI_FREEZE_ENABLE,bFreeze,1))){
		rtd_pr_vsc_emerg("[dc2h]ret=%d, SCALERIOC_SET_VODMADI_FREEZE_ENABLE RPC fail !!!\n", ret);
	}
}


void Scaler_SetFreeze_impl(unsigned char channel, unsigned char mode)
{
    VSC_INPUT_TYPE_T srctype;
	srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
    
#ifdef CONFIG_FORCE_RUN_I3DDMA
	if (SLR_MAIN_DISPLAY == channel) {
		if((srctype != VSC_INPUTSRC_VDEC)&&(srctype != VSC_INPUTSRC_JPEG)&&(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)==FALSE)){
			/*livezoom on k4lp,for smoothtgogle,could not m domain freeze, so progressive hdmi do freeze at i3ddma capture*/
			drvif_I3DDMA_freeze(mode);

		} else {
			if(mode == TRUE) {
				if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
					drvif_vodma_di_freeze(0);/*di freeze on*/
				else
					drvif_vodma_di_freeze(1);/*vo freeze on*/
			} else {
				if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
					drvif_vodma_di_freeze(2);/*di freeze off*/
				else
					drvif_vodma_di_freeze(3);/*vo freeze off*/
			}
		}
	}
#else
	if (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)channel, SLR_INPUT_FRAMESYNC))
	{
		if(Scaler_DispGetStatus((SCALER_DISP_CHANNEL)channel, SLR_DISP_THRIP) 
                || Scaler_DispGetStatus((SCALER_DISP_CHANNEL)channel, SLR_DISP_RTNR))
		{
            rtd_pr_vsc_emerg( "[%s %d]\n", __FUNCTION__, __LINE__);
            drvif_color_di_freeze(mode); 
        }
        else
        {
            if(((srctype == VSC_INPUTSRC_VDEC)||(srctype == VSC_INPUTSRC_JPEG) ||(get_line_alternative_3d_mode_enable() == TRUE)
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		        || (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
#endif
		    )&&(SLR_MAIN_DISPLAY == channel))
		    {
                if(mode == TRUE) 
                {
                    rtd_pr_vsc_emerg( "[%s %d]\n", __FUNCTION__, __LINE__);
                    drvif_vodma_di_freeze(1);/*vo freeze on*/
                } 
                else 
                {
                    rtd_pr_vsc_emerg( "[%s %d]\n", __FUNCTION__, __LINE__);
                    drvif_vodma_di_freeze(3);/*vo freeze off*/
                }

            }
        }
	}
	else
	{
        rtd_pr_vsc_emerg( "[%s %d]\n", __FUNCTION__, __LINE__);
		drvif_scalerdisplay_set_freeze(channel, mode);
	}
#endif
}
void (*Scaler_SetFreeze)(unsigned char channel, unsigned char mode) = Scaler_SetFreeze_impl;
#endif
extern void magnifier_color_ultrazoom_config_scaling_up(unsigned char display);
//extern void imd_smooth_enable_sub_double_buffer(unsigned char bEnable);

unsigned short Scaler_CalAVD27MWidth(SCALER_DISP_CHANNEL display,unsigned short a_usInput)
{
	unsigned short usRet = a_usInput;

	//rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	//rtd_pr_vsc_debug("outregion.w=%d,display=%d,  outputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", outregion->w,display,Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);

	//if (outregion->w >= AVD_DI_5A_WIDTH )
	if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode(display))
	{
		if (display == SLR_MAIN_DISPLAY)
		{
			usRet = a_usInput * AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH * 2;
		}
#ifdef CONFIG_DUAL_CHANNEL
		else
		{
		// Sub can use DI
		#ifdef CONFIG_I2RND_ENABLE
			usRet = a_usInput * AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH * 2;
		#else
			// By pass DI
			usRet = a_usInput * 2;
		#endif
		}
#endif
	}
	else if(VD_27M_HSD1440_DI3A== fw_video_get_27mhz_mode(display))
	{
		usRet = a_usInput * 2;
	}

	return usRet;

}


unsigned char Scaler_CalWindowZoominForAVD(SCALER_DISP_CHANNEL display,VIDEO_RECT_T *inregion, VIDEO_RECT_T *outregion)
{
	VIDEO_RECT_T tmpinregion;

#if 1
	if (display == SLR_MAIN_DISPLAY)
	{
		tmpinregion.x = Main_InputRegion_x;
		tmpinregion.y = Main_InputRegion_y;
		tmpinregion.w = Main_InputRegion_w;
		tmpinregion.h = Main_InputRegion_h;

		rtd_pr_vsc_debug("Main path inputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY)
	{
		tmpinregion.x = Sub_InputRegion_x;
		tmpinregion.y = Sub_InputRegion_y / 2;  // ByPass DI
		tmpinregion.w = Sub_InputRegion_w;
		tmpinregion.h = Sub_InputRegion_h / 2;  // ByPass ID

		rtd_pr_vsc_debug("Sub path inputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);
	}
#endif

#endif


	rtd_pr_vsc_debug("outregion.w=%d,display=%d,  outputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", outregion->w,display,Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);

	if (outregion->w >= AVD_DI_5A_WIDTH )
	{
		if (display == SLR_MAIN_DISPLAY)
		{
			inregion->x = tmpinregion.x*2*AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH ;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w*2*AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH ;
			inregion->h = tmpinregion.h;

			#ifdef CONFIG_FIXED_VD_27MHZ_960_TO_UZU
				inregion->x = 0;
				inregion->w = 960;
			#endif
		}
#ifdef CONFIG_DUAL_CHANNEL
		else
		{
			inregion->x = tmpinregion.x*2;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w*2;
			inregion->h = tmpinregion.h;
		}
#endif
	}
	else
	{
		if (outregion->w > tmpinregion.w)
		{
			inregion->x = tmpinregion.x;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w;
			inregion->h = tmpinregion.h;
		}
		else
		{
			inregion->x = (tmpinregion.x *2*outregion->w)/AVD_27M_VGIP_WIDTH;
			inregion->y = tmpinregion.y;
			inregion->w = (tmpinregion.w *2*outregion->w)/AVD_27M_VGIP_WIDTH;
			inregion->h = tmpinregion.h;

			rtd_pr_vsc_debug("inregion.w=%d, outregion.w=%d\n", inregion->w, outregion->w);
		}
	}

	#if 1
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("rtk_run_scaler 1 inregion x=%d, y=%d, w=%d, h=%d\n", inregion->x, inregion->y, inregion->w, inregion->h);
	rtd_pr_vsc_debug("rtk_run_scaler 1 outregion x=%d, y=%d, w=%d, h=%d\n", outregion->x, outregion->y, outregion->w, outregion->h);
	rtd_pr_vsc_debug("**** Scaler_DispWindowZoominForAVD()\n");
	#endif

	#if 0
	rtd_pr_vsc_emerg( "display=%d\n", display);
	rtd_pr_vsc_emerg( "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_emerg( "rtk_run_scaler 1 inregion x=%d, y=%d, w=%d, h=%d\n", inregion->x, inregion->y, inregion->w, inregion->h);
	rtd_pr_vsc_emerg( "rtk_run_scaler 1 outregion x=%d, y=%d, w=%d, h=%d\n", outregion->x, outregion->y, outregion->w, outregion->h);
	rtd_pr_vsc_emerg( "**** Scaler_DispWindowZoominForAVD()\n");
	#endif

	return TRUE;
}
#ifndef BUILD_QUICK_SHOW
#ifndef UT_flag
extern void avdmdsmooth_color_ultrazoom_config_scaling_up(unsigned char display);
unsigned char Scaler_DispWindowZoominForAVD(SCALER_DISP_CHANNEL display, VIDEO_RECT_T inputwin, VIDEO_RECT_T outputwin, unsigned char changetomain)
{
	unsigned short usAfterDILen = 0;
	unsigned short usAfterDIWid = 0;
	unsigned short mDomainCapLen = 0;
	unsigned short mDomainCapWid = 0;
	unsigned short x_offset = 0;
	unsigned short w_offset = 0;
	unsigned int ulMemActLen;
	unsigned int ulMemActSta;

	mdomain_disp_ddr_mainsubctrl_RBUS mdomain_disp_ddr_mainsubctrl_Reg;
	ppoverlay_double_buffer_ctrl_RBUS ppoverlay_double_buffer_ctrl_Reg;
	scaleup_dm_uzu_db_ctrl_RBUS scaleup_dm_uzu_db_ctrl_Reg;
	scaleup_ds_uzu_db_ctrl_RBUS scaleup_ds_uzu_db_ctrl_Reg;


	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if (((outputwin.x + outputwin.w) > _DISP_WID) || ((outputwin.y + outputwin.h) > _DISP_LEN)) {
		rtd_pr_vsc_debug("Zoom in fail, for out size out of panel range\n");
		return FALSE;
	}
#ifdef CONFIG_DUAL_CHANNEL

	if (display == SLR_SUB_DISPLAY) {
		sub_dispwin.srcx = outputwin.x;
		sub_dispwin.srcy = outputwin.y;
		sub_dispwin.src_height = outputwin.h;
		sub_dispwin.src_wid = outputwin.w;
		Scaler_SubDispWindowSet(sub_dispwin);
	} else
#endif
    {
		main_dispwin.srcx = outputwin.x;
		main_dispwin.srcy = outputwin.y;
		main_dispwin.src_height = outputwin.h;
		main_dispwin.src_wid = outputwin.w;

		Scaler_DispWindowSet(main_dispwin);
	}

	if (display == SLR_MAIN_DISPLAY)
	{
		if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			usAfterDILen =	(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN) << 1);
		} else {
			//usAfterDILen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN);
			usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);
		}

		rtd_pr_vsc_debug("main path usAfterDILen=%d\n", usAfterDILen);
	}
	else
	{
		usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);

		rtd_pr_vsc_debug("sub path usAfterDILen=%d\n", usAfterDILen);
	}

	if ((display == SLR_SUB_DISPLAY) && (changetomain == TRUE))
	{
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID);
	} else {
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_WID);
	}

	usAfterDIWid = mDomainCapWid;

	rtd_pr_vsc_debug("mDomainCapLen=%d, mDomainCapWid=%d\n", mDomainCapLen, mDomainCapWid);

	rtd_pr_vsc_debug("inputwin.y=%d,  SLR_INPUT_IPV_ACT_STA=%d, SLR_INPUT_IPV_ACT_STA_PRE=%d, usAfterDILen=%d\n", inputwin.y, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA), Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE), usAfterDILen);

#if 1
		if (inputwin.w > mDomainCapWid)
		{
			if (SLR_MAIN_DISPLAY == display)
			{
				inputwin.x = inputwin.x * mDomainCapWid / AVD_DI_5A_WIDTH ;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_DI_5A_WIDTH ;
			}
			else
			{
				inputwin.x = inputwin.x * mDomainCapWid / AVD_27M_VGIP_WIDTH ;;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_27M_VGIP_WIDTH ;

			}

		}
		else if (mDomainCapWid > AVD_NORMAL_WIDTH && mDomainCapWid < AVD_DI_5A_WIDTH)
		{
			inputwin.x = inputwin.x * mDomainCapWid / AVD_NORMAL_WIDTH;
			inputwin.w = inputwin.w * mDomainCapWid / AVD_NORMAL_WIDTH;
		}

		/*
		if (inputwin.h >= mDomainCapLen)
		{
			inputwin.h = mDomainCapLen;
			inputwin.y = 0;
		}
		*/
#endif

	ulMemActLen =  inputwin.h * mDomainCapLen / usAfterDILen;
	ulMemActSta = inputwin.y * mDomainCapLen / usAfterDILen;

	//rtd_pr_vsc_info("ulMemActLen = %d\n", ulMemActLen);

	if (ulMemActLen > mDomainCapLen)
	{
		ulMemActLen = mDomainCapLen;
		ulMemActSta = 0;
	}
	//rtd_pr_vsc_info("2 ulMemActLen = %d\n", ulMemActLen);


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, ulMemActLen);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, ulMemActSta);


#if 0
	if (display == SLR_MAIN_DISPLAY)
	{
		if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
			//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y - 2*(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE))) / usAfterDILen);
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, inputwin.y * inputwin.h / usAfterDILen);
		} else {
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y - (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE))) / usAfterDILen);
		}
	}
	else
	{
#if 0
		if (inputwin.w > mDomainCapWid)
		{
			if (SLR_MAIN_DISPLAY == display)
			{
				inputwin.x = 0;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_DI_5A_WIDTH ;
			}
			else
			{
				inputwin.x = 0;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_27M_VGIP_WIDTH ;

			}

		}

		if (inputwin.h >= mDomainCapLen)
		{
			inputwin.h = mDomainCapLen;
			inputwin.y = 0;
		}
#endif
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, inputwin.y * inputwin.h / usAfterDILen);
	}

#endif

	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_LEN=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN));
	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_VSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA));

	rtd_pr_vsc_debug("mDomainCapWid = %d,inputwin.w=%d,usAfterDIWid=%d\n",mDomainCapWid,inputwin.w,usAfterDIWid);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, mDomainCapWid * inputwin.w / usAfterDIWid);
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, mDomainCapWid * (inputwin.x - (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE))) / usAfterDIWid);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, inputwin.x);

	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, drvif_memory_get_data_align(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID), 2));
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, drvif_memory_get_data_align(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA), 2));

	rtd_pr_vsc_debug("align 2 SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_pr_vsc_debug("align 2 SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));

	if ((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA)  + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID)) > mDomainCapWid) {
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - 4));
	}

	DbgSclrFlgTkr.main_inputregion_x_ori_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
	DbgSclrFlgTkr.main_inputregion_w_ori_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);

	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_x_ori_pre=%d\n", DbgSclrFlgTkr.main_inputregion_x_ori_pre);
	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_w_ori_pre=%d\n", DbgSclrFlgTkr.main_inputregion_w_ori_pre);
	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_x_pre=%d\n", DbgSclrFlgTkr.main_inputregion_x_pre);
	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_w_pre=%d\n", DbgSclrFlgTkr.main_inputregion_w_pre);

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < DbgSclrFlgTkr.main_inputregion_w_pre)
		w_offset = DbgSclrFlgTkr.main_inputregion_w_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
	else
		w_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - DbgSclrFlgTkr.main_inputregion_w_pre;

	//add AVD offset modification flow for ISF @Crixus 20151220
	if(w_offset <= 4){//in the ISF control, there is only 2 pixels shift
		if(DbgSclrFlgTkr.main_inputregion_w_pre == 0){
			DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
			DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
		}
		else{
			if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) > DbgSclrFlgTkr.main_inputregion_x_pre) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < DbgSclrFlgTkr.main_inputregion_w_pre)){
				x_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) - DbgSclrFlgTkr.main_inputregion_x_pre;
				w_offset = DbgSclrFlgTkr.main_inputregion_w_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
				if(w_offset > x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) + (w_offset - x_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
				else if(w_offset < x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - (x_offset-w_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
			}
			else if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) < DbgSclrFlgTkr.main_inputregion_x_pre) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) > DbgSclrFlgTkr.main_inputregion_w_pre)){
				x_offset = DbgSclrFlgTkr.main_inputregion_x_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
				w_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - DbgSclrFlgTkr.main_inputregion_w_pre;
				if(w_offset > x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - (w_offset - x_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
				else if(w_offset < x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) + (x_offset-w_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}

			}
			else{
				if((DbgSclrFlgTkr.main_check_pre_flag == 1) && (DbgSclrFlgTkr.main_inputregion_x_ori_pre == Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA)) && (DbgSclrFlgTkr.main_inputregion_w_ori_pre == Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID))){
					//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, DbgSclrFlgTkr.main_inputregion_x_pre);
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, DbgSclrFlgTkr.main_inputregion_w_pre);
					DbgSclrFlgTkr.main_check_pre_flag = 0;
				}
			}
				DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
				DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
		}
	}
	else{
		DbgSclrFlgTkr.main_check_pre_flag = 0;
		DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
		DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
	}

	rtd_pr_vsc_debug("final SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_pr_vsc_debug("final SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_WID, outputwin.w);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_LEN, outputwin.h);

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID)){
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, TRUE);
	}else{
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, FALSE);
	}

	rtd_pr_vsc_debug("SLR_SCALE_H_UP=%d\n", Scaler_DispGetScaleStatus(display, SLR_SCALE_H_UP));


	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN))
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, TRUE);
	else
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, FALSE);

	rtd_pr_vsc_debug("SLR_SCALE_V_UP=%d\n", Scaler_DispGetScaleStatus(display, SLR_SCALE_V_UP));

	if (display == SLR_SUB_DISPLAY) {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 1;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
	} else {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT1);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT1);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 1;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);

	}
	//imd_smooth_enable_sub_double_buffer(TRUE);

	/*IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);//Enable double buffer register*/
	/*WaitFor_DEN_START();*/
	/*WaitFor_DEN_STOP_Done_SUB();*/
	/*sub m domain display*/
	if (display == SLR_SUB_DISPLAY) {
		memory_set_sub_displaywindow_change(changetomain);
	} else {
		memory_set_main_displaywindow_change();
	}
	/*sub uzu*/
	avdmdsmooth_color_ultrazoom_config_scaling_up(display);

	if (display == SLR_SUB_DISPLAY) {
		#ifdef CONFIG_DUAL_CHANNEL
		PipmpSetSubDisplayWindow(
			outputwin.x, outputwin.x + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID) - 1,
			outputwin.y, outputwin.y + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN) - 1,
			0);

		PipmpSetSubActiveWindow(
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_WID)  - 1,
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_LEN) - 1);
		#endif

	} else {
		ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
		ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;

		// Main Active H pos
		main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
		main_active_h_start_end_reg.mh_act_sta = outputwin.x & 0x0fff;
		main_active_h_start_end_reg.mh_act_end = (outputwin.x + outputwin.w) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);

		// Main Active V pos
		main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
		main_active_v_start_end_reg.mv_act_sta = outputwin.y & 0x0fff;
		main_active_v_start_end_reg.mv_act_end = (outputwin.y + outputwin.h) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);

	}

	if (display == SLR_SUB_DISPLAY) {
		unsigned int uzulinecntA =0;
		unsigned int uzulinecntB =0;

		unsigned int timeoutcount = 0x3ffff;
		ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
		ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//load M domain double buffer
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_apply = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);
#if 0
		IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT4);//load D domaindouble buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_set = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
#endif
		//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT0);//load uzu double buffer
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_apply = 1;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);

		dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);

		do {
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntA = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntB = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			if((uzulinecntA == uzulinecntB)&&((uzulinecntA < (dv_den_start_end_reg.dv_den_sta)) || (uzulinecntA > (dv_den_start_end_reg.dv_den_end)))) {
				//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
				ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
				ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
				IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
				break;
			}
			timeoutcount--;
		} while(timeoutcount);

		if(timeoutcount == 0){
			//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
			ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
			rtd_pr_vsc_debug("[SUB DEN]timeout error!!!\n");
		}
#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT4) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT16) || (IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
#endif
	} else {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//load M domain double buffer
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_apply = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT4);//load D domaindouble buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_set = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT0);//load uzu double buffer
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_apply = 1;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT0) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT0) || (IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT2);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
#endif
	}

	return TRUE;
}

#endif
void Scaler_SetDisplaySingleBufferMode(SCALER_DISP_CHANNEL channel, unsigned char mode)
{
	if (channel == SLR_MAIN_DISPLAY) {
		mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl_reg;
		ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
		if (mode) {
			ddr_mainctrl_reg.main_v_flip_3buf_en = 0;
			ddr_mainctrl_reg.main_double_en = 0;
			ddr_mainctrl_reg.main_single_buffer_select = 2;
		} else {
			ddr_mainctrl_reg.main_v_flip_3buf_en = 1;
			ddr_mainctrl_reg.main_double_en = 1;
		}
		IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, ddr_mainctrl_reg.regValue);
	} else if (channel == SLR_SUB_DISPLAY) {
		mdomain_disp_ddr_subctrl_RBUS ddr_subctrl_reg;
		ddr_subctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_SubCtrl_reg);
		if (mode) {
			ddr_subctrl_reg.sub_v_flip_3buf_en = 0;
			ddr_subctrl_reg.sub_double_en = 0;
			ddr_subctrl_reg.sub_single_buffer_select = 2;
		} else {
			ddr_subctrl_reg.sub_v_flip_3buf_en = 1;
			ddr_subctrl_reg.sub_double_en = 1;
		}
		IoReg_Write32(MDOMAIN_DISP_DDR_SubCtrl_reg, ddr_subctrl_reg.regValue);
	}
	drvif_memory_set_dbuffer_write();
}

#ifndef UT_flag

static unsigned char Hdmi_GameMode = FALSE;

unsigned char Get_HDMI_SingleBuffer_GameMode(void)
{
	//only support 50hz/60hz hdmi timing go data frc
	//if(((Scaler_InputSrcGetMainChType() == _SRC_HDMI) || (Scaler_InputSrcGetMainChType() == _SRC_DVI)) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE))
	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)
	{
		/*magellan and sirius ic m cap and m disp not the same, but merlin the same*/
		if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 490) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 510)) || ((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 590) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 610)))
		{
			return Hdmi_GameMode;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}
}

extern unsigned int Get_fine_tune_dclk_forGameMode(void);
#define IV2DVLINE_GAPSPACE 2
void FineTune_iv2dvline_GameMode(void)
{

	unsigned int htotal = Get_DISP_HORIZONTAL_TOTAL();
	unsigned int vtotal = Get_DISP_VERTICAL_TOTAL();
	unsigned int Dclock = Get_fine_tune_dclk_forGameMode();
	unsigned int dispDFRate =  (10*Dclock/(htotal*vtotal));
	unsigned int iputFRate = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

	unsigned int dispLen = Scaler_DispGetInputInfo(SLR_INPUT_DISP_LEN);
	unsigned int inputSta = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA);
	unsigned int inputLen = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN);

	mdomain_disp_ddr_mainprevstart_RBUS ddr_mainprevstart_Reg;
	ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
	ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
	unsigned int preread = 0;
	unsigned int dv_sta = 0;
	unsigned int mv_sta = 0;
	int iv2dvlinesta = 0;
	unsigned int iv2dvlinefreq = 0;

	if(Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
		inputLen = inputLen*2;

	rtd_pr_vsc_debug("[Game_mode]input frame rate = %d;output frame rate = %d\n",(unsigned int)iputFRate, (unsigned int)dispDFRate);
	rtd_pr_vsc_debug("[Game_mode]inputSta = %d;inputLen = %d;dispLen = %d\n",(unsigned int)inputSta, (unsigned int)inputLen, (unsigned int)dispLen);

	if ((0 == iputFRate) || (0 == inputLen))
		return;

	ddr_mainprevstart_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainPreVStart_reg);
	preread = ddr_mainprevstart_Reg.main_pre_rd_v_start;
	rtd_pr_vsc_debug("[Game_mode]preread = %d\n",preread);


	dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);
	dv_sta = dv_den_start_end_reg.dv_den_sta;


	main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
	mv_sta = main_active_v_start_end_reg.mv_act_sta;

	rtd_pr_vsc_debug("[Game_mode]dv_sta = %d;mv_sta = %d\n",dv_sta,mv_sta);

	iv2dvlinesta = (inputSta*(dispLen*dispDFRate)/(inputLen*iputFRate)) + IV2DVLINE_GAPSPACE + preread - (dv_sta+mv_sta);

	if(iv2dvlinesta < 0)
		iv2dvlinesta = 0;
	rtd_pr_vsc_debug("[Game_mode]iv2dvline for reason sta diff = %d\n", iv2dvlinesta);

	if(iputFRate<dispDFRate)
		iv2dvlinefreq = (inputLen - inputLen*iputFRate/dispDFRate);

	rtd_pr_vsc_debug("[Game_mode]iv2dvline for reason freq diff = %d\n", iv2dvlinefreq);
	drvif_set_frc_ivs2dvsdelay_line((iv2dvlinesta+iv2dvlinefreq),(iv2dvlinesta+iv2dvlinefreq), 0);
}

#endif
#endif
#ifndef UT_flag

static unsigned char vscFilmMode = FALSE;

unsigned char Get_vscFilmMode(void)
{
	return vscFilmMode;
}
#endif

bool IsVideoModeTiming(int height, int width, int freq)
{
    switch(height)
    {
        case 480:
        {
            if(width == 1440)
                return true;
            break;
        }
        case 490:
        case 576:
        {
            return true;
        }
        case 720:
        {
            if((freq <= 505 && freq >= 495) || (freq <= 605 && freq >= 595))
                return true;
            break;
        }
        case 1080:
        {
            if((freq <= 245 && freq >= 235) || (freq <= 255 && freq >= 245)
                || (freq <= 305 && freq >= 295) || (freq <= 505 && freq >= 495))
                return true;
            break;
        }
        default:
            break;
    }
    return false;
}

bool IsPcModeTiming(vfe_hdmi_timing_info_t *info, vfe_hdmi_avi_t* aviInfo)
{
    // Check if DVI format
    if (info->dvi_hdmi == KADP_VFE_HDMI_DVI)
    {
        rtd_pr_vsc_info("%s, DVI format", __func__);
        return true;
    }

    // interlaced video signal should be video mode
    // 0 stands for interlaced video signal
    if(info->scan_type == 0)
    {
        return false;
    }

    if(aviInfo)
    {
        // Check if content is valid and detect graph content
        if((aviInfo->it_content == VFE_HDMI_AVI_IT_CONTENT_ITCONTENT) && (aviInfo->content_type == VFE_HDMI_AVI_CONTENT_TYPE_GRAPHICS))
        {
            rtd_pr_vsc_info("%s, graph content", __func__);
            return true;
        }

        // Check If Chroma format is YCBCR
        if((aviInfo->pixel_encoding == VFE_HDMI_AVI_CSC_YCBCR422) || (aviInfo->pixel_encoding == VFE_HDMI_AVI_CSC_YCBCR444))
        {
            return false;
        }
    }

    // Check specific timings for HDMI mode
    if(IsVideoModeTiming(info->active.h, info->active.w, info->v_freq))
    {
        return false;
    }

    return false;
}

void quickshow_set_pc_mode(void)
{
    vfe_hdmi_timing_info_t hdmitiminginfo = {0};
    vfe_hdmi_avi_t hdmiaviinfo = {0};
    bool isPcMode = FALSE;

    if(0 != vfe_hdmi_drv_get_display_timing_info(&hdmitiminginfo, SLR_MAIN_DISPLAY))
    {
        rtd_pr_vsc_err("vfe_hdmi_drv_get_display_timing_info error\n");
    }

    if(0 != vfe_hdmi_drv_get_port_avi_info(&hdmiaviinfo))
    {
        rtd_pr_vsc_err("vfe_hdmi_drv_get_port_avi_info error\n");
    }

    if(IsPcModeTiming(&hdmitiminginfo, &hdmiaviinfo))
    {
        isPcMode = TRUE;
    } else if(is_QS_pc_mode()){
        isPcMode = TRUE;
    } else 
    {
        isPcMode = FALSE;
    }

    if(isPcMode)
    {
        DbgSclrFlgTkr.RGB444Mode = TRUE;
        Set_Val_vsc_run_pc_mode(TRUE);
        sync_pc_mode_info();
        rtd_pr_vsc_info("pc mode enable\n");
    }

}

PQ_HDR_TYPE Scaler_QsGetHdrType(void)
{
    HDMI_DRM_T hdmiDrm = {0};
    PQ_HDR_TYPE hdrType = HDR_DM_MODE_NONE;

    drvif_Hdmi_GetDrmInfoFrame(&hdmiDrm);

    if((hdmiDrm.ver == 1) && (hdmiDrm.len != 0))
    {
        switch(hdmiDrm.eEOTFtype)
        {
            case 0:
                hdrType = HDR_DM_MODE_NONE;
                break;
            case 1:
                hdrType = HDR_DM_HDR10;
                break;
            case 2:
                hdrType = HDR_DM_HDR10;
                break;
            case 3:
                hdrType = HDR_DM_HLG;
                break;
            default:
                hdrType = HDR_DM_MODE_NONE;
                break;
        }
    }

    return hdrType;
    //return HDR_DM_MODE_NONE;
}

extern unsigned char is_QS_game_mode(void);
unsigned char Get_Val_qs_game_flag(void)
{
	unsigned char ucRet = 0;

	ucRet = is_QS_game_mode();
	ucRet |= (unsigned char)drvif_Hdmi_GetALLMEnable()
		|| vbe_disp_get_VRR_timingMode_flag()
		|| vbe_disp_get_freesync_mode_flag();

	return ucRet;
}
#ifndef BUILD_QUICK_SHOW
#ifndef UT_flag
void filmmode_videofw_config(unsigned int filmmode, unsigned int buf4addr)//filmmode:0 disable filmmode;filmmode:0 enable filmmode
{
	FILM_MODE_IOCTL_PARAM param = {filmmode, buf4addr};
	unsigned int *pulTemp = NULL;
	unsigned int ulCount = 0, i = 0;
	int ret;

	pulTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_VIDEO_FILMMODE_ENABLE);
	ulCount = sizeof(FILM_MODE_IOCTL_PARAM) / sizeof(unsigned int);
	// copy to RPC share memory
	memcpy(pulTemp, &param, sizeof(FILM_MODE_IOCTL_PARAM));

	for (i = 0; i < ulCount; i++)
		pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);

	if (0 != (ret = Scaler_SendRPC(SCALERIOC_VIDEO_FILMMODE_ENABLE, 0, 0)))
	{
		rtd_pr_vsc_debug("ret=%d, Deinit SCALERIOC_VIDEO_FILMMODE_ENABLE fail !!!\n", ret);
	}
}

extern unsigned int FilmModeCachaddr;
extern unsigned int FilmModePhyadddr;

unsigned char rtk_vsc_setFilmMode(bool value)
{
//remove by ben, due to mag2 remove fs_5_4 hw
#ifdef CONFIG_5_4_FS
#if 0
	vscFilmMode = value;
	if(value == TRUE)
	{
		HAL_VBE_DISP_SetFrameRate(TRUE,48);
	}
	else
	{
		HAL_VBE_DISP_SetFrameRate(FALSE,60);
		dvr_free((void *)FilmModeCachaddr);
		FilmModeCachaddr = NULL;
		FilmModePhyadddr = NULL;
		filmmode_videofw_config(FALSE,NULL);
	}
//#else
	if(value==TRUE)
	{
		ppoverlay_dh_total_last_line_length_RBUS ppoverlay_dh_total_last_line_length_Reg;
		ppoverlay_dh_total_last_line_length_Reg.regValue=IoReg_Read32(PPOVERLAY_DH_TOTAL_LAST_LINE_LENGTH_VADDR);

		ppoverlay_dv_total_RBUS ppoverlay_dv_total_Reg;
		ppoverlay_dv_total_Reg.regValue = IoReg_Read32(PPOVERLAY_DV_TOTAL_VADDR);

		ppoverlay_fs54_dh_RBUS ppoverlay_fs54_dh_Reg;
		ppoverlay_fs54_dh_Reg.fs54_dh_total = ppoverlay_dh_total_last_line_length_Reg.dh_total;
		ppoverlay_fs54_dh_Reg.fs54_dh_last_line = ppoverlay_dh_total_last_line_length_Reg.dh_total_last_line;
		IoReg_Write32(PPOVERLAY_FS54_DH_VADDR, ppoverlay_fs54_dh_Reg.regValue);

		ppoverlay_fs54_dv_RBUS ppoverlay_fs54_dv_Reg;
		ppoverlay_fs54_dv_Reg.fs54_dv_total = ppoverlay_dv_total_Reg.dv_total*5/4;
		IoReg_Write32(PPOVERLAY_FS54_DV_VADDR,ppoverlay_fs54_dv_Reg.regValue);

		fs54_ctrl_RBUS ppoverlay_fs54_ctrl_Reg;
		ppoverlay_fs54_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_FS54_CTRL_VADDR);
		ppoverlay_fs54_ctrl_Reg.fs54_dclk_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_dclk_slow_modify_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_pseudo_fsync_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_timing_en = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_vs_align = 3;
		ppoverlay_fs54_ctrl_Reg.fs54_force = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_main_sub_sel = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_frc_fastslow = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_db_load = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_en = 1;
		if((IoReg_Read32(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR)&_BIT2)>>2)
		{
			IoReg_ClearBits(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR, _BIT2);
			IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
			IoReg_SetBits(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR, _BIT2);
		}
		else
		{
			IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
		}
	}
	else
	{
		fs54_ctrl_RBUS ppoverlay_fs54_ctrl_Reg;
		ppoverlay_fs54_ctrl_Reg.regValue = 0;
		IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
	}
#else
	if(value == TRUE)
		drvif_framesync_5_4();
	else
		drvif_framesync_5_4_release();
#endif
#endif
	return TRUE;

}

void scaler_sub_sync_main_timing_info(void)
{
	unsigned short IPH_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE);
	unsigned short IPV_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE);
	unsigned short IPH_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE);
	unsigned short IPV_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE);

	Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);

	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE, IPH_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE, IPV_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE, IPH_ACT_WID);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE, IPV_ACT_LEN);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA, IPH_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA, IPV_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID, IPH_ACT_WID);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN, IPV_ACT_LEN);

}

void scaler_set_sub_vgip(unsigned char src, unsigned char mode)
{
	sub_vgip_vgip_chn2_ctrl_RBUS vgip_chn2_ctrl_reg;
	sub_vgip_vgip_chn2_act_hsta_width_RBUS vgip_chn2_act_hsta_width_reg;
	sub_vgip_vgip_chn2_act_vsta_length_RBUS vgip_chn2_act_vsta_length_reg;
	sub_vgip_vgip_chn2_delay_RBUS sub_vgip_vgip_chn2_delay_reg;

	// Disable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_clk_en = 0;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	// determine the input source
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_sel = src;
	vgip_chn2_ctrl_reg.ch2_digital_mode = mode;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	//sub vgip size sync from main
	vgip_chn2_act_hsta_width_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg);
	vgip_chn2_act_hsta_width_reg.ch2_ih_act_sta = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE);
	if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) < 720)
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_wid = 720;
	else
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_wid = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg, vgip_chn2_act_hsta_width_reg.regValue);

	vgip_chn2_act_vsta_length_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg);
	vgip_chn2_act_vsta_length_reg.ch2_iv_act_sta = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE);

	if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) < 288 ) && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))//SE do scaling up to 720x288 interlace
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = 288;
	else if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) < 576 ) && !Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))//SE do scaling up to 720x288 profrassive
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = 576;
	else
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg, vgip_chn2_act_vsta_length_reg.regValue);

	sub_vgip_vgip_chn2_delay_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_DELAY_reg);
	sub_vgip_vgip_chn2_delay_reg.ch2_ihs_dly = 0;//reset 0
	sub_vgip_vgip_chn2_delay_reg.ch2_ivs_dly = 0;//reset 0
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_DELAY_reg, sub_vgip_vgip_chn2_delay_reg.regValue);

	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_field_det_en = _DISABLE;		//bit16
	vgip_chn2_ctrl_reg.ch2_field_sync_edge = _ENABLE;	//bit17
	vgip_chn2_ctrl_reg.ch2_field_inv = _ENABLE;		//bit18
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	// enable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_clk_en = 1;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

}
#ifdef CONFIG_DUAL_CHANNEL
void scaler_run_sub_capture_tve(SIZE outsize)
{
	unsigned char src;
	unsigned char mode;
	SIZE insize;
	unsigned char nMode = 0;
	src = VGIP_SRC_HDR1;

	scaler_set_sub_vgip(src, VGIP_MODE_ANALOG);

	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, false);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_FSYNC_VUZD, 0x2);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_COMP, false);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, true);

	mode = Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);
	if ((mode !=  _MODE_480I) && (mode !=  _MODE_480P) && (mode !=  _MODE_576I) && (mode !=  _MODE_576P))
		nMode = 1;
	drvif_color_set422to444(SLR_SUB_DISPLAY, false);
	fwif_color_colorspacergb2yuvtransfer(SLR_SUB_DISPLAY, _SRC_VO, nMode, 1);

	insize.nWidth = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
	insize.nLength = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);

	if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))
	{

		outsize.nLength /=2;
		rtd_pr_vsc_debug("[scart out]enter DI, nLength = %d\n",outsize.nLength);
	}
	Scaler_DispSetScaleStatus(SLR_SUB_DISPLAY, SLR_SCALE_H_DOWN, (insize.nWidth > outsize.nWidth)?true:false);
	Scaler_DispSetScaleStatus(SLR_SUB_DISPLAY, SLR_SCALE_V_DOWN, (insize.nLength > outsize.nLength)?true:false);
	drvif_color_ultrazoom_set_scale_down(SLR_SUB_DISPLAY, &insize, &outsize, 0);

	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_WID,outsize.nWidth);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_LEN,outsize.nLength);
	mdomain_handler_onlycap();
}
#endif
#if 0	//remove tve
void scaler_vodmatosub_prog(TVE_VIDEO_MODE_SEL tve_mode, UINT8 tve_vflip_en)
{

	SIZE tve_outsize;

	if (tve_mode == TVE_NTSC) {
		tve_outsize.nWidth = 720;
		tve_outsize.nLength = 480;
	}
	else if (tve_mode == TVE_PAL_I) {
		tve_outsize.nWidth = 720;
		tve_outsize.nLength = 576;
	} else {
			rtd_pr_vsc_debug("wrong params	tve_mode=%d\n",(int)tve_mode);
			return ;
	   }

	scaler_sub_sync_main_timing_info();

	scaler_run_sub_capture_tve(tve_outsize);
	//drvif_module_tve_init();
	drvif_module_tve_set_mode(tve_mode);
	drvif_module_tve_video_memory_setting(tve_vflip_en);
	drvif_module_tve_change_memory_setting(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE),tve_vflip_en);

	scaler_scart_out_isr_set_enable(TRUE);
	//rtd_pr_vsc_debug("[scart out]fScartOut_isr_Enable = %x\n",fScartOut_isr_Enable);

	//VODMA clock fine tune
	#if 0
	if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 720) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) <= 576)){
		fScartOut_VO_clock_check = TRUE;
		//SE scaling up
		if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) < 720) || (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) < 576))
			fScartOut_VO_scaling_enable = TRUE;
		else
			fScartOut_VO_scaling_enable = FALSE;
	}else{
		fScartOut_VO_clock_check = FALSE;
	}
	#endif
	scaler_set_tve_vflip_enable(tve_vflip_en);

	 //bVodma2I3Dma = true;
#if 0//M-disp debug using
	//M-domain Disp verify
	IoReg_ClearBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg,_BIT1); //clear double buffer
	IoReg_ClearBits(MDOMAIN_DISP_DDR_MainCtrl_reg,MDOMAIN_DISP_DDR_MainCtrl_main_double_en_mask); //use single buffer. [9:8] = 0 use buffer 0,
									   // [9:8] = 1 use buffer 1
	i3ddmaCapAddr = IoReg_Read32(I3DDMA_CAP_L1_START_VADDR); //capture Buf L1
	//UINT32 i3ddmaCapAddr = IoReg_Read32(I3DDMA_CAP_L2_START_VADDR); //capture Buf L2
	rtd_pr_vsc_debug("##### i3ddmaCapAddr : %x ##### \n", i3ddmaCapAddr);  //capture Buf L
	IoReg_Write32(MDOMAIN_DISP_DDR_MainAddr_reg, i3ddmaCapAddr); //M-Disp Buffer0 use capture Buf
#endif
}
#endif
#endif //UT_flag

static unsigned char VscInitdone_Flag = FALSE;
static unsigned char VscOpendone_Flag = FALSE;
#ifdef CONFIG_DUAL_CHANNEL
static unsigned char Sub_VscOpendone_Flag = FALSE;
#endif
struct semaphore vsc_initial_ctrl_semaphore;//for call  rtk_hal_vsc_initialize use

unsigned char rtk_hal_vsc_initialize(void)
{
	if(VscInitdone_Flag == FALSE)
 	{
 		down(&vsc_initial_ctrl_semaphore);
		if(VscInitdone_Flag == FALSE)
 		{
			rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
			VscInitdone_Flag = TRUE;
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
			Scaler_Orbit_Timer_Init();
#endif
			panel_parameter_send_info(); //send panel info
			reset_support_vo_force_v_top();
#ifdef	CONFIG_SUPPORT_SDR_MAX_RGB
			set_support_vo_force_v_top(true, support_sdr_max_rgb);
#else
			set_support_vo_force_v_top(false, support_sdr_max_rgb);
#endif
            if(!is_QS_scaler_enable())
            {
                reset_all_top_dolby_mode();
            }
#ifdef CONFIG_I2RND_ENABLE
				//Eric@20170904 I2rnd & pst init
				drvif_scaler_i2rnd_initial();
				drvif_scaler_pst_initial(_MAIN_MD);
				drvif_scaler_pst_initial(_SUB_MD);
				vsc_i2rnd_initial_done = _ENABLE;
#ifdef CONFIG_PST_ENABLE
				vsc_pst_initial_done = _ENABLE;
#endif
				//set_i2rnd_s0_pst_check_stage(MAIN_PST_TOP_CTRL_STAGE_DISABLE);
				//set_i2rnd_s1_pst_check_stage(SUB_PST_TOP_CTRL_STAGE_DISABLE);
#endif

#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			drvif_scaler_pst_initial(_MAIN_VO_IMD);
			drvif_scaler_pst_initial(_SUB_VO_IMD);
#endif
#endif

#ifdef CONFIG_SCALER_BRING_UP
			modestate_EnableDispInt(TRUE);
#endif
			if(FALSE==Scaler_StructInit(PcbSource_GetTable(), PcbSource_GetTableSize(), PcbSource_GetTableSize()-3 /*OSD*/, 4 /*ypp*/))
			{
				rtd_pr_vsc_err("function=%s Scaler_StructInit fail\n", __FUNCTION__);
			}
		}
		up(&vsc_initial_ctrl_semaphore);
	}
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_initialize)(void) = rtk_hal_vsc_initialize;

unsigned char rtk_hal_vsc_uninitialize(void)
{
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
#ifdef CONFIG_DUAL_CHANNEL
	if ((VscOpendone_Flag == TRUE) || (Sub_VscOpendone_Flag == TRUE)) {
#else
	if (VscOpendone_Flag == TRUE) {
#endif
		rtd_pr_vsc_debug("VSC main and sub not all closed,so can not uninitialize!\n");
		return TRUE;
	} else {
		return TRUE;

/*

		if (VscInitdone_Flag == TRUE) {
			Scaler_StructUninit();
			VscInitdone_Flag = FALSE;
			return TRUE;
		} else {
			rtd_pr_vsc_debug("VSC not init\n");
			return TRUE;
		}
*/
	}
}
unsigned char (*fp_rtk_hal_vsc_uninitialize)(void) = rtk_hal_vsc_uninitialize;
void QS_VSCInit_SyncConnectInfo_impl(void)
{
    KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo={KADP_VSC_INPUTSRC_MAXN, 0, 0};
    if(is_QS_hdmi_enable()) {
        inputSrcInfo.type = KADP_VSC_INPUTSRC_HDMI;
    } else {
        return;
    }
    inputSrcInfo.attr = 0;
    inputSrcInfo.resourceIndex=0;
    Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
    increase_source_connect_verify_num(SLR_MAIN_DISPLAY);//increase the main source num
    DbgSclrFlgTkr.OuputDisplayMode = TRUE;
    set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler

    vbe_disp_set_freesync_mode_flag(drvif_Hdmi_GetAMDFreeSyncEnable());//save current freesync mode
    Set_Val_VRR_timingMode_flag(drvif_Hdmi_GetVRREnable());//save current vrr mode
}
void (* QS_VSCInit_SyncConnectInfo)(void) = QS_VSCInit_SyncConnectInfo_impl;

int QS_VSCInit_SyncInputregionAndOutputregionInfo(void)
{
        vfe_hdmi_timing_info_t vfehdmitiminginfo;    
        if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
                if((0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, SLR_MAIN_DISPLAY)))
                {
                    rtd_pr_vsc_err("qs init vfe_hdmi_drv_get_display_timing_info error or onlinemeasure\n");
                    return -1;
                }
                Scaler_SET_VSCDispinfo_WithVFEHMDI(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
        }
        main_input_size.srcx = 0;
        main_input_size.srcy = 0;
        main_input_size.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
        if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
           main_input_size.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
        else
            main_input_size.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);

        Scaler_AdaptiveStream_InputWindowSet(main_input_size,KADP_VIDEO_WID_0);
        main_dispwin.srcx = 0;
        main_dispwin.srcy = 0;
        main_dispwin.src_wid = _DISP_WID;
        main_dispwin.src_height = _DISP_LEN;        
        Set_Val_main_dispwin_pre(main_dispwin);
        set_shiftxy_main_dispwinpre(main_dispwin);
        set_shiftxy_main_inputpre(main_input_size);
        set_main_scaler_stop_flag(FALSE);//Let scaler can be run
        set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
        return 0;
}
void QS_VSCInit_SyncDisplayProcinfo(void)
{
        //drvif_mode_enableonlinemeasure(display);//Enable online measure
        save_online_enable_time(SLR_MAIN_DISPLAY);//save online enable time
        DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
        check_ARC_status(SLR_MAIN_DISPLAY, (KADP_VSC_INPUT_TYPE_T)DisplayModeInputInfo.type);
        DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
        if(Get_Val_vsc_run_pc_mode() == TRUE)
        {
            Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP, false);
            dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_16_BITS);
        } else {
            Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP, TRUE);
            dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_12_BITS);
        }
        Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT, TRUE);
        dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, TRUE);
        dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);
        drv_memory_set_limit_boundary_mode(SLR_MAIN_DISPLAY, TRUE);
        Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
        drvif_memory_compression_rpc(SLR_MAIN_DISPLAY);
}
void QS_VSCInit_SyncIMDInfo(void)
{
    VSC_INPUT_TYPE_T srctype;
        Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_STA, Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
        Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_WID, Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
        Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_STA, Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
        Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_LEN, Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID));
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN));
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_DLY_PRE,IoReg_ReadByte0(VGIP_VGIP_CHN1_DELAY_reg));
        modestate_decide_pixel_mode();
        modestate_decide_dtg_m_mode();
        modestate_decide_fractional_framesync();
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DISP_WID,_DISP_WID);
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DISP_LEN,_DISP_LEN);
        //Scaler_AdjustPathAndInfo_HW_SNR();	// Include patch for SNR issue
        // Calculate Overscan
        fw_scaler_cal_sdnr_capture(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
        fw_scaler_cal_scale_down_size();
        modestate_decide_nr_path();
        //Scaler_disp_setting
        srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
        //for vrr flow, qs run timing sync, kernel should not run other timing mode
        if((srctype == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
        {
            modestate_set_fll_running_flag(_DISABLE);
        }
        else
        {
            modestate_set_fll_running_flag(_ENABLE);
        }
        Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
        state_update_disp_info();//Update the active state
        set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_VSC, FALSE);
        //scaler_set_online_measure(display, inputType);
}
void QS_VSCInit_SyncScalerTskInfo(void)
    {
    VSC_INPUT_TYPE_T srctype;
    unsigned char port;

    set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
    srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
    port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
    if(srctype == VSC_INPUTSRC_HDMI)
    	set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());//recode current hdr mode
    Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
    QS_VSCInit_SyncDisplayProcinfo();
	if(Get_Val_qs_game_flag())
	{
		drv_memory_set_game_mode(_ENABLE);
		drv_memory_set_game_mode_dynamic(_ENABLE);
	}
    QS_VSCInit_SyncIMDInfo();
    //smoothtoggle info update
    if (!is_2k_memory_buffer_source(SLR_MAIN_DISPLAY))
    {//m odmain using 4k size need to borrow the memory from i3ddma
    #if 0
        if (1==scaler_borrowmemory_from_i3ddma_for_mdomain()) {//borrow fail
            rtd_pr_vsc_emerg("mdomian borrow i3ddma memory fail\n");
        }
    #else
        drvif_memory_set_memtag_startaddr(IoReg_Read32(MDOMAIN_CAP_DDR_In1_3rdAddr_reg), MEMIDX_MAIN_THIRD);
        drvif_memory_set_memtag_startaddr(IoReg_Read32(MDOMAIN_CAP_DDR_In1_2ndAddr_reg), MEMIDX_MAIN_SEC);
        drvif_memory_set_memtag_startaddr(IoReg_Read32(MDOMAIN_CAP_DDR_In1Addr_reg), MEMIDX_MAIN);	
        drvif_memory_set_memtag_startaddr(IoReg_Read32(DI_DI_DATMemoryStartAdd1_reg), MEMIDX_DI);
        rtd_pr_vsc_emerg("[QS]mdomain memory info:%x,%x,%x-DI :%x\n",drvif_memory_get_memtag_startaddr(MEMIDX_MAIN_THIRD),drvif_memory_get_memtag_startaddr(MEMIDX_MAIN_SEC),drvif_memory_get_memtag_startaddr(MEMIDX_MAIN), drvif_memory_get_memtag_startaddr(MEMIDX_DI));
    #endif
    }
//    memory_set_memory_size(TRUE, MEMCAPTYPE_FRAME);
    smooth_toggle_preset_info(SLR_MAIN_DISPLAY);
    }

void QS_VSCInit_SyncHdrInfo(void)
{
    PQ_HDR_TYPE hdrType = Scaler_QsGetHdrType();
    KADP_VSC_HDR_TYPE_T vscHdrType = KADP_VSC_HDR_AUTO;

    Scaler_color_set_HDR_Type(hdrType);
    switch(hdrType)
    {
        case HDR_DM_HDR10:
            vscHdrType = KADP_VSC_HDR_HDR10;
            break;
        case HDR_DM_HLG:
            vscHdrType = KADP_VSC_HDR_HLG;
            break;
        case HDR_DM_ST2094:
            vscHdrType = KADP_VSC_HDR_HDR10_PLUS;
            break;
        case HDR_DM_DOLBY:
            vscHdrType = KADP_VSC_HDR_DOLBY;
            break;
        case HDR_DM_TECHNICOLOR:
            vscHdrType = KADP_VSC_HDR_AUTO;
            break;
        default:
            break;
    }

    if(hdrType != HDR_DM_MODE_NONE)
    {
        rtd_pr_vsc_emerg("[%s %d]qs init hdrtype:%d\n", __FUNCTION__, __LINE__, vscHdrType);
        set_HDMI_HDR_mode(HDR_HDR10_HDMI);
        if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
        {
            set_force_i3ddma_enable(TRUE);
        }
        else
        {
            set_force_hdmi_hdr_flow_enable(true);
        }

        Set_Val_main_vsc_hdrtype(vscHdrType);
    }
}

unsigned char Get_Val_bQsmode(void)
{
    return bQsmode;
}

void Set_Val_bQsmode(unsigned char val)
{
    bQsmode = val;
}

void rtk_hal_QS_vscInit(void)
{
    int ret = 0;
    if(is_QS_scaler_enable()){
            QS_VSCInit_SyncConnectInfo();
            bQsmode = TRUE;
            if (VSC_INPUTSRC_MAXN ==Get_DisplayMode_Src(SLR_MAIN_DISPLAY)) {
                rtd_pr_vsc_err(" qs init source not connect\n");
                return;
            }
            ret = QS_VSCInit_SyncInputregionAndOutputregionInfo();
            if(ret < 0)
            {
                rtd_pr_vsc_err(" qs init vfe_hdmi_drv_get_display_timing_info error\n");
                return;
            }
            quickshow_set_pc_mode();
            QS_VSCInit_SyncHdrInfo();
            if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE))
            {
                rtd_pr_vsc_emerg("qs init onlinemeasure SLR_FORCE_BG_TYPE_SIG_UNSTABLE enable to rerun scaler\n");
                set_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_VSC,FALSE);
                DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
                return;
            }
            QS_VSCInit_SyncScalerTskInfo();
#ifndef UT_flag
            Scaler_VIP_PQ_QS_init();
#endif

    }
}
unsigned char rtk_hal_vsc_open(VIDEO_WID_T wid)
{
#ifdef CONFIG_DUAL_CHANNEL
	if ((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX)) {
		rtd_pr_vsc_debug("wid id is not right\n");
		return FALSE;
	}
#else
	if (wid !=VIDEO_WID_0) {
		rtd_pr_vsc_debug("wid id is not right\n");
		return FALSE;
	}
#endif

	if (VscInitdone_Flag == FALSE) {
		rtd_pr_vsc_debug("VSC is not init, can not be opened\n");
	} else {
		if (wid ==VIDEO_WID_0) {
			if(VscOpendone_Flag == FALSE)	{
				rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
                           rtk_hal_QS_vscInit();
				VscOpendone_Flag = TRUE;
			} else {
				rtd_pr_vsc_debug("Main vsc open have done, not need open again\n");
			}
		}
#ifdef CONFIG_DUAL_CHANNEL
		if (wid ==VIDEO_WID_1) {
			if(Sub_VscOpendone_Flag == FALSE)	{
				rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				Sub_VscOpendone_Flag = TRUE;
			} else {
				rtd_pr_vsc_debug("Sub vsc open have done,not need open again\n");
			}
		}
#endif
	}
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_open)(VIDEO_WID_T wid) = rtk_hal_vsc_open;

unsigned char rtk_hal_vsc_close(VIDEO_WID_T wid)
{
#ifdef CONFIG_DUAL_CHANNEL
	if ((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX)) {
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if (wid != VIDEO_WID_0) {
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		if (DbgSclrFlgTkr.OuputDisplayMode || DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode ||
		    DbgSclrFlgTkr.OutputAveMode) {
			rtd_pr_vsc_debug("Main vsc have source not disconnect, so can not close!\n");
		} else {
			if(VscOpendone_Flag == TRUE) {
				rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				//drvif_mode_resetmode(SLR_MAIN_DISPLAY);
				down(&Main_ResetMode_Semaphore);
				rtd_pr_vsc_debug("\r\n####func:%s request reset mode####\r\n", __FUNCTION__);
				DbgSclrFlgTkr.Main_Reset_Mode_flag = TRUE;
				up(&Main_ResetMode_Semaphore);
				VscOpendone_Flag = FALSE;
		 	} else {
		 		rtd_pr_vsc_debug("Main vsc not opened\n");
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		if (DbgSclrFlgTkr.Sub_OuputDisplayMode || DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode ||
		    DbgSclrFlgTkr.Sub_OutputAveMode) {
			rtd_pr_vsc_debug("Sub vsc have source not disconnect, so can not close!\n");
		} else {
			if(Sub_VscOpendone_Flag == TRUE) {
				rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				//drvif_mode_resetmode(SLR_SUB_DISPLAY);
				down(&Sub_ResetMode_Semaphore);
				DbgSclrFlgTkr.Sub_Reset_Mode_flag = TRUE;
				up(&Sub_ResetMode_Semaphore);
				Sub_VscOpendone_Flag = FALSE;
		 	} else {
		 		rtd_pr_vsc_debug("Sub vsc not opened\n");
			}
		}
	}
#endif
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_close)(VIDEO_WID_T wid) = rtk_hal_vsc_close;

long Scaler_Send_VoDisconnect_VOMDA_impl(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port)
{
	long ret = 0;
#ifndef UT_flag
#ifdef CONFIG_RTK_KDRV_RPC
	unsigned char type_local;
	unsigned char port_local;
	rtd_pr_vsc_debug("[]###############%s\n", __FUNCTION__);

	if (type == KADP_VO_VSC_SRC_VDEC) {
		rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 0;
	} else if(type == KADP_VO_VSC_SRC_JPEG){
		rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 1;
	} else {
		rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 2;
	}
	if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Port(SLR_MAIN_DISPLAY) != Get_DisplayMode_Port(SLR_SUB_DISPLAY)) {
		type_local = 0x10 | type_local;
	}

	port_local = wid_port;
	rtd_pr_vsc_debug("\n\n[pool test][sendVo]wid:%d,port:%d,plane:%d\n",(wid_port&0xf0)>>4,wid_port&0xf,Scaler_DispGetInputInfoByDisp(((wid_port&0xf0)>>4), SLR_INPUT_VODMA_PLANE));
	rtd_pr_vsc_debug("[vo]%s type %d, port %d, m[%d/%d] s[%d/%d]\n", __FUNCTION__, type_local, port_local, Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Port(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY), Get_DisplayMode_Port(SLR_SUB_DISPLAY));
#ifdef CONFIG_RTK_KDRV_RPC
	//set_vo_nosignal_flag((port_local & 0xf), 1);
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCDISCONNECT_TO_VODMA, type_local, port_local, &ret))
		rtd_pr_vsc_err("RPC fail!!\n");
#endif
    // reset decomp info for main VDEC
    if((type == KADP_VO_VSC_SRC_VDEC) && ((wid_port & 0xf) < 2) && (((wid_port&0xf0)>>4) == 0))
        set_vo_veComp_flag(wid_port & 0xf,0);
#endif
#endif
	return ret;
}
long (*Scaler_Send_VoDisconnect_VOMDA)(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port) = Scaler_Send_VoDisconnect_VOMDA_impl;

long Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port)
{
	long ret = 0;
#ifndef UT_flag
#ifdef CONFIG_RTK_KDRV_RPC
	unsigned char type_local;
	unsigned char port_local;
	rtd_pr_vsc_debug("[]###############%s\n", __FUNCTION__);

	if (type == KADP_VO_VSC_SRC_VDEC) {
		rtd_pr_vsc_debug("\r\n###func:%s line:%d VO_VSC_SRC_VDEC####\r\n", __FUNCTION__, __LINE__);
		type_local = 0;
	} else if(type == KADP_VO_VSC_SRC_JPEG){
		rtd_pr_vsc_debug("\r\n###func:%s line:%d VO_VSC_SRC_JPEG####\r\n", __FUNCTION__, __LINE__);
		type_local = 1;
	} else {
		rtd_pr_vsc_debug("\r\n###func:%s line:%d VO_VSC_SRC_HDMI####\r\n", __FUNCTION__, __LINE__);
		type_local = 2;
	}
	if ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Port(SLR_MAIN_DISPLAY) != Get_DisplayMode_Port(SLR_SUB_DISPLAY))){
		type_local = 0x10 | type_local;
	}

	port_local = wid_port;
	rtd_pr_vsc_debug("\n\n[pool test][sendVo]wid:%d,port:%d,plane:%d\n",(wid_port&0xf0)>>4,wid_port&0xf,Scaler_DispGetInputInfoByDisp(((wid_port&0xf0)>>4), SLR_INPUT_VODMA_PLANE));
	rtd_pr_vsc_debug("[vo]%s type %d, port %d, m[%d/%d] s[%d/%d]\n", __FUNCTION__, type_local, port_local, Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Port(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY), Get_DisplayMode_Port(SLR_SUB_DISPLAY));

	if((type == KADP_VO_VSC_SRC_VDEC) || (type == KADP_VO_VSC_SRC_JPEG)){
		set_vo_nosignal_flag((port_local & 0xf), 1);
		set_vo_EOS_flag((port_local & 0xf), 0);
		set_film_detect_done_flag((port_local & 0xf), 0);
       }
#if 0
	VIDEO_RPC_VOUT_VSCCONNECT_STRUCT *connect_parms;
	unsigned int vir_addr, vir_addr_noncache;
	unsigned int phy_addr;

	vir_addr = (unsigned int)dvr_malloc_uncached_specific(sizeof(VIDEO_RPC_VOUT_VSCCONNECT_STRUCT), GFP_DCU1, (void **)&vir_addr_noncache);
	phy_addr = (unsigned int)dvr_to_phys((void*)vir_addr);

	connect_parms = (VIDEO_RPC_VOUT_VSCCONNECT_STRUCT *)vir_addr_noncache;
	connect_parms->wid = port_local;
	connect_parms->vsc_source = type_local;
	connect_parms->vdo_port = connect_parms->wid;
	connect_parms->hdr_mode = port_local; //TODO

	connect_parms->wid = htonl(connect_parms->wid);
	connect_parms->vsc_source = htonl(connect_parms->vsc_source);
	connect_parms->vdo_port = htonl(connect_parms->vdo_port);
	connect_parms->hdr_mode = htonl(connect_parms->hdr_mode);

	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCINPUTTYPE_TO_VODMA,phy_addr, 0, &ret))
		rtd_pr_vsc_err("RPC fail!!\n");

        dvr_free((void *)vir_addr);
#else
#ifdef CONFIG_RTK_KDRV_RPC
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCINPUTTYPE_TO_VODMA, type_local, port_local, &ret))
		rtd_pr_vsc_err("RPC fail!!\n");
#endif
#endif


#endif
#endif

	return ret;
}

unsigned char vsc_force_disconnect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{//This API is patch for CI test not work. force disconnect current outputMode.
	unsigned int *p_sourceID = NULL;
	KADP_VSC_INPUT_SRC_INFO_T input_src_info = {KADP_VSC_INPUTSRC_MAXN, 0, 0};
#ifdef CONFIG_DUAL_CHANNEL
	StructSrcRect SrcRect = {0, 0, 0, 0};
#endif
	unsigned char plane=0;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	} else if (wid == VIDEO_WID_0) {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	}
#else
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#endif


	rtd_pr_vsc_debug(KERN_WARNING "\r\n####function:%s wid:%d outputMode:%d####\r\n", __FUNCTION__, wid, outputMode);
	if (wid == VIDEO_WID_0) {
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){//AP not mute on yet
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);//reset  vsc connect ready
				down(&SetMainOutPutRegion_Semaphore);
				set_main_scaler_stop_flag(TRUE);
				DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
				DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				is_DTV_flag_set(_DISABLE);
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetMainOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
				DbgSclrFlgTkr.main_winfreeze=0;
				DbgSclrFlgTkr.mainVscFreezeFlag=0;
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				drivf_scaler_reset_freerun();
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {

				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.OuputDisplayMode = FALSE; // Preset for vo
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);// Preset for vo
					set_vo_change_flag(SLR_MAIN_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OuputDisplayMode = FALSE;
				Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);
				*p_sourceID = _UNKNOWN_INPUT;
				//close display panel

				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);

				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					//smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OutputVencMode = FALSE;
				Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, input_src_info);
				*p_sourceID = _UNKNOWN_INPUT;

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE://Current same with VSC_OUTPUT_DISPLAY_MODE
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){//AP not mute on yet
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);//reset  vsc connect ready
				down(&SetMainOutPutRegion_Semaphore);
				set_main_scaler_stop_flag(TRUE);
				DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
				DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				is_DTV_flag_set(_DISABLE);
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetMainOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
				DbgSclrFlgTkr.main_winfreeze=0;
				DbgSclrFlgTkr.mainVscFreezeFlag=0;
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.OutputMemoryMode = FALSE;
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, input_src_info);
					set_vo_change_flag(SLR_MAIN_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OutputMemoryMode = FALSE;
				Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, input_src_info);
				*p_sourceID = _UNKNOWN_INPUT;

				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);

				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				HAL_VBE_AVE_Disconnect();
				DbgSclrFlgTkr.OutputAveMode = FALSE;
				Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_AVE_MODE, input_src_info);
				break;
			}
            case KADP_VSC_OUTPUT_MAXN:
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid == VIDEO_WID_1) {
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				down(get_forcebg_semaphore());
				scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//Auto mue before disconnect
				drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
				up(get_forcebg_semaphore());
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetSubOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

				drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type ==KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE; // Preset for vo
					plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);
					set_vo_change_flag(SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}

				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
				DbgSclrFlgTkr.sub_wind0000 = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				//add semaphore for sub disp @Crixus 20150901

				Scaler_SubDispWindowSet(SrcRect);
				Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);
				*p_sourceID = _UNKNOWN_INPUT;

				//close display panel

				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
					rtd_pr_vsc_emerg("[vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
					rtd_pr_vsc_emerg("rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

					if(run_i2rnd_flag == 1){
						run_i2rnd_flag = 0;
						rtk_hal_vsc_i2rnd_enable(_DISABLE);
						//frank@I2run disable main VENC flag
						VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
						DbgSclrFlgTkr.OutputVencMode = FALSE;
						vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
						rtd_pr_vsc_emerg("[%s][frank]I2RND close\n", __FUNCTION__);
					}
#endif
#endif
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
					//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				}
				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();
				DbgSclrFlgTkr.Sub_OutputVencMode = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, input_src_info);
				*p_sourceID = _UNKNOWN_INPUT;

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
				up(&SetSubOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

				drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL2,Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE; // Preset for vo
					plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, input_src_info);
					set_vo_change_flag(SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}

				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.sub_wind0000 = FALSE;
				DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				Scaler_SubDispWindowSet(SrcRect);
				Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, input_src_info);
				*p_sourceID = _UNKNOWN_INPUT;
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{

				HAL_VBE_AVE_Disconnect();
				DbgSclrFlgTkr.Sub_OutputAveMode = FALSE;
				Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_AVE_MODE, input_src_info);

				break;
			}
            case KADP_VSC_OUTPUT_MAXN:
			default:
				break;
		}
	}
#endif
	return TRUE;
}

unsigned char rtk_hal_vsc_Connect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif
	rtd_pr_vsc_info("vsc_connect wid:%d SrcInfo:%d;%d;%d,Mode:%d\n", wid, inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

	if (wid ==VIDEO_WID_0) {
		if (VscOpendone_Flag == FALSE) {
			rtd_pr_vsc_debug("Main vsc not open,so can not connect!\n");
			return FALSE;
		}
		increase_source_connect_verify_num(SLR_MAIN_DISPLAY);//increase the main source num
		if(KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type)
		{
			if(SRC_CONNECT_DONE == get_AVD_Global_Status()){
				Scaler_AVD_SetHalVscConnect(SLR_MAIN_DISPLAY,TRUE);
				drvif_module_vpq_DmaAccessCtrl(ON);
				drvif_adc_power_control(ADC_POWER_ADC_DISABLE_VDC_ALIVE_CONTROL,__func__,__LINE__);
				if(get_AVD_Input_Source() == _SRC_CVBS){
					drvif_adc_ctl_rgb12_check(get_AVD_Input_Source());
				}
				rtd_pr_vsc_info("########[%s(%d)] ##drvif_module_vpq_DmaAccessCtrl(ON)######", __FUNCTION__, __LINE__);
			}
		}
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				scaler_Setdualdecoder_notchange(0);
				if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
				{
					 if(rtk_hal_vsc_Getdualdecoder_run() && (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)) {
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						rtd_pr_vsc_info("dual decoder case,connect just change port return\n");
						DisplayModeInputInfo = inputSrcInfo;
						set_current_scaler_source_num(SLR_MAIN_DISPLAY);
						return TRUE;
					}
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OuputDisplayMode is on, please disconnect output display mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					if((VencModeInputInfo.type == inputSrcInfo.type) && (VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because venc mode is on, and display mode input is not the same with venc mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					if((MemoryModeInputInfo.type == inputSrcInfo.type) && (MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because memory mode is on, and display mode input is not the same with memory mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					if((AveModeInputInfo.type == inputSrcInfo.type) && (AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because ave mode is on, and display mode input is not the same with ave mode\n");
						return TRUE;
					}

				}
				else
				{
					Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
					if((inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG))
						DisplayModeInputInfo.resourceIndex = 0;//add by will for live zoom

					DbgSclrFlgTkr.OuputDisplayMode = TRUE;
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
						rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					}
					else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
						rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
					}

					if(KADP_VSC_INPUTSRC_HDMI != inputSrcInfo.type)
					{
						if(SRC_CONNECT_DONE == get_HDMI_Global_Status())
							drvif_Hdmi_WatchDogApply(_DISABLE, HDMI_WD_VSC_COND);

						//drvif_Hdmi_OutputDisable(1); //willychou remove it for fixing KTASKWBS-9866 on 2018/11/28
					}
					else
					{
						drvif_Hdmi_OutputDisable(0);
#ifdef CONFIG_SUPPORT_FREESYNC
						vbe_disp_set_freesync_mode_flag(1);
						rtd_pr_vsc_info("\r\n########[FreeSync] set_freesync_mode_flag enable!!!######\r\n");
#endif
					}

				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, TRUE);
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.OutputVencMode==TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output venc mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputMemoryMode is on, please disconnect output memory mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return FALSE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputVencMode = TRUE;
							Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, inputSrcInfo);
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and venc mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, inputSrcInfo);
						DbgSclrFlgTkr.OutputVencMode = TRUE;
					}
				}

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.OutputMemoryMode==TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output memory mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputMemoryMode = TRUE;
							Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, inputSrcInfo);
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and memory mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, inputSrcInfo);
						DbgSclrFlgTkr.OutputMemoryMode = TRUE;
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						} else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
						}
					}
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, TRUE);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output ave mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputAveMode = TRUE;
							Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_AVE_MODE, inputSrcInfo);
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and AVE mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						DbgSclrFlgTkr.OutputAveMode = TRUE;
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_AVE_MODE, inputSrcInfo);
					}
				}
				break;
			}

            case KADP_VSC_OUTPUT_MAXN:
			default:
				return FALSE;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		if (Sub_VscOpendone_Flag == FALSE) {
			rtd_pr_vsc_debug("Sub vsc not open,so can not connect!\n");
			return FALSE;
		}
		increase_source_connect_verify_num(SLR_SUB_DISPLAY);//increase the sub source num

		if(KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type)
		{
			if(SRC_CONNECT_DONE == get_AVD_Global_Status()){
				Scaler_AVD_SetHalVscConnect(SLR_SUB_DISPLAY,TRUE);
				drvif_module_vpq_DmaAccessCtrl(ON);
				rtd_pr_vsc_info("\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(ON)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OuputDisplayMode is on, please disconnect output display mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					if((Sub_VencModeInputInfo.type == inputSrcInfo.type) && (Sub_VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because venc mode is on, and display mode input is not the same with venc mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					if((Sub_MemoryModeInputInfo.type == inputSrcInfo.type) && (Sub_MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because memory mode is on, and display mode input is not the same with memory mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					if((Sub_AveModeInputInfo.type == inputSrcInfo.type) && (Sub_AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because ave mode is on, and display mode input is not the same with ave mode\n");
						return TRUE;
					}

				}
				else
				{
					Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, inputSrcInfo);

#ifdef CONFIG_I2RND_ENABLE
					//fixed sub use port 1;
					Sub_DisplayModeInputInfo.resourceIndex = 1;
#else
					if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC /*|| (inputSrcInfo.type == VSC_INPUTSRC_JPEG)*/)
					{
						Sub_DisplayModeInputInfo.resourceIndex = 1;
					}
#endif

					DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;

#ifdef CONFIG_I2RND_ENABLE
						down(&I2RND_Semaphore);
						if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC){
							set_i2rnd_vo1_refine_status_vir_addr(I2RND_S1_REFINE_VO1);
							rtd_pr_vsc_emerg("[I2RND]sub connect, I2RND_S1_REFINE_VO1!!\n");
						}
						up(&I2RND_Semaphore);
#endif

#ifdef CONFIG_PST_ENABLE
						if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
							drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
						if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
							drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
						sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);

							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						}
						else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
						}

				}

				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output venc mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputVencMode = TRUE;
							Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, inputSrcInfo);
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and venc mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, inputSrcInfo);
						DbgSclrFlgTkr.Sub_OutputVencMode = TRUE;
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
						rtd_pr_vsc_emerg("[vsc_connect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
						rtd_pr_vsc_emerg("rtk_hal_vsc_Connect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

						if((run_i2rnd_flag == 0) && (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)){
							run_i2rnd_flag = 1;
							rtk_hal_vsc_i2rnd_enable(_ENABLE);
							Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
							VSC_OUTPUT_VENC_MODE_FLAG = TRUE;

							//apvr trigger scaler flow in tsk @Crixus 20160824
							if((vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_DISABLE) || (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE))
								vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_TRIGGER_RUN_MAIN;
							rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
						}
#endif
#endif
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output memory mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputMemoryMode = TRUE;
							Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, inputSrcInfo);
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and memory mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{

						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_MEMORY_MODE, inputSrcInfo);
						DbgSclrFlgTkr.Sub_OutputMemoryMode = TRUE;
#ifdef CONFIG_PST_ENABLE
						if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
							drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
						if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
							drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
						sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);

							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						}
						else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
						}
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputAveMode is on, please disconnect output ave mode first\n");
					return FALSE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputAveMode = TRUE;
							Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_AVE_MODE, inputSrcInfo);
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and AVE mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						DbgSclrFlgTkr.Sub_OutputAveMode = TRUE;
						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_AVE_MODE, inputSrcInfo);
					}
				}
				break;
			}
            case KADP_VSC_OUTPUT_MAXN:
			default:
				return FALSE;
		}
	}
#endif
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_Connect)(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode) = rtk_hal_vsc_Connect;

void rtk_i3ddma_disable(void)
{
	unsigned int timeoutcount = 5;
	I3DDMA_3DDMA_CTRL_T *p_i3ddmaCtrl = NULL;
#if 1//def CONFIG_FORCE_RUN_I3DDMA
	down(&Force_Run_Idma_Semaphore);
	p_i3ddmaCtrl = Get_Val_i3ddmaCtrl_addr();
	if((get_force_i3ddma_enable(SLR_MAIN_DISPLAY)) || (p_i3ddmaCtrl && p_i3ddmaCtrl->cap_buffer[0].phyaddr) || (H3DDMA_CAP0_CTI_DMA_WR_Ctrl_get_cap0_dma_enable(IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Ctrl_reg))) || 
		(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_get_cap1_dma_enable(IoReg_Read32(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_reg))) ||
		(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_get_cap2_dma_enable(IoReg_Read32(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_reg))) ||
		(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_get_cap3_dma_enable(IoReg_Read32(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_reg)))){
	if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
		Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
	//set i3ddma read hw level
	IoReg_ClearBits(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_reg, H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_db_read_sel_mask);

	drvif_I3DDMA_Reset_Vgip_Source_Sel();

	set_force_i3ddma_enable(false);
#ifdef CONFIG_ENABLE_HDMI_NN
	if(h3ddma_nn_get_sub_path_enable())
		h3ddma_nn_disable_sub_path();
#endif
	h3ddma_set_capture_enable(0,0);
	h3ddma_set_capture_enable(1,0);
	h3ddma_set_capture_enable(2,0);
	h3ddma_set_capture_enable(3,0);
	if(p_i3ddmaCtrl)
		I3DDMA_Setup3DDMA(p_i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);

	do {
		if((H3DDMA_CAP0_CTI_DMA_WR_Ctrl_get_cap0_dma_enable(IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Ctrl_reg)) == 0) && ((H3DDMA_CAP1_CTI_DMA_WR_Ctrl_get_cap1_dma_enable(IoReg_Read32(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_reg))) == 0) &&
			(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_get_cap2_dma_enable(IoReg_Read32(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_reg)) == 0) && (H3DDMA_CAP3_CTI_DMA_WR_Ctrl_get_cap3_dma_enable(IoReg_Read32(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_reg)) == 0))
			break;

		msleep(10);
		timeoutcount--;
	}while(timeoutcount);

	rtd_pr_vsc_notice("########%s i3ddma capture disable status (%d,%d,%d,%d), timeoutcnt=%d db=%x", __FUNCTION__, (H3DDMA_CAP0_CTI_DMA_WR_Ctrl_get_cap0_dma_enable(IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Ctrl_reg))),
			(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_get_cap1_dma_enable(IoReg_Read32(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_reg))), (H3DDMA_CAP2_CTI_DMA_WR_Ctrl_get_cap2_dma_enable(IoReg_Read32(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_reg))),
			(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_get_cap3_dma_enable(IoReg_Read32(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_reg))), timeoutcount, IoReg_Read32(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_reg));

	//recovery i3ddma read level
	IoReg_SetBits(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_reg, H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_db_read_sel_mask);
	drvif_I3DDMA_Disable_Vgip();
	// [IDMA] allocate/release IDMA memory dynamic
	if(I3DDMA_Get3DAllocReleaseMemoryDynamic() == TRUE)
		I3DDMA_DolbyVision_HDMI_DeInit();
#ifdef CONFIG_ENABLE_HDMI_NN
		h3ddma_free_nv12_mermory();
#endif
	}
	up(&Force_Run_Idma_Semaphore);
#endif
}

#ifndef UT_flag
struct semaphore* get_double_buffer_semaphore(void)
{
	return &Double_buffer_Semaphore;
}
#endif //UT_flag
extern void vo_free_photo_buffer(unsigned int ch);

extern int flag_vdo_disconnect;
unsigned char vdo_connect(unsigned char display, unsigned char vdec_port)
{
#ifdef CONFIG_RTK_KDRV_RPC
	unsigned long ret = 0;
#endif
	if (display == VIDEO_WID_0)
	{
		if(vdo0_connect)
		{
			rtd_pr_vsc_notice("\r\n## main vdo_connect already connect ##\r\n");
			return TRUE;
		}
	}
	else
	{
		if(vdo1_connect)
		{
			rtd_pr_vsc_notice("\r\n## sub vdo_connect already connect ##\r\n");
			return TRUE;
		}
	}
	rtd_pr_vsc_info("vdo_connect wid:%d vdec_port:%d\n", display, vdec_port);


	if(display == VIDEO_WID_0)//add by will for live zoom
		vdo0_connect = TRUE; //vo 0 connect
	else
		vdo1_connect = TRUE; //vo 1 connect

	increase_source_connect_verify_num(display);//increase the vsc source verify num. for checking vsc connect again

#ifdef CONFIG_RTK_KDRV_RPC
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDOCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
	{
		rtd_pr_vsc_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDOCONNECT_TO_VODMA RPC fail ####\r\n");
		return FALSE;
	}
#endif


#ifdef CONFIG_DUMP_REGISTER_WHEN_ONLY_DISCONNECT
		flag_vdo_disconnect = 0;

#endif

	return TRUE;

}

UINT8 get_read_buffer_first_flag(unsigned char display)
{
	if (display == VIDEO_WID_0)
    	return read_buffer_first_flag;
	else
    	return sub_read_buffer_first_flag;
}

void set_read_buffer_first_flag(unsigned char display, UINT8 flag)
{
	if (display == VIDEO_WID_0)
    	read_buffer_first_flag = flag;
	else
		sub_read_buffer_first_flag = flag;
}

unsigned char Get_Val_vdo0_connect(void)
{
    return vdo0_connect;
}

unsigned char Get_Val_vdo1_connect(void)
{
    return vdo1_connect;
}

void Set_Val_vdo0_connect(unsigned char input)
{
    vdo0_connect = input;
}

void Set_Val_vdo1_connect(unsigned char input)
{
    vdo1_connect = input;
}

unsigned char vdo_disconnect(unsigned char display, unsigned char vdec_port)
{
	unsigned char result = TRUE;
#ifdef CONFIG_RTK_KDRV_RPC
	unsigned long ret;
#endif

#ifdef CONFIG_DUMP_REGISTER_WHEN_ONLY_DISCONNECT
	flag_vdo_disconnect = 1;
#endif

	if (display == VIDEO_WID_0)
	{
		if(!vdo0_connect)
		{
			rtd_pr_vsc_notice("\r\n## main vdo_disconnect already disconnect ##\r\n");
			return TRUE;
		}
	}
	else
	{
		if(!vdo1_connect)
		{
			rtd_pr_vsc_notice("\r\n## sub vdo_disconnect already disconnect ##\r\n");
			return TRUE;
		}
	}
	if (rtk_hal_vsc_Getdualdecoder_run()) {
#ifdef CONFIG_RTK_KDRV_RPC
		if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
		{
			rtd_pr_vsc_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA RPC fail ####\r\n");
			result =  FALSE;
		}
#endif
		if (display == VIDEO_WID_0) {
			vdo0_connect = FALSE;
		} else {
			vdo1_connect = FALSE;
		}
		rtd_pr_vsc_info("dual decoder case,vdo_disconnect not change,return\n");
		return result;
	}
	set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
	mute_control(display, TRUE);/*Auto BG. Add by Will*/
	rtd_pr_vsc_info("vdo_disconnect wid:%d vdec_port:%d (0x%08x)\n", display, vdec_port, IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg));


	if (display == VIDEO_WID_0) {
		vdo0_connect = FALSE; //vo 0 disconnect
		down(&SetMainOutPutRegion_Semaphore);
		set_main_scaler_stop_flag(TRUE);
		DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
		DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
		DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
		DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
		DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
		Set_Val_ap_rotate_mode(DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
		main_rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
		set_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
		set_ori_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
		is_DTV_flag_set(_DISABLE);
		DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
		zoom_clear_input_output_region_record((unsigned char)display);
		Scaler_InputRegionType_Set(display,INPUT_BASE_ON_TIMING);
		up(&SetMainOutPutRegion_Semaphore);
		source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero

		DbgSclrFlgTkr.main_winfreeze=0;
		drivf_scaler_reset_freerun();
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
        scaler_vsc_set_adaptive_pst_lowdelay_mode(0);
#endif
	}
	else
	{
#ifdef CONFIG_DUAL_CHANNEL
		vdo1_connect = FALSE; //vo 1 disconnect
		down(&SetSubOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
		zoom_clear_input_output_region_record((unsigned char)display);
		Scaler_InputRegionType_Set(display,INPUT_BASE_ON_TIMING);
		up(&SetSubOutPutRegion_Semaphore);
		source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero
#endif
	}

	drvif_mode_disableonlinemeasure(display);//Diable online measure
	drvif_mode_onlinemeasure_setting(display, Scaler_InputSrcGetType(display), FALSE, FALSE);

	down(get_vo_infosemaphore());
    if(display == VIDEO_WID_0)
    {
        Set_Val_scaler_vdec_source_type(VSC_VDEC_CASE_UNKNOWN);//reset vdec source type
    }
	set_vo_change_flag((display == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
	set_force_change_vo_flag((display == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, TRUE);
	up(get_vo_infosemaphore());

	Check_smooth_toggle_update_flag(display);
#ifdef CONFIG_RTK_KDRV_RPC
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
	{
		rtd_pr_vsc_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA RPC fail ####\r\n");
		result =  FALSE;
	}
#endif
	smooth_toggle_disconnect(display,display);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
	state_update_disp_info();

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if ((display == SLR_MAIN_DISPLAY) && (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY)))
	{
		down(&Main_ResetMode_Semaphore);
		rtd_pr_vsc_debug("\r\n####func:%s request reset mode####\r\n", __FUNCTION__);
		DbgSclrFlgTkr.Main_Reset_Mode_flag = TRUE;
		up(&Main_ResetMode_Semaphore);
	}
#endif


#ifdef Mer2_MEMORY_ALLOC
	if (display == VIDEO_WID_0)
	{
		Scaler_color_set_HDR_Type(0xff);	// reset hdr type
		#ifdef CONFIG_HW_SUPPORT_I_DE_XC
		drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(0, 0, 0, 1);
		drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(1, 0, 0, 1);
		#endif
		drv_memory_MA_SNR_Disable(0);
		drv_memory_MA_SNR_Disable(1);
		/* for PQ IP Enable monitor*/
		//Scaler_PQ_IP_Enable_Monitor_clear_Buff();//mac7p pq compile fix
	}
#endif

	if (display == VIDEO_WID_0) {
		DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
		DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
		down(&SetMainOutPutRegion_Semaphore);
		reset_any_srcrect(&main_dispwin_pre);
		reset_any_srcrect(&main_dispwin_for_only_xy);
		up(&SetMainOutPutRegion_Semaphore);
	} else {
#ifdef CONFIG_DUAL_CHANNEL
		DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
		down(&SetSubOutPutRegion_Semaphore);
		reset_any_srcrect(&sub_dispwin_pre);
		up(&SetSubOutPutRegion_Semaphore);
#endif
	}


	rtd_pr_vsc_notice("[VSC] vdo_disconnect done (0x%08x)\n", IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg));
	return result;
}


unsigned char rtk_hal_vsc_Disconnect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{
	unsigned int *p_sourceID = NULL;
	KADP_VSC_INPUT_SRC_INFO_T input_src_info = {KADP_VSC_INPUTSRC_MAXN, 0, 0};
#ifdef CONFIG_DUAL_CHANNEL
	StructSrcRect SrcRect = {0, 0, 0, 0};
#endif
	unsigned char plane=0;
#ifdef CONFIG_I2RND_ENABLE
	unsigned char i2rnd_port_main = 0;
	unsigned char i2rnd_port_sub = 0;
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
     if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
           //  rtd_pr_vsc_info("!!!!!!!!!!!!!!!!!!!!!!!!!!!b05_vsc_Disconnect!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
             rtk_hal_vsc_i2rnd_b05_enable(_DISABLE);
     }
#endif

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	} else if (wid == VIDEO_WID_0) {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	}
#else
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#endif
//Eric@20171013 set cmd table index before setting register
#ifdef CONFIG_I2RND_ENABLE
	if(Scaler_I2rnd_get_timing_enable()){
		if(wid == VIDEO_WID_0)
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
		else if (wid == VIDEO_WID_1)
			Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
	}
#endif
	rtd_pr_vsc_info("vsc_disconnect wid:%d SrcInfo:%d;%d;%d,Mode:%d\n", wid, inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

	if (wid ==VIDEO_WID_0) {

		if((KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type))
		{
			Scaler_AVD_SetHalVscConnect(SLR_MAIN_DISPLAY,FALSE);
			if(Scaler_AVD_GetHalVscConnect(SLR_SUB_DISPLAY) == FALSE){
				drvif_module_vpq_DmaAccessCtrl(OFF);
				rtd_pr_vsc_info("\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(OFF)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			case KADP_VSC_OUTPUT_MEMORY_MODE://Current same with VSC_OUTPUT_DISPLAY_MODE
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
				{
					if(DisplayModeInputInfo.type == inputSrcInfo.type)
					{
						if ((inputSrcInfo.type == (KADP_VSC_INPUT_TYPE_T)VSC_INPUTSRC_VDEC) && rtk_hal_vsc_Getdualdecoder_run()) {
							Scaler_Send_VoDisconnect_VOMDA((KADP_VO_VSC_SRC_TYPE_T)VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
							down(get_vo_infosemaphore());
							set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
							up(get_vo_infosemaphore());
                            reset_any_srcrect(&main_input_size);
							reset_any_srcrect(&main_dispwin);
							scaler_Setdualdecoder_notchange(1);
							rtd_pr_vsc_info("dual decoder case,disconnect not change,return, and clear pre input,output\n");
							return TRUE;
						}
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
						set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);
						down(&SetMainOutPutRegion_Semaphore);
						set_main_scaler_stop_flag(TRUE);
						DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
						DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
						Set_Val_ap_rotate_mode(DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
						main_rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
						set_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
						set_ori_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
						is_DTV_flag_set(_DISABLE);
						zoom_clear_input_output_region_record(wid);
						Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
						up(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.main_winfreeze=0;
						DbgSclrFlgTkr.mainVscFreezeFlag=0;
						source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
#ifndef CONFIG_MEMC_BYPASS
                        memc_me_clock_set_off = 0;	//reset me_clock_set_off flag
#endif
                        //reset film parameter
						film_mode_parameter.enable = 0;
						film_mode_parameter.type= 0;
						film_mode_parameter.v_freq = 0;
						set_ori_voclk_ratio_num(0);
						Scaler_set_dynamic_framerate_change_flag(_DISABLE);
						drv_memory_set_vdec_direct_low_latency_mode(_DISABLE);
						scaler_set_VRR_pwm_frequency_update_in_isr(FALSE);
                        			scaler_RGB444Mode_pre = FALSE;
						vsc_force_rerun_main_scaler = FALSE;
#ifdef CONFIG_SUPPORT_FREESYNC
						vbe_disp_set_freesync_mode_flag(0);
						rtd_pr_vsc_info("\r\n########[FreeSync] set_freesync_mode_flag disable!!!######\r\n");
#endif
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							vo_free_photo_buffer(0);
						}
						drivf_scaler_reset_freerun();

						if((DbgSclrFlgTkr.OutputVencMode == FALSE) && (DbgSclrFlgTkr.OutputMemoryMode == FALSE) && (DbgSclrFlgTkr.OutputAveMode == FALSE))
						{
							drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
							set_force_hdmi_hdr_flow_enable(false);
							//set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
								rtd_pr_vsc_info("#####[%s(%d)] get_ADC_Global_Status=%d,get_ADC_Input_Source=%d\n", __func__, __LINE__, get_ADC_Global_Status(), get_ADC_Input_Source());
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									drvif_adc_power_control(ADC_POWER_YPP_ONLY_DETECT_CONTROL,__func__,__LINE__);
									drvif_adc_ctl_rgb12_check(get_ADC_Input_Source());
								}
                                rtk_i3ddma_disable();
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
                                rtk_i3ddma_disable();
								//drvif_Hdmi_OutputDisable(1); // not HDMI source, disable HDMI output,willychou remove it for fixing KTASKWBS-9866 on 2018/11/28
								drvif_Hdmi_WatchDogApply(_DISABLE, HDMI_WD_VSC_COND);
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								rtk_i3ddma_disable();
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							//	vo_overscan_disable(inputSrcInfo.type);
                                Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
                                if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
                                {
                                    Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
                                }
                                else
                                    Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);


                                down(get_vo_infosemaphore());
                                Set_Val_scaler_vdec_source_type(VSC_VDEC_CASE_UNKNOWN);//reset vdec source type
                                DbgSclrFlgTkr.OuputDisplayMode = FALSE;
                                plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
                                Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);

                                set_vo_change_flag(SLR_MAIN_DISPLAY, FALSE);//Reset Vo change flag
                                set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);

                                rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
                                up(get_vo_infosemaphore());
							}
							smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();

#ifdef Mer2_MEMORY_ALLOC
							Scaler_color_set_HDR_Type(0xff);	// reset hdr type
							#ifdef CONFIG_HW_SUPPORT_I_DE_XC
							drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(0, 0, 0, 1);
							drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(1, 0, 0, 1);
							#endif
							drv_memory_MA_SNR_Disable(0);
							drv_memory_MA_SNR_Disable(1);
							/* for PQ IP Enable monitor*/
							//Scaler_PQ_IP_Enable_Monitor_clear_Buff();//mac7p pq compile fix
#endif

						}
						//USER:Lewislee DATE:2015/10/2
						//when PIP off, need reset setting
						Scaler_Disp3dSetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE, SLR_3D_2D_ONLY);
						Scaler_Set3DMode_Attr(SLR_MAIN_DISPLAY, SLR_3DMODE_2D);
#ifdef CONFIG_I2RND_ENABLE
						//rtd_pr_vsc_emerg("[crixus][vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
						//rtd_pr_vsc_emerg("[crixus]rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);
						down(&I2RND_Semaphore);
						//clear i2rnd main voinfo i2r_fix_me
						i2rnd_main_voinfo = i2rnd_empty_voinfo;

						//Eric@20170809 disable i2rnd when VDEC src disconnected
						if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE)){
							//sub already disconnect
							Scaler_I2rnd_set_force_cmd(_DISABLE);
							Scaler_pst_buffer_initial(_MAIN_MD);
							rtd_pr_vsc_emerg("[%s][I2RND][main disconnect]I2RND initial\n", __FUNCTION__);
						}
						else{
							//sub still connect, keep 1:1 mode
							rtd_pr_vsc_emerg("[%s][I2RND][main disconnect]sub still connect, keep 1:1\n", __FUNCTION__);
						}
						if(get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S0_CONNECTED){
							set_i2rnd_vo1_refine_status_vir_addr(I2RND_VO1_REFINE_OFF);
							rtd_pr_vsc_emerg("[I2RND]main disconnect, I2RND_VO1_REFINE_OFF!!\n");
						}
						set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_OFF);
						rtd_pr_vsc_emerg("[I2RND]main disconnect, I2RND_S0_IDOMAIN_STAGE_OFF!!\n");
						up(&I2RND_Semaphore);
#endif

						DbgSclrFlgTkr.OuputDisplayMode = FALSE;
                                        bQsmode = FALSE;
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);
						*p_sourceID = _UNKNOWN_INPUT;
						//close display panel
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#ifdef CONFIG_SUPPORT_DOLBY_VSIF
						if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)//disconnect hdmi change the resource
							vfe_hdmi_drv_set_infoframe_thread_stop(_FALSE);
#endif //#ifdef CONFIG_SUPPORT_DOLBY_VSIF
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;display mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error display mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
#ifdef CONFIG_HW_SUPPORT_DC2H
				if(get_vdec_securestatus()==TRUE){
					set_vdec_securestatus(FALSE);
					set_dtv_securestatus(FALSE);
				}
#endif

#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
				if(read_buffer_first_flag == 1){
					read_buffer_first_flag = 0;
					rtd_pr_vsc_debug("[self-dianosis]27M reset !!\n");
				}
#endif //CONFIG_ENABLE_VD_27MHZ_MODE
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					if((VencModeInputInfo.type == inputSrcInfo.type) && (VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.OuputDisplayMode == FALSE)
						{
							drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
							//set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
								//smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							}
							smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						DbgSclrFlgTkr.OutputVencMode = FALSE;
						Set_vsc_input_src_info(SLR_MAIN_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, input_src_info);
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;venc mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error venc mode not open\n");
						return TRUE;
					}
				}

				break;
			}
            case KADP_VSC_OUTPUT_MAXN:
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {

		if((KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type))
		{
			Scaler_AVD_SetHalVscConnect(SLR_SUB_DISPLAY,FALSE);
			if(Scaler_AVD_GetHalVscConnect(SLR_MAIN_DISPLAY) == FALSE){
				drvif_module_vpq_DmaAccessCtrl(OFF);
				rtd_pr_vsc_info("\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(OFF)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				{
					if(Sub_DisplayModeInputInfo.type == inputSrcInfo.type)
					{
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//Auto mue before disconnect
						drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
						up(get_forcebg_semaphore());
						if((DbgSclrFlgTkr.Sub_OutputVencMode == FALSE) && (DbgSclrFlgTkr.Sub_OutputMemoryMode == FALSE) && (DbgSclrFlgTkr.Sub_OutputAveMode == FALSE))
						{
							down(&SetSubOutPutRegion_Semaphore);
							DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
							DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
							zoom_clear_input_output_region_record(wid);
							Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
							up(&SetSubOutPutRegion_Semaphore);
							source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero
#ifdef CONFIG_I2RND_ENABLE
							down(&I2RND_Semaphore);
							//clear i2rnd sub voinfo //i2r_fix_me
							i2rnd_sub_voinfo = i2rnd_empty_voinfo;
							vsc_i2rnd_dualvo_sub_stage= I2RND_DUALVO_STAGE_SUB_DISABLE;
							vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
							//Eric@20171213 disable pst flag
							Scaler_main_md_pst_set_enable(_DISABLE);
							Scaler_sub_md_pst_set_enable(_DISABLE);

							if(DbgSclrFlgTkr.OuputDisplayMode == FALSE){
								rtd_pr_vsc_emerg("[%s][I2RND]PIP disconnect sub src!\n", __FUNCTION__);
							}
							else{
								//main still connect
								Scaler_I2rnd_set_force_cmd(_ENABLE);
								Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
								//drivf_scaler_reset_freerun();
								//modestate_set_fll_running_flag(_ENABLE);
								rtd_pr_vsc_emerg("[%s][I2RND]PIP disconnect sub src, main still connect, set force cmd enable!\n", __FUNCTION__);
							}
							//disable dual vo mode flag
							if((inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC))
								Scaler_Send_VoDisconnect_VOMDA(VO_VSC_SRC_HDMI, 0xaa); //0xaa use for i2r sub window

							if(get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S1_REFINE_VO1){
								set_i2rnd_vo1_refine_status_vir_addr(I2RND_VO1_REFINE_OFF);
								rtd_pr_vsc_emerg("[I2RND]sub disconnect, I2RND_VO1_REFINE_OFF!!\n");
							}
							up(&I2RND_Semaphore);
#endif
							drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
							drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
							//set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								down(get_vo_infosemaphore());
								DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
								plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);
								set_vo_change_flag(SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag

								set_force_change_vo_flag(SLR_SUB_DISPLAY, TRUE);

								rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
								up(get_vo_infosemaphore());
							//	vo_overscan_disable(inputSrcInfo.type);
								Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								else
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

								//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							}

							smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
						DbgSclrFlgTkr.sub_wind0000 = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Scaler_SubDispWindowSet(SrcRect);

						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_DISPLAY_MODE, input_src_info);
						*p_sourceID = _UNKNOWN_INPUT;
						//close display panel

						//USER:Lewislee DATE:2015/10/2
						//when PIP off, need reset setting
						Scaler_Disp3dSetInfo(SLR_SUB_DISPLAY, SLR_DISP_3D_3DTYPE, SLR_3D_2D_ONLY);
						Scaler_Set3DMode_Attr(SLR_SUB_DISPLAY, SLR_3DMODE_2D);
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;display mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error display mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				if (DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) {
					DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
				}
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);

                #ifdef CONFIG_ENABLE_VD_27MHZ_MODE
				if(sub_read_buffer_first_flag == 1){
					Scaler_AVD_EnableVD27MMode(VD_27M_HSD960_DI5A);
					Scaler_AVD_SetDetectStage(0);//DETECT_STAGE_INIT
					sub_read_buffer_first_flag = 0;
					rtd_pr_vsc_debug("[self-dianosis]27M reset !!\n");
				}
                #endif
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					if((Sub_VencModeInputInfo.type == inputSrcInfo.type) && (Sub_VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.Sub_OuputDisplayMode == FALSE)
						{
							drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
							drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
							//set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
							/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
							*/
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
							rtd_pr_vsc_emerg("[vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
							rtd_pr_vsc_emerg("rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

							if(run_i2rnd_flag == 1){
								run_i2rnd_flag = 0;
								//i2rnd_send_table_idx(I2RND_TABLE_OFF);
								rtk_hal_vsc_i2rnd_enable(_DISABLE);
								//frank@I2run disable main VENC flag
								VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
								DbgSclrFlgTkr.OutputVencMode = FALSE;
								vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
								vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
								//apvr_request_run_main_path();
								rtd_pr_vsc_emerg("[%s][frank]I2RND close\n", __FUNCTION__);
							}
#endif
#endif

							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
								//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							}
							smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}

						DbgSclrFlgTkr.Sub_OutputVencMode = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Set_vsc_input_src_info(SLR_SUB_DISPLAY, KADP_VSC_OUTPUT_VENC_MODE, input_src_info);
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;venc mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error venc mode not open\n");
						return TRUE;
					}
				}
				break;
			}
            case KADP_VSC_OUTPUT_MAXN:
			default:
				break;
		}
	}
#endif
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_Disconnect)(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode) = rtk_hal_vsc_Disconnect;

#ifndef UT_flag
unsigned char check_zoom_smooth_toggle_proc(void)
{//added by rika 20140904
	//int failflag=ZOOM_STATE_OK;
	//unsigned char resetflag=_DISABLE;
	return ZOOM_STATE_OK;//temp return by will.
#if 0
	if(zoom_smooth_toggle_get_finish() == ZOOM_STATE_NONE){
		rtd_pr_vsc_debug("_rk %s none\n",__FUNCTION__);
		///Scaler_DispSetInputInfo(SLR_INPUT_STATE,_MODE_STATE_ACTIVE);//For check timing
	}
	else if(zoom_smooth_toggle_get_finish() == ZOOM_STATE_WAIT_APPLY_OK){
		//zoom_smooth_toggle_set_finish(ZOOM_STATE_DONOW);
		rtd_pr_vsc_debug("_rk wait ok here\n-----\n");
		resetflag=_ENABLE;//reset size anyway  rika 20141112
		failflag=zoom_imd_smooth_toggle_proc(_ENABLE, _ENABLE, Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));//need review rika 20141224

		if(failflag==ZOOM_STATE_OK){
			rtd_pr_vsc_debug("_rk %s wait ok done. send active2 \n", __FUNCTION__);
			///Scaler_DispSetInputInfo(SLR_INPUT_STATE,_MODE_STATE_ACTIVE);//For check timing

		}
		//else fail
		// do not set active
	}
	return failflag;
#endif
}
#endif

#define AVD_480i_MAX_LENGTH 504   // WebOS adjust v_size max size (2*v_start + v_length)
unsigned char CheckAVDandWebOSInfo_impl(unsigned char display)
{
	unsigned char ucRet = TRUE;

	// The current signal color std is supported, check the M-domain size and InputRegion
	if( (Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL)
		&& (0 == Scaler_AVD_IsSupportedColorSys()))  // 0: supported, -1: non-supported
	{
		unsigned short usAfterDILen = 0;
		unsigned short usInputRegion_h = 0, usInputRegion_y = 0;
		rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
		rtd_pr_vsc_debug("DbgSclrFlgTkr.Main_Output_Set_flag=%x, DbgSclrFlgTkr.Main_Scaler_Stop_flag=%x, DbgSclrFlgTkr.Main_Run_Scaler_flag=%x\n", DbgSclrFlgTkr.Main_Output_Set_flag, get_main_scaler_stop_flag(), DbgSclrFlgTkr.Main_Run_Scaler_flag);


		if (display == SLR_MAIN_DISPLAY && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			usAfterDILen =	(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN) << 1);
		} else {
			usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);
		}

		if(display == SLR_MAIN_DISPLAY)
		{
			usInputRegion_h = Main_InputRegion_h;
			usInputRegion_y = Main_InputRegion_y;
		}
        #ifdef CONFIG_DUAL_CHANNEL
		else
		{
			usInputRegion_h = Sub_InputRegion_h / 2;  // 480=>240, 576=>288 (InputRegion_h is full size)
			usInputRegion_y = Sub_InputRegion_y / 2;
		}
        #endif

#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT){
			if(display == SLR_MAIN_DISPLAY)
			{
				usInputRegion_h = Scaler_intputRegion_base_scalerTiming[display].src_height;//Main_InputRegion_h;
				usInputRegion_y = Scaler_intputRegion_base_scalerTiming[display].srcy;//Main_InputRegion_y;
			}
#ifdef CONFIG_DUAL_CHANNEL
			else
			{
				usInputRegion_h = Scaler_intputRegion_base_scalerTiming[display].src_height / 2;//Sub_InputRegion_h / 2;  // 480=>240, 576=>288 (InputRegion_h is full size)
				usInputRegion_y = Scaler_intputRegion_base_scalerTiming[display].srcy / 2;//Sub_InputRegion_y / 2;
			}
#endif
		}
#endif

		rtd_pr_vsc_debug("usInputRegion=%d,  usAfterDILen=%d\n", usInputRegion_h , usAfterDILen);

		if ((usInputRegion_h > usAfterDILen)
			|| ((usInputRegion_y*2 + usInputRegion_h) <= AVD_480i_MAX_LENGTH && usAfterDILen > 500)  //Throw DI (Current signal is 576i, but inputRegion is 480i)
			|| ((usInputRegion_y*2 + usInputRegion_h) <= (AVD_480i_MAX_LENGTH/2) && usAfterDILen > 250) ) // ByPass DI
		{
			rtd_pr_vsc_debug(" m-domain size wrong, return false\n");

			ucRet = FALSE;
		}
	}

	return ucRet;
}

void wait_DI_auto_freeze(void)
{
	if(((rtd_inl(VODMA_VODMA_V1_DCFG_reg) &VODMA_VODMA_V1_DCFG_vodma_go_mask)==0)
			&&((rtd_inl(VODMA_VODMA_V1INT_reg) &VODMA_VODMA_V1INT_vgip_en_mask) == 0))
		{

			int timeout = 50;
			while(((rtd_inl(DI_IM_DI_DEBUG_MODE_reg)&_BIT8)>>8==0)&&timeout--){
				rtd_pr_vsc_emerg("wait DI freeze\n");
				mdelay(1);
			}
			if(timeout == 0)
				rtd_pr_vsc_emerg("wait_DI_auto_freeze timeout\n");

		}
}


void reset_rotate_mode_impl(unsigned char display)
{
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if(display == SLR_MAIN_DISPLAY)
	{
		if (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
		{
		    extern void scaler_mdom_stop(void);
                    Set_Val_rotatedisconnecten(1);
		    scaler_Rotate_VI_init_send_rpc();
                    Set_Val_rotatedisconnecten(0);
		    if(get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY))
		    	wait_DI_auto_freeze();
		    scaler_mdom_stop();
			Set_rotate_function(SLR_MAIN_DISPLAY, FALSE);

		    if(!Get_PANEL_VFLIP_ENABLE())
		    {
		        scaler_send_rotate_vflip_rpc(FALSE);
		    }
		}
	}else
	rtd_pr_vsc_emerg("reset_rotate_mode sub do nothing\n");


#endif
}

unsigned char wait_to_after_avsync_do = 0;
unsigned char new_voinfo_flag = 0;// to check vo overscan or not
unsigned char Get_Val_new_voinfo_flag(void)
{
    return new_voinfo_flag;
}
void Set_Val_new_voinfo_flag(unsigned char enable)
{
    new_voinfo_flag = enable;
}
unsigned char Get_Val_wait_avsync_do_flag(void)
{
    return wait_to_after_avsync_do;
}
void Set_Val_wait_avsync_do_flag(unsigned char enable)
{
    wait_to_after_avsync_do = enable;
}
void decide_rotate_flag_impl(unsigned char display)
{
	#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			if(display == SLR_MAIN_DISPLAY)
			{

			down(&SetMainOutPutRegion_Semaphore);
			if((get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)
				||(get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
				||(get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270))
			{
				Set_rotate_function(SLR_MAIN_DISPLAY, TRUE);
			}
			#if 0
			else if ((display == SLR_MAIN_DISPLAY) && (get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
			        && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
            {
            	Set_rotate_function(TRUE);
            }else
            {
		        Set_rotate_function(FALSE);
	        }
			#endif
			//set_ori_rotate_mode(get_rotate_mode());
			up(&SetMainOutPutRegion_Semaphore);
			#if 0
            if(!Get_PANEL_VFLIP_ENABLE()){
                if((get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
                    && (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == FALSE))
                {
                	rtd_pr_vsc_emerg("progressive rotate 180, send vo vflip to vcpu true \n");
                	scaler_send_rotate_vflip_rpc(TRUE);
                }
                else
                {
                    rtd_pr_vsc_emerg("interlace rotate 180, send vo vflip to vcpu  false \n");
                	scaler_send_rotate_vflip_rpc(FALSE);
                }
            }
			#endif
			if((Get_rotate_function(SLR_MAIN_DISPLAY) == TRUE) || (get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)))
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ROTATE, TRUE);
		}
#endif

}
void (*decide_rotate_flag)(unsigned char) = decide_rotate_flag_impl;
void (*reset_rotate_mode)(unsigned char) = reset_rotate_mode_impl;


void run_scaler_fail_handle(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType)
{
	StructDisplayInfo  *p_timing = NULL;
	unsigned char hdmi_unstable_reset_timing = TRUE;//if TRUE, do reset timing info. If false, this is hdr change case
	if(display == SLR_MAIN_DISPLAY) {
		if((inputType == KADP_VSC_INPUTSRC_ADC) || (inputType == KADP_VSC_INPUTSRC_HDMI) || ((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV)))
		{//adc hdmi av case
			reset_ARC_cmd(SLR_MAIN_DISPLAY);
		}
		down(&SetMainOutPutRegion_Semaphore);
		reset_any_srcrect(&main_dispwin_pre);
		up(&SetMainOutPutRegion_Semaphore);
		} else {
#ifdef CONFIG_DUAL_CHANNEL
		down(&SetSubOutPutRegion_Semaphore);
		reset_any_srcrect(&sub_dispwin_pre);
		up(&SetSubOutPutRegion_Semaphore);
#endif
		}
	if(inputType == KADP_VSC_INPUTSRC_ADC)
	{
		if (display == SLR_MAIN_DISPLAY) {
			Reset_YPP_Auto_Phase_SmartFit_Setting();//Reset auto phase related setting
		}
		down(get_adc_detectsemaphore());
		reset_adc_timing_ready();
		p_timing = Get_ADC_Dispinfo();
             if(p_timing) {
        		p_timing->IPH_ACT_WID_PRE = 0;
        		p_timing->IPV_ACT_LEN_PRE = 0;
        		p_timing->IVFreq = 0;
        		p_timing->IHFreq = 0;
        		p_timing->IHTotal = 0;
        		p_timing->IVTotal = 0;
        		p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
             }
		if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
			ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
			Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
			//YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
			ADC_set_detect_flag(TRUE);
		}
		up(get_adc_detectsemaphore());
	}
	else if(inputType == KADP_VSC_INPUTSRC_HDMI)
	{
	    if((display == SLR_MAIN_DISPLAY) && (vsc_force_rerun_main_scaler == TRUE)){
			rtd_pr_vsc_notice("######run scaler again due to condition changed#######\n");
			DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
		}
        	else{
        		if (display == SLR_MAIN_DISPLAY)
        		{
        			set_hdr_semaless_active(FALSE);
        			if(Scaler_InputSrcGetType(display) == _SRC_VO)
        			{
        				if(drvif_mode_check_dma_onlinemeasure_status())
        					hdmi_unstable_reset_timing = FALSE;
        			}
        			else
        			{
        				if(drvif_mode_check_onlinemeasure_status(SLR_MAIN_DISPLAY))
        					hdmi_unstable_reset_timing = FALSE;
        			}
        		}
        		if(hdmi_unstable_reset_timing)
        		{
        			reset_hdmi_timing_ready();
        			vfe_hdmi_drv_handle_on_line_measure_error(0);
        		}
        		vfe_hdmi_drv_set_infoframe_thread_stop_nonseamphore(FALSE);

        		down(get_hdmi_detectsemaphore());
        		if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
        			Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
        			HDMI_set_detect_flag(TRUE);
        		}
        		up(get_hdmi_detectsemaphore());
            }
	}
	else if(inputType == KADP_VSC_INPUTSRC_AVD)
	{
		/*//no need because AVD don't stop detect task
		down(get_vdc_detectsemaphore());
		if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {

			VDC_set_detect_flag(TRUE);
		}
		up(get_vdc_detectsemaphore());
		*/
		reset_avd_timing_ready();
		Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
	} else if(inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC){
		 //[WOSQRTK-7490]update to add Dolby OTT condition @Crixus 20160414
		if((get_vo_open_smooth_toggle_enable(display) || vsc_get_adaptivestream_flag(display) || (get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER)) && (display == SLR_MAIN_DISPLAY)) {//direct vo and VO change
			rtd_pr_vsc_notice("######run scale again vo change for direct vo#######\n");
			DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
		}
		if (display == SLR_MAIN_DISPLAY)
			DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag
	}

        if (display == SLR_MAIN_DISPLAY) {
		drivf_scaler_reset_freerun();
		if(DbgSclrFlgTkr.Main_AutoRunScaler) {
			rtd_pr_vsc_debug("######Need to run scale again#######\n");
			DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
		}
	} else {
		if(DbgSclrFlgTkr.Sub_AutoRunScaler) {
			rtd_pr_vsc_debug("######Need to run scale again#######\n");
			DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
		}
	}
}
#endif
void scaler_set_online_measure(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType)
{
	if (Scaler_InputSrcGetType(display) != _SRC_VO)
	{
		if (Scaler_InputSrcGetType(display) == _SRC_TV)//ATV no need online interrupt
			drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, FALSE);
		else
#ifndef BUILD_QUICK_SHOW
		{
			if(inputType == KADP_VSC_INPUTSRC_ADC)
			{
				if(check_verify_mode_enable())//adc verify mode
					drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), FALSE, FALSE);
				else
					drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
			}
			else
				drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
		}

		if (Scaler_InputSrcGetType(display) == _SRC_YPBPR || Scaler_InputSrcGetType(display) == _SRC_VGA) {
			if(YPbPr_Small_Signal_precheck() == FALSE)
				fw_scaler_adc_nolock_wdg_ctrl(display, TRUE);
		}
#else
            drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
#endif
	}
	else
	{
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if(display == SLR_MAIN_DISPLAY)
		{
			if(inputType == KADP_VSC_INPUTSRC_ADC)
			{
				if(check_verify_mode_enable())
					drvif_mode_dma_onlinemeasure_setting( FALSE, FALSE);//ADC verify mode
				else
					drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//ADC CASE
			}
			else if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV))
				drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//AV CASE
			else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//HDMI CASE
		}
#else
		if((display == SLR_MAIN_DISPLAY) && get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
		{
		drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);

		}


#endif
#ifndef BUILD_QUICK_SHOW
		enable_vodma_empty_gate(Scaler_Get_CurVoInfo_VoVideoPlane(display));//Enable vo gating
		//Scaler_SendDisplayReadyIrc(Scaler_Get_CurVoInfo_VoVideoPlane(display));/*Send display ready to video FW*/
#endif
	}
}
#ifndef BUILD_QUICK_SHOW

void scaler_run_smoothtoggle_proc(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType)
{
    StructSrcRect winSrcRect = {0, 0, 0, 0};
    unsigned int input_len_tmp = 0;
    unsigned int vo_len_tmp = 0;

    down(&SetMainOutPutRegion_Semaphore);
    Scaler_DispWindowSet(main_dispwin);
    up(&SetMainOutPutRegion_Semaphore);
    
    winSrcRect = Scaler_DispWindowGet();

    if (Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_FRAMESYNC)) {//curr source timing go data fs,need vo overscan
    	Convert_Timing_To_fs_Depend_datafs(display);

    if(!Scaler_VOInfoPointer(Get_DisplayMode_Port(SLR_MAIN_DISPLAY)))
        return;
                
    down(get_vo_infosemaphore());
    vo_len_tmp =  Scaler_VOInfoPointer(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))->v_length;
    up(get_vo_infosemaphore());

    down(&SetMainOutPutRegion_Semaphore);
    if (Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_DISP_WIN) {
        StructSrcRect newInput = cal_new_input_base_on_display_win(display);
        input_len_tmp = newInput.src_height;
	} else {
        input_len_tmp = main_input_size.src_height;
    }
    Scaler_DispWindowSet(main_dispwin);
    up(&SetMainOutPutRegion_Semaphore);
    
    	if (input_len_tmp !=vo_len_tmp)
    		zoom_clear_input_output_region_record(display);//clear size to run vo smooth toggle
    	else if(!Get_Val_new_voinfo_flag())//new_voin_flag=0 && vo len no changed, no run smt
              return;
    }
#ifdef SPEEDUP_NEW_SCALER_FLOW
    set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//disable arc ready mask. because we will run smooth toggle below
#endif
    smooth_toggle_preset_info(display);
    Check_smooth_toggle_update_flag(display);
    zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
    rtd_pr_vsc_notice("\r\n####scaler to run smooth toggle!!!####\r\n");
    Check_smooth_toggle_update_flag(display);    
}

unsigned char scaler_decide_smoothtoggle_flow_impl(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType)
{
    if(display == SLR_MAIN_DISPLAY) {
        if((DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) 
            && (get_main_scaler_stop_flag() == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
	{
            if(Scaler_InputSrcGetType(display) == _SRC_VO ){
                if(get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY)) == FALSE) {
                    if (DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting) {
                        //This is for smooth togggle presetting
                        //state_update_disp_info();//Update the active state
                        DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
                        smooth_toggle_preset_info(display);
                    }
                } else {
                    Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
                    state_update_disp_info();
                    DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag
                    return FALSE;
                }
            }
            else {
                if (DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting) {
                    //This is for smooth togggle presetting
                    //state_update_disp_info();//Update the active state
                    DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
                    smooth_toggle_preset_info(display);
                }
            }
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
            if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
                return FALSE;
#endif
            down(&SetMainOutPutRegion_Semaphore);
            if(!compare_rerify_vsc_source_num_result(display))
            {
            	up(&SetMainOutPutRegion_Semaphore);
            	rtd_pr_vsc_notice("### rtk_run_scaler main source already change line:%d###\r\n", __LINE__);
            	return FALSE;
            }
            Scaler_DispWindowSet(main_dispwin);
            up(&SetMainOutPutRegion_Semaphore);

            if (inputType != KADP_VSC_INPUTSRC_VDEC) {
                Set_Val_new_voinfo_flag(TRUE);
                scaler_run_smoothtoggle_proc(display, inputType);
            } else {
                Set_Val_wait_avsync_do_flag(TRUE);
            }
#ifdef SPEEDUP_NEW_SCALER_FLOW
            set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
                if(inputType == KADP_VSC_INPUTSRC_AVD)
                    avd_start_compensation();//compensation h v start
#endif
            down(&SetMainOutPutRegion_Semaphore);
            if(((get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90) || (get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)  || (get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270))||
                    ((Get_Val_ap_roate_mode() ==DIRECT_VO_FRAME_ORIENTATION_ROTATE_90) || (Get_Val_ap_roate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)  || (Get_Val_ap_roate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270))){
                up(&SetMainOutPutRegion_Semaphore);
                return FALSE;
            }else{
                DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
                DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
                DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
                DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
            }
            up(&SetMainOutPutRegion_Semaphore);
            rtd_pr_vsc_notice("\r\n#### scaler to run smooth toggle 1 (%d %d %d %d)####\r\n", main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);   
	}else if ((DbgSclrFlgTkr.rotate_run_scaler_flag||DbgSclrFlgTkr.rotate_muteoff_request_flag) && (get_main_scaler_stop_flag() == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
				rtd_pr_vsc_debug("request mute off run rotate-scaler\n");
				return FALSE;
			}

		}
#if 0//for sub smooth toggle test
#ifdef CONFIG_DUAL_CHANNEL
		else
		{
			down(&SetSubOutPutRegion_Semaphore);
			//if(DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE)
			{
				//Scaler_DispWindowSet(main_dispwin);
				Scaler_SubDispWindowSet(sub_dispwin);
				rtd_pr_vsc_notice("\r\n####send sub smooth toggle info!!!####\r\n");
				//sub always sends memory info to video after scaler
				smooth_toggle_preset_info(display);

				//DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
			}
			if(!compare_rerify_vsc_source_num_result(display))
			{
				up(&SetSubOutPutRegion_Semaphore);
				rtd_pr_vsc_notice("### rtk_run_scaler sub source already change line:%d###\r\n", __LINE__);
				return FALSE;
			}
			if((inputType != KADP_VSC_INPUTSRC_AVD) || (_SRC_TV != get_AVD_Input_Source()))
			{
				if(((DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) || (DbgSclrFlgTkr.Sub_Run_Scaler_flag == TRUE)) && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					if(decide_run_sub_smoothtoggle_case())
					{
						set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
						zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, hal_sub_InputRegionType, sub_input_size, sub_input_timing, sub_dispwin);
						DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
					}
					else
					{
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						state_update_disp_info();
						reset_any_srcrect(&sub_dispwin_pre);
						up(&SetSubOutPutRegion_Semaphore);
						rtd_pr_vsc_notice("####(%d) got new output. need to run scaler again ####\n", __LINE__);
						return FALSE;
					}
				}
			}
			up(&SetSubOutPutRegion_Semaphore);
		}
#endif
#endif
        scaler_check_smoothtoggle_again(display, inputType);

      
	return TRUE;
}

#define WAIT_AVSYNC_FILMMODE_NORMAL_RETURN  0
#define WAIT_AVSYNC_FILMMODE_SCALER_RETURN  1
#define WAIT_AVSYNC_FILMMODE_SEARCH_RETURN  2
unsigned char wait_vo_avsync_filmmode_done(unsigned char display)
{
    int port = Get_DisplayMode_Port(display);
    int vo_timeout = 30;
    int filmDetect_timeout = FILM_DETECT_TO;

    // [K5LG-828] wait for film mode detect done
    while(((get_vo_avsync_flag(port) == FALSE) && vo_timeout)|| ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout))
    {
        vo_timeout -- ;
        filmDetect_timeout--;
        if(display == SLR_MAIN_DISPLAY) 
        {
            if(DbgSclrFlgTkr.Main_Scaler_Stop_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag)
    	        return WAIT_AVSYNC_FILMMODE_SCALER_RETURN;
        }
        else
        {
            if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag || DbgSclrFlgTkr.Sub_Run_Scaler_flag)
                return WAIT_AVSYNC_FILMMODE_SCALER_RETURN;
        }
        if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	    return WAIT_AVSYNC_FILMMODE_SEARCH_RETURN;
        msleep(1);

    }
    rtd_pr_vsc_notice("\r\n### main/sub[%d] vo wait sync & film detect done timeout:%d, %d####\r\n", display,vo_timeout, filmDetect_timeout);
    return WAIT_AVSYNC_FILMMODE_NORMAL_RETURN;
}

unsigned char scaler_check_smoothtoggle_again(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType)
{

#ifdef SPEEDUP_NEW_SCALER_FLOW
		if((inputType == KADP_VSC_INPUTSRC_AVD) && (_SRC_TV != get_AVD_Input_Source()))
		{//av condition
			if(wait_atv_stable_for_bg(display) == FALSE)
			{
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					state_update_disp_info();
					reset_avd_timing_ready();
					Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/

			}

		}
#endif
		else if(inputType == KADP_VSC_INPUTSRC_VDEC)
		{
			if(display == SLR_MAIN_DISPLAY) {
                            wait_vo_avsync_filmmode_done(display);
                            
				if (Get_Val_wait_avsync_do_flag()) {
					Set_Val_wait_avsync_do_flag(FALSE);
                    
					down(&SetMainOutPutRegion_Semaphore);
					DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
                                 DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
					up(&SetMainOutPutRegion_Semaphore);

                                 Set_Val_new_voinfo_flag(TRUE);
					scaler_run_smoothtoggle_proc(display, inputType);
					
				}
				if((DbgSclrFlgTkr.Main_smooth_toggle_set_flag) || (DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off))
				{
				       down(&SetMainOutPutRegion_Semaphore);
                                  DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
                                  DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
                                  up(&SetMainOutPutRegion_Semaphore);
                                  
					Set_Val_new_voinfo_flag(TRUE);
					scaler_run_smoothtoggle_proc(display, inputType);
				}
			}
#ifdef CONFIG_DUAL_CHANNEL
			else
			{
			    wait_vo_avsync_filmmode_done(display);
			}
#endif
		}
		else if(inputType == KADP_VSC_INPUTSRC_HDMI)
		{
			drvif_Hdmi_WatchDogApply(_ENABLE, HDMI_WD_VSC_COND);
		}

              if((display == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_FRAMESYNC) && (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) && (Get_Val_new_voinfo_flag() == FALSE) && (!DbgSclrFlgTkr.Main_smooth_toggle_set_flag) && (!DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag)) {
                scaler_run_smoothtoggle_proc(display, inputType);
	        } 
		return TRUE;
}


unsigned char (*get_displayinfo_proc)(unsigned char, VSC_INPUT_TYPE_T) = get_displayinfo_proc_impl;
unsigned char (*Setup_IMD)(StructDisplayInfo*) = Setup_IMD_impl;
unsigned char (*scaler_decide_smoothtoggle_flow)(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType) = scaler_decide_smoothtoggle_flow_impl;
unsigned char rtk_run_scaler_impl(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType, KADP_VSC_OUTPUT_MODE_T outputMode)
{
	StructDisplayInfo  *p_timing = NULL;
	//StructSrcRect winSrcRect = {0, 0, 0, 0};
	//unsigned char hdmi_unstable_reset_timing = TRUE;//if TRUE, do reset timing info. If false, this is hdr change case
#ifdef CONFIG_RTK_KDRV_PWM
	extern void HAL_VBE_DISP_GetOutputFrameRate(UINT8* pframeRates);
//	UINT8 frameRates;
#endif
	//unsigned char wait_to_after_avsync_do = 0;
	//unsigned char new_voinfo_flag = 0;// to check vo overscan or not
	unsigned char game_mode_wait_timeout = 40;	//400ms
	//unsigned char port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);

	switch(outputMode)
	{
		case KADP_VSC_OUTPUT_DISPLAY_MODE:
		case KADP_VSC_OUTPUT_MEMORY_MODE:
		{
#if(VSC_PROFILE == 1)
			unsigned int before_time = 0;
			unsigned int after_time = 0;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

#if 1//def CONFIG_FORCE_RUN_I3DDMA
			if ((get_force_i3ddma_enable(display) == false)&&((get_rotate_mode(SLR_MAIN_DISPLAY)==get_ori_rotate_mode(SLR_MAIN_DISPLAY))|| (get_ori_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				)
#endif
			{
				drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
			} else {
				  if((get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)) && (get_ori_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)) {
					reset_rotate_mode(display);
				}

				if ((display == SLR_MAIN_DISPLAY)
					&&(!((get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)) && (get_ori_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)))
				) {
					//disable data path s1 clock for snr hw bug
					drvif_color_Set_DRV_SNR_Clock(display, _DISABLE);
				}

				set_zoom_reset_double_state(_DISABLE, display);//always disable double buffer
			}

			decide_rotate_flag(display);

			if(get_displayinfo_proc(display, (VSC_INPUT_TYPE_T)inputType) == FALSE)
			{
				rtd_pr_vsc_notice("######get_displayinfo_proc fail fail fail!!!#######\n");

				run_scaler_fail_handle(display, inputType);
				return FALSE;
			}
			else
			{
				rtd_pr_vsc_info("######get_displayinfo_proc success!!!#######\n");
			}

			if (Setup_IMD(Scaler_DispGetInfoPtr()) == false)
			{
				//reset smoothtoggle state
				if(Get_vo_smoothtoggle_timingchange_flag(display)) {
					unsigned int plane = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(display);
					set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
	                           	smooth_toggle_state_info_rpc(display);
				}
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();//Update the search state

				run_scaler_fail_handle(display, inputType);

				rtd_pr_vsc_notice("######Channel:%d src:%d Setup_IMD fail!!!#######\n", display, inputType);
				return FALSE;
			}
			else
			{
				if(display == SLR_MAIN_DISPLAY)
				{
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ROTATE, FALSE);//disable roate mask
				}
				else
				{
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				}

				if(display == SLR_MAIN_DISPLAY){
					Share_Memory_Set_Scaler_Run_Flag(0);
					if(inputType == KADP_VSC_INPUTSRC_AVD){
						//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
						zoom_clear_input_output_region_record(display);
					}
				}

				//imd_smooth_toggle_check_pre_double_buffer(display);

				rtd_pr_vsc_debug("######Channel:%d src:%d Setup_IMD success!!!#######\n", display, inputType);
                #if 0
				//Need to check MEMC output BG again for first booting
				if(Scaler_MEMC_Get_First_Run_FBG_enable() || Scaler_MEMC_Get_instanboot_resume_Done() || Scaler_MEMC_Get_snashop_resume_Done()){
					Scaler_MEMC_Set_CheckMEMC_Outbg(TRUE);
				}
                #endif
				//state_update_disp_info();//Update the active state
				if (display == SLR_MAIN_DISPLAY) {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre);
					up(&SetMainOutPutRegion_Semaphore);
				} else {
				#ifdef CONFIG_DUAL_CHANNEL
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre);
					up(&SetSubOutPutRegion_Semaphore);
                    #endif
				}

				scaler_set_online_measure(display, inputType);

				if(inputType == KADP_VSC_INPUTSRC_AVD) //Let AVD detect enable
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
					rtd_pr_vsc_info("#####[%s(%d) Scaler_AVD_SetRunSearchState(false)\n",__func__,__LINE__);
					Scaler_AVD_SetRunSearchState(display, false);
				}
#if 0
				if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
					Scaler_MEMC_SetInOutFrameRate();
                }
#endif

			}

#if(VSC_PROFILE == 1)
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_pr_vsc_debug("\nVSC VSC_CONNECT time=%d ms\n",(after_time-before_time));
#endif


			if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV) && (display == SLR_MAIN_DISPLAY))
			{//current smooth toggle is at video fw, so need alwasy to call smooth_toggle_preset_info
				if (DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting){
				//This is for smooth togggle presetting
					DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
					smooth_toggle_preset_info(display);
				}
				return FALSE;//no need to do forcebg. we always to mute off at smooth toggle
			}



			if (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
				//Avoid online interrupt occur
//				if(Scaler_InputSrcGetType(display) == _SRC_TV) {
				//if((Scaler_InputSrcGetType(display) == _SRC_TV)||(Scaler_InputSrcGetType(display) == _SRC_CVBS)) {
                        if(scaler_decide_smoothtoggle_flow(display, inputType) ==  FALSE) {
			        return FALSE;
		            }


				if(display == SLR_SUB_DISPLAY){
#ifdef CONFIG_DUAL_CHANNEL
				       if((DbgSclrFlgTkr.Sub_Output_Set_flag || DbgSclrFlgTkr.Sub_Run_Scaler_flag) && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE)){
						rtd_pr_vsc_notice("####(%d) got new output. need to run scaler again ####\n", __LINE__);
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						state_update_disp_info();
						down(&SetSubOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
				        reset_any_srcrect(&sub_dispwin_pre);
				        up(&SetSubOutPutRegion_Semaphore);

						return FALSE;
					}
#endif
				}
#if 0
				if((KADP_VSC_INPUTSRC_AVD == inputType) && (_SRC_TV == get_AVD_Input_Source()))
				{
					if(fwif_color_GetAutoMAFlag() == 0){
						fwif_color_SetAutoMAFlag(1);
					}

					// Ready to clear forceBG, finish channel change
					DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart = FALSE;
					DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount = 0;
					//rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
					rtd_pr_vsc_debug("Ready to Clear forceBG, set DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart=0\n");
				}
#endif

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				// FixMe, 20170602
				//rtd_pr_vsc_debug("[HDR10] src/st/ret=%d/%d/%d\n", Scaler_InputSrcGetType(display), Scaler_HDR10_Hdmi_Get_Detect_Status(), hdmi_is_drm_info_ready());
#endif
#if 0//def CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
				rtd_pr_vsc_debug("[DolbyVision] src/st/ret=%d/%d/%d\n", Scaler_InputSrcGetType(display), Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status(), Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result());
				if((Scaler_InputSrcGetType(display) == _SRC_HDMI)
					&& (Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status() != SLR_DV_HDMI_DETECT_OFF)
					&& Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
				{
					rtd_pr_vsc_debug("[DolbyVision] Skip disable BG...\n");
				}else if((Scaler_InputSrcGetType(display) == _SRC_VO)
					&& (Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status() == SLR_DV_HDMI_DETECT_FOUND_CRC))
				{
					rtd_pr_vsc_debug("[DolbyVision] disable BG later...\n");
				}else
#endif
#if 0//defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				if((Scaler_InputSrcGetType(display) == _SRC_HDMI)
					&& (Scaler_Hdmi_DM_Get_Status() != SLR_HDMI_DM_CLOSE))
					// FixMe, 20170602
					// && hdmi_is_drm_info_ready())
				{
					rtd_pr_vsc_debug("[HDR10] Skip disable BG...\n");
				}else if((Scaler_InputSrcGetType(display) == _SRC_VO)
					&& (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT))
				{
					rtd_pr_vsc_debug("[DolbyVision] disable BG later...\n");
				}else
#endif
				if (get_HDMI_HDR_mode() == HDR_DOLBY_HDMI && (inputType == KADP_VSC_INPUTSRC_HDMI)
					&& (display == SLR_MAIN_DISPLAY)) {
#ifdef CONFIG_RTK_KDRV_DV
					unsigned char cnt = 200;
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
					while (dolby_adapter_get_g_picModeUpdateFlag() && !get_main_scaler_stop_flag()) {
#else
					while (g_picModeUpdateFlag && !get_main_scaler_stop_flag()) {
#endif
						if (cnt == 0){
							rtd_pr_vsc_notice("Dolby signal not update yet!!\n");
							break;
						}
						cnt--;
						msleep(1);
					}
#endif
				}

				//Race condition isse for HDR HDMI aspect ratio faster changing @Crixus 20160412
				if((inputType == KADP_VSC_INPUTSRC_HDMI) && (get_HDMI_HDR_mode() == HDR_HDR10_HDMI) 
					&& (DbgSclrFlgTkr.Main_Run_Scaler_flag == TRUE) && (get_main_scaler_stop_flag() == FALSE)){
					rtd_pr_vsc_debug("WebOS will run scaler again, do not disable FBG[%s]:%d\n", __FUNCTION__, __LINE__);
				}
				else{
					if(display == SLR_MAIN_DISPLAY) {
						DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag. Means webos can mute off directly
					}
#ifdef CONFIG_I2RND_ENABLE
					//if i2rnd and multivie case, do not disable fbg in sub scaler. @Crixus 20160728
					if((display == SLR_SUB_DISPLAY) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);
						up(get_forcebg_semaphore());
						rtd_pr_vsc_emerg("[I2RND]Do not disable fbg in sub scaler.\n");
					}
					else if((display == SLR_SUB_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_CONNECT)){
						//Eric@0802 if i2rnd dualvo case, do not disable fbg in sub scaler
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);
						up(get_forcebg_semaphore());
						rtd_pr_vsc_emerg("[I2RND] DualVO sub scaler path, do not disable fbg!!\n");
					}
					else
#endif
					{
						if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_HDMI))
						{
							if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()) {
								state_update_disp_info();//current should be search state
								rtd_pr_vsc_notice("\r\n####hdmi hdr case change (%d->%d) before mute off!!!####\r\n",get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
								return TRUE;
							}
						}
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
						if(display == SLR_MAIN_DISPLAY)
						{
							if(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
							{//means not run arc yet
								down(&SetMainOutPutRegion_Semaphore);
								if(!get_main_scaler_stop_flag())
								{
									down(&new_input_output_main_sem);
									reset_pst_sharemem_buffer(SLR_MAIN_DISPLAY);//reset pst buffer data
									set_pst_active_state(SLR_MAIN_DISPLAY, TRUE);//update to enable PST
									up(&new_input_output_main_sem);
								}
								up(&SetMainOutPutRegion_Semaphore);
							}
						}
#endif
						//HDMI game mode scaler flow, disable forcebg after game mode task done.
						if((inputType == KADP_VSC_INPUTSRC_HDMI) && drv_memory_get_game_mode_dynamic()){
							//rtd_pr_vsc_notice("[GAME MODE] HDMI wait game mode ready  %d\n",game_mode_wait_timeout);
							while(game_mode_wait_timeout--){
								if(!Get_Val_game_mode_ignore_cmd_check()){
									break;
								}
								//wait 10ms
								msleep(0);
							}
							//rtd_pr_vsc_notice("[GAME MODE] HDMI wait game mode done  %d\n",game_mode_wait_timeout);
							if(game_mode_wait_timeout == 0)
								rtd_pr_vsc_notice("[GAME MODE] HDMI game mode wait timeout = %d\n",game_mode_wait_timeout);
						}
						trigger_mute_off(display, 1);
						if((drv_memory_get_game_mode_dynamic() == drv_memory_get_game_mode_flag()) && (Get_Val_game_mode_ignore_cmd_check() == _ENABLE))
							game_mode_set_ignore_cmd_check(_DISABLE);
					}
					Scaler_MEMC_fbg_control();


#ifdef CONFIG_SUPPORT_SRC_VGA //for first-timing adjust
					if((inputType == KADP_VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_VGA) && (display == SLR_MAIN_DISPLAY)){

						rtd_pr_vsc_notice("#####[%s(%d)]check_vga_auto_calib_status=%d #####\n", __func__, __LINE__, check_vga_auto_calib_status());
						if(!check_vga_auto_calib_status())
						{
							down(get_adc_adjustsemaphore());
							Scaler_AdjustPCAuto(display);
							up(get_adc_adjustsemaphore());
						}
					}
#endif



				}
#if 0
				if(!drv_memory_get_game_mode_dynamic_flag())	//WOSQRTK-10203 already done in Scaler_disp_setting if game mode (patch for QA stage)
					Scaler_MEMC_SetInOutFrameRate();
#endif

#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
				cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90 - cost_time;
				rtd_pr_vsc_emerg( "\r\n####vsc cost time:%d ms after mute off####\r\n", cost_time);
#endif
				//state_update_disp_info();//Update the active state
				if(Scaler_InputSrcGetType(display) == _SRC_VO) {
					Scaler_SendDisplayReadyIrc(Scaler_Get_CurVoInfo_VoVideoPlane(display));/*Send display ready to video FW*/
				}
			}//active mode end

			if (/*Scaler_InputSrcGetType(display) == _SRC_VO && */DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting && (display == SLR_MAIN_DISPLAY)){
			//This is for smooth togggle presetting
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
			#ifdef CONFIG_I2RND_ENABLE
					if (!((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)))
			#endif
				smooth_toggle_preset_info(display);
			}
			else if(Scaler_InputSrcGetType(display) == _SRC_VO && (display == SLR_SUB_DISPLAY))
			{
#ifdef CONFIG_DUAL_CHANNEL
				smooth_toggle_preset_info(display);
				down(&SetSubOutPutRegion_Semaphore);
				if(!DbgSclrFlgTkr.Sub_Scaler_Stop_flag && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					down(&new_input_output_sub_sem);
					reset_pst_sharemem_buffer(SLR_SUB_DISPLAY);//reset pst buffer data
					set_pst_active_state(SLR_SUB_DISPLAY, FALSE);//update to enable PST
					up(&new_input_output_sub_sem);
				}
				up(&SetSubOutPutRegion_Semaphore);
#endif
			}

/////////////////////////////////////////
			break;
		}
		case KADP_VSC_OUTPUT_VENC_MODE:
		{
			if(Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT) == 0)
			{
				rtd_pr_vsc_debug("\r\n####Go VencMode Src:%d!!!#####\r\n", VencModeInputInfo.type);
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();
				rtd_pr_vsc_debug("\r\n######set search state#####\r\n");
			}
			else
			{
				rtd_pr_vsc_debug("######get_displayinfo_proc success!!!#######\n");
			}

#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
 			if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){//capture progressive video data

			}
			else{
				drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
			}

			drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif
#else
			drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif



			if(get_displayinfo_proc(display, (VSC_INPUT_TYPE_T)inputType)== FALSE)
			{
				//rtd_pr_vsc_debug("######get_displayinfo_proc fail fail fail!!!#######\n");
				return FALSE;
			}

			if (Setup_IMD(Scaler_DispGetInfoPtr()) == false)
			{
				if(inputType == KADP_VSC_INPUTSRC_ADC)
				{
                                    down(get_adc_detectsemaphore());
                                    reset_adc_timing_ready();
                                    p_timing = Get_ADC_Dispinfo();
                                    if(!p_timing)
                                        return FALSE;
                                    p_timing->IPH_ACT_WID_PRE = 0;
                                    p_timing->IPV_ACT_LEN_PRE = 0;
                                    p_timing->IVFreq = 0;
                                    p_timing->IHFreq = 0;
                                    p_timing->IHTotal = 0;
                                    p_timing->IVTotal = 0;
                                    p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
                                    if(get_ADC_Global_Status() == SRC_CONNECT_DONE) ADC_set_detect_flag(TRUE);
                                    up(get_adc_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
				}
				rtd_pr_vsc_emerg("######VSC_OUTPUT_VENC_MODE Setup_IMD fail fail!!!#######\n");
				return FALSE;
			}
			else
			{
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
				if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)){
					rtd_pr_vsc_emerg("apvr flow finish, so didnot re-run sub path\n");
					break;
				}
#endif
#endif
				rtd_pr_vsc_emerg("######VSC_OUTPUT_VENC_MODE Channel:%d src:%d Setup_IMD success!!!#######\n", display, inputType);
				//imd_smooth_toggle_check_pre_double_buffer(display);
				//state_update_disp_info();//Update the active state

				if(inputType == KADP_VSC_INPUTSRC_AVD) //Let AVD detect enable
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
					rtd_pr_vsc_info("#####[%s(%d)] Scaler_AVD_SetRunSearchState(false)\n",__func__,__LINE__);
					Scaler_AVD_SetRunSearchState(display, false);
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
					//I2rnd sub=>vo RPC
					if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){
						vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
						rtd_pr_vsc_emerg("[frank]APVR step 2@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
						Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
						i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
						drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, inputType);
						drivf_Sub_I2rnd_SetupVODMA();
						//i2rnd_debug();
						rtd_pr_vsc_emerg("[frank]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
					}
#endif
#endif
				}

				if (Scaler_InputSrcGetType(display) != _SRC_VO)
				{
					if (Scaler_InputSrcGetType(display) == _SRC_TV)//ATV no need online interrupt
						drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, FALSE);
					else
						drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
				}
			}
			break;
		}
            case KADP_VSC_OUTPUT_AVE_MODE:
            case KADP_VSC_OUTPUT_MAXN:
                break;

		default:

			break;
	}
	return TRUE;
}
unsigned char (*rtk_run_scaler)(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType, KADP_VSC_OUTPUT_MODE_T outputMode) = rtk_run_scaler_impl;

void set_frc_style_input_fast_than_display(bool enable)
{
	unsigned char frc_style = (enable) ? 1 : 0;

	mdomain_disp_ddr_mainsubctrl_RBUS disp_mainsubctrl;
	mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl;

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	if(ddr_mainctrl.main_frc_style == frc_style)
		return;//no need to do

	disp_mainsubctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	disp_mainsubctrl.disp1_double_enable = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, disp_mainsubctrl.regValue);

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	ddr_mainctrl.main_frc_style = frc_style;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, ddr_mainctrl.regValue);

	disp_mainsubctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	disp_mainsubctrl.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, disp_mainsubctrl.regValue);
}

unsigned char get_frc_style_input_fast_than_display(void)
{
	mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl;

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	return ddr_mainctrl.main_frc_style;
}

unsigned char scaler_get_current_framesync_mode(unsigned char display)
{
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	mdomain_disp_ddr_subctrl_RBUS mdomain_disp_ddr_subctrl_reg;

	if(display==SLR_MAIN_DISPLAY){
		mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
		if(mdomain_disp_ddr_mainctrl_reg.main_source_sel == 0x3)
			return TRUE; //data fs
	}
	else if (display==SLR_SUB_DISPLAY){
		mdomain_disp_ddr_subctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_SubCtrl_reg);
		if(mdomain_disp_ddr_subctrl_reg.sub_source_sel == 0x3)
			return TRUE; //data fs
	}

	return FALSE; ////data frc
}

unsigned char rtk_check_signal(unsigned char display)
{/*This is for source check signal stable or not. Must be _MODE_STATE_ACTIVE*/
	unsigned char result;
	KADP_VSC_OUTPUT_MODE_T outputMode;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;
#ifndef UT_flag
	unsigned int inputVfreq = 0;
#endif
/*
	unsigned char frame_idicator=0;
	unsigned char b_run_frame_check=0;
	ppoverlay_dtg_frame_cnt1_RBUS dtg_frame_cnt1_reg;
	ppoverlay_new_meas1_linecnt_real_RBUS new_meas1_linecnt_real_reg;
	vgip_vgip_chn1_lc_RBUS vgip_chn1_lc_reg;
	unsigned int count2 = 0x3fffff;
	unsigned int ch1_line_cnt_lower = 0;
	unsigned int ch1_line_cnt_upper = 0;

	//check fix last line lock status @Crixus 20151219
	ppoverlay_fix_last_line_mode_lock_status_RBUS fix_last_line_mode_lock_status_reg;
//	display_timing_ctrl1_RBUS display_timing_ctrl1_reg;
	extern unsigned char modestate_decide_display_timing(void);
	static UINT8 checkStableCnt=0;
*/
	unsigned char plane = 0;//get_vo_plane_flag(display);
    unsigned char hdmi_check_mode_err = 0;
    unsigned char cur_vrr_status = 0;
    unsigned char cur_freesync_status = 0;
#ifdef _VBY1_TO_HDMI_DIRTY_FIX
	static unsigned char bfirst_boot = 1;
#endif


	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = DisplayModeInputInfo.type;
			inputPort = DisplayModeInputInfo.resourceIndex;
		}
		else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
		}
		else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = MemoryModeInputInfo.type;
			inputPort = MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}

#ifdef _VBY1_TO_HDMI_DIRTY_FIX
		if(bfirst_boot == 1){
			scaler_dtg_reconfig(); //vtotal set 0x8ca during boot up, recover to 0x8c9
			bfirst_boot	= 0;
		}
#endif
		//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//Remove by Will
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}
		//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);//Remove by Will
	}
#endif

#ifdef CONFIG_I2RND_ENABLE
if((VSC_OUTPUT_VENC_MODE_FLAG == TRUE) && (Scaler_I2rnd_get_enable())){
	//Eric@0809
	rtd_pr_vsc_emerg( "[OUTPUT_VENC_MODE] timing framesync!\n");
	modestate_set_fll_running_flag(_DISABLE);
	if(modestate_decide_display_timing() != DISPLAY_MODE_FRAME_SYNC){
		if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
            fwif_color_safe_od_enable(0);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			fwif_color_safe_od_enable(1);
		}
	}
	VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
}
#endif

#if 0
	down(get_scaler_fll_running_semaphore());
	if((display == SLR_MAIN_DISPLAY) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
		if(modestate_get_fll_running_flag()){
			if(checkStableCnt> 2){
				if((modestate_decide_display_timing() == DISPLAY_MODE_NEW_FLL_MODE) &&
					(drvif_scaler_get_display_mode() != DISPLAY_MODE_NEW_FLL_MODE)){
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					//add check frame cnt and add 1 frame delay @Crixus 20151221
					if((inputType == KADP_VSC_INPUTSRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)){
						//if HDMI source, not to run check mode until sync OK @Crixus 20151229
						DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 1;
					}
					if(Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) > 1){
						b_run_frame_check = 1;
						frame_idicator = Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO)-1;
						switch (Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR)) {
							case _MODE_480I:
								ch1_line_cnt_lower = MODE_480I_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_480I_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_480P:
								ch1_line_cnt_lower = MODE_480P_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_480P_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_576I:
								ch1_line_cnt_lower = MODE_576I_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_576I_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_576P:
								ch1_line_cnt_lower = MODE_576P_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_576P_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_720P50:
								ch1_line_cnt_lower = MODE_720P50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_720P50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_720P60:
								ch1_line_cnt_lower = MODE_720P60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_720P60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080I25:// Mode 100: YPbPr 1920x1080ix50HZ (802R)
								ch1_line_cnt_lower = MODE_1080I50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080I50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080I30:// Mode 101: YPbPr 1920x1080ix60HZ (802R)
								ch1_line_cnt_lower = MODE_1080I60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080I60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P50:
								ch1_line_cnt_lower = MODE_1080P50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P60:
								ch1_line_cnt_lower = MODE_1080P60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P23:
							case _MODE_1080P24:
							case _MODE_1080P25:
								ch1_line_cnt_lower = MODE_1080P24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P29:
							case _MODE_1080P30:
								//[KTASK-3997]Modify 1080p30Hz line count setting for 60Hz panel @Crixus 20160527
								if((Get_DISPLAY_REFRESH_RATE() == 60) && (Get_DISPLAY_PANEL_CUSTOM_INDEX() == VBY_ONE_PANEL_LG_4K2K_600M_1S_8L)){
									ch1_line_cnt_lower = MODE_1080P30_FRAME_DELAY_LOWER_BOUNDARY_60HZ_PANEL;
									ch1_line_cnt_upper = MODE_1080P30_FRAME_DELAY_UPPER_BOUNDARY_60HZ_PANEL;
								}
								else{
									ch1_line_cnt_lower = MODE_1080P30_FRAME_DELAY_LOWER_BOUNDARY;
									ch1_line_cnt_upper = MODE_1080P30_FRAME_DELAY_UPPER_BOUNDARY;
								}
								break;
							case _MODE_4k2kP24:
								ch1_line_cnt_lower = MODE_4K2K24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP25:
								ch1_line_cnt_lower = MODE_4K2K24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP30:
								ch1_line_cnt_lower = MODE_4K2K30_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K30_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP50:
								ch1_line_cnt_lower = MODE_4K2K50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP60:
								ch1_line_cnt_lower = MODE_4K2K60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K60_FRAME_DELAY_UPPER_BOUNDARY;
								break;

							default:
								ch1_line_cnt_lower = 0;
								ch1_line_cnt_upper = (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN) * 1 / 4);
							break;
						}
						//rtd_pr_vsc_emerg("\n SLR_INPUT_MODE_CURR = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						//rtd_pr_vsc_emerg("\n ch1_line_cnt_lower = %d, ch1_line_cnt_upper = %d\n", ch1_line_cnt_lower, ch1_line_cnt_upper);
					}
					if(b_run_frame_check == 1){
						dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
						if(dtg_frame_cnt1_reg.uzudtg_input_frame_cnt == (frame_idicator-1)){
							dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
							//make sure that we can have a full porch apply timing change settings
							while((dtg_frame_cnt1_reg.uzudtg_input_frame_cnt != frame_idicator)&& --count2){
								dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
							}
							vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
							if((vgip_chn1_lc_reg.ch1_line_cnt >= ch1_line_cnt_lower) && (vgip_chn1_lc_reg.ch1_line_cnt <= ch1_line_cnt_upper)){
								//change to FLL
								rtd_pr_vsc_debug("### set fll new mode 1.###\n");
								framesync_lastlinefinetune_at_new_mode();
								modestate_set_display_timing(0);
								modestate_set_fll_running_flag(FALSE);
								checkStableCnt=0;
								if(inputType == KADP_VSC_INPUTSRC_HDMI){
									DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 0;
								}
								//rtd_pr_vsc_emerg("\n vgip_chn1_lc_reg.ch1_line_cnt = %d\n", vgip_chn1_lc_reg.ch1_line_cnt);
							}
							if(count2 == 0)
								rtd_pr_vsc_notice("count timeout !!!\n");
						}
					}
					else{
						new_meas1_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas1_linecnt_real_reg);
						if(new_meas1_linecnt_real_reg.memcdtg_line_cnt_rt < 200){
							//change to FLL
							rtd_pr_vsc_debug("### set fll new mode 2.###\n");
							framesync_lastlinefinetune_at_new_mode();
							modestate_set_display_timing(0);
							modestate_set_fll_running_flag(FALSE);
							checkStableCnt=0;
						}
					}
					up(&VSC_Semaphore);
				}
			}else{
				checkStableCnt++;
			}
		}else{

			if(vbe_disp_get_adaptivestream_fs_mode() == 1){
                drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			}
			if(Get_DISPLAY_PANEL_OLED_TYPE()==TRUE){
				if((drv_memory_get_game_mode_dynamic() == _ENABLE)&&(drv_memory_get_game_mode() == TRUE)){
                    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
				}
			}
			checkStableCnt = 0;
			//if source is table, change to false
			if(DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 1){
				DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 0;
			}
		}


		fix_last_line_mode_lock_status_reg.regValue = IoReg_Read32(PPOVERLAY_fix_last_line_mode_lock_status_reg);
		fix_last_line_mode_lock_status_reg.lock_th = 0x800;
		IoReg_Write32(PPOVERLAY_fix_last_line_mode_lock_status_reg, fix_last_line_mode_lock_status_reg.regValue);
#if 0//mark redundaent code
		display_timing_ctrl1_reg.regValue = IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg);
		if((display_timing_ctrl1_reg.disp_fix_last_line == 2) && (fix_last_line_mode_lock_status_reg.t_s != 0)){
			//double buffer D0
			ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			double_buffer_ctrl_reg.dreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);

			display_timing_ctrl1_reg.disp_fix_last_line = 0;
			IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, display_timing_ctrl1_reg.regValue);

			//double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			//double_buffer_ctrl_reg.dreg_dbuf_set = 1;
			//IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);

			//display_timing_ctrl1_reg.disp_fix_last_line = 2;
			//IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, display_timing_ctrl1_reg.regValue);
			rtd_pr_vsc_notice("FLL re-sync!!\n");
			modestate_set_fll_running_flag(TRUE);

			//double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			//double_buffer_ctrl_reg.dreg_dbuf_set = 1;
			//IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
		}
#endif
	}else{
		checkStableCnt = 0;
	}
	up(get_scaler_fll_running_semaphore());
#endif

	//check abnormal dvs flag
	drvif_scaler_check_abnormal_dvs_flag();

	// check IVS over threshold error
	// RL6557-448 add ivs over threshold test function
	//drvif_scaler_check_ivs_over_threshold(TRUE);

	//check onlinemeasure flag
	if(Scaler_InputSrcGetMainChType() == _SRC_VO){
		drvif_scaler_check_main_onlinemeasure_flag();
	}

	if (inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC) {
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)//If get_vo_change_flag() == TRUE, VO info change
		{
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)
		//	static unsigned int hdrCrcErrCnt = 0;
#endif
			plane = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);//Avoid to print port error
			down(get_vo_infosemaphore());
			if(get_vo_change_flag(inputPort) == TRUE)
			{
				up(get_vo_infosemaphore());
				if (Get_vo_smoothtoggle_timingchange_flag(display)) {
	               if(get_vo_run_smooth_toggle_enable(display)) {
#if 0
	                   if (get_vo_imd_disable(display)) {
	                       set_vo_change_flag(inputPort, FALSE);
	                       set_vo_imd_disable(_DISABLE,display);
						   inputVfreq = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ);
   	                       rtd_pr_vsc_debug("\n +++ adaptive stream before vfreq:%d\n", inputVfreq);
						   Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
   	                       rtd_pr_vsc_debug("\n +++ adaptive stream after vfreq:%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ));
						   if(inputVfreq!=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ)){
							   scaler_disp_smooth_variable_setting();
						   }
	                       rtd_pr_vsc_debug("\n smooth toggle timing change don't need to go scaler\n");
	                       return TRUE;
	                   }
#endif
	               } else {
                       if (get_vo_smoothtoggle_state(display) == SLR_SMOOTH_TOGGLE_ACTIVE) {
                           //vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(display), display);
                           set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
                           smooth_toggle_state_info_rpc(display);
                           rtd_pr_vsc_debug("set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_INIT\n");
                       }
	               }
				}
				rtd_pr_vsc_debug("\r\n####check_signal vo change active to search####\r\n");

				if(display == SLR_MAIN_DISPLAY) {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetMainOutPutRegion_Semaphore);
				} else {
#ifdef CONFIG_DUAL_CHANNEL
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetSubOutPutRegion_Semaphore);
#endif
				}
				Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);    //WOSQRTK-3464
				state_update_disp_info();

				return TRUE;
			} else {
				up(get_vo_infosemaphore());
			}

			if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC) == FALSE) || (drvif_framesync_detect()))//If Framesync case, we just check drvif_framesync_detect
			{
				down(get_vo_infosemaphore());
				if (get_vo_run_smooth_toggle_enable(display) && get_vo_imd_disable(display)) {
					set_vo_imd_disable(_DISABLE,display);
#ifndef UT_flag
					inputVfreq = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ);
					rtd_pr_vsc_debug("\n +++ adaptive stream before vfreq:%d\n", inputVfreq);
#endif
					Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
					rtd_pr_vsc_debug("\n +++ adaptive stream after vfreq:%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ));
					up(get_vo_infosemaphore());
					//add frame rate changing smooth toggle flow @Crixus 20151215
					if((get_vo_frameratechange_enable(display) == 1) && (!vsc_get_adaptivestream_flag(display)) && (scaler_get_current_framesync_mode(display) == 0)){
						//before set DTG frame rate, it has to wait for smooth toggle done. @Crixus 20151215
						down(&SetMainOutPutRegion_Semaphore);
						Check_smooth_toggle_update_flag(display);
						scaler_disp_smooth_variable_settingByDisp(0);
						up(&SetMainOutPutRegion_Semaphore);
						set_frc_style_input_fast_than_display(FALSE);
					}
					drvif_scaler_wclr_abnormal_dvs_long_short();
					rtd_pr_vsc_notice("\n timing:go smooth toggle\n");
				}
				else{
					up(get_vo_infosemaphore());
				}

				if(Get_vo_smoothtoggle_timingchange_flag(display))  //direct vo smooth toggle
				{
					if(get_vo_run_smooth_toggle_enable(display))  //direct_vo :curr display size changed  go smooth toggle
					{
					}
					else
					{
						if (get_reset_smooth_toggle_state(display)) {
							//vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(display), display);
							smooth_toggle_state_info_rpc(display);
							set_reset_smooth_toggle_state(_DISABLE,display);
							rtd_pr_vsc_debug("set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_ACTIVE\n");
						}
					}
				}
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
				if((vsc_get_adaptivestream_flag(display)||scaler_vsc_get_force_pst_lowdelay_mode())&&(scaler_vsc_get_adaptive_pst_lowdelay_mode()==TRUE)&&(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)){
					ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
					ppoverlay_uzudtg_fractional_fsync_RBUS uzudtg_fractional_fsync_reg;
					memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
					if(memc_mux_ctrl_reg.memc_outmux_sel == 1){
						uzudtg_fractional_fsync_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_fractional_fsync_reg);
						rtd_pr_vsc_notice("[%s][line:%d] uzudtg_fractional_fsync_reg.regValue:%x\r\n", __FUNCTION__, __LINE__, uzudtg_fractional_fsync_reg.regValue);
						if((uzudtg_fractional_fsync_reg.uzudtg_multiple_vsync == 0) && (uzudtg_fractional_fsync_reg.uzudtg_remove_half_ivs_mode == 0)){
							rtd_pr_vsc_notice("[%s][line:%d] Scaler_MEMC_Bypass_On\r\n", __FUNCTION__, __LINE__);
							Scaler_MEMC_Bypass_On(1);
						}
					}
				}
#endif
				return TRUE;
			}
			else
			{
				rtd_pr_vsc_notice("####VO frame sync error!!!######\r\n");
				mute_control(display, TRUE);/*Auto BG. Add by Will*/

				down(get_vo_infosemaphore());
				if(get_vo_change_flag(inputPort) == TRUE)
				{
					up(get_vo_infosemaphore());
					if(display == SLR_MAIN_DISPLAY) {
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetMainOutPutRegion_Semaphore);
					} else {
					#ifdef CONFIG_DUAL_CHANNEL
						down(&SetSubOutPutRegion_Semaphore);
						reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetSubOutPutRegion_Semaphore);
                        #endif
					}
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					state_update_disp_info();
					return TRUE;
				}
				Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
				if (get_vo_run_smooth_toggle_enable(display) && get_vo_imd_disable(display)) {
					set_vo_imd_disable(_DISABLE,display);
				}
				up(get_vo_infosemaphore());
				Check_smooth_toggle_update_flag(display);
				if(Get_vo_smoothtoggle_timingchange_flag(display))  //framesync fail need vo smooth toggle reset to init
				{
					set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
					smooth_toggle_state_info_rpc(display);
				}
			}
		}
		else//if(Scaler_DispGetInputInfo(SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
					return TRUE;
		}
	} else {
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
			return TRUE;/* State is not _MODE_STATE_ACTIVE. No need to check signal*/

		//if HDMI source, not to run check mode until sync OK @Crixus 20151229
		//USER:LewisLee DATE:2016/02/21
		//for zhaodong_yin suggest
		//to fix HDR mode, Scaler_InputSrcGetType() will change to _SRC_VO
		//it need change to Get_DisplayMode_Src()
//		if((Scaler_InputSrcGetType(display) == _SRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)) {
		if((Get_DisplayMode_Src(display) == VSC_INPUTSRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)) {
            if(drvif_Hdmi_CheckMode() == FALSE)
                hdmi_check_mode_err = 1;
            else
            {
                cur_vrr_status = drvif_Hdmi_GetVRREnable();
                if(vbe_disp_get_VRR_timingMode_flag() != cur_vrr_status)
                    hdmi_check_mode_err = 2;
                else
                {
                    cur_freesync_status = drvif_Hdmi_GetAMDFreeSyncEnable();
                    if(vbe_disp_get_freesync_mode_flag() != cur_freesync_status)
                        hdmi_check_mode_err = 3;
                }
            }
			if(hdmi_check_mode_err)
			{
				set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				mute_control(display, TRUE);/*Auto BG*/

				rtd_pr_vsc_debug("\n drvif_Hdmi_CheckMode ERROR\n");

  				drvif_mode_disableonlinemeasure(display);//Disable online measure
				drvif_mode_onlinemeasure_setting(display, _SRC_HDMI, FALSE, FALSE);//Disable online measure watchdog and interrupt
				if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
					rtd_pr_vsc_debug("\n HDMI Interrupt already happen\n");
					return TRUE;
				}
				Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				if (display == SLR_MAIN_DISPLAY) {
					drivf_scaler_reset_freerun();
				}
				reset_hdmi_timing_ready();
 				vfe_hdmi_drv_handle_on_line_measure_error(0);
				down(get_hdmi_detectsemaphore());
				if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
					Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
					HDMI_set_detect_flag(TRUE);
				}
				up(get_hdmi_detectsemaphore());
                if(hdmi_check_mode_err == 1)
                {
                   rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by drvif_Hdmi_CheckMode error\n");
                }
                else if(hdmi_check_mode_err == 2)
                {
                   rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by VRR (%d %d) change\n", vbe_disp_get_VRR_timingMode_flag(), cur_vrr_status);
                }
                else if(hdmi_check_mode_err == 3)
                {
                   rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by freesync (%d %d) change\n",vbe_disp_get_freesync_mode_flag(), cur_freesync_status);
                }
				return false;
			}
		}
		return TRUE; /* Not VO source no need to auto run scaler*/
	}
    check_bsp_error_event(Abnormal_Run_Scaler, (vsc_scaler_tsk_pending != _low_power_tsk_no_pending) ? TRUE : FALSE);//Abnormal case to run scaler recover
	down(&VSC_Semaphore);
	Scaler_SetCurrentDispInfo(display);
	result = rtk_run_scaler(display, inputType, outputMode); /*This is for VO frame sync error*/
	Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
	up(&VSC_Semaphore);
	return result;

}


static int GamemodeSaveI3ddmaGetcurMode;

int Get_GamemodeSaveI3ddmaGetcurMode(void)
{
	return GamemodeSaveI3ddmaGetcurMode;
}

void Set_GamemodeSaveI3ddmaGetcurMode(int value)
{
	GamemodeSaveI3ddmaGetcurMode = value;
}

unsigned char rtk_output_connect(unsigned char display)
{
	KADP_VSC_OUTPUT_MODE_T outputMode = KADP_VSC_OUTPUT_MAXN;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;
	unsigned char result;
	unsigned short mode_id;
	if(get_scaler_stop_flag(display) == TRUE)
		  return false;

	//rtd_pr_vsc_emerg("[crixus]@@@@@[%s][%d]\n", __FUNCTION__, __LINE__);
#ifdef CONFIG_I2RND_ENABLE
	if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) &&(vsc_i2rnd_sub_output_mode ==KADP_VSC_OUTPUT_VENC_MODE)){
		//save sub info
		VencModeInputInfo.type = vsc_i2rnd_sub_input_type;
		VencModeInputInfo.resourceIndex = vsc_i2rnd_sub_input_port;
	}

#endif
	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = DisplayModeInputInfo.type;
			inputPort = DisplayModeInputInfo.resourceIndex;
		}
		else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}

		Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);

		if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_MAIN_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort) == FALSE) {
				rtd_pr_vsc_notice("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				return false;
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}

		Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);
		if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_SUB_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort) == FALSE) {
				rtd_pr_vsc_notice("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.sub_opensourceID = _UNKNOWN_INPUT;
				return false;
			}
		}
	}
	else
		return false;
#endif
#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC || get_line_alternative_3d_mode_enable() == TRUE
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
		#endif
		|| (get_force_i3ddma_enable(display) == true)
#ifdef CONFIG_I2RND_ENABLE
		|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))//VO source
#endif
		) && !((display == SLR_MAIN_DISPLAY) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)|| (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == true))))
#else
	if(inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC || get_line_alternative_3d_mode_enable() == TRUE
				|| get_force_i3ddma_enable(display) == true
		)//VO source
#endif
	{
		if((inputType == KADP_VSC_INPUTSRC_AVD) && (display == SLR_MAIN_DISPLAY))
		{
			mode_id = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR);

		}
		down(get_vo_infosemaphore());
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			|| get_force_i3ddma_enable(display) == true
#ifdef CONFIG_I2RND_ENABLE
			|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) && (vsc_i2rnd_sub_output_mode == KADP_VSC_OUTPUT_DISPLAY_MODE))
#endif
			)
#else
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			)
#endif
		{
#ifdef CONFIG_HDR_SDR_SEAMLESS
			if((display == SLR_MAIN_DISPLAY) && (inputType != KADP_VSC_INPUTSRC_VDEC) && (inputType != KADP_VSC_INPUTSRC_JPEG))
#endif

			inputPort = 0; //hdmi hdr always set vo port0:
		}
#ifdef CONFIG_I2RND_ENABLE
		if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_output_mode == KADP_VSC_OUTPUT_DISPLAY_MODE)
			&& ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) ||(vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
		){
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;; //pip sub use planeV2
			rtd_pr_vsc_emerg("[crixus]sub re-run main scaler, need to use sub inputPort = %d\n", inputPort);
		}
#endif
		if(display == SLR_SUB_DISPLAY)
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		
		set_vo_change_flag(inputPort, FALSE);
	#if 0
		if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF || get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM || get_vo_3d_mode() == VO_3D_FRAME_PACKING)
		{
			drvif_scalerdisplay_force_bg((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), 1);//enable force BG for vo 3d auto detect
		}
	#endif
		if ((Get_sub_from_DI_mux_path()) && (display == SLR_SUB_DISPLAY)) {
			//tmp code
			Scaler_SET_VSCSubDispinfo_Withmain();
		} else {
			Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
		}
        if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_VDEC))
        {
            unsigned char vdec_type = VSC_VDEC_CASE_UNKNOWN;
            switch(Get_Val_vodma1_vdec_source())
            {
                case VDEC_SRC_PLAYBACK:      /* playback source */
                    if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
                        vdec_type = VSC_VDEC_CASE_CP;
                    else
                        vdec_type = VSC_VDEC_CASE_PLAYBACK;
                break;

                case VDEC_SRC_DTV:      /* DTV source */
                    vdec_type = VSC_VDEC_CASE_DTV;
                break;

                case VDEC_SRC_CP:      /* CP source */
                    vdec_type = VSC_VDEC_CASE_CP;
                break;

                case VDEC_SRC_ATSC3:      /* ATSC3.0 source */
                    vdec_type = VSC_VDEC_CASE_ATSC3;
                break;

                case VDEC_SRC_JP4K:      /* JP4K source */
                    vdec_type = VSC_VDEC_CASE_JP4k;
                break;

                case VDEC_SRC_AIRPLAY:      /* airplay source */
                    vdec_type = VSC_VDEC_CASE_AIRPLAY;
                break;

                case VDEC_SRC_MIRACAST:      /* miracast source */
                    vdec_type = VSC_VDEC_CASE_MIRACAST;
                break;

                default:
                    return false;
                break;
            }
            Set_Val_scaler_vdec_source_type(vdec_type);//update vdec source type
        }
		up(get_vo_infosemaphore());

		if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0) && (display == SLR_MAIN_DISPLAY))
		{
			//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE) >> 1);
		}
		if (vsc_timinginfo_check() == FALSE) {
			rtd_pr_vsc_err("\n####VO info is zero####\n");
			if (display == SLR_MAIN_DISPLAY) {
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				up(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset Main_during_scalerflag
			} else {
#ifdef CONFIG_DUAL_CHANNEL
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
#endif
			}
			return false;
		}
		if(inputType == KADP_VSC_INPUTSRC_VDEC)
		{
			Check_smooth_toggle_update_flag(display);
		}
		if((inputType == KADP_VSC_INPUTSRC_AVD) && (display == SLR_MAIN_DISPLAY))
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR, mode_id);
	}
	else
	{

	}
	vbe_disp_set_pre_VRR_ALLM_flag(0);	//reset pre vrr allm flag
#ifdef CONFIG_I2RND_ENABLE
	//Update sub source i2r condition @Crixus 20170928
	if(Get_Live_zoom_mode() == LIVE_ZOOM_OFF){
		if(inputType == KADP_VSC_INPUTSRC_VDEC){
			//first time or sub scaler re-run, need to check condition
			//Eric@20170315 only sub display mode go i2rnd flow
			if((display == SLR_SUB_DISPLAY) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))){
				vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_CONNECT;
				//save sub info
				vsc_i2rnd_sub_output_mode= outputMode;
				vsc_i2rnd_sub_input_type = inputType;
				vsc_i2rnd_sub_input_port = Sub_MemoryModeInputInfo.resourceIndex;
				rtd_pr_vsc_emerg( "[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_SUB_CONNECT@@@@@@@@@@\n");
			}
		}
		else{
			//i2rnd sub=>vodma checking @Crixus 2160721
			//Eric@20180315 if sub venc mode , do not go i2rnd flow
			if((display == SLR_SUB_DISPLAY) && (DbgSclrFlgTkr.Sub_OutputVencMode == FALSE) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH))){
				vsc_i2rnd_sub_stage = I2RND_STAGE_DETECT_SOURCE;
				//save sub info
				vsc_i2rnd_sub_output_mode= outputMode;
				vsc_i2rnd_sub_input_type = inputType;
				vsc_i2rnd_sub_input_port = Sub_MemoryModeInputInfo.resourceIndex;
				rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_DETECT_SOURCE\n");
			}
		}
	}

	//I2run case, check sub over 2k1k do not run i2run @Crixus 20170906
	if(display == SLR_SUB_DISPLAY)
		Scaler_I2rnd_condition_check(DbgSclrFlgTkr.OuputDisplayMode, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) , Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_emerg("[frank]rtk_output_connect %d,%d,%d\n",display,inputType,outputMode);
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
	if((Scaler_I2rnd_b05_get_enable() == _ENABLE) && (inputType == KADP_VSC_INPUTSRC_VDEC)){
		if(display == SLR_MAIN_DISPLAY)
			drvif_scaler_i2rnd_b05_vodma_setting(SLR_MAIN_DISPLAY);
	}
#endif

	//reset film parameter
	film_mode_parameter.enable = 0;
	film_mode_parameter.type= 0;
	film_mode_parameter.v_freq = 0;
	set_ori_voclk_ratio_num(0);
	result = rtk_run_scaler(display, inputType, outputMode);
	if (result == TRUE)/*checking vsc freeze flag*/
	{
		if (display == SLR_MAIN_DISPLAY) {
			if (DbgSclrFlgTkr.mainVscFreezeFlag) {
				rtd_pr_vsc_emerg( "\r\n####func:%s line:%d####\r\n", __FUNCTION__, __LINE__);
				Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.mainVscFreezeFlag);
			}
		}
		if (display == SLR_SUB_DISPLAY) {
			if (DbgSclrFlgTkr.subVscFreezeFlag) {
				Scaler_SetFreeze(SLR_SUB_DISPLAY, DbgSclrFlgTkr.subVscFreezeFlag);
			}
		}
	}

	return result;

}
#ifndef UT_flag
void scaler_i2rnd_run_main(void){
	//rtd_pr_vsc_emerg("[crixus]@@@@@[%s][%d]\n", __FUNCTION__, __LINE__);
	rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
}
#endif

extern unsigned char Scaler_AVD_GetDetectStage(void);
extern unsigned char g_ucColorOK;

void wait_buffer_ready_after_SetupIMD(unsigned char num)
{//this api is for wait buffer ready after Setup_IMD
//num:How many frames to wait for
	unsigned int cur_counter;
	unsigned int need_time, vfreq;
	unsigned char timeout = 10;

	if(num != 0)
	{
		vfreq = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

		if(vfreq)
			need_time = 900000 * num / vfreq;
		else
		{
			rtd_pr_vsc_info("\r\n#####func:%s err frame rate zero####\r\n", __FUNCTION__);
			return;
		}
		while(timeout)
		{
			cur_counter = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
			if(cur_counter < record_Setup_IMD_timer_counter)
			{
				if((cur_counter + (0xFFFFFFFF - record_Setup_IMD_timer_counter)) >= need_time)
					break;

			}
			else if ((cur_counter - record_Setup_IMD_timer_counter) >= need_time)
				break;
			msleep(10);
			timeout --;
		}

		rtd_pr_vsc_info("\r\n###func:%s ori:%d needwait num:%d time:%d cur_counter=%d timeout=%d#####\r\n", __FUNCTION__, record_Setup_IMD_timer_counter, num, need_time,cur_counter,timeout);
		if(!timeout)
			rtd_pr_vsc_info("\r\n#####func:%s err wait timeout#####\r\n", __FUNCTION__);
	}
}

unsigned char wait_atv_stable_for_bg_impl(unsigned char display)
{
	UINT8 ucVdReady = 0;
	unsigned short Timeout = 0;
	unsigned short Channel_Ch_Timeout = 0;
	unsigned char *p_stop_flag = &DbgSclrFlgTkr.Main_Scaler_Stop_flag;
	unsigned char *p_output_set_flag = &DbgSclrFlgTkr.Main_Output_Set_flag;
	unsigned char *p_run_scaler_flag = &DbgSclrFlgTkr.Main_Run_Scaler_flag;
	if(display == SLR_MAIN_DISPLAY) {
		p_stop_flag = &DbgSclrFlgTkr.Main_Scaler_Stop_flag;
		p_output_set_flag = &DbgSclrFlgTkr.Main_Output_Set_flag;
		p_run_scaler_flag = &DbgSclrFlgTkr.Main_Run_Scaler_flag;
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		p_stop_flag = &DbgSclrFlgTkr.Sub_Scaler_Stop_flag;
		p_output_set_flag = &DbgSclrFlgTkr.Sub_Output_Set_flag;
		p_run_scaler_flag = &DbgSclrFlgTkr.Sub_Run_Scaler_flag;
	}
#endif
	//rtd_pr_vsc_info("p_stop_flag=%d, p_output_set_flag=%d, p_run_scaler_flag=%d [%s(line:%d)]\n",p_stop_flag, p_output_set_flag, p_run_scaler_flag, __FUNCTION__, __LINE__);
	down(get_avd_power_semaphore());
	if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
	{
		ucVdReady = drvif_module_vdc_OutputStable();
	}
	up(get_avd_power_semaphore());

	if (drvif_module_vdc_GetLockStatus())
	{
		//extern UINT8 dma_3d_ON_count;
		//dma_3d_ON_count = 0;	//init

		if(get_AVD_Input_Source() == _SRC_TV){
			while(Scaler_AVD_GetIsChannelChange()){
				msleep(10);
				Channel_Ch_Timeout++;
				if ((Channel_Ch_Timeout >= 30)||
					(Scaler_AVD_GetIsChannelChange()== FALSE)) {
					rtd_pr_vsc_info("drvif_module_vdc_GetLockStatus=%d, Channel_Ch_Timeout=%d, IsChannelChange=%d [%s(line:%d)]\n",drvif_module_vdc_GetLockStatus(), Channel_Ch_Timeout, Scaler_AVD_GetIsChannelChange(), __FUNCTION__, __LINE__);
					break;
				}
			}
		}

		while (ucVdReady == FALSE)
		{
			VDC_DEBUG_MSG(VDC_MSG_TVCHCH, "[1]V_state timeout = %d\n",Timeout);
			msleep(10);
			if(*p_stop_flag || *p_output_set_flag || *p_run_scaler_flag)
				return FALSE;
			//Timeout++;
			if (Timeout++ >= 100) {
				rtd_pr_vsc_info("[VSC]V_state timeout\n");
				drvif_module_vdc_set_vstate_new2to3_en(_ENABLE);		/* vstate != 3, set */
				VDC_DEBUG_MSG(VDC_MSG_TVCHCH, "[VSC]V_state timeout\n");
				//return FALSE;
				break;  //modify for [KTASKWBS-7166],if vdpq_dma_ctrl4_reg.dma_3d_on_off is always 0, no need keep mute
			}

			down(get_avd_power_semaphore());
			if(get_AVD_Global_Status() == SRC_CONNECT_DONE){
				ucVdReady = drvif_module_vdc_OutputStable();
			}
			up(get_avd_power_semaphore());
		}
	}else{
		if(0 == drvif_video_status_reg(VDC_no_signal))
			return FALSE;
	}

	rtd_pr_vsc_info("drvif_module_vdc_GetLockStatus=%x, ucVdReady=%x, count=%d [%s(line:%d)]\n",drvif_module_vdc_GetLockStatus(), ucVdReady, Timeout, __FUNCTION__, __LINE__);

#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif

	drvif_module_vdc_new_vdetect_Enable(New_vedetect);
	drvif_module_vdc_set_vstate_speedup(vstate_count_default);
	//Check if there are three frames after Setup_IMD to here
	wait_buffer_ready_after_SetupIMD(3);//For KTASKWBS-9770 AV DC off/on judder
	if(*p_stop_flag || *p_output_set_flag || *p_run_scaler_flag)
		return FALSE;
	else
		return TRUE;
}

//Calc the count of SetWinBlank=0 durning ATV Channel change
void	CalcWinBlankCountForATVChanlChg(unsigned char channel, bool bonoff)
{
	//rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	// VSC is connectd to AVD
	if (!bonoff && (VSC_INPUTSRC_AVD == Get_DisplayMode_Src(channel))
		&& (get_AVD_Input_Source() == _SRC_TV))
	{
		if (TRUE == DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange)
		{
			DbgSclrFlgTkr.g_ucVDCDetectStage = Scaler_AVD_GetDetectStage();

			DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange = FALSE;
			DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart = TRUE;

			rtd_pr_vsc_info("reset DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=0\n");
		}


		if (TRUE == DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart)
		{
			DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount++;
			rtd_pr_vsc_info("DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=%d\n", DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount);
		}
	}
}

unsigned char get_sync_memc_ready(void){
	return sync_memc_ready;
}

void Set_Val_sync_memc_ready(unsigned char value){
    sync_memc_ready = value;
}

unsigned char rtk_hal_vsc_SetWinBlank(VIDEO_WID_T wid, unsigned char bonoff, KADP_VIDEO_DDI_WIN_COLOR_T color)
{
	SCALER_DISP_CHANNEL channel;

	rtd_pr_vsc_info("#####[%s(%d)] wid:%d, enable=%d\n",__func__,__LINE__, wid, bonoff);

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid != VIDEO_WID_0)
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#endif

	if((color > KADP_VIDEO_DDI_WIN_COLOR_COLOR_RGB_API) || (color < KADP_VIDEO_DDI_WIN_COLOR_BLACK))
		return FALSE;

	if (wid == VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	}
#ifdef CONFIG_DUAL_CHANNEL
    else if (wid == VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}
#endif
    else{
        return TRUE;
    }

	if(Get_Val_OutpuLocalDimmingPatMode() == TRUE){
        if(bonoff)
            set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);
        else
            set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
		return TRUE;
	}

	if(bonoff)
		set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);
	//Calc the count of SetWinBlank=0 durning ATV Channel change
	CalcWinBlankCountForATVChanlChg(channel, bonoff);
#if 0
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)&&(get_AVD_Input_Source() == _SRC_TV)){//For KTASKWBS-5200
		if (!bonoff && Scaler_AVD_GetIsChannelChange()&& (Scaler_AVD_GetDemodType()==KADP_AVD_EXTERNAL_DEMOD)
			&&(DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount ==1)
			&& 0 == drvif_video_status_reg(VDC_no_signal)){
			set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			rtd_pr_vsc_info("######[%s(line:%d)]external_ch_change_flag =1 don't run rtk_hal_vsc_SetWinBlank\n",__FUNCTION__, __LINE__);
			return TRUE;
		}

		if (!bonoff

			&&(Scaler_AVD_GetVDPreMode() == _MODE_UNKNOWN)
			&&(0 == drvif_video_status_reg(VDC_no_signal))
			&&(0 == drvif_video_status_reg(VDC_noisy))
			&&(DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount ==1)){
			set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			rtd_pr_vsc_info("######[%s(line:%d)]fast zapping, flicker garbage.#####\n",__FUNCTION__, __LINE__);
			return TRUE;

		}
	}
#endif
	if (bonoff) {
		if(channel == SLR_MAIN_DISPLAY) {
			DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = FALSE;//ATV can not run smooth toggle

		}
#ifdef CONFIG_DUAL_CHANNEL
        else {
			DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag = FALSE;//ATV can not run smooth toggle
		}
#endif
		//frank@03102016 DOLBYCERT-144 store mode change playback file osd flash issue ++
		if ((channel == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_FRAMESYNC) &&(get_HDMI_HDR_mode() !=HDR_DOLBY_HDMI) && (get_HDMI_HDR_mode() !=HDR_HDR10_HDMI) &&(!vbe_disp_get_adaptivestream_fs_mode())){
			#ifndef CONFIG_FORCE_RUN_I3DDMA //not define
			drivf_scaler_reset_freerun();
			#endif
		}
		//if((Get_DISPLAY_PANEL_OLED_TYPE()==1)&& vsc_get_adaptivestream_flag() && (channel == SLR_MAIN_DISPLAY)){
		if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (channel == SLR_MAIN_DISPLAY)&&(Check_AP_Set_Enable_ForceBG(channel) == FALSE)){
			Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
			rtd_pr_vsc_notice("######### [%s]line:%d, enable wdg\n", __FUNCTION__, __LINE__);
			drvif_mode_enableonlinemeasure(channel);//Enable online measure
			drvif_mode_onlinemeasure_setting(channel, _SRC_VO, TRUE, FALSE);
		}
		//frank@03102016 DOLBYCERT-144 store mode change playback file osd flash issue --


		if(color == KADP_VIDEO_DDI_WIN_COLOR_BLACK)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x0000, 0x0000, 0x0000);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_BLUE)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x0000, 0x0000, 0x3FFF);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_GRAY)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x2fff, 0x2fff, 0x2fff);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_COLOR_RGB_API)
		{
			rtd_pr_vsc_info("\r\n rtk_hal_vsc_SetWinBlank display:%d follow RGB color API\n", channel);
		}


		//set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);

		if((channel == SLR_MAIN_DISPLAY) && Get_tv006_wb_pattern())	//WOSQRTK-7731
		{
			return TRUE;
		}

	} else {
		if(channel == SLR_MAIN_DISPLAY) {
			down(&SetMainOutPutRegion_Semaphore);
			if(DbgSclrFlgTkr.Main_Output_Set_flag) {
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
				set_main_scaler_stop_flag(FALSE);
#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
				cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s request main scaler##########\r\n", __FUNCTION__);
				return TRUE;
			} else  if(DbgSclrFlgTkr.rotate_muteoff_request_flag) {

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				DbgSclrFlgTkr.rotate_run_scaler_flag = TRUE;
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s request main rotate##########\r\n", __FUNCTION__);
				return TRUE;
			} else if(DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) {

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = TRUE;
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s request main smooth toggle##########\r\n", __FUNCTION__);
				return TRUE;
			} else if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off){//Rika
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s smoothtoggle now##########\r\n", __FUNCTION__);
				return TRUE;
			}
			up(&SetMainOutPutRegion_Semaphore);

			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				if(DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag == TRUE){
					if(((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && drvif_module_vdc_OutputStable())|| (1 == drvif_video_status_reg(VDC_no_signal))){
						rtd_pr_vsc_notice("#####[%s(%d)]ATV signal stable to trigger_mute_off!\n", __func__, __LINE__);
						trigger_mute_off(SLR_MAIN_DISPLAY, 0);//trigger mute off. switch ratio case
					}
					rtd_pr_vsc_info("########func:%s(%d) atv case##########\r\n", __FUNCTION__,__LINE__);
					return TRUE;
				}
			}
			if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

				rtd_pr_vsc_info("########func:%s Main currently is not active can not disable BG##########\r\n", __FUNCTION__);
				return TRUE;
			}
			else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) ==  VSC_INPUTSRC_VDEC) && DbgSclrFlgTkr.Main_during_scalerflow_flag)
			{
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				rtd_pr_vsc_notice("####func:%s Main during scaler flow so can not disable BG####\r\n", __FUNCTION__);
				return TRUE;
			}
		}
#ifdef CONFIG_DUAL_CHANNEL
        else {
			down(&SetSubOutPutRegion_Semaphore);
			if(DbgSclrFlgTkr.Sub_Output_Set_flag) {
				DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetSubOutPutRegion_Semaphore);
				rtd_pr_vsc_debug("\r\n########func:%s request sub scaler##########\r\n", __FUNCTION__);
				return TRUE;
			}
			up(&SetSubOutPutRegion_Semaphore);

			if((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

				rtd_pr_vsc_info("########func:%s(%d) atv case##########\r\n", __FUNCTION__,__LINE__);
				return TRUE;
			}
			if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

				rtd_pr_vsc_info("########func:%s Sub currently is not active can not disable BG##########\r\n", __FUNCTION__);
			}

		}
#endif
		set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
	}

	if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) && !bonoff) {
		rtd_pr_vsc_info("########func:%s line:%d signal not stable can not disable BG##########\r\n", __FUNCTION__, __LINE__);
		return TRUE;
	}

	if(channel == SLR_MAIN_DISPLAY)
	{
		if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY))
		{
			mute_control(SLR_MAIN_DISPLAY, TRUE);
				//These are for mute on to wait memc already blck video
			if(get_sync_memc_ready() && bonoff)//if TRUE. when mute on to wait memc buffer
			{
				wait_memc_ready();//wait memc buffer
			}

		}
		else
		{
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
				if(drvif_module_vdc_OutputStable()||drvif_video_status_reg(VDC_no_signal)){
					rtd_pr_vsc_notice("#####[%s(%d)]ATV signal stable to trigger_mute_off!\n", __func__, __LINE__);
					trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off
				}else{
					rtd_pr_vsc_notice("#####[%s(%d)]ATV signal not stable, can not mute off!\n", __func__, __LINE__);
				}
			}else{
				rtd_pr_vsc_notice("#####[%s(%d)]trigger_mute_off\n", __func__, __LINE__);
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		if(bonoff)
		{
/*			down(&SetSubOutPutRegion_Semaphore);
			set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
			up(&SetSubOutPutRegion_Semaphore);*/
		}

		if(Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY))
		{
			mute_control(SLR_SUB_DISPLAY, TRUE);
		}
		else
		{
			trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off
		}
	}
#endif

#if 1
//	if (bonoff)
	if (bonoff && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (!get_sub_OutputVencMode()))
	{
		if (get_AVD_Input_Source() == _SRC_TV)
		{
#if 1  //ch_change_flag, 20151221
			set_vdc_resetTV_Count(0x0);
#else
			if (drvif_module_vdc_read_Clamping_path() == 0)
			{
				vdc_exTV_chch = TRUE;
				vdc_resetTV_Count = 0x0;
				drvif_module_vdc_set_ch_change_flag(1);
			}/* mark internal ch change
			else {
				vdc_inTV_chch = TRUE;
				vdc_resetTV_Count = 0x0;
			}*/
#endif
		} else if (get_AVD_Input_Source() == _SRC_CVBS)
			set_vdc_AV_modech(TRUE);
	}
	else
	{
#if 0  //ch_change_flag, 20151221
		vdc_inTV_chch = FALSE;
		vdc_exTV_chch = FALSE;
#endif
		set_vdc_resetTV_Count(0x0);
	}
#endif
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetWinBlank)(VIDEO_WID_T wid, unsigned char bonoff, KADP_VIDEO_DDI_WIN_COLOR_T color) = rtk_hal_vsc_SetWinBlank;

unsigned char rtk_hal_vsc_GetInputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pinregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

		rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==KADP_VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			pinregion->x = main_input_size.srcx;
			pinregion->w = main_input_size.src_wid;
			pinregion->y = main_input_size.srcy;
			pinregion->h = main_input_size.src_height;
#ifdef CONFIG_SDNR_CROP
#ifdef CONFIG_I2RND_ENABLE
			if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				pinregion->x = sub_input_size.srcx;
				pinregion->w = sub_input_size.src_wid;
				pinregion->y = sub_input_size.srcy;
				pinregion->h = sub_input_size.src_height;
			}
#endif
#endif
		} else {
			pinregion->x = 0;
			pinregion->y = 0;
			pinregion->w = 0;
			pinregion->h = 0;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
    else if (wid ==KADP_VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			pinregion->x = sub_input_size.srcx;
			pinregion->w = sub_input_size.src_wid;
			pinregion->y = sub_input_size.srcy;
			pinregion->h = sub_input_size.src_height;
		} else {
			pinregion->x = 0;
			pinregion->y = 0;
			pinregion->w = 0;
			pinregion->h = 0;
		}

	}
 #endif
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_GetInputRegion)(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pinregion) = rtk_hal_vsc_GetInputRegion;

unsigned char check_only_xy_shift_case(unsigned char display, StructSrcRect *input, StructSrcRect *inputTiming, StructSrcRect *output);
void apply_only_xy_shift(unsigned char display, StructSrcRect input, StructSrcRect inputTiming, StructSrcRect output);

unsigned char rtk_hal_vsc_SetInputRegion_ForAdaptive_impl(VIDEO_WID_T wid, KADP_VIDEO_RECT_T  inregion)
{
	VSC_INPUT_TYPE_T srctype;


	if(wid == VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
#if 0
	if((srctype == VSC_INPUTSRC_HDMI) && (wid == VIDEO_WID_0))
	{
#ifdef CONFIG_FORCE_RUN_I3DDMA
		unsigned int input_w;
		input_w = Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID);
		//input_w = Scaler_HDR10_Hdmi_Get_Input_ACT_WID_info();
		if(input_w > 3840){
			rtd_pr_vsc_debug("\n input_w=%d ->3840\n",input_w);
			inregion.x = 3840*inregion.x/input_w;
			inregion.w = 3840*inregion.w/input_w;
		}
#else
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		unsigned int input_w;
		if(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		{
			input_w = Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID);
			if(input_w > 3840){
				rtd_pr_vsc_debug("\n hdr input_w=%d ->3840\n",input_w);
				inregion.x = 3840*inregion.x/input_w;
				inregion.w = 3840*inregion.w/input_w;
			}
		}
		#endif
#endif

	}
#endif

	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_debug("rtk_hal_vsc_SetInputRegion_ForAdaptive x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1)) {
		rtd_pr_vsc_debug("\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);

		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		return TRUE;
	}
	else
	{
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(_DISP_WID && _DISP_LEN){
		if(inregion.w + inregion.x > _DISP_WID){
			inregion.x = 0;
			inregion.w = _DISP_WID;
			rtd_pr_vsc_emerg( "rtk_hal_vsc_SetInputRegion_ForAdaptive wrong wid\n");
		}
		if(inregion.h + inregion.y > _DISP_LEN){
			inregion.y = 0;
			inregion.h = _DISP_LEN;
			rtd_pr_vsc_emerg( "rtk_hal_vsc_SetInputRegion_ForAdaptive wrong len\n");
		}
	}

	if(wid == VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;

		Scaler_AdaptiveStream_InputWindowSet(main_input_size, wid);//for the first time, adpative stream timing change smooth toggle overscan size
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_DISP_WIN);//add this to identify different input region
		hal_main_InputRegionType = INPUT_BASE_ON_DISP_WIN;

		if (srctype == VSC_INPUTSRC_AVD)
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(wid,hal_main_InputRegionType);
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre, &main_dispwin_for_only_xy))
				{
					rtd_pr_vsc_debug("apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_DISP_WIN);
		hal_sub_InputRegionType = INPUT_BASE_ON_DISP_WIN;
		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_size, wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	return TRUE;
}
unsigned char (*rtk_hal_vsc_SetInputRegion_ForAdaptive)(VIDEO_WID_T wid, KADP_VIDEO_RECT_T  inregion) = rtk_hal_vsc_SetInputRegion_ForAdaptive_impl;

unsigned char rtk_hal_vsc_GetInputRegion_ForAdaptive_impl(VIDEO_WID_T wid, VIDEO_RECT_T * poutregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			poutregion->x = main_dispwin.srcx;
			poutregion->y = main_dispwin.srcy;
			poutregion->w = main_dispwin.src_wid;
			poutregion->h = main_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
    else if (wid ==VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			poutregion->x = sub_dispwin.srcx;
			poutregion->y = sub_dispwin.srcy;
			poutregion->w = sub_dispwin.src_wid;
			poutregion->h = sub_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}

	}
#endif
	return TRUE;

}
unsigned char (*rtk_hal_vsc_GetInputRegion_ForAdaptive)(VIDEO_WID_T wid, VIDEO_RECT_T * poutregion) = rtk_hal_vsc_GetInputRegion_ForAdaptive_impl;

unsigned char rtk_hal_vsc_SetInputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T  inregion)
{
	VSC_INPUT_TYPE_T srctype;

	if(wid == KADP_VIDEO_WID_0)
    {
    	//if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetInputRegion main input(%d %d %d %d) \n", inregion.x, inregion.y, inregion.w, inregion.h);
    	}
    }
	else
	{
		//if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetInputRegion sub input(%d %d %d %d) \n", inregion.x, inregion.y, inregion.w, inregion.h);
    	}
	}

    if(wid == KADP_VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(wid == KADP_VIDEO_WID_0)
	{
		inregion.h = inregion.h/2;
		inregion.y = inregion.y/2;
	}
#endif

	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if(inregion.x >4096) {
		 inregion.x=0;
	}
	if(inregion.w >4096) {
		 inregion.w=0;
	}
	if(inregion.h >4096) {
		 inregion.h=0;
	}
	if(inregion.y >4096) {
		 inregion.y=0;
	}
	//rtd_pr_vsc_debug("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1)) {
		rtd_pr_vsc_debug("\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);
		main_InputRegion_0000 = 1;
		return TRUE;
	}
	else
	{
		if (wid == KADP_VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(wid == KADP_VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		//rtd_pr_vsc_notice("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);

		Scaler_AdaptiveStream_InputWindowSet(main_input_size,wid);
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
		hal_main_InputRegionType = INPUT_BASE_ON_TIMING;

		if (srctype == VSC_INPUTSRC_AVD)
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);

			inregion.x = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.x);
			inregion.w = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.w);

			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);

		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
                //jpeg sorce always not enter shifxy flow,only vdec source can enter shiftxy flow
				/*if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre,&main_dispwin_for_only_xy))
				{
					rtd_pr_vsc_debug("apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else*/ {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else {
		down(&SetSubOutPutRegion_Semaphore);

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
		hal_sub_InputRegionType = INPUT_BASE_ON_TIMING;

		// for sub smooth toggle test
		//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);

		Scaler_AdaptiveStream_InputWindowSet(sub_input_size,wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetInputRegion)(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T inregion) = rtk_hal_vsc_SetInputRegion;

unsigned char rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * poutregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN) || (wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==KADP_VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			poutregion->x = main_dispwin.srcx;
			poutregion->y = main_dispwin.srcy;
			poutregion->w = main_dispwin.src_wid;
			poutregion->h = main_dispwin.src_height;
#ifdef CONFIG_SDNR_CROP
#ifdef CONFIG_I2RND_ENABLE
			if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				poutregion->x = sub_dispwin.srcx;
				poutregion->y = sub_dispwin.srcy;
				poutregion->w = sub_dispwin.src_wid;
				poutregion->h = sub_dispwin.src_height;
			}
#endif
#endif
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
    else if (wid ==KADP_VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			poutregion->x = sub_dispwin.srcx;
			poutregion->y = sub_dispwin.srcy;
			poutregion->w = sub_dispwin.src_wid;
			poutregion->h = sub_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}

	}
#endif
	return TRUE;

}
unsigned char (*fp_rtk_hal_vsc_GetOutputRegion)(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T *poutregion) = rtk_hal_vsc_GetOutputRegion;

extern void vbe_disp_orbit_set_vo_overscan_state(unsigned char bEnable);
//extern unsigned char vbe_disp_oled_orbit_enable;
//extern unsigned char vbe_disp_oled_orbit_mode;

//New set input region for K4LP @Crixus 20170608
unsigned char rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_T wid, VIDEO_RECT_T  inregion, VIDEO_RECT_T originalInput)
{
	VSC_INPUT_TYPE_T srctype;

#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	inregion.x =0 ;
	inregion.y =0 ;
	inregion.w = originalInput.w;
	inregion.h = originalInput.h;
#endif

    if(wid == VIDEO_WID_0)
    {
    	//if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetInputRegionEx main input(%d %d %d %d) ori(%d %d)\n", inregion.x, inregion.y, inregion.w, inregion.h, originalInput.w, originalInput.h);
    	}
    }
	else
	{
		//if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetInputRegionEx sub input(%d %d %d %d) ori(%d %d)\n", inregion.x, inregion.y, inregion.w, inregion.h, originalInput.w, originalInput.h);
    	}
	}

    if(wid == VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid != VIDEO_WID_0) && (wid != VIDEO_WID_1))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (srctype == VSC_INPUTSRC_AVD)
	{
#if 0 //ch_change_flag, 20151221
		vdc_inTV_chch = FALSE;
		vdc_exTV_chch = FALSE;
#endif
#if 0
		if((get_AVD_Input_Source() == _SRC_TV) && (Scaler_AVD_GetIsChannelChange())&& (Scaler_AVD_GetDemodType()==KADP_AVD_EXTERNAL_DEMOD)){//For KTASKWBS-5200
			rtd_pr_vsc_notice("external_ch_change_flag =1 don't clear exTV flag and count\n");
			return TRUE;
		}else{
			//vdc_resetTV_Count = 0x0;
			//rtd_pr_vsc_notice("clear exTV flag and count\n");
		}
#endif
	}

	//rtd_pr_vsc_debug("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1) || (originalInput.w < 1) || (originalInput.h < 1)) {
		rtd_pr_vsc_debug("\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);

		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		return TRUE;
	}
	else
	{
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(wid == VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		//rtd_pr_vsc_notice("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);

		main_input_timing.srcx = originalInput.x;
		main_input_timing.srcy = originalInput.y;
		main_input_timing.src_wid = originalInput.w;
		main_input_timing.src_height = originalInput.h;
        if((vbe_disp_get_orbit_mode() ==_VBE_PANEL_ORBIT_AUTO_MODE || vbe_disp_get_orbit_mode() ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_get_orbit())
        {
            vbe_orbit_set_input_size(main_input_size);
        }
		if (srctype == VSC_INPUTSRC_AVD)
		{
			main_input_timing.src_wid = 720; // ATV
			if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)wid)){//AV
				main_input_timing.src_wid = 720;
			}else if(VD_27M_HSD1440_DI3A== fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)wid)){
				main_input_timing.src_wid = 1440;
			}
		}

		Scaler_AdaptiveStream_InputWindowSet(main_input_size,wid);
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
		hal_main_InputRegionType = INPUT_BASE_ON_HAL_ORIGINAL_INPUT;

		if (srctype == VSC_INPUTSRC_AVD)
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(wid,hal_main_InputRegionType);

			//inregion.x = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.x);
			//inregion.w = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.w);

			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			//zoom_imd_smooth_toggle_config(wid, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(wid,hal_main_InputRegionType);
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre,&main_dispwin_for_only_xy))
				{
					rtd_pr_vsc_debug("apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL

	else if(wid == VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		if(DbgSclrFlgTkr.Sub_OutputVencMode && (originalInput.w == 704) && (srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
			rtd_pr_vsc_notice("#####[%s(%d)] reset original input width to 720 #####", __FUNCTION__, __LINE__);
			originalInput.w=720;
		}

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		sub_input_timing.srcx = originalInput.x;
		sub_input_timing.srcy = originalInput.y;
		sub_input_timing.src_wid = originalInput.w;
		sub_input_timing.src_height = originalInput.h;

		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
		hal_sub_InputRegionType = INPUT_BASE_ON_HAL_ORIGINAL_INPUT;
		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		zoom_imd_smooth_toggle_config(wid, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_timing,wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	return TRUE;
}

unsigned char check_only_xy_shift_case(unsigned char display, StructSrcRect *input, StructSrcRect *inputTiming, StructSrcRect *output)
{
	unsigned char ret = NOT_EQUAL;
	VSC_INPUT_TYPE_T srctype;
#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
	if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT){
		//if hal input timing is different, it will not go shiftxy
		//NEED FIX pool test
		//if input x=50 inputTiming wid=1000, then change to input x=100, inputTiming wid = 2000.
		//the ratio stays the same, so it may run shiftxy flow
		if(inputTiming->srcx != main_input_timing.srcx || inputTiming->srcy != main_input_timing.srcy
		     || inputTiming->src_wid != main_input_timing.src_wid || inputTiming->src_height != main_input_timing.src_height){
			input->srcx = main_input_size.srcx;
			input->srcy = main_input_size.srcy;
			input->src_wid = main_input_size.src_wid;
			input->src_height = main_input_size.src_height;
			inputTiming->srcx = main_input_timing.srcx;
			inputTiming->srcy = main_input_timing.srcy;
			inputTiming->src_wid = main_input_timing.src_wid;
			inputTiming->src_height = main_input_timing.src_height;
			output->srcx = main_dispwin.srcx;
			output->srcy = main_dispwin.srcy;
			output->src_wid = main_dispwin.src_wid;
			output->src_height = main_dispwin.src_height;
			DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
			return ret;
		}
	}
#endif
         if(input->src_wid != main_input_size.src_wid || input->src_height != main_input_size.src_height
         || output->srcx != main_dispwin.srcx || output->srcy != main_dispwin.srcy
         || output->src_wid != main_dispwin.src_wid || output->src_height != main_dispwin.src_height)
         {
         		   input->srcx = main_input_size.srcx;
                   input->srcy = main_input_size.srcy;
                   input->src_wid = main_input_size.src_wid;
                   input->src_height = main_input_size.src_height;
                   output->srcx = main_dispwin.srcx;
                   output->srcy = main_dispwin.srcy;
                   output->src_wid = main_dispwin.src_wid;
                   output->src_height = main_dispwin.src_height;
                   DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
				   return ret;

         }
         else
         {
                   // all region are the same, just run apply_only_xy_shift, but do nothing
                   if(input->srcx == main_input_size.srcx && input->srcy == main_input_size.srcy)
                   {
                            DbgSclrFlgTkr.check_only_xy_shift_same_region = TRUE;
							ret = ALL_EQUAL;
                            return ret;
                   } else if((input->srcx != main_input_size.srcx) &&
				   			(input->srcy != main_input_size.srcy)){
				   			ret = ONLY_SHIFT_XY;
                   } else if(input->srcx != main_input_size.srcx){
				   			ret = ONLY_SHIFT_X;
                   } else if(input->srcy != main_input_size.srcy){
				   			ret = ONLY_SHIFT_Y;
                   }

                   input->srcx = main_input_size.srcx;
                   input->srcy = main_input_size.srcy;
                   input->src_wid = main_input_size.src_wid;
                   input->src_height = main_input_size.src_height;
                   output->srcx = main_dispwin.srcx;
                   output->srcy = main_dispwin.srcy;
                   output->src_wid = main_dispwin.src_wid;
                   output->src_height = main_dispwin.src_height;
                   DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
                   srctype = Get_DisplayMode_Src(display);
                   if(srctype == VSC_INPUTSRC_VDEC)	{
					   if ((!DbgSclrFlgTkr.Main_smooth_toggle_set_flag) && (!DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off)) {// && (!DbgSclrFlgTkr.smoothtoggle_start_flag)) {
							if (!DbgSclrFlgTkr.smoothtoggle_start_flag) {
								 send_vo_freeze_shiftxy_share_memory();
		                           			 return ret;
							} else {
								//wait
								unsigned int timeout = 15;

								while((DbgSclrFlgTkr.Main_smooth_toggle_set_flag ||DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off || DbgSclrFlgTkr.smoothtoggle_start_flag)&&timeout)
									{
										timeout--;
										msleep(10);
									}

								if(!timeout){
									rtd_pr_vsc_info("shiftxf wait smoothtoogh timeout !\n");
									return NOT_EQUAL;
								}else{
									 send_vo_freeze_shiftxy_share_memory();
									return ret;
								}
							}
						} else {
							return NOT_EQUAL;
						}
				  } else {
					return NOT_EQUAL;
				  }
         }
}

void apply_only_xy_shift(unsigned char display, StructSrcRect input, StructSrcRect inputTiming, StructSrcRect output)
{
	int timeout = 30;
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(display);

	scaledown_ich1_uzd_ctrl0_RBUS	ich1_uzd_Ctrl0_REG;
	scaledown_ich1_uzd_db_ctrl_RBUS ich1_uzd_db_ctrl_reg;
	scaledown_ich1_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
	scaledown_ich1_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
	//scaledown_ich1_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
	StructSrcRect SDNR_size = input;
	//int mid = 0;

	// all region are the same, just run apply_only_xy_shift, but do nothing
	if(DbgSclrFlgTkr.check_only_xy_shift_same_region == TRUE){
		rtd_pr_vsc_debug("apply_only_xy_shift do nothing\n");
		return;
	}


#if 0
	rtd_pr_vsc_info("========input size============\n");
	rtd_pr_vsc_info("x:%d,y:%d,wid:%d,len:%d\n",input.srcx,input.srcy,input.src_wid,input.src_height);
	rtd_pr_vsc_info("========output size============\n");
	rtd_pr_vsc_info("x:%d,y:%d,wid:%d,len:%d\n",output.srcx,output.srcy,output.src_wid,output.src_height);
	rtd_pr_vsc_info("===============================\n");
#endif
	SDNR_size = drvif_cal_SDNR_size(display,input,inputTiming,output);
	rtd_pr_vsc_emerg("[shiftxy][SDNR]x:%d,y:%d,wid:%d,len:%d\n",SDNR_size.srcx,SDNR_size.srcy,SDNR_size.src_wid,SDNR_size.src_height);
#if 0
	rtd_pr_vsc_info("############SDNR size#############\n");
	rtd_pr_vsc_info("x:%d,y:%d,wid:%d,len:%d\n",SDNR_size.srcx,SDNR_size.srcy,SDNR_size.src_wid,SDNR_size.src_height);
	rtd_pr_vsc_info("################################\n");
#endif
#ifdef CONFIG_I2RND_ENABLE
	if (!Scaler_I2rnd_get_timing_enable())
#endif
	{
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		while(ich1_uzd_db_ctrl_reg.h_db_en && ich1_uzd_db_ctrl_reg.v_db_en && ich1_uzd_db_ctrl_reg.v_db_apply)
		{
			timeout --;
			mdelay(1); /*wait 1ms 30 counts for vsync */
			if(!timeout) break;
			ich1_uzd_db_ctrl_reg.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		}
		if(timeout == 0) rtd_pr_vsc_info("uzd aplly time out !!! :%d\n",timeout);
		//uzu double buffer enbale
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		ich1_uzd_db_ctrl_reg.h_db_en=1;
		ich1_uzd_db_ctrl_reg.h_db_apply=0;
		ich1_uzd_db_ctrl_reg.v_db_en=1;
		ich1_uzd_db_ctrl_reg.v_db_apply=0;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg,ich1_uzd_db_ctrl_reg.regValue);
	}

	ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg);
	ich1_sdnr_cutout_range_hor_reg.hor_front = SDNR_size.srcx;
	ich1_sdnr_cutout_range_hor_reg.hor_back = SDNR_size.srcx + SDNR_size.src_wid + 1; // chip setting need to +1
	IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

	if(!Scaler_get_data_framesync(SLR_MAIN_DISPLAY))
	{
		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front = SDNR_size.srcy;
		ich1_sdnr_cutout_range_ver0_reg.ver_back = SDNR_size.srcy + SDNR_size.src_height + 1;// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);
	}

	//mid = ich1_sdnr_cutout_range_ver0_reg.ver_back;
	//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg);
	//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top = mid;
	//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot = mid - 1;
	//IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);

	ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_Ctrl0_reg);
	ich1_uzd_Ctrl0_REG.cutout_en = 1;
	IoReg_Write32(SCALEDOWN_ICH1_UZD_Ctrl0_reg, ich1_uzd_Ctrl0_REG.regValue);
#ifdef CONFIG_I2RND_ENABLE
	if (!Scaler_I2rnd_get_timing_enable())
#endif
	{
		//uzu double buffer apply
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		ich1_uzd_db_ctrl_reg.h_db_apply=1;
		ich1_uzd_db_ctrl_reg.v_db_apply=1;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg,ich1_uzd_db_ctrl_reg.regValue);
	}


	//KTASKWBS-5348  move update info after execution
	if(srctype == VSC_INPUTSRC_VDEC)
		zoom_record_input_output_pre_size(display,main_input_size, main_input_timing, main_dispwin);

}

extern unsigned char drvif_module_vdc_Read_Vstate(void);
extern unsigned char drvif_HDR_get_VO_Decompress_Status(unsigned char ch);

unsigned char  CompareATVOutputRegion(unsigned char a_ucChannel, VIDEO_RECT_T *a_ptOutputregion)
{
	if (SLR_MAIN_DISPLAY == a_ucChannel)
	{

		if (DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre == a_ptOutputregion->h
		)
		{
			return TRUE;
		}
	}
	else
	{
		if (DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre == a_ptOutputregion->h
		)
		{
			return TRUE;
		}
	}

	return FALSE;
}


unsigned char CompareATVInputOutputRegion_impl(unsigned char a_ucChannel, KADP_VIDEO_RECT_T *a_ptOutputregion, KADP_VIDEO_RECT_T *a_ptInputRegion)
{
	if (SLR_MAIN_DISPLAY == a_ucChannel)
	{
		if (DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre == a_ptOutputregion->h
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_x_pre == a_ptInputRegion->x
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_y_pre == a_ptInputRegion->y
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_w_pre == a_ptInputRegion->w
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_h_pre == a_ptInputRegion->h
		)
		{
			return TRUE;
		}
	}
	else
	{
		if (DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre == a_ptOutputregion->h
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre == a_ptInputRegion->x
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre == a_ptInputRegion->y
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre == a_ptInputRegion->w
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre == a_ptInputRegion->h
		)
		{
			return TRUE;
		}
	}

	return FALSE;
}

unsigned char (*CompareATVInputOutputRegion)(unsigned char, KADP_VIDEO_RECT_T *, KADP_VIDEO_RECT_T *) = CompareATVInputOutputRegion_impl;

unsigned char uc4_get_main_dispwin_value(unsigned short *x, unsigned short *y, unsigned short *w, unsigned short *h)	//WOSQRTK-7731
{
	if((x !=NULL)&&(y !=NULL)&&(w !=NULL)&&(h !=NULL))
	{
		*x = main_dispwin.srcx;
		*y = main_dispwin.srcy;
		*w = main_dispwin.src_wid;
		*h = main_dispwin.src_height;
	}
	else
		return 1;
	return 0;
}

#if 0
void set_vsc_SetCircle_OutputRegion(KADP_VIDEO_RECT_T outregion, unsigned short W, unsigned short H, UINT32 shape)
{
	//rtd_pr_vsc_debug("rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);

	//rtd_pr_vsc_debug("\n ********************* Sub_circle_center_h = %d ", outregion.x+(outregion.w/2));
	//rtd_pr_vsc_debug("\n ********************* Sub_circle_center_v = %d ", outregion.y+(outregion.h/2));
	//rtd_pr_vsc_debug("\n ********************* Sub_act_rad_a = %d ", (outregion.w/2 * outregion.w/2));
	//rtd_pr_vsc_debug("\n ********************* Sub_act_rad_b = %d ", (outregion.h/2 * outregion.h/2));

	ppoverlay_sub_active_rad_a_RBUS           SUB_Active_Red_A_reg;
	ppoverlay_sub_active_rad_b_RBUS           SUB_Active_Red_B_reg;
	ppoverlay_sub_background_rad_a_RBUS ppoverlay_sub_background_rad_a_reg;
	ppoverlay_sub_background_rad_b_RBUS ppoverlay_sub_background_rad_b_reg;
	ppoverlay_sub_den_rad_a_RBUS ppoverlay_sub_den_rad_a_reg;
	ppoverlay_sub_den_rad_b_RBUS ppoverlay_sub_den_rad_b_reg;
	ppoverlay_sub_circle_center_RBUS		SUB_Circle_center_reg;
	int	Circle_x=0, Circle_y=0, Circle_w=0, Circle_h=0;

	unsigned short temp_w=0, temp_h=0;
	unsigned short true_w=0, true_h=0;

	if (outregion.w%2==0)
		temp_w = (outregion.w-1)/2;
	else
		temp_w = (outregion.w)/2;
	true_w = temp_w;

	if (outregion.h%2==0)
		temp_h = (outregion.h-1)/2;
	else
		temp_h = (outregion.h)/2;
	true_h = temp_h;

	if (shape == VSC_MGF_TYPE_CIRCLE)
	{
		if (W%2==0)
			temp_w = (W-1);
		else
			temp_w = (W);

		if (H%2==0)
			temp_h = (H-1);
		else
			temp_h = (H);
	}

	rtd_pr_vsc_debug("\n ***** 0.SLR_INPUT_DISP_WID=%d ", Scaler_DispGetInputInfoByDisp(1, SLR_INPUT_DISP_WID));
	rtd_pr_vsc_debug("\n ***** 0.SLR_INPUT_DISP_LEN=%d ", Scaler_DispGetInputInfoByDisp(1, SLR_INPUT_DISP_LEN));
	rtd_pr_vsc_debug("\n ***** 1.set_vsc_OutputRegion  x=%d, y=%d, w=%d, h=%d ", outregion.x, outregion.y, outregion.w, outregion.h);
	rtd_pr_vsc_debug("\n ***** 2.virtual_w=%d, virtual_h=%d ", W, H);

	if ((outregion.x== 0) && (outregion.y== 0) && (outregion.w >= W) && (outregion.h >= H))
	{
		Circle_x = (int)(outregion.x + outregion.w - W);
		Circle_y = (int)(outregion.y + outregion.h - H);
		rtd_pr_vsc_debug("\n ***** 3.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ((outregion.x== 0) && (outregion.w >= W) && (outregion.h/2 <=  H))
	{
		Circle_x = (int)(outregion.x + outregion.w - W);
		Circle_y = (int)(outregion.y + H);
		rtd_pr_vsc_debug("\n ***** 4.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.y== 0) && (outregion.w >= W) && (outregion.h >= H))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + outregion.h - H);
		rtd_pr_vsc_debug("\n ***** 5.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.y + outregion.h == 2160) && (outregion.h/2 < H))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + H);
		rtd_pr_vsc_debug("\n ***** 6.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.x + outregion.w == 3840) && (outregion.w/2 < W))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + H);
		rtd_pr_vsc_debug("\n ***** 7.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else
	{
		Circle_x = (int)(outregion.x + true_w);
		Circle_y = (int)(outregion.y + true_h);
		rtd_pr_vsc_debug("\n ***** 8.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}

	SUB_Active_Red_A_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Active_Rad_A_reg);
	SUB_Active_Red_A_reg.sub_act_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Active_Rad_A_reg, SUB_Active_Red_A_reg.regValue);

	SUB_Active_Red_B_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Active_Rad_B_reg);
	SUB_Active_Red_B_reg.sub_act_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Active_Rad_B_reg, SUB_Active_Red_B_reg.regValue);

	ppoverlay_sub_background_rad_a_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Background_Rad_A_reg);
	ppoverlay_sub_background_rad_a_reg.sub_bg_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Background_Rad_A_reg, ppoverlay_sub_background_rad_a_reg.regValue);

	ppoverlay_sub_background_rad_b_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Background_Rad_B_reg);
	ppoverlay_sub_background_rad_b_reg.sub_bg_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Background_Rad_B_reg, ppoverlay_sub_background_rad_b_reg.regValue);

	ppoverlay_sub_den_rad_a_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Den_Rad_A_reg);
	ppoverlay_sub_den_rad_a_reg.sub_den_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Den_Rad_A_reg, ppoverlay_sub_den_rad_a_reg.regValue);

	ppoverlay_sub_den_rad_b_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Den_Rad_B_reg);
	ppoverlay_sub_den_rad_b_reg.sub_den_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Den_Rad_B_reg, ppoverlay_sub_den_rad_b_reg.regValue);

	if (shape == VSC_MGF_TYPE_CIRCLE)
	{
		SUB_Circle_center_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);
		SUB_Circle_center_reg.sub_circle_center_h= (Circle_x)*2;
		SUB_Circle_center_reg.sub_circle_center_v= (Circle_y)*2;
		SUB_Circle_center_reg.sub_window_form_sel= 1;
		IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg.regValue);
	}
	else
	{
	SUB_Circle_center_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);
	SUB_Circle_center_reg.sub_circle_center_h= (outregion.x+temp_w)*2;
	SUB_Circle_center_reg.sub_circle_center_v= (outregion.y+temp_h)*2;
	SUB_Circle_center_reg.sub_window_form_sel= 0;
	IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg.regValue);
	}
}

void set_vsc_SetMagnifire_shape(UINT32 num)
{

	ppoverlay_sub_circle_center_RBUS		SUB_Circle_center_reg_shape;
	SUB_Circle_center_reg_shape.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);

	if(num==1)
		SUB_Circle_center_reg_shape.sub_window_form_sel= 1;//Circle
	//else if(num==2) //no need in arrow
  	//	SUB_Circle_center_reg.sub_window_form_sel= 2; //arrow
	else
  		SUB_Circle_center_reg_shape.sub_window_form_sel= 0; //rectangle

  	IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg_shape.regValue);

}
#endif
unsigned char Get_Val_OutpuLocalDimmingPatMode(void)
{
	return OutpuLocalDimmingPatMode;
}
void Set_Val_OutpuLocalDimmingPatMode(unsigned char mode)
{
	OutpuLocalDimmingPatMode = mode;
}

unsigned char (*p_OutpuLocalDimmingPatMode)(void) = Get_Val_OutpuLocalDimmingPatMode;

unsigned char pattern_LD_WB_handle(KADP_VIDEO_RECT_T outregion)
{
    static unsigned char OutpuLocalDimmingPatMode_pre = FALSE;
    ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
    ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
    unsigned long flags=0x00;//for spin_lock_irqsave
    if(Get_Val_OutpuLocalDimmingPatMode() || Get_tv006_wb_pattern()){

		osdovl_mixer_ctrl2_RBUS mixer_ctrl2_reg;
		ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
		ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
		ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
		ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
		unsigned int timeout=0x3fffff;
		ppoverlay_main_background_color1_RBUS	main_background_color1_reg;
		ppoverlay_main_background_color2_RBUS main_background_color2_reg;
		ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
		//ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
		//ppoverlay_double_buffer_ctrl2_RBUS double_buffer_ctrl2_reg;
		ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
		if(!Get_tv006_wb_pattern()) {
		if((outregion.x ==0)&&(outregion.y == 0)&&(outregion.w == 3840)&&(outregion.h== 2160))
			return TRUE;
		}
		rtd_pr_vsc_debug("+++OutpuLocalDimmingPatMode");

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

		//set free run timing
		//drivf_scaler_reset_freerun_60Hz();
		//fw_scaler_dtg_double_buffer_enable(TRUE);
		down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
		double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		double_buffer_ctrl_reg.dmainreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
		spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
		up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		if(!Get_tv006_wb_pattern()){
		// turn off osd mixer
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 0;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);
		}

		main_background_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_H_Start_End_reg);
		main_background_h_start_end_reg.mh_bg_sta = outregion.x;
		main_background_h_start_end_reg.mh_bg_end = outregion.x+outregion.w;
		IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);

		main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
		main_active_h_start_end_reg.mh_act_sta= outregion.x;
		main_active_h_start_end_reg.mh_act_end = outregion.x+outregion.w;
		IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);

		main_background_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_V_Start_End_reg);
		main_background_v_start_end_reg.mv_bg_sta = outregion.y;
		main_background_v_start_end_reg.mv_bg_end = outregion.y+outregion.h;
		IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);

		main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
		main_active_v_start_end_reg.mv_act_sta = outregion.y;
		main_active_v_start_end_reg.mv_act_end = outregion.y+outregion.h;
		IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);
		if(!Get_tv006_wb_pattern()){
			main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
			main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
			main_background_color1_reg.m_bg_b = 0x3fff;
			main_background_color1_reg.m_bg_g = 0x3fff;
			main_background_color2_reg.m_bg_r = 0x3fff;
			IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
			IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);
			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
			main_display_control_rsv_reg.m_force_bg = 1;
			IoReg_Write32(PPOVERLAY_Main_Display_Control_RSV_reg, main_display_control_rsv_reg.regValue);
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		}
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}

		if(Get_Val_OutpuLocalDimmingPatMode()) {
    		OutpuLocalDimmingPatMode_pre = TRUE;
    		return TRUE;
		}

	} else{

		if(OutpuLocalDimmingPatMode_pre == TRUE){
			ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
			ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
			ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
			ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
			ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
			unsigned int timeout=0x3fffff;

			ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			double_buffer_ctrl_reg.dmainreg_dbuf_en = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			main_background_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_H_Start_End_reg);
			main_background_h_start_end_reg.mh_bg_sta = Get_DISP_ACT_STA_HPOS();
			main_background_h_start_end_reg.mh_bg_end = Get_DISP_ACT_END_HPOS();
			IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);
			main_background_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_V_Start_End_reg);
			main_background_v_start_end_reg.mv_bg_sta = Get_DISP_ACT_STA_VPOS();
			main_background_v_start_end_reg.mv_bg_end = Get_DISP_ACT_END_VPOS();
			IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);
			main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
			main_active_h_start_end_reg.mh_act_sta= outregion.x;
			main_active_h_start_end_reg.mh_act_end = outregion.x+outregion.w;
			IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);
			main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
			main_active_v_start_end_reg.mv_act_sta = outregion.y;
			main_active_v_start_end_reg.mv_act_end = outregion.y+outregion.h;
			IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			do{
				dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
			}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

			if(timeout==0){
				rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
				dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
				IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
				dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
				dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
				IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
				dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
				IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			}else{
				dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
				dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
				IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			}
			OutpuLocalDimmingPatMode_pre = FALSE;
		}
		else
		OutpuLocalDimmingPatMode_pre = FALSE;

	}
	return FALSE;
}
unsigned char check_force_rerun_scaler_condition(unsigned char srctype, unsigned char display)
{
	unsigned char result = FALSE;
	if(display == SLR_MAIN_DISPLAY) {
		if((srctype == VSC_INPUTSRC_HDMI) && (scaler_RGB444Mode_pre != rtk_hal_vsc_GetRGB444Mode()))
			result = TRUE;
	}

#ifdef CONFIG_DUAL_CHANNEL
	else
	{
	}
#endif
	return result;
}

void update_force_rerun_scaler_condition(unsigned char srctype, unsigned char display)
{
	if(display == SLR_MAIN_DISPLAY) {
		if(srctype == VSC_INPUTSRC_HDMI){
			scaler_RGB444Mode_pre = rtk_hal_vsc_GetRGB444Mode();
		}
	}

#ifdef CONFIG_DUAL_CHANNEL
	else
	{
	}
#endif
}
unsigned char atv_main_outputregion_handle(KADP_VIDEO_RECT_T outregion,StructSrcRect m_dispwin)
{//For ATV case
	unsigned ucVDTimingChange;
//				if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag){//This means that currently force bg is disabled, so directly run scaler flow
	ucVDTimingChange = Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY); // it will not clear ATV run search state flag
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
	//if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && !avd_small_output_flag)
	if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
#else
	if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
#endif
	{//This means that currently force bg is disabled and color std is not changed, so run smooth toggle flow //For Sub black video issue patch will 20151211
		set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
		set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
		set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
		Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
		rtd_pr_vsc_notice("2 rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
		main_dispwin.srcx = m_dispwin.srcx;
		main_dispwin.srcy = m_dispwin.srcy;
		main_dispwin.src_height = m_dispwin.src_height;
		main_dispwin.src_wid = m_dispwin.src_wid;

		//back up output region	//WOSQRTK-6617
		DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre = outregion.x;
		DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre = outregion.y;
		DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre = outregion.w;
		DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre = outregion.h;

		down(&VSC_Semaphore);
		Scaler_DispWindowSet(m_dispwin);
		rtd_pr_vsc_info("####[%s(%d)] atv smooth toggle#####\r\n", __FUNCTION__,__LINE__);
		Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);

		//zoom_imd_smooth_toggle_config(wid, outregion.x, outregion.y, outregion.w, outregion.h, ZOOM_DISP);
		zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, main_dispwin);

		up(&VSC_Semaphore);
	} else {//This means that currently force bg is enabled. Need to check run smooth toggle or scaler
		down(&SetMainOutPutRegion_Semaphore);

		if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && ucVDTimingChange)//This means that currently force bg is disabled and color std is changed, so directly run scaler flow
		{
			DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Special case:mute off=>set ARC have to run
			set_main_scaler_stop_flag(FALSE);
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
			rtd_pr_vsc_notice("####[%s(%d)] [special case]request atv run main scaler flow atv#####\r\n", __FUNCTION__,__LINE__);
		}
		else{
			if((Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE) && (Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY) == FALSE)) {
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//This is special case for VIP test
				set_main_scaler_stop_flag(FALSE);//Let scaler can be run
				rtd_pr_vsc_notice("####[%s(%d)] no mute on, so request run main scaler flow for atv directly####\r\n",__func__,__LINE__);
			} else {
				//DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//KTASKWBS-11685
				set_main_scaler_stop_flag(FALSE);//Let scaler can be run
				rtd_pr_vsc_info("####[%s(%d)] request atv run main scaler flow atv#####\r\n",__func__,__LINE__);
			}
		}
		reset_any_srcrect(&main_dispwin_for_only_xy);
		DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag = TRUE;//in ATV set this flag to check ATV will run scaler flow.
		main_dispwin.srcx = m_dispwin.srcx;
		main_dispwin.srcy = m_dispwin.srcy;
		main_dispwin.src_height = m_dispwin.src_height;
		main_dispwin.src_wid = m_dispwin.src_wid;

		//back up output region	//WOSQRTK-6617
		DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre = outregion.x;
		DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre = outregion.y;
		DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre = outregion.w;
		DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre = outregion.h;

		if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
			set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
		}
		up(&SetMainOutPutRegion_Semaphore);
	}

	complete(&vsc_scaler_tsk_completion);
	return TRUE;
}
unsigned char rotate_outputregion_handle(StructSrcRect m_dispwin)
{
	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
	{
		rtd_pr_vsc_emerg("output rotate run=%d,%d\n",get_rotate_mode(SLR_MAIN_DISPLAY),Get_Val_ap_roate_mode());
		down(&SetMainOutPutRegion_Semaphore);
		reset_any_srcrect(&main_dispwin_for_only_xy);
		main_dispwin.srcx = m_dispwin.srcx;
		main_dispwin.srcy = m_dispwin.srcy;
		main_dispwin.src_wid = m_dispwin.src_wid;
		main_dispwin.src_height = m_dispwin.src_height;
		if (Get_Val_ap_roate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_0) {
			DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
		}
		if (Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE) {
			ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
			DbgSclrFlgTkr.rotate_run_scaler_flag = TRUE;
			set_main_scaler_stop_flag(FALSE);
			up(&SetMainOutPutRegion_Semaphore);
			rtd_pr_vsc_emerg("[Rotate]active case run rotate scaler\n");
			main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
			if (!main_display_control_rsv_reg.m_force_bg) {
				rtd_pr_vsc_emerg("[Rotate]force to forcbg \n");
				down(get_forcebg_semaphore());
				scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
				up(get_forcebg_semaphore());
			}
		} else {
			DbgSclrFlgTkr.rotate_muteoff_request_flag = TRUE;
			//set_main_scaler_stop_flag(FALSE);
			up(&SetMainOutPutRegion_Semaphore);
			rtd_pr_vsc_emerg("[Rotate] active case mute off go rotate\n");
		}
	} else {
		down(&SetMainOutPutRegion_Semaphore);
		reset_any_srcrect(&main_dispwin_for_only_xy);
		main_dispwin.srcx = m_dispwin.srcx;
		main_dispwin.srcy = m_dispwin.srcy;
		main_dispwin.src_wid = m_dispwin.src_wid;
		main_dispwin.src_height = m_dispwin.src_height;
		if(check_input_and_output_the_same(SLR_MAIN_DISPLAY) == FALSE)
		{
		//	if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
				Share_Memory_Set_Scaler_Run_Flag(1);
			DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;

			if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
				set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
			}

			DbgSclrFlgTkr.rotate_muteoff_request_flag = TRUE;
			set_main_scaler_stop_flag(FALSE);
			rtd_pr_vsc_emerg("[Rotate] search case mute off go rotate\n");
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
	return TRUE;
}

void main_outputregion_smoothtoggle_handle(VSC_INPUT_TYPE_T srctype,StructSrcRect m_dispwin)
{
    unsigned char equal_type = NOT_EQUAL;
    down(&SetMainOutPutRegion_Semaphore);
    main_dispwin.srcx = m_dispwin.srcx;
    main_dispwin.srcy = m_dispwin.srcy;
    main_dispwin.src_wid = m_dispwin.src_wid;
    main_dispwin.src_height = m_dispwin.src_height;
    if(check_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY) == TRUE){
        rtd_pr_vsc_notice("\r\n####[ACTIVE] condition changed[RGB444 %d/%d], so force re-run scaler####\r\n", scaler_RGB444Mode_pre , rtk_hal_vsc_GetRGB444Mode());
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
        DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//trigger run scaler
        DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
        vsc_force_rerun_main_scaler = TRUE;
        update_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY);
        up(&SetMainOutPutRegion_Semaphore);
    } else if((srctype != VSC_INPUTSRC_AVD) && ((equal_type = check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre, &main_dispwin_for_only_xy)) != 0)//need to updatemain_input_size_pre and main_dispwin_for_only_xy always
			&& (Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)
#ifdef CONFIG_PST_ENABLE
			&& (Scaler_main_imd_pst_get_enable()==FALSE)
#endif
    ){
        up(&SetMainOutPutRegion_Semaphore);
        if ((srctype == VSC_INPUTSRC_VDEC) &&  Scaler_get_data_framesync(SLR_MAIN_DISPLAY)
        	&& (equal_type == ONLY_SHIFT_XY || equal_type == ONLY_SHIFT_Y)) {
        	down(&VSC_Semaphore);
        	zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, main_dispwin);
        	up(&VSC_Semaphore);
        } else {
        	rtd_pr_vsc_info("apply_only_xy_shift...\n");
        	apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
        }
    } else {
        if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){
        	rtd_pr_vsc_debug("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
        	DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
        } else {
        	rtd_pr_vsc_debug("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
        	DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
        }
        up(&SetMainOutPutRegion_Semaphore);
    }
}

void main_outputregion_scaler_handle(VSC_INPUT_TYPE_T srctype,StructSrcRect m_dispwin)
{
    down(&SetMainOutPutRegion_Semaphore);
    reset_any_srcrect(&main_dispwin_for_only_xy);
    main_dispwin.srcx = m_dispwin.srcx;
    main_dispwin.srcy = m_dispwin.srcy;
    main_dispwin.src_height = m_dispwin.src_height;
    main_dispwin.src_wid = m_dispwin.src_wid;
    if(check_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY) == TRUE){
        rtd_pr_vsc_notice("\r\n####[SEARCH] condition changed[RGB444 %d/%d], so force re-run scaler####\r\n", scaler_RGB444Mode_pre , rtk_hal_vsc_GetRGB444Mode());
        DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//trigger run scaler
        DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
        vsc_force_rerun_main_scaler = TRUE;
        update_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY);
    } else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH)||(check_input_and_output_the_same(SLR_MAIN_DISPLAY) == FALSE)) {
        Share_Memory_Set_Scaler_Run_Flag(1);
        DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
        if((Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)) {
        	DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//This is special case for VIP test
        	set_main_scaler_stop_flag(FALSE);//Let scaler can be run
        	rtd_pr_vsc_notice("\r\n####no mute on, so request run main scaler flow directly####\r\n");
        } else {
        	if((srctype == VSC_INPUTSRC_HDMI) && vfe_hdmi_drv_timing_ready())
        	{
        		DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//directly to run scaler
        		rtd_pr_vsc_debug("\r\n####func:%s hdmi directly run main scaler flow#####\r\n", __FUNCTION__);
        	}
        	else
        	{
        		DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
        		rtd_pr_vsc_debug("\r\n####func:%s src:%d request run main scaler flow#####\r\n", __FUNCTION__, srctype);
        	}
        	set_main_scaler_stop_flag(FALSE);//Let scaler can be run
        }
        if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
        	set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
        }
        complete(&vsc_scaler_tsk_completion);
    } else {
    	rtd_pr_vsc_debug("\r\n####func:%s src:%d main the input and output is the same#####\r\n", __FUNCTION__, srctype);
    }
    up(&SetMainOutPutRegion_Semaphore);
}

unsigned char main_outputregion_handle(KADP_VIDEO_RECT_T outregion,VSC_INPUT_TYPE_T srctype)
{
	StructSrcRect m_dispwin = {0}; //temp add by will
	unsigned char port_num = 0;
	unsigned char plane=0;
	if(main_InputRegion_0000)
	{
		rtd_pr_vsc_err("#####[%s(%d)]input is zero, return\n",__func__,__LINE__);
		return TRUE;
	}
	if ((outregion.w < 1) || (outregion.h < 1)) {
		down(&SetMainOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
		main_dispwin.srcx = outregion.x;
		main_dispwin.srcy = outregion.y;
		main_dispwin.src_height = outregion.h;
		main_dispwin.src_wid = outregion.w;
		check_input_and_output_the_same(SLR_MAIN_DISPLAY);
		up(&SetMainOutPutRegion_Semaphore);
		rtd_pr_vsc_emerg("outputregion is zero, return\n");
		return TRUE;
	}
	if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
		m_dispwin.srcx = 0;
		m_dispwin.srcy = 0;
		m_dispwin.src_height = _DISP_LEN;
		m_dispwin.src_wid = _DISP_WID;
	}else {
		m_dispwin.srcx = outregion.x;
		m_dispwin.srcy = outregion.y;
		m_dispwin.src_height = outregion.h;
		m_dispwin.src_wid = outregion.w;
	}
	if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) {
		atv_main_outputregion_handle(outregion,m_dispwin);
		return TRUE;
	}
	if (srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG)
	{
		port_num = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);

		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
			down(get_vo_infosemaphore());
			if(get_vo_change_flag(port_num))
			{
				up(get_vo_infosemaphore());
				if (Get_vo_smoothtoggle_timingchange_flag(SLR_MAIN_DISPLAY)) {
					if(get_vo_run_smooth_toggle_enable(SLR_MAIN_DISPLAY)) {
					} else {
						if (get_vo_smoothtoggle_state(SLR_MAIN_DISPLAY) == SLR_SMOOTH_TOGGLE_ACTIVE) {
							plane = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);;
							//vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(SLR_MAIN_DISPLAY), SLR_MAIN_DISPLAY);
							set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, SLR_MAIN_DISPLAY,plane);
							smooth_toggle_state_info_rpc(SLR_MAIN_DISPLAY);
							rtd_pr_vsc_debug("set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_INIT\n");
						}
					//	if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
							Share_Memory_Set_Scaler_Run_Flag(1);
						rtd_pr_vsc_notice("\r\n####Voinfo is change. Active to search 1####\r\n");
						Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					}
				} else {
					rtd_pr_vsc_notice("\r\n####Voinfo is change. Active to search 2####\r\n");
					Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				}
			} else {
				up(get_vo_infosemaphore());
			}

		}
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
			down(&SetMainOutPutRegion_Semaphore);
			reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
			up(&SetMainOutPutRegion_Semaphore);
		}
	}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if ((((get_rotate_mode(SLR_MAIN_DISPLAY)!=Get_Val_ap_roate_mode())) &&((get_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT) ||(Get_Val_ap_roate_mode()!=0)))
				|| ((Get_Val_ap_roate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)||(Get_Val_ap_roate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270)||(Get_Val_ap_roate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)))
	{
		rotate_outputregion_handle(m_dispwin);
	}else
#endif
	if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (DbgSclrFlgTkr.OuputDisplayMode || DbgSclrFlgTkr.OutputMemoryMode)) {		
            main_outputregion_smoothtoggle_handle(srctype, m_dispwin);
	}
	else if (DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode) {
            main_outputregion_scaler_handle(srctype, m_dispwin);
	}
	return TRUE;
}

unsigned char atv_sub_outputregion_handle(KADP_VIDEO_RECT_T outregion, StructSrcRect m_dispwin)
{
#ifdef CONFIG_DUAL_CHANNEL
	KADP_VIDEO_RECT_T tInputRegion;
#endif

	rtd_pr_vsc_debug("SetOutputRegion DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
	rtd_pr_vsc_debug("SetOutputRegion scaler state=%x\n", Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE));
	rtd_pr_vsc_debug("SetOutputRegion Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY)=%x\n", Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY));

	//rtd_pr_vsc_emerg( "SetOutputRegion DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
	//rtd_pr_vsc_emerg( "SetOutputRegion scaler state=%x\n", Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE));
	//rtd_pr_vsc_emerg( "SetOutputRegion Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY)=%x\n", Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY));

	rtk_hal_vsc_GetInputRegion(1, &tInputRegion);

	//rtd_pr_vsc_emerg( "SetOutputRegion rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);
	rtd_pr_vsc_debug("SetOutputRegion rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);


	if (DbgSclrFlgTkr.Sub_OutputVencMode) {
		down(&SetSubOutPutRegion_Semaphore);
		sub_dispwin.srcx = m_dispwin.srcx;
		sub_dispwin.srcy = m_dispwin.srcy;
		sub_dispwin.src_height = m_dispwin.src_height;
		sub_dispwin.src_wid = m_dispwin.src_wid;

		set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
		set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
		set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
		Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,hal_sub_InputRegionType);

		Scaler_SubDispWindowSet(sub_dispwin);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
		DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
		up(&SetSubOutPutRegion_Semaphore);
		return TRUE;
	} else if(DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {//For Sub black video issue patch will 20151211
		if (CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &outregion, &tInputRegion))
		{
			//rtd_pr_vsc_emerg( "0  ATV sub path, no forcebg, intput and output region are the same\n");
			rtd_pr_vsc_debug("0  ATV sub path, no forcebg, intput and output region are the same\n");
			return TRUE;
		}
		mute_control(SLR_SUB_DISPLAY, TRUE);/*Auto BG. Add by Will*/
		down(&SetSubOutPutRegion_Semaphore);
		sub_dispwin.srcx = m_dispwin.srcx;
		sub_dispwin.srcy = m_dispwin.srcy;
		sub_dispwin.src_height = m_dispwin.src_height;
		sub_dispwin.src_wid = m_dispwin.src_wid;
		set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
		//Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//For Sub black video issue patch will 20151211
		DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;

		rtd_pr_vsc_debug("\r\n####func:%s sub smooth toggle temp flow#####\r\n", __FUNCTION__);
		up(&SetSubOutPutRegion_Semaphore);
		return TRUE;
	}
	else if(Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
	{
		if (CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &outregion, &tInputRegion))
		{
			//rtd_pr_vsc_emerg( "1  ATV sub path, no forcebg, intput and output region are the same\n");
			rtd_pr_vsc_debug("1  ATV sub path, no forcebg, intput and output region are the same\n");
			DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
			DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
			return TRUE;
		}
	}
	down(&SetSubOutPutRegion_Semaphore);
	sub_dispwin.srcx = m_dispwin.srcx;
	sub_dispwin.srcy = m_dispwin.srcy;
	sub_dispwin.src_height = m_dispwin.src_height;
	sub_dispwin.src_wid = m_dispwin.src_wid;

	set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area

	if((Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE)) {
		DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;//This is special case for VIP test
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//Let scaler can be run
		rtd_pr_vsc_notice("\r\n####no mute on, so request run sub scaler flow for atv directly####\r\n");
	} else {
		DbgSclrFlgTkr.Sub_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler

		rtd_pr_vsc_debug("\r\n####func:%s request atv run sub scaler flow atv#####\r\n", __FUNCTION__);
	}
	if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
		set_source_info_forPQ(SLR_SUB_DISPLAY);//Set source info for PQ request befor scaler
	}
	up(&SetSubOutPutRegion_Semaphore);
	return TRUE;
}
unsigned char sub_outputregion_handle(KADP_VIDEO_RECT_T outregion,VSC_INPUT_TYPE_T srctype)
{
	StructSrcRect m_dispwin = {0}; //temp add by will
#ifdef CONFIG_DUAL_CHANNEL
	if (DbgSclrFlgTkr.Sub_OuputDisplayMode || DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode) {
		if ((outregion.w < 1) || (outregion.h < 1))
		{
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
				sub_dispwin_pre.srcx = outregion.x;
				sub_dispwin_pre.srcy = outregion.y;
				sub_dispwin_pre.src_height = outregion.h;
				sub_dispwin_pre.src_wid = outregion.w;
				up(&SetSubOutPutRegion_Semaphore);
				rtd_pr_vsc_err("sub outputregion is zero, return\n");
				return TRUE;
		}
		if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
			m_dispwin.srcx = 0;
			m_dispwin.srcy = 0;
			m_dispwin.src_height = _DISP_LEN;
			m_dispwin.src_wid = _DISP_WID;
		} else {
			m_dispwin.srcx = outregion.x;
			m_dispwin.srcy = outregion.y;
			m_dispwin.src_height = outregion.h;
			m_dispwin.src_wid = outregion.w;
		}

		if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) {
			atv_sub_outputregion_handle(outregion,m_dispwin);
			return TRUE;
		}

#if 1//for sub smooth toggle test
//if sub supports timing change flow ,need mark this code
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
			if ((srctype == VSC_INPUTSRC_VDEC) || (srctype == VSC_INPUTSRC_JPEG))
			{
				down(get_vo_infosemaphore());
				if(get_vo_change_flag(Get_DisplayMode_Port(SLR_SUB_DISPLAY)))
				{
						rtd_pr_vsc_debug("\r\n####Voinfo is change. Active to search 3####\r\n");
						Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				}
				up(get_vo_infosemaphore());
				if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetSubOutPutRegion_Semaphore);
				}
			}
		}
#endif
		if (DbgSclrFlgTkr.Sub_OutputVencMode) {
			down(&VSC_Semaphore);
			sub_dispwin.srcx = m_dispwin.srcx;
			sub_dispwin.srcy = m_dispwin.srcy;
			sub_dispwin.src_height = m_dispwin.src_height;
			sub_dispwin.src_wid = m_dispwin.src_wid;
			set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
			set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
			set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
			Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,hal_sub_InputRegionType);

			Scaler_SubDispWindowSet(sub_dispwin);
			DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
			set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
			rtk_output_connect(SLR_SUB_DISPLAY);
			Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//avoid main path display flag wrong
			up(&VSC_Semaphore);

		} else if (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
			down(&SetSubOutPutRegion_Semaphore);
			sub_dispwin.srcx = m_dispwin.srcx;
			sub_dispwin.srcy = m_dispwin.srcy;
			sub_dispwin.src_height = m_dispwin.src_height;
			sub_dispwin.src_wid = m_dispwin.src_wid;
			set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
			DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = TRUE;
			//DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
			//DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
			up(&SetSubOutPutRegion_Semaphore);
			rtd_pr_vsc_emerg( "\r\n####func:%s sub smooth toggle flow#####\r\n", __FUNCTION__);
		} else {
			down(&SetSubOutPutRegion_Semaphore);
			sub_dispwin.srcx = m_dispwin.srcx;
			sub_dispwin.srcy = m_dispwin.srcy;
			sub_dispwin.src_height = m_dispwin.src_height;
			sub_dispwin.src_wid = m_dispwin.src_wid;
			set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
			if(check_input_and_output_the_same(SLR_SUB_DISPLAY) == FALSE){//Check input and output parameter is the same or not
				if((Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE)) {
					DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;//This is special case for VIP test
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//Let scaler can be run
					rtd_pr_vsc_notice("\r\n####no mute on, so request run sub scaler flow directly####\r\n");
				} else {
					DbgSclrFlgTkr.Sub_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler

					rtd_pr_vsc_debug("\r\n####func:%s src:%d request run sub scaler flow#####\r\n", __FUNCTION__, srctype);
				}
				if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
					set_source_info_forPQ(SLR_SUB_DISPLAY);//Set source info for PQ request befor scaler
				}
			} else {
				rtd_pr_vsc_debug("\r\n####func:%s src:%d sub the input and output is the same#####\r\n", __FUNCTION__, srctype);
			}
			up(&SetSubOutPutRegion_Semaphore);
		}
		if(DbgSclrFlgTkr.sub_wind0000 == TRUE) {
			down(get_forcebg_semaphore());
			drvif_scalerdisplay_subdisplay_hidenfunc( _DISABLE);
			up(get_forcebg_semaphore());
			DbgSclrFlgTkr.sub_wind0000 = FALSE;
		}
	}
#endif
	return TRUE;
}

extern unsigned char Scaler_main_imd_pst_get_enable(void);
unsigned char rtk_hal_vsc_SetOutputRegion(VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion, unsigned short Wide, unsigned short High)
{
	VSC_INPUT_TYPE_T srctype = VSC_INPUTSRC_AVD;
	unsigned char channel = 0;
	//unsigned char avd_small_output_flag = FALSE;
	extern unsigned char rtk_hal_vsc_dm_connect(unsigned char display, KADP_VSC_HDR_TYPE_T eHdrMode);

	//rtd_pr_vsc_debug("rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
	//rtd_pr_vsc_emerg( "rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
	//frank@0323 add TV006_WB_Pattern_En to support output region function

#ifdef CONFIG_MEMC_BYPASS
	outregion.x = outregion.x/(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) +1);
	outregion.w = outregion.w/(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) +1);
	//rtd_pr_vsc_notice("after memc_bypass rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
#endif

    if(wid == VIDEO_WID_0)
    {
    	//if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetOutputRegion main output(%d %d %d %d) \n", outregion.x, outregion.y, outregion.w, outregion.h);
    	}
    }
	else
	{
		//if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetOutputRegion sub output(%d %d %d %d) \n", outregion.x, outregion.y, outregion.w, outregion.h);
    	}
	}

    vsc_adaptivestream_save_region((KADP_VIDEO_WID_T)wid, outregion);

	if (TRUE==pattern_LD_WB_handle(outregion)) {
		return TRUE;
	}
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif
	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}
	srctype = Get_DisplayMode_Src(channel);

	//rtd_pr_vsc_emerg( "rtk_hal_vsc_SetOutputRegion wid=%x  channel=%x\n", wid, channel);

	if(wid == VIDEO_WID_0) {
		main_outputregion_handle(outregion,srctype);
	} else if (wid == VIDEO_WID_1) {
		sub_outputregion_handle(outregion,srctype);
	}

	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetOutputRegion)(VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion, unsigned short Wide, unsigned short High) = rtk_hal_vsc_SetOutputRegion;

unsigned char check_input_output_valid(KADP_VIDEO_RECT_T inregion_parm, KADP_VIDEO_RECT_T originalInput_parm, KADP_VIDEO_RECT_T outregion_parm)
{//check input and output parameter is supported or not.  return TURE: valid, return False: unsupport
	#define MAX_SCALING_UP_FACTOR 32
	#define MAX_SCALING_DOWN_FACTOR 32

	if((inregion_parm.w > originalInput_parm.w) || (inregion_parm.h > originalInput_parm.h))
		return FALSE;//crop size bigger than source resolution
	if((outregion_parm.w > _DISP_WID) || (outregion_parm.h > _DISP_LEN))
		return FALSE;// output bigger than panel size.
	if(inregion_parm.w < outregion_parm.w)
	{//w scaling up case
		if((unsigned int)inregion_parm.w * MAX_SCALING_UP_FACTOR < (unsigned int)outregion_parm.w)//scaling up bigger than 32x
			return FALSE;
	}
	else if(inregion_parm.w > outregion_parm.w)
	{//w scaling down case
		if((unsigned int)outregion_parm.w * MAX_SCALING_DOWN_FACTOR < (unsigned int)inregion_parm.w)//scaling down bigger than 32x
			return FALSE;
	}

	if(inregion_parm.h < outregion_parm.h)
	{//h scaling up case
		if((unsigned int)inregion_parm.h * MAX_SCALING_UP_FACTOR < (unsigned int)outregion_parm.h)//scaling up bigger than 32x
			return FALSE;
	}
	else if(inregion_parm.h > outregion_parm.h)
	{//h scaling down case
		if((unsigned int)outregion_parm.h * MAX_SCALING_DOWN_FACTOR < (unsigned int)inregion_parm.h)//scaling down bigger than 32x
			return FALSE;
	}

	return TRUE;
}

void vsc_adaptivestream_save_region(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion)
{
	if((outregion.w == 0) || (outregion.h == 0))
		return;

	rtd_pr_vsc_emerg("air mode save display%d output(%d %d %d %d)", wid, outregion.x, outregion.y, outregion.w, outregion.h);

	if(wid == KADP_VIDEO_WID_0) {
		air_mode_save_outregion_parm[SLR_MAIN_DISPLAY] = outregion;
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1) {
		air_mode_save_outregion_parm[SLR_SUB_DISPLAY] = outregion;
	}
#endif
}


void scaler_airModeSendDispSize(unsigned char display, KADP_VIDEO_RECT_T outregion)
{
    int ret = 0;
    AIRMODE_DISP_SIZE_INFO sendDispInfo = {0};

    sendDispInfo.display = display;
    if(display == SLR_MAIN_DISPLAY)
    {
        sendDispInfo.main_output_x =  outregion.x;
        sendDispInfo.main_output_y =  outregion.y;
        sendDispInfo.main_output_w =  outregion.w;
        sendDispInfo.main_output_h =  outregion.h;
    } else if(display == SLR_SUB_DISPLAY) {
        sendDispInfo.sub_output_x =  outregion.x;
        sendDispInfo.sub_output_y =  outregion.y;
        sendDispInfo.sub_output_w =  outregion.w;
        sendDispInfo.sub_output_h =  outregion.h;
    }

    // change endian
    sendDispInfo.display = Scaler_ChangeUINT32Endian(sendDispInfo.display);

    sendDispInfo.main_output_x = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_x);
    sendDispInfo.main_output_y = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_y);
    sendDispInfo.main_output_w = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_w);
    sendDispInfo.main_output_h = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_h);

    sendDispInfo.sub_output_x = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_x);
    sendDispInfo.sub_output_y = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_y);
    sendDispInfo.sub_output_w = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_w);
    sendDispInfo.sub_output_h = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_h);

    // copy from RPC share memory
    memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALER_AIRMODE_SEND_DISP_SIZE), (unsigned char*)&sendDispInfo, sizeof(AIRMODE_DISP_SIZE_INFO));

    if ((ret = Scaler_SendRPC(SCALER_AIRMODE_SEND_DISP_SIZE, 0, 0)) < 0)
    {
        rtd_pr_vsc_emerg( "ret = %d, set SCALER_AIRMODE_SEND_DISP_SIZE to video fw fail !!!\n", ret );
        return;
    }

}

#endif

unsigned char scaler_borrowmemory_from_i3ddma_for_mdomain(void)
{
    set_force_i3ddma_enable(false);
    down(&Force_Run_Idma_Semaphore);
    if(I3DDMA_DolbyVision_HDMI_Init())//borrow i3ddma memory for m domain using
    {//borrow  memory fail
        up(&Force_Run_Idma_Semaphore);
#ifndef BUILD_QUICK_SHOW
        reset_ARC_cmd(SLR_MAIN_DISPLAY);
        reset_hdmi_timing_ready();
        vfe_hdmi_drv_handle_on_line_measure_error(0);
        down(get_hdmi_detectsemaphore());
        if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
            Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
            HDMI_set_detect_flag(TRUE);
        }
        up(get_hdmi_detectsemaphore());
 #endif
        rtd_pr_vsc_err("###[ERR] can not borrow memory from i3ddma ###\r\n");
        return 1;
    }
    else{
        up(&Force_Run_Idma_Semaphore);
        return 0;
    }
}

void vsc_adaptivestream_calc_outregion(unsigned char display)
{
    SLR_VOINFO* VOInfo = Scaler_VOInfoPointer(Get_DisplayMode_Port(display));
    unsigned int panel_ratio = 0;
    unsigned int source_ratio = 0;
    unsigned int oriWidth = 0;
    unsigned int oriHeight = 0;
    unsigned int source_wid = 0;
    unsigned int source_len = 0;
    StructSrcRect* pcustom_win_size = Get_Val_Scaler_DispWindowPnt();

    if((VOInfo == NULL) || (pcustom_win_size == NULL)) {
        return;
    }

    source_wid = VOInfo->src_h_wid;
    source_len = (VOInfo->progressive ? VOInfo->src_v_len : VOInfo->src_v_len*2);

    if(display == SLR_MAIN_DISPLAY) {
        if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) == ADAPTIVE_AIR_MODE) {
            panel_ratio = (unsigned int)source_len * main_dispwin.src_wid;
            source_ratio = (unsigned int)source_wid * main_dispwin.src_height;
            oriWidth = main_dispwin.src_wid;
            oriHeight = main_dispwin.src_height;

            if(panel_ratio > source_ratio){//Change panel width
                pcustom_win_size->src_wid = ((main_dispwin.src_height * source_wid * 100) / source_len + 50)/100;
                pcustom_win_size->src_height = main_dispwin.src_height;
                pcustom_win_size->srcx = main_dispwin.srcx + (ABS(pcustom_win_size->src_wid, oriWidth))/2;
                pcustom_win_size->srcy = main_dispwin.srcy;
            }else if(panel_ratio < source_ratio) {//Change panel height
                pcustom_win_size->src_wid = main_dispwin.src_wid;
                pcustom_win_size->src_height = ((source_len* main_dispwin.src_wid *100)/source_wid + 50 )/100 ;
                pcustom_win_size->srcx = main_dispwin.srcx;
                pcustom_win_size->srcy = main_dispwin.srcy + (ABS(pcustom_win_size->src_height, oriHeight))/2;
            } else {
                pcustom_win_size->src_wid = main_dispwin.src_wid;
                pcustom_win_size->src_height = main_dispwin.src_height;
                pcustom_win_size->srcx = main_dispwin.srcx;
                pcustom_win_size->srcy = main_dispwin.srcy;
                
            }

            //Scaler_DispWindowSet(main_dispwin);

            rtd_pr_vsc_info("adaptive stream air mode change display size (%d,%d,%d,%d)->(%d,%d,%d,%d)\r\n",  main_dispwin.srcx, main_dispwin.srcy,
                main_dispwin.src_wid, main_dispwin.src_height, pcustom_win_size->srcx, pcustom_win_size->srcy, pcustom_win_size->src_wid, pcustom_win_size->src_height);
        }
    }
#ifdef CONFIG_DUAL_CHANNEL
    else if(display == SLR_SUB_DISPLAY) {
        if (vsc_get_adaptivestream_flag(SLR_SUB_DISPLAY) == ADAPTIVE_AIR_MODE) {
            panel_ratio = (unsigned int)source_len * sub_dispwin.src_wid;
            source_ratio = (unsigned int)source_wid * sub_dispwin.src_height;
            oriWidth = sub_dispwin.src_wid;
            oriHeight = sub_dispwin.src_height;

            if(panel_ratio > source_ratio){//Change panel width
                DbgSclrFlgTkr.sub_zoom_disp_hsize = ((sub_dispwin.src_height * source_wid * 100) / source_len + 50)/100;
                DbgSclrFlgTkr.sub_zoom_disp_vsize = sub_dispwin.src_height;
                DbgSclrFlgTkr.sub_zoom_disp_hpos = sub_dispwin.srcx + (ABS(DbgSclrFlgTkr.sub_zoom_disp_hsize, oriWidth))/2;
                DbgSclrFlgTkr.sub_zoom_disp_vpos = sub_dispwin.srcy;
            }
            else if(panel_ratio < source_ratio) {//Change panel height
                DbgSclrFlgTkr.sub_zoom_disp_hsize = sub_dispwin.src_wid;
                DbgSclrFlgTkr.sub_zoom_disp_vsize = ((source_len* sub_dispwin.src_wid *100)/source_wid + 50 )/100 ;
                DbgSclrFlgTkr.sub_zoom_disp_hpos = sub_dispwin.srcx;
                DbgSclrFlgTkr.sub_zoom_disp_vpos = sub_dispwin.srcy + (ABS(DbgSclrFlgTkr.sub_zoom_disp_vsize, oriHeight))/2;
            }
            else
            {
                DbgSclrFlgTkr.sub_zoom_disp_hsize = sub_dispwin.src_wid;
                DbgSclrFlgTkr.sub_zoom_disp_vsize = sub_dispwin.src_height;
                DbgSclrFlgTkr.sub_zoom_disp_hpos = sub_dispwin.srcx;
                DbgSclrFlgTkr.sub_zoom_disp_vpos = sub_dispwin.srcy;
            }

            //Scaler_SubDispWindowSet(sub_dispwin);

            rtd_pr_vsc_info("sub adaptive stream air mode change display size (%d,%d,%d,%d)->(%d,%d,%d,%d)\r\n",  sub_dispwin.srcx, sub_dispwin.srcy,
                sub_dispwin.src_wid, sub_dispwin.src_height, DbgSclrFlgTkr.sub_zoom_disp_hpos, DbgSclrFlgTkr.sub_zoom_disp_vpos, DbgSclrFlgTkr.sub_zoom_disp_hsize, DbgSclrFlgTkr.sub_zoom_disp_vsize);
        }
    }
#endif
#ifndef BUILD_QUICK_SHOW
    scaler_airModeSendDispSize(display, air_mode_save_outregion_parm[display]);
#endif
}

#ifndef BUILD_QUICK_SHOW
void scaler_SendDispSize(StructSrcRect outregion)
{
	int ret;
	unsigned long i = 0, ulItemCount = 0;
	unsigned short *pulTemp;
    SEND_DISP_SIZE_INFO sendDispInfo;

	ulItemCount = sizeof(SEND_DISP_SIZE_INFO) / sizeof(unsigned short);

    sendDispInfo.output_x =  outregion.srcx;
    sendDispInfo.output_y =  outregion.srcy;
    sendDispInfo.output_w =  outregion.src_wid;
    sendDispInfo.output_h =  outregion.src_height;
    sendDispInfo.rotate_type = (unsigned short)get_rotate_mode(SLR_MAIN_DISPLAY);

    pulTemp = (unsigned short *)&sendDispInfo;

	// change endian
	for (i = 0; i < ulItemCount; i++)
		pulTemp[i] = Scaler_ChangeUINT16Endian(pulTemp[i]);

	// copy from RPC share memory
	memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALER_SEND_DISP_SIZE_RERUN_VO), &sendDispInfo, sizeof(SEND_DISP_SIZE_INFO));

	if ((ret = Scaler_SendRPC(SCALER_SEND_DISP_SIZE_RERUN_VO, 0, 0)) < 0)
	{
		rtd_pr_vsc_emerg( "ret = %d, set SCALER_SEND_DISP_SIZE_RERUN_VO to video fw fail !!!\n", ret );
		return;
	}

}


unsigned char rtk_hal_vsc_SetInputRegion_OutputRegion(KADP_VIDEO_WID_T wid, KADP_VSC_ROTATE_T rotate_type, KADP_VIDEO_RECT_T  inregion,
	KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion, unsigned char null_input, unsigned char null_output)
{

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
	extern unsigned char check_pst_active_state(unsigned char display);//Return TRUE: active state can run pst. Return False: not active state can not run pst
	unsigned long flags = 0;//for spin_lock_irqsave
	unsigned char is_atv = FALSE;

	if(null_input && null_output)
	{
		return TRUE;//input output both are null. directly return for LG spec
	}
	/*
	rtd_pr_vsc_debug("rtk_hal_vsc_SetInputRegion_OutputRegion()\n");
	rtd_pr_vsc_debug("wid=%x, inregion x=%d, y=%d, width=%d, height=%d\n", wid, inregion.x, inregion.y, inregion.w, inregion.h);
	rtd_pr_vsc_debug("wid=%x, outregion x=%d, y=%d, width=%d, height=%d\n", wid, outregion.x, outregion.y, outregion.w, outregion.h);
	rtd_pr_vsc_debug("null_input=%x, null_output=%x\n", null_input, null_output);
	*/
	if(wid == KADP_VIDEO_WID_0)
	{
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			is_atv = TRUE;//vsc connect atv

		down(&new_input_output_main_sem);//lock semaphore
		if (!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) || is_atv || (check_pst_active_state(SLR_MAIN_DISPLAY) == FALSE))//PST not ready state. or ATV case
		{//atv alwasy set original input and output
			if(null_input)
			{//input is null
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{//no need to copy input. input is null
					if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}

					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_main_rotate_type_parm = rotate_type;//copy rotate type
					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{//no need to copy output. output is null
					if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_main_rotate_type_parm = rotate_type;//copy rotate type
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;
					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
				}
			}
			else
			{
				//RTKREQ-456 : patch for scaler flow update osd callback delay to webos.
				if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
					Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region(outregion);

				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else if((inregion.w == 0) || (inregion.h == 0))
				{//input zero but output is not zero
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					}
				}
				else
				{
					if(!check_input_output_valid(inregion, originalInput, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_main_rotate_type_parm = rotate_type;//copy rotate type
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;

					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						if(is_atv){//avoid of mute off earlier video output
							//rtd_pr_vsc_info("#####[%s(%d)]Scaler_AVD_GetRunSearchState=%d\n",__func__,__LINE__,Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY));
							//if(Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY) == FALSE)
							//	trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}else{
							VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
							if (srctype == VSC_INPUTSRC_VDEC) {
								unsigned char wait_mute_off = FALSE;
								int port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
								down(get_vo_infosemaphore());
								if ((get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY)) == false) && (get_vo_avsync_flag(port) == TRUE)) {//vo no change and vo av sync ready
									trigger_mute_off(SLR_MAIN_DISPLAY, 1);
								}
								else
								{
									wait_mute_off = TRUE;
								}
								up(get_vo_infosemaphore());
								if(wait_mute_off)
								{
									rtd_pr_vsc_info("### func:%s line:%d wait scaler or smooth toggle mute off##\r\n",__FUNCTION__, __LINE__);
								}
							} else {
								trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
							}
						}
					}

				}
			}
		}
		else
		{//active state
			if(rotate_type != ap_main_rotate_type_parm)
			{//rotate case
				if(null_input)
				{//input is null
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy input. input is null
						if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}


					}
				}
				else if(null_output)
				{//output is null
					if((inregion.w == 0) || (inregion.h == 0))
					{//input is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy output. output is null
						if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}
					}
				}
				else
				{
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else if((inregion.w == 0) || (inregion.h == 0))
					{//input zero
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
						{
							spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
							ap_main_rotate_type_parm = rotate_type;//copy rotate type
							//copy output region
							ap_main_outregion_parm.x = outregion.x;
							ap_main_outregion_parm.y = outregion.y;
							ap_main_outregion_parm.w = outregion.w;
							ap_main_outregion_parm.h = outregion.h;
							main_arc_change_flag = TRUE;
							spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
							wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						}
					}
					else
					{
						if(!check_input_output_valid(inregion, originalInput, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;

						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;

						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute on. set the mask
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}

					}
				}

			}
			else
			{//non rotate case
#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
				//ensure pst can work on inerrupt.
				scaler_imd_pst_enable_interrupt();
#endif
#endif
				if(null_input)
				{//input is snull
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy input. input is null
						if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}


					}
				}
				else if(null_output)
				{//output is null
					if((inregion.w == 0) || (inregion.h == 0))
					{//input is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy output. output is null
						if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute on. set the mask
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}
					}
				}
				else
				{//input and output is not null
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else if((inregion.w == 0) || (inregion.h == 0))
					{//input zero
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

					}
					else
					{//normal case
						if(!check_input_output_valid(inregion, originalInput, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;

						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;

						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}

					}
				}

			}
		}
		vsc_adaptivestream_save_region(wid, ap_main_outregion_parm);
		up(&new_input_output_main_sem);//unlock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_MAXN)
				return TRUE;//no connect source

		down(&new_input_output_sub_sem);//lock semaphore
		if(check_pst_active_state(SLR_SUB_DISPLAY) == FALSE){
			if(null_input)
			{//input is null

				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{

					if(!check_input_output_valid(ap_sub_inregion_parm, ap_sub_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_SUB_DISPLAY, TRUE);
						up(&new_input_output_sub_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					sub_hidden = FALSE;
					if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
						//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					sub_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, ap_sub_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				sub_hidden = FALSE;
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				sub_arc_change_flag = TRUE;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

			}
			else
			{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
						//copy output region
						ap_sub_outregion_parm.x = outregion.x;
						ap_sub_outregion_parm.y = outregion.y;
						ap_sub_outregion_parm.w = outregion.w;
						ap_sub_outregion_parm.h = outregion.h;
						sub_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					}
					up(&new_input_output_sub_sem);//unlock semaphore
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, outregion))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				sub_hidden = FALSE;
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;

				//copy output region
				ap_sub_outregion_parm.x = outregion.x;
				ap_sub_outregion_parm.y = outregion.y;
				ap_sub_outregion_parm.w = outregion.w;
				ap_sub_outregion_parm.h = outregion.h;

				sub_arc_change_flag = TRUE;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

			}
		} else {
#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			//ensure pst can work on inerrupt.
			scaler_imd_pst_enable_interrupt();
#endif
#endif
			if(null_input)
			{//input is null
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{

					if(!check_input_output_valid(ap_sub_inregion_parm, ap_sub_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_SUB_DISPLAY, TRUE);
						up(&new_input_output_sub_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
					if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
						trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
					#if 0 //for hidden
					if(sub_hidden)
					{
						sub_hidden = FALSE;
						drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
					}
					#endif
				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, ap_sub_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				#if 0//for hidden
				if(sub_hidden)
				{
					sub_hidden = FALSE;
					drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
				}
				#endif
			}
			else
			{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
					up(&new_input_output_sub_sem);//unlock semaphore
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, outregion))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				//copy output region
				ap_sub_outregion_parm.x = outregion.x;
				ap_sub_outregion_parm.y = outregion.y;
				ap_sub_outregion_parm.w = outregion.w;
				ap_sub_outregion_parm.h = outregion.h;

                vsc_adaptivestream_save_region(wid, ap_sub_outregion_parm);
                
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				#if 0//for hidden
				if(sub_hidden)
				{
					sub_hidden = FALSE;
					drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
				}
				#endif
			}
		}
		up(&new_input_output_sub_sem);//unlock semaphore
	}
#endif
	return TRUE;


#else//#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG //original input and output flow
	VIDEO_RECT_T inregion_parm;//for new input output.
	VIDEO_RECT_T originalInput_parm;//for new input output. input resolution parameter
	unsigned char mute_off_flag = FALSE;//currently parameter is normal mute off

	rtd_pr_vsc_info("\r\n#### func:%s null(%d %d) in(%d %d %d %d) ori(%d %d %d %d) out(%d %d %d %d)####\r\n", __FUNCTION__, null_input, null_output, inregion.x, inregion.y, inregion.w, inregion.h,
	originalInput.x, originalInput.y, originalInput.w, originalInput.h, outregion.x, outregion.y, outregion.w, outregion.h);


	if(null_input && null_output)
	{
		return TRUE;//input output both are null. directly return for LG spec
	}

	if(wid == KADP_VIDEO_WID_0)
		;//window_id = VIDEO_WID_0;
	else if(wid == KADP_VIDEO_WID_1)
		;//window_id = VIDEO_WID_1;
	else
	{
		rtd_pr_vsc_err("\r\n### func:%s wid:%d error###\r\n",__FUNCTION__, wid);
		return FALSE;
	}

	if(wid == KADP_VIDEO_WID_0)
	{
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		down(&new_input_output_main_sem);//lock semaphore
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		//rotate part
		down(&SetMainOutPutRegion_Semaphore);
		main_rotate_mode_pre = Get_Val_ap_roate_mode();
		Set_Val_ap_rotate_mode((DIRECT_VO_FRAME_ORIENTATION) rotate_type);
		up(&SetMainOutPutRegion_Semaphore);

#endif
		virtual_w = true_wide;//magnify and livezoom use
		virtual_h = true_high;//magnify and livezoom use
		if(null_input)
		{//input is snull
			if((outregion.w == 0) || (outregion.h == 0))
			{//output is zero not null. need to mute
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
				mute_control(SLR_MAIN_DISPLAY, TRUE);
				up(&new_input_output_main_sem);//unlock semaphore
				rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
				return TRUE;
			}
			else
			{//no need to copy input. input is null
				//copy output region
				ap_main_outregion_parm.x = outregion.x;
				ap_main_outregion_parm.y = outregion.y;
				ap_main_outregion_parm.w = outregion.w;
				ap_main_outregion_parm.h = outregion.h;
				if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				mute_off_flag = TRUE;//need try mute off
			}
		}
		else if(null_output)
		{//output is null
			if((inregion.w == 0) || (inregion.h == 0))
			{//input is zero not null. need to mute
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
				mute_control(SLR_MAIN_DISPLAY, TRUE);
				up(&new_input_output_main_sem);//unlock semaphore
				rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
				return TRUE;
			}
			else
			{//no need to copy output. output is null

				//copy input region
				ap_main_inregion_parm.x = inregion.x;
				ap_main_inregion_parm.y = inregion.y;
				ap_main_inregion_parm.w = inregion.w;
				ap_main_inregion_parm.h = inregion.h;

				//copy original input region
				ap_main_originalInput_parm.x = originalInput.x;
				ap_main_originalInput_parm.y = originalInput.y;
				ap_main_originalInput_parm.w = originalInput.w;
				ap_main_originalInput_parm.h = originalInput.h;
				if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}

				mute_off_flag = TRUE;//need try mute off
			}
		}
		else
		{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else if((inregion.w == 0) || (inregion.h == 0))
				{//input zero but output is not zero
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					mute_off_flag = FALSE;
				}
				else
				{
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					mute_off_flag = TRUE;//need try mute off
				}
		}

		//copy input
		inregion_parm.x = ap_main_inregion_parm.x;
		inregion_parm.y = ap_main_inregion_parm.y;
		inregion_parm.w = ap_main_inregion_parm.w;
		inregion_parm.h = ap_main_inregion_parm.h;

		//copy input
		originalInput_parm.x = ap_main_originalInput_parm.x;
		originalInput_parm.y = ap_main_originalInput_parm.y;
		originalInput_parm.w = ap_main_originalInput_parm.w;
		originalInput_parm.h = ap_main_originalInput_parm.h;

		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, inregion_parm, originalInput_parm);//normal parameter case to call input
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, ap_main_outregion_parm, virtual_w, virtual_h);//normal parameter case to call output
		if(mute_off_flag)
		{//norma parameter case need to mute off
			if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
			{//previou mute on
				rtd_pr_vsc_info("#####[%s(%d)] trigger_mute_off\r\n",__func__,__LINE__);
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
			}
		}
		up(&new_input_output_main_sem);//unlock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		down(&new_input_output_sub_sem);//lock semaphore
		virtual_w = true_wide;//magnify and livezoom use
		virtual_h = true_high;//magnify and livezoom use
		//copy input region
		ap_sub_inregion_parm.x = inregion.x;
		ap_sub_inregion_parm.y = inregion.y;
		ap_sub_inregion_parm.w = inregion.w;
		ap_sub_inregion_parm.h = inregion.h;

		//copy original input region
		ap_sub_originalInput_parm.x = originalInput.x;
		ap_sub_originalInput_parm.y = originalInput.y;
		ap_sub_originalInput_parm.w = originalInput.w;
		ap_sub_originalInput_parm.h = originalInput.h;

		//copy output region
		ap_sub_outregion_parm.x = outregion.x;
		ap_sub_outregion_parm.y = outregion.y;
		ap_sub_outregion_parm.w = outregion.w;
		ap_sub_outregion_parm.h = outregion.h;

		inregion_parm.x = ap_sub_inregion_parm.x;
		inregion_parm.y = ap_sub_inregion_parm.y;
		inregion_parm.w = ap_sub_inregion_parm.w;
		inregion_parm.h = ap_sub_inregion_parm.h;


		originalInput_parm.x = ap_sub_originalInput_parm.x;
		originalInput_parm.y = ap_sub_originalInput_parm.y;
		originalInput_parm.w = ap_sub_originalInput_parm.w;
		originalInput_parm.h = ap_sub_originalInput_parm.h;

		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, inregion_parm, originalInput_parm);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, ap_sub_outregion_parm, virtual_w, virtual_h);
		up(&new_input_output_sub_sem);//unlock semaphore
	}
#endif
#endif

	return TRUE;

}

#ifndef UT_flag
unsigned char rtk_hal_vsc_SetSplitInfoForHDMI(void)
{
	rtd_pr_vsc_info("rtk_hal_vsc_SetSplitInfoForHDMI() called\n");

	//TODO: implement API


	return TRUE;
}
#endif

unsigned char rtk_hal_vsc_SetWinFreeze(VIDEO_WID_T wid, bool bonoff)
{
	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;

	if (wid == VIDEO_WID_0) {
  		channel = SLR_MAIN_DISPLAY;
 		// DbgSclrFlgTkr.mainVscFreezeFlag = bonoff;
 	} else if (wid == VIDEO_WID_1) {
  		channel = SLR_SUB_DISPLAY;
 		// DbgSclrFlgTkr.subVscFreezeFlag = bonoff;
	}

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid != VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif
	down(&VSC_Semaphore);
	if (wid == VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
		DbgSclrFlgTkr.mainVscFreezeFlag = bonoff;
	} else if (wid == VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
		DbgSclrFlgTkr.subVscFreezeFlag = bonoff;
	}
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if ((channel == SLR_MAIN_DISPLAY) && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)) {
		DbgSclrFlgTkr.main_winfreeze=bonoff;
	} else {
		Scaler_SetFreeze(channel, bonoff);
	}
	up(&VSC_Semaphore);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetWinFreeze)(VIDEO_WID_T wid, bool bonoff) = rtk_hal_vsc_SetWinFreeze;


static unsigned char ForceSmoothtoggleGo = FALSE;

unsigned char get_ForceSmoothtoggleGo(void)
{
	return ForceSmoothtoggleGo;
}

void SelfDiagnosis_mainscaler_run(SCALER_DISP_CHANNEL channel, VIDEO_RECT_T inregion, VIDEO_RECT_T outregion)
{
	if (channel == SLR_MAIN_DISPLAY) {
		/*re run main scaler start*/
		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
		set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
		set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);

		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
		mute_control(SLR_MAIN_DISPLAY, TRUE);
		//Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH); //Remove by Will
		down(&SetMainOutPutRegion_Semaphore);
		if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
			main_dispwin.srcx = 0;
			main_dispwin.srcy = 0;
			main_dispwin.src_height = _DISP_LEN;
			main_dispwin.src_wid = _DISP_WID;
		} else {
			main_dispwin.srcx = outregion.x;
			main_dispwin.srcy = outregion.y;
			main_dispwin.src_height = outregion.h;
			main_dispwin.src_wid = outregion.w;
		}
		Scaler_DispWindowSet(main_dispwin);
		up(&SetMainOutPutRegion_Semaphore);

		down(&VSC_Semaphore);
		set_main_scaler_stop_flag(FALSE);
		if (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) {
			DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
		}
		set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
		rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);
		mute_control(SLR_MAIN_DISPLAY, FALSE);
	}
#ifdef CONFIG_DUAL_CHANNEL
    else if (channel == SLR_SUB_DISPLAY) {
		/*re run sub scaler start*/
		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;
		set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
		set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
		set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
		mute_control(SLR_SUB_DISPLAY, TRUE);
		//Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH); //Remove by Will
		down(&SetSubOutPutRegion_Semaphore);
		if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
			sub_dispwin.srcx = 0;
			sub_dispwin.srcy = 0;
			sub_dispwin.src_height = _DISP_LEN;
			sub_dispwin.src_wid = _DISP_WID;
		} else {
			sub_dispwin.srcx = outregion.x;
			sub_dispwin.srcy = outregion.y;
			sub_dispwin.src_height = outregion.h;
			sub_dispwin.src_wid = outregion.w;
		}
		Scaler_SubDispWindowSet(sub_dispwin);
		up(&SetSubOutPutRegion_Semaphore);

		down(&VSC_Semaphore);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
		set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
		rtk_output_connect(SLR_SUB_DISPLAY);
		up(&VSC_Semaphore);
		mute_control(SLR_SUB_DISPLAY, FALSE);
	}

#endif
}
#endif
unsigned static char Factory_SelfDiagnosis_Mode = FALSE;

void Set_Factory_SelfDiagnosis_Mode(unsigned char mode)
{
	Factory_SelfDiagnosis_Mode = mode;
}

unsigned char Get_Factory_SelfDiagnosis_Mode(void)
{
	return Factory_SelfDiagnosis_Mode;
}

#ifndef BUILD_QUICK_SHOW
unsigned char change_vscinput_with_vfetiming(SCALER_DISP_CHANNEL channel)
{
	VIDEO_RECT_T  inregion;
	VIDEO_RECT_T outregion;
	unsigned int timeoutcount;

	timeoutcount = 60;
	do {
		if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			&&(Check_ForceBG_Mask_Enable(channel, TRUE)==FALSE))
		{
			break;
		} else {
			msleep(200);
		}
		timeoutcount--;
	} while(timeoutcount);

	if(timeoutcount==0)
		rtd_pr_vsc_notice("wait active timeoutcount 0#####[%s(%d)]\n", __FUNCTION__, __LINE__);


	if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
		if(channel == SLR_MAIN_DISPLAY) {
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
			//self-dianosis AV source have to do no overscan @Crixus 20151201
			if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD){
				//self-dianosis AV source, rzhen@2016-09-01
				if(read_buffer_first_flag) return TRUE;
				read_buffer_first_flag = 1;

				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				main_input_size.srcx = inregion.x;
				main_input_size.srcy = inregion.y;
				main_input_size.src_wid = inregion.w;
				main_input_size.src_height = inregion.h;
				set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;

				main_dispwin.srcx = outregion.x;
				main_dispwin.srcy = outregion.y;
				main_dispwin.src_height = outregion.h;
				main_dispwin.src_wid = outregion.w;
				Scaler_DispWindowSet(main_dispwin);

				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}

				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Let main path run scaler again
				up(&SetMainOutPutRegion_Semaphore);
				msleep(1000);
			}
			else
#endif
			{
				StructSrcRect maindispwind;

				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;
				maindispwind = Scaler_DispWindowGet();
				if((inregion.x != Main_InputRegion_x)
					||(inregion.y != Main_InputRegion_y)
					||(inregion.w != Main_InputRegion_w)
					||(inregion.h != Main_InputRegion_h)
					||(maindispwind.srcx != outregion.x)
					||(maindispwind.srcy != outregion.y)
					||(maindispwind.src_wid != outregion.w)
					||(maindispwind.src_height != outregion.h)
					||dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY)
					){

					rtd_pr_vsc_notice("#####[%s(%d)] \n", __FUNCTION__, __LINE__);
					SelfDiagnosis_mainscaler_run(SLR_MAIN_DISPLAY, inregion, outregion);
					msleep(1000);
				}
			}
		} else if (channel == SLR_SUB_DISPLAY){
#if 0//def CONFIG_ENABLE_VD_27MHZ_MODE
			//self-dianosis AV source have to do no overscan @Crixus 20151201
			if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_AVD){
				if(read_buffer_first_flag == 0){
					read_buffer_first_flag = 1;
					Scaler_AVD_EnableVD27MMode(VD_27M_OFF);
					msleep(1000);
					rtd_pr_vsc_debug("[self-dianosis]read buffrt 27M on !!\n");
				}
			} else
#endif
#ifdef CONFIG_DUAL_CHANNEL
			{
				StructSrcRect subdispwind;
				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;
				subdispwind = Scaler_SubDispWindowGet();
				if((inregion.x != Main_InputRegion_x)
					||(inregion.y != Main_InputRegion_y)
					||(inregion.w != Main_InputRegion_w)
					||(inregion.h != Main_InputRegion_h)
					||(subdispwind.srcx != outregion.x)
					||(subdispwind.srcy != outregion.y)
					||(subdispwind.src_wid != outregion.w)
					||(subdispwind.src_height != outregion.h)
					) {
					SelfDiagnosis_mainscaler_run(SLR_SUB_DISPLAY, inregion, outregion);
				}
			}
 #endif
		}
		return TRUE;
	} else {
		rtd_pr_vsc_notice("wait active NG#####[%s(%d)]\n", __FUNCTION__, __LINE__);
		return FALSE;
	}
}

unsigned char rtk_hal_vsc_FreezeVideoFrameBuffer(VIDEO_WID_T wid, bool bonoff)
{
	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}

	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_pr_vsc_notice("change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	drvif_scalerdisplay_set_freeze(channel, bonoff);
	Scaler_SetDisplaySingleBufferMode(channel, bonoff);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_FreezeVideoFrameBuffer)(VIDEO_WID_T wid, bool bonoff) = rtk_hal_vsc_FreezeVideoFrameBuffer;

unsigned char rtk_hal_vsc_ReadVideoFrameBuffer(VIDEO_WID_T wid, VIDEO_RECT_T * pin,KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pRead, KADP_VIDEO_DDI_COLOR_STANDARD_T *pColor_standard, KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T * pPixelColorFormat)
{
	unsigned int linesize = 0;
	unsigned char * capturebufferaddr = NULL;
	unsigned int capturebuffersize = 0;
	unsigned int capturebufferphyaddr = 0;

	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;
	KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * readaddr = pRead;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	} else {
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
	

	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_pr_vsc_notice("change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	if (pRead == NULL) {
		rtd_pr_vsc_debug("pRead == NULL not ok\n");
		return FALSE;
	}

	rtd_pr_vsc_debug("x=%d;;y=%d;;w=%d;;h=%d\n", pin->x, pin->y, pin->w,pin->h);
	if(((pin->x+pin->w)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID)) || ((pin->y+pin->h)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_LEN)))
	{
		rtd_pr_vsc_debug("wrong ReadVideoFrameBuffer size!!!!!!!\n");
		return FALSE;
	}

	//linesize = memory_get_capture_size(channel, MEMCAPTYPE_LINE);
	//linesize = drvif_memory_get_data_align(linesize, DMA_SPEEDUP_ALIGN_VALUE/8);

	//linesize = SHL(linesize, 3); //unit conversion. 64bits to 8bits

	if (channel == SLR_MAIN_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_MainLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_mainblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_MAIN);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_MAIN);
	} else if (channel == SLR_SUB_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_SubLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_subblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_SUB);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_SUB);
	}
	else
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}

	//dmac_inv_range(capturebufferaddr, capturebufferaddr + capturebuffersize);
	//outer_inv_range(capturebufferphyaddr, capturebufferphyaddr + capturebuffersize);

	rtd_pr_vsc_debug("linesize==%d\n",linesize);
	if(capturebufferaddr)
	{
		rtd_pr_vsc_debug("capturebufferaddr==%lx\n",drvif_memory_get_mainblock_viraddr());
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[0],capturebufferaddr[1],capturebufferaddr[2],capturebufferaddr[3]);
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[4],capturebufferaddr[5],capturebufferaddr[6],capturebufferaddr[7]);
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[8],capturebufferaddr[9],capturebufferaddr[10],capturebufferaddr[11]);
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[12],capturebufferaddr[13],capturebufferaddr[14],capturebufferaddr[15]);
	}
	rtd_pr_vsc_notice("SLR_DISP_10BIT = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_10BIT)));
	rtd_pr_vsc_notice("SLR_DISP_422CAP = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_422CAP)));


	if(Scaler_DispGetStatus(channel, SLR_DISP_10BIT))
	{
		rtd_pr_vsc_notice("SLR_DISP_10BIT no support read write m domain\n");
		return FALSE;
#if	0
		* pPixelColorFormat = KADP_VIDEO_DDI_PIXEL_10BIT;
		* pColor_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//10bit 422 format
		{
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			unsigned int arraynum = ((pin->x+pin->w)%2)?(pin->x+pin->w+1):(pin->x+pin->w);
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
				for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					if(remainbit<10)
					{
						lowvalue = value4byte;
						value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
						highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
					}
					else
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCb = highvalue;
							linepixel[i+1].pixelStandardCb = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardY = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardCr= highvalue;
							linepixel[i+1].pixelStandardCr = highvalue;
							colorindex = 3;
							break;
						case 3:
							linepixel[i+1].pixelStandardY = highvalue;
							colorindex = 0;
							i = i+2;
							break;
					}
				}
				memcpy((unsigned char *)(readaddr+p*pin->w), (unsigned char *)(linepixel+pin->x), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		else//10bit 444 format
		{
			unsigned int *linebuffer=NULL;
			unsigned int *srclineptr;
			unsigned int tempvalue;
			unsigned int arraynum = pin->x+pin->w;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<(pin->x+pin->w);)
				{
					if(remainbit<10)
			       		 {
			           		lowvalue = value4byte;
			        		value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
					    	highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
			        	}
					else
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCr = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardCb = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardY= highvalue;
							colorindex = 0;
							i++;
							break;
					}
				}
				memcpy((unsigned char *)(readaddr+p*pin->w), (unsigned char *)(linepixel+pin->x), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		return TRUE;
#endif
	}
	else
	{
		unsigned int i,k;
		* pPixelColorFormat = KADP_VIDEO_DDI_PIXEL_8BIT;
		* pColor_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//8bit 422 format
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					readaddr->pixelStandardY = capturebufferaddr[i*linesize+2*k];
					readaddr->pixelStandardCb = capturebufferaddr[i*linesize+2*(k/2)*2+1];
					readaddr->pixelStandardCr = capturebufferaddr[i*linesize+2*(k/2)*2+3];
					readaddr ++;
				}
			}
		}
		else//8bit 444 fromat
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					readaddr->pixelStandardY= capturebufferaddr[i*linesize+3*k+2];
					readaddr->pixelStandardCb= capturebufferaddr[i*linesize+3*k+1];
					readaddr->pixelStandardCr= capturebufferaddr[i*linesize+3*k];
					readaddr++;
				}
			}
		}
		return TRUE;
	}
}
unsigned char (*fp_rtk_hal_vsc_ReadVideoFrameBuffer)(VIDEO_WID_T wid, VIDEO_RECT_T * pin,
		KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pRead,
		KADP_VIDEO_DDI_COLOR_STANDARD_T *pColor_standard,
		KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T *pPixelColorFormat)
	= rtk_hal_vsc_ReadVideoFrameBuffer;


unsigned char rtk_hal_vsc_WriteVideoFrameBuffer(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pin,KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pWrite)
{
	unsigned int linesize = 0;
	unsigned char * capturebufferaddr = NULL;
	unsigned int capturebuffersize = 0;
	unsigned int capturebufferphyaddr = 0;

	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;
	KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * writeaddr = pWrite;
	rtd_pr_vsc_debug("pWrite = %lx\n",(unsigned long)pWrite);
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==KADP_VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==KADP_VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	} else {
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
	

	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_pr_vsc_notice("change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	if(pWrite == NULL)
	{
		rtd_pr_vsc_debug("pWrite == NULL not ok\n");
		return FALSE;
	}
	rtd_pr_vsc_debug("x=%d;;y=%d;;w=%d;;h=%d\n", pin->x, pin->y, pin->w, pin->h);

	if(((pin->x+pin->w)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID))||((pin->y+pin->h)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_LEN)))
	{
		rtd_pr_vsc_debug("wrong WriteVideoFrameBuffer size!!!!!!!\n");
		return FALSE;
	}

	//linesize = memory_get_capture_size(channel, MEMCAPTYPE_LINE);
	//linesize = SHL(linesize, 3); //unit conversion. 64bits to 8bits


	if (channel == SLR_MAIN_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_MainLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_mainblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_MAIN);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_MAIN);
	} else if (channel == SLR_SUB_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_SubLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_subblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_SUB);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_SUB);
	}
	else
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
	
	rtd_pr_vsc_debug("linesize = %d\n",linesize);
	if(capturebufferaddr)
	{
		rtd_pr_vsc_debug("capturebufferaddr = %lx\n",(unsigned long)capturebufferaddr);
	}
	rtd_pr_vsc_notice("SLR_DISP_10BIT = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_10BIT)));
	rtd_pr_vsc_notice("SLR_DISP_422CAP = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_422CAP)));

	if(Scaler_DispGetStatus(channel, SLR_DISP_10BIT))
	{
		rtd_pr_vsc_notice("SLR_DISP_10BIT no support read write m domain\n");

		return FALSE;
#if 0
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//422 10bit fomat
		{
			unsigned int arraynum = Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID);
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel=NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;

			rtd_pr_vsc_debug("arraynum = %d\n",arraynum);
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif

			rtd_pr_vsc_debug("linebuffer = %lx\n",(unsigned long)linebuffer);
			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
				for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					rtd_pr_vsc_debug("arraynum = %d\n",arraynum);
					if((remainbit<10)&&(remainbit>=0))
					{
						lowvalue = value4byte;
						value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
						highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
					}
					else if((remainbit>=10)&&(remainbit<=32))
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCb = highvalue;
							linepixel[i+1].pixelStandardCb = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardY = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardCr= highvalue;
							linepixel[i+1].pixelStandardCr = highvalue;
							colorindex = 3;
							break;
						case 3:
							linepixel[i+1].pixelStandardY = highvalue;
							colorindex = 0;
							i = i+2;
							break;
					}
				}
				//write user's pixel to linepixel array
				memcpy((unsigned char *)(linepixel+pin->x),(unsigned char *)(writeaddr+p*pin->w), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
				//clear linebuffer
				memset((unsigned char *)linebuffer, 0,linesize);
				//linepixel is the new pixel line should be written in memory. so next do
				remainbit = 32;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					switch(colorindex)
					{
						case 0:
							value4byte = linepixel[i].pixelStandardCb;
							colorindex = 1;
							break;
						case 1:
							value4byte = linepixel[i].pixelStandardY;
							colorindex = 2;
							break;
						case 2:
							value4byte = linepixel[i].pixelStandardCr;
							colorindex = 3;
							break;
						case 3:
							value4byte = linepixel[i+1].pixelStandardY;
							colorindex = 0;
							i = i+2;
							break;
					}

					if(remainbit==0)
			       	{
						//lowvalue = value4byte&0;
						highvalue = (value4byte&0x000003ff);
						linebuffer[j] = linebuffer[j];
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if(remainbit<10)&&(remainbit>0)
			       	{
						lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff)>>remainbit;
						linebuffer[j] = linebuffer[j] |(lowvalue<<(32-remainbit));
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
				        linebuffer[j] =  linebuffer[j] |(value4byte&0x000003ff)<<(32-remainbit);
				        remainbit = remainbit - 10;
					}
				}
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					srclineptr[i] =( (linebuffer[i]&0x000000ff)<<24 )|( (linebuffer[i]&0x0000ff00)<<8 )| ( (linebuffer[i]&0x00ff0000)>>8 )|( (linebuffer[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = srclineptr[i];
					srclineptr[i] = srclineptr[i+1];
					srclineptr[i+1] = tempvalue;
				}
				//Do Swap end
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		else//444 10bit format
		{
			unsigned int arraynum = Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID);
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;

#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			rtd_pr_vsc_debug("arraynum = %d\n",arraynum);
			rtd_pr_vsc_debug("linebuffer = %lx\n",(unsigned long)linebuffer);

			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_WriteVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
	    		for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end
				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					if(remainbit<10)
			       	{
			           	lowvalue = value4byte;
			        	value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
					    highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCr = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardCb = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardY= highvalue;
							colorindex = 0;
							i++;
							break;
					}
				}

				//write user's pixel to linepixel array
				memcpy((unsigned char *)(linepixel+pin->x),(unsigned char *)(writeaddr+p*pin->w), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
				//clear linebuffer
				memset((unsigned char *)linebuffer, 0,linesize);
				//linepixel is the new pixel line should be written in memory. so next do
				remainbit = 32;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					switch(colorindex)
					{
						case 0:
							value4byte = linepixel[i].pixelStandardCr;
							colorindex = 1;
							break;
						case 1:
							value4byte = linepixel[i].pixelStandardCb;
							colorindex = 2;
							break;
						case 2:
							value4byte = linepixel[i].pixelStandardY;
							colorindex = 0;
							i++;
							break;
					}

					if(remainbit==0)
			       	{
						//lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff);
						//linebuffer[j] = linebuffer[j];
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit<10)&&(remainbit>0))
			       	{
						lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff)>>remainbit;
						linebuffer[j] = linebuffer[j] |(lowvalue<<(32-remainbit));
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
						linebuffer[j] =  linebuffer[j] |(value4byte&0x000003ff)<<(32-remainbit);
						remainbit = remainbit - 10;
					}
				}
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					srclineptr[i] =( (linebuffer[i]&0x000000ff)<<24 )|( (linebuffer[i]&0x0000ff00)<<8 )| ( (linebuffer[i]&0x00ff0000)>>8 )|( (linebuffer[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = srclineptr[i];
					srclineptr[i] = srclineptr[i+1];
					srclineptr[i+1] = tempvalue;
				}
				//Do Swap end
			}

			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
#endif
	}
	else
	{
		unsigned int i,k;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//422 8bit fomat
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					capturebufferaddr[i*linesize+2*k] = writeaddr->pixelStandardY;
					capturebufferaddr[i*linesize+2*(k/2)*2+1] = writeaddr->pixelStandardCb;
					capturebufferaddr[i*linesize+2*(k/2)*2+3] = writeaddr->pixelStandardCr;
					writeaddr ++;
				}
			}
		}
		else//444 8bit format
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					capturebufferaddr[i*linesize+3*k+2] = writeaddr->pixelStandardY;
					capturebufferaddr[i*linesize+3*k+1] = writeaddr->pixelStandardCb;
					capturebufferaddr[i*linesize+3*k] = writeaddr->pixelStandardCr;
					writeaddr++;
				}
			}
		}
	}
	dmac_flush_range(capturebufferaddr, capturebufferaddr + capturebuffersize);
	outer_flush_range(capturebufferphyaddr, capturebufferphyaddr + capturebuffersize);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_WriteVideoFrameBuffer)(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pin,KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pWrite);


/*New HAL_VSC function*/
//add vsc pattern @Crixus 20170419
unsigned char rtk_hal_vsc_SetPattern(BOOLEAN on_off, VIDEO_WID_T winID, VSC_VIDEO_PATTERN_LOCATION_T pattern_location){
       vgip_vgip_chn1_ctrl_RBUS vgip_vgip_chn1_ctrl_reg;
       sub_vgip_vgip_chn2_ctrl_RBUS sub_vgip_vgip_chn2_ctrl_reg;
       scaleup_d_uzu_globle_ctrl_RBUS scaleup_d_uzu_globle_ctrl_reg;
       scaleup_ds_uzu_globle_ctrl_RBUS scaleup_ds_uzu_globle_ctrl_reg;
       sfg_sfg_force_bg_at_dif_RBUS sfg_sfg_force_bg_at_dif_reg;
	   di_di_ptg_ctrl_RBUS di_di_ptg_ctrl_reg;//ecn RL6543-594
	   di_di_ptg_act_window_RBUS di_di_ptg_act_window_reg;//ecn RL6543-594

#ifdef CONFIG_DUAL_CHANNEL
       if((winID < VIDEO_WID_MIN)||(winID > VIDEO_WID_MAX))
       {
               rtd_pr_vsc_debug("wid id is not ok\n");
               return FALSE;
       }
#else
       if(winID !=VIDEO_WID_0)
       {
               rtd_pr_vsc_debug("wid id is not ok\n");
               return FALSE;
       }
#endif

       rtd_pr_vsc_emerg("[%s]on_off = %d, winID = %d, pattern_location = %d\n", __FUNCTION__, on_off, winID, pattern_location);
       switch(pattern_location){
				case VSC_VIDEO_PATTERN_MUX:
					if(winID == VIDEO_WID_0){
						vgip_vgip_chn1_ctrl_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_CTRL_reg);
						vgip_vgip_chn1_ctrl_reg.ch1_random_en = on_off;
						IoReg_Write32(VGIP_VGIP_CHN1_CTRL_reg, vgip_vgip_chn1_ctrl_reg.regValue);
					}
					else{
						sub_vgip_vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
						sub_vgip_vgip_chn2_ctrl_reg.ch2_random_en = on_off;
						IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, sub_vgip_vgip_chn2_ctrl_reg.regValue);
					}
					break;

				case VSC_VIDEO_PATTERN_DI_NR:
					if(winID == VIDEO_WID_0){
						if(on_off && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE))
						{
							rtd_pr_vsc_err("[%s] scaler not ready\n", __FUNCTION__);
						}
						else
						{
							if(on_off)
							{
								//set PTG color bar
								di_di_ptg_ctrl_reg.regValue = IoReg_Read32(DI_DI_PTG_CTRL_reg);
								di_di_ptg_ctrl_reg.di_color_num = 2;//2'b00:2 color 2'b01:4 color 2'b10:8 color. set 8 color
								di_di_ptg_ctrl_reg.di_color_bar_vertical_mode = 1;//vertical
								IoReg_Write32(DI_DI_PTG_CTRL_reg, di_di_ptg_ctrl_reg.regValue);

								//set PTG size
								di_di_ptg_act_window_reg.regValue = IoReg_Read32(DI_DI_PTG_ACT_WINDOW_reg);
								// @willlin, 20180614
								if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
									di_di_ptg_act_window_reg.di_ptg_length =  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) * 2;
								else
									di_di_ptg_act_window_reg.di_ptg_length =  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
								di_di_ptg_act_window_reg.di_ptg_width = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
								IoReg_Write32(DI_DI_PTG_ACT_WINDOW_reg, di_di_ptg_act_window_reg.regValue);
							}
							di_di_ptg_ctrl_reg.regValue = IoReg_Read32(DI_DI_PTG_CTRL_reg);
							di_di_ptg_ctrl_reg.di_color_bar_mode_en = on_off ? 1 : 0;//enble or disable PTG
							IoReg_Write32(DI_DI_PTG_CTRL_reg, di_di_ptg_ctrl_reg.regValue);
						}
					}
					else{
						rtd_pr_vsc_err("[%s]Do not support sub PATTERN_DI_NR\n", __FUNCTION__);
					}



					break;

				case VSC_VIDEO_PATTERN_SCALER:
					if(winID == VIDEO_WID_0){
						scaleup_d_uzu_globle_ctrl_reg.regValue = IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg);
						scaleup_d_uzu_globle_ctrl_reg.patgen_sel = on_off;
						scaleup_d_uzu_globle_ctrl_reg.patgen_mode = 2;
						IoReg_Write32(SCALEUP_D_UZU_Globle_Ctrl_reg, scaleup_d_uzu_globle_ctrl_reg.regValue);
					}
					else{
						scaleup_ds_uzu_globle_ctrl_reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_Globle_Ctrl_reg);
						scaleup_ds_uzu_globle_ctrl_reg.patgen_sel = on_off;
						scaleup_ds_uzu_globle_ctrl_reg.patgen_mode = 2;
						IoReg_Write32(SCALEUP_DS_UZU_Globle_Ctrl_reg, scaleup_ds_uzu_globle_ctrl_reg.regValue);
					}
					break;

				case VSC_VIDEO_PATTERN_MEMC:
					if(on_off)
					{
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_GB_reg, 0x08000800);//set color
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_R_reg, 0x00000800);//set color
						IoReg_SetBits(PPOVERLAY_MEMC_MUX_CTRL_reg, _BIT12);//enable ptg
						IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL2_reg, _BIT16);//double buffer apply
						//IoReg_SetBits(IPPRE__IPPRE_20_ADDR, _BIT7);

					}
					else
					{
						IoReg_ClearBits(PPOVERLAY_MEMC_MUX_CTRL_reg, _BIT12);//clear color
						IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL2_reg, _BIT16);//double buffer apply
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_GB_reg, 0);//clear color
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_R_reg, 0);//clear color
						//IoReg_ClearBits(IPPRE__IPPRE_20_ADDR, _BIT7);
					}
					break;

				case VSC_VIDEO_PATTERN_DISPLAY:
					sfg_sfg_force_bg_at_dif_reg.regValue = IoReg_Read32(SFG_SFG_FORCE_BG_AT_DIF_reg);
					if(on_off)
						sfg_sfg_force_bg_at_dif_reg.bg_dif_blu = 0x3ff;
					else
						sfg_sfg_force_bg_at_dif_reg.bg_dif_blu = 0;
					sfg_sfg_force_bg_at_dif_reg.en_force_bg_dif = on_off;
					IoReg_Write32(SFG_SFG_FORCE_BG_AT_DIF_reg, sfg_sfg_force_bg_at_dif_reg.regValue);
					break;

				default:
					break;
       }
       return TRUE;
}


unsigned char rtk_hal_vsc_CaptureVideoFrame(KADP_VIDEO_DDI_CAPTURE_PLACE_T place, KADP_VIDEO_DDI_CAPTURE_INFO_T * pCaptureInfo)
{

	rtd_pr_vsc_debug("have VT, V2G and VSCcapture not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}


unsigned char rtk_rerun_scaler(SCALER_DISP_CHANNEL channel)
{
	return TRUE;//No work
}

unsigned char rtk_hal_vsc_SetRGB444Mode(bool bonoff)
{
#ifdef ENABLE_FORCE_PC_MODE
	// Test Only, force set 444 mode
	bonoff = TRUE;
#endif
	rtd_pr_vsc_notice(" function=%s, bonoff: %d\n", __FUNCTION__, bonoff);
	DbgSclrFlgTkr.RGB444Mode = bonoff;
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetRGB444Mode)(bool bonoff) = rtk_hal_vsc_SetRGB444Mode;

bool rtk_hal_vsc_GetRGB444Mode(void)
{
	return DbgSclrFlgTkr.RGB444Mode;
}

#ifndef UT_flag
unsigned char rtk_hal_vsc_setwinprop(VSC_SET_SUB_WINDOW_MODE_TYPE vsc_set_sub_win_mode)
{
   /*for testing
   vsc_set_sub_win_mode.mode = VSC_SUB_MODE_PIP;
   vsc_set_sub_win_mode.connectType = VSC_SUB_CONNECT_TYPE_MIRROR;
   vsc_set_sub_win_mode.memoryUse = VSC_SUB_MEMORY_USE_MULTI;

   rtd_pr_vsc_emerg("[%s][crixus]@@VSC_IOC_SET_SetSubWinMode,mode = %d, connectType = %d, memoryUse = %d\n", __FUNCTION__, vsc_set_sub_win_mode.mode, vsc_set_sub_win_mode.connectType, vsc_set_sub_win_mode.memoryUse);
   */
   sub_mode_type = vsc_set_sub_win_mode.mode;//get sub mode

   if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_MIRROR){
		//disable ST game mode timeout checking task when enter livezoom for quickly switching case @Crixus 20170726
		down(&GameMode_Check_Semaphore);
		if(drv_memory_get_game_mode() == _ENABLE){
			Set_Val_smooth_toggle_game_mode_timeout_trigger_flag(_DISABLE);
			//smooth_toggle_game_mode_check_cnt = 0;
			rtd_pr_new_game_mode_notice("Disable ST game mode timeout tsk!!(before sub scaler)\n");
		}
		up(&GameMode_Check_Semaphore);
   }
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
   //connect type is non-mirror => multi-view or overlay miracast
   else if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NON_MIRROR){
		   if((sub_mode_type == VSC_SUB_MODE_EX_PBP)){
				   //i2rnd_test_done = 1;
				   rtk_hal_vsc_i2rnd_enable(_ENABLE);
				   rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
		   }else if((sub_mode_type == VSC_SUB_MODE_EX_PIP)){
				   //i2rnd_test_done = 0;
				   rtk_hal_vsc_i2rnd_enable(_DISABLE);
				   rtd_pr_vsc_emerg("[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
		   }
   }
#endif
#endif

   else if((vsc_set_sub_win_mode.mode == VSC_SUB_MODE_EX_NONE) && (vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NONE)
				   && (vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_NONE)){
		   //exit PIP or PBP app.
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
		   if((Scaler_I2rnd_get_enable() == _ENABLE)){
				   //disable i2run mode
				   //i2rnd_test_done = 0;
				   i2rnd_send_table_idx(I2RND_TABLE_OFF);
				   rtk_hal_vsc_i2rnd_enable(_DISABLE);
				   //frank@I2run disable main VENC flag
				   VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
				   DbgSclrFlgTkr.OutputVencMode = FALSE;
				   vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
				   vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
				   //apvr_request_run_main_path();
				   rtd_pr_vsc_emerg("[%s][frank]I2RND close\n", __FUNCTION__);
		   }
#endif
#endif
   }
	return TRUE;
}

unsigned char rtk_hal_vsc_Set3DForScaler(TRIDTV_SCALER_CTRL_T * p3DCfgInfo)
{
	unsigned char curmode;
	unsigned char support3Dinput[INPUT_TYPE_MAX]= {
		SLR_3DMODE_2D, SLR_3DMODE_3D_TB, SLR_3DMODE_3D_SBS, SLR_3DMODE_2D,
		SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_3D_FP,
		SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_3D_SBS, SLR_3DMODE_3D_FP,
		SLR_3DMODE_2D_CVT_3D};

	rtd_pr_vsc_debug("vsc_3d:%d=%d=%d=%d\n",p3DCfgInfo->mode, p3DCfgInfo->in_fmt, p3DCfgInfo->out_fmt, p3DCfgInfo->lr);
	if(p3DCfgInfo == NULL)
	{
		rtd_pr_vsc_debug("scaler vsc Set3DForScaler paramter NULL!!!\n");
		return FALSE;
	}
	if(p3DCfgInfo->mode > TRIDTV_3DMODE_MAX || p3DCfgInfo->mode  < TRIDTV_3DMODE_OFF
		||p3DCfgInfo->in_fmt > INPUT_TYPE_MAX || p3DCfgInfo->in_fmt < INPUT_TYPE_3DOFF
		||p3DCfgInfo->out_fmt > SC_OUT_MAX || p3DCfgInfo->out_fmt < SC_OUT_SINGLE_2D
		||p3DCfgInfo->lr > INPUT_LR_MAX || p3DCfgInfo->lr  < INPUT_LR_SEQ)
	{
		rtd_pr_vsc_debug("scaler vsc Set3DForScaler paramter error!!!\n");
		return FALSE;
	}

	set_field_alternative_3d_mode_enable(FALSE);
#if 1
	if(get_line_alternative_3d_mode_enable() == TRUE)
	{
		Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, false);
		set_line_alternative_3d_mode_enable(FALSE);
		DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	}
#endif
	if(p3DCfgInfo->mode == TRIDTV_3DMODE_OFF  || p3DCfgInfo->mode == TRIDTV_3DMODE_3DTO2D)
	{

		if(get_3D_mode_enable() == TRUE)
		{
			rtd_pr_vsc_debug("scaler vsc Set3DForScaler OFF!change to 2D!\n");
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}
	else if(p3DCfgInfo->mode == TRIDTV_3DMODE_MAX || p3DCfgInfo->in_fmt == INPUT_TYPE_MAX  ||p3DCfgInfo->out_fmt == SC_OUT_MAX ||p3DCfgInfo->lr == INPUT_LR_MAX)
	{

		if(get_3D_mode_enable() == TRUE)
		{
			rtd_pr_vsc_debug("scaler vsc Set3DForScaler MAXNUM!change to 2D!\n");
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}


	/*force set the out_fmt SC_OUT_SINGLE_FS*/
	if(p3DCfgInfo->out_fmt != SC_OUT_SINGLE_FS)
		p3DCfgInfo->out_fmt = SC_OUT_SINGLE_FS;

	if(p3DCfgInfo->out_fmt != SC_OUT_SINGLE_FS)
	{
		rtd_pr_vsc_debug("scaler vsc Set3DForScaler out format no support!change to 2D!\n");
		if(get_3D_mode_enable() == TRUE)
		{
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}

	if(p3DCfgInfo->in_fmt == INPUT_TYPE_DUALSTREAM)
	{
		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);

		return TRUE;
	}

	if(p3DCfgInfo->in_fmt == INPUT_TYPE_LINE_ALTERNATIVE/*&& DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI*/)
	{
		vfe_hdmi_timing_info_t vfehdmitiminginfo;
		rtd_pr_vsc_debug("input is line alternative\n");
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_LBL, TRUE);

		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);

		 //DisplayModeInputInfo.type = VSC_INPUTSRC_VDEC;

		if(0!=vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, SLR_MAIN_DISPLAY))
			return FALSE;
		Scaler_SET_VSCDispinfo_WithVFEHMDI(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
		drvif_I3DDMA_Init();
		HDMI_set_detect_flag(FALSE);
		Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, true);
		set_line_alternative_3d_mode_enable(TRUE);
		drivf_I3DDMA_3D_config();

		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		Scaler_Disp3dSetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE,SLR_3D_FRAME_PACKING);
		Scaler_Set3DMode_Attr(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP);
		set_vo_3d_mode(VO_2D_MODE);

		DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  			rtk_output_connect(SLR_MAIN_DISPLAY);
   		up(&VSC_Semaphore);

		return TRUE;


	}
	else if(p3DCfgInfo->in_fmt == INPUT_TYPE_FIELD_ALTERNATIVE/*&& DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI*/)
	{
		rtd_pr_vsc_debug("input is feild alternative\n");
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,true);
		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		set_field_alternative_3d_mode_enable(TRUE);
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);

		 return TRUE;

	}
	if(p3DCfgInfo->mode == TRIDTV_3DMODE_ON ||p3DCfgInfo->mode == TRIDTV_3DMODE_2DTO3D)
	{
		curmode = p3DCfgInfo->in_fmt;
		curmode = support3Dinput[(curmode < INPUT_TYPE_MAX? curmode: INPUT_TYPE_3DOFF)];

		if(curmode == SLR_3DMODE_2D)
		{
			if(get_3D_mode_enable() == TRUE)
			{
				set_3D_mode_enable(FALSE);
				set_3D_overscan_enable(FALSE);
				Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
				down(&VSC_Semaphore);
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  					rtk_output_connect(SLR_MAIN_DISPLAY);
   				up(&VSC_Semaphore);
				return TRUE;
			}
			else
			{
				return TRUE;
			}
		}

		Scaler_Set3DMode(SLR_MAIN_DISPLAY, curmode, TRUE);
		 if (Get_PANEL_SCALER_2D_3D_CVT_HWSHIFT_ENABLE() && p3DCfgInfo->in_fmt == INPUT_TYPE_2DTO3D)
		{
			// [2D3D] default mode init
			rtd_pr_vsc_debug("2d concvt 3d init\n");
			scaler_2Dcvt3D_init();
		}
		 if( drvif_scaler3d_decide_HDMI_framePacking_interlaced_status() && p3DCfgInfo->in_fmt == INPUT_TYPE_FRAMEPAC)
		 {
		 	rtd_pr_vsc_debug("Interlace Fp 3D, change progress to interlace!\n");
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,true);
		 }

		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  			rtk_output_connect(SLR_MAIN_DISPLAY);
   		up(&VSC_Semaphore);
		//Scaler_Set3DLRSwap(p3DCfgInfo->lr);
	}

	return TRUE;
}

unsigned char rtk_hal_vsc_Get3DAutoDetectmode(VIDEO_WID_T wid, KADP_VIDEO_DDI_3D_FORMAT_TYPE_T * pvideo3DType)
{
	unsigned char  curmode;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if(pvideo3DType == NULL)
	{
		rtd_pr_vsc_debug("scaler vsc Get3DAutoDetectmode paramter is error!\n");
		return FALSE;
	}

	if (Scaler_InputSrcGetMainChType() == _SRC_VO)
	{
		if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF)
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_SIDEBYSIDE_HALF;
		else if(get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM)
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_TOP_BOTTOM;
		else
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_2D;
		return TRUE;
	}

	Scaler_Set3D_VoAutoDetect_Enable(true);

#ifdef CONFIG_DUAL_CHANNEL
	if(VIDEO_WID_1 == wid)
		check_vo3d_detect_result(SLR_SUB_DISPLAY);
	else// if(VIDEO_WID_0 == wid)
		check_vo3d_detect_result(SLR_MAIN_DISPLAY);
#else //#ifdef CONFIG_DUAL_CHANNEL
	check_vo3d_detect_result(SLR_MAIN_DISPLAY);
#endif //#ifdef CONFIG_DUAL_CHANNEL

	curmode = modestate_get_vo3d_detect_result();
	switch(curmode)
	{
		case VO_2D_MODE:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_2D;
			break;
		case VO_3D_SIDE_BY_SIDE_HALF:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_SIDEBYSIDE_HALF;
			break;
		case VO_3D_TOP_AND_BOTTOM:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_TOP_BOTTOM;
			break;
		default:
			rtd_pr_vsc_debug("Can't detect 3D auto mode!\n");
			break;
	}


	return TRUE;
}

unsigned char rtk_hal_vsc_Set3Dpatternmode(VIDEO_WID_T wid, KADP_VIDEO_DDI_3D_PATTERN_TYPE_T video3DType)
{
	unsigned char curmode;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	switch(video3DType)
	{
		case KADP_VIDEO_DDI_3D_PATTERN_TOP_BOTTOM:
			curmode = SLR_3DMODE_3D_TB;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_SIDEBYSIDE_HALF:
			curmode = SLR_3DMODE_3D_SBS;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_LINE_INTERLEAVE_HALF:
			curmode = SLR_3DMODE_3D_LBL;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_FRAME_PACKING:
			curmode = SLR_3DMODE_3D_FP;
			break;
		default:
			curmode = SLR_3DMODE_2D;
			break;
	}

	Scaler_Set3DMode(SLR_MAIN_DISPLAY, curmode, TRUE);
	rtk_rerun_scaler(SLR_MAIN_DISPLAY);
	return TRUE;
}

#endif
unsigned char rtk_hal_vsc_SetVENEMode(unsigned short framerate, unsigned short scantype)
{
	rtd_pr_vsc_debug("VENEMode hal venc support framerate setting,but no scantype setting!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetVENEMode)(unsigned short framerate, unsigned short scantype) = rtk_hal_vsc_SetVENEMode;



unsigned char 	rtk_hal_vsc_OpenV2G(VIDEO_WID_T wid )
{
	rtd_pr_vsc_debug("V2G not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_OpenV2G)(VIDEO_WID_T wid) = rtk_hal_vsc_OpenV2G;

unsigned char 	rtk_hal_vsc_CloseV2G(VIDEO_WID_T wid )
{
	rtd_pr_vsc_debug("V2G not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_CloseV2G)(VIDEO_WID_T wid) = rtk_hal_vsc_CloseV2G;

unsigned char 	rtk_hal_vsc_GetV2GFramebuffer(VIDEO_WID_T wid , KADP_VIDEO_DDI_CAPTURE_INFO_T* pCaptureInfo)
{
	rtd_pr_vsc_debug("have VT, V2G not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_GetV2GFramebuffer)(VIDEO_WID_T wid, KADP_VIDEO_DDI_CAPTURE_INFO_T* pCaptureInfo) = rtk_hal_vsc_GetV2GFramebuffer;

unsigned char	rtk_hal_vsc_SetUDInput(KADP_VIDEO_UD_MODE_T videoUDMode)
{
	rtd_pr_vsc_debug("UD not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetUDInput)(KADP_VIDEO_UD_MODE_T videoUDMode) = rtk_hal_vsc_SetUDInput;

unsigned char 	rtk_hal_vsc_SetUDOutput(KADP_VIDEO_DDI_DIS_FMT_T disFmt)
{
		rtd_pr_vsc_debug("UD not use,keep empty!!\n");
		rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
		return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetUDOutput)(KADP_VIDEO_DDI_DIS_FMT_T disFmt) = rtk_hal_vsc_SetUDOutput;



unsigned char	rtk_hal_vsc_GetVideoDelayedTime (VIDEO_WID_T wid , unsigned short *pDelayedTime)
{

        unsigned short scaler_dispInfo = 0;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

        scaler_dispInfo = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

        if(scaler_dispInfo != 0)
        {
	        *pDelayedTime = 10000/scaler_dispInfo;
		return TRUE;
        }
	else
	{
                rtd_pr_vsc_debug("DispGetInputInfo is 0\n");
		return FALSE;
	}
}
unsigned char (*fp_rtk_hal_vsc_GetVideoDelayedTime)(VIDEO_WID_T wid, unsigned short *pDelayedTime) = rtk_hal_vsc_GetVideoDelayedTime;


unsigned char 	rtk_hal_vsc_SetTileMode(BOOLEAN bOnOff)
{
	//pip not support
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("pip pop mode not support!!\n");
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetTileMode)(BOOLEAN bOnOff) = rtk_hal_vsc_SetTileMode;

unsigned char 	rtk_hal_vsc_SetTileMaxRowVal(unsigned char uMaxRow, unsigned char uMaxCol)
{
	//pip not support
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("pip pop mode not support!!\n");
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetTileMaxRowVal)(unsigned char uMaxRow, unsigned char uMaxCol) = rtk_hal_vsc_SetTileMaxRowVal;

unsigned char 	rtk_hal_vsc_SetTileID(unsigned char uTileID)
{
	//pip not support
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("pip pop mode not support!!\n");
	return TRUE;
}
unsigned char (*fp_rtk_hal_vsc_SetTileID)(unsigned char uTileID) = rtk_hal_vsc_SetTileID;

unsigned char rtk_hal_vsc_SetAdaptiveStream(unsigned char bOnOff)
{
	int ret = -1;
		//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_notice("file=%s, function=%s, line=%d,bOnOff=%d,DbgSclrFlgTkr.adaptive_stream_pre=%d\n", __FILE__, __FUNCTION__, __LINE__, bOnOff,DbgSclrFlgTkr.adaptive_stream_pre);

	if(scaler_vsc_get_force_pst_lowdelay_mode() == TRUE){
		bOnOff = TRUE;
	}
	if((0 == bOnOff) && rtk_hal_vsc_Getdualdecoder())
	{
		rtd_pr_vsc_notice("file=%s, function=%s, line=%d dual decoder case true, not set adaptive stream false, return\n",__FILE__, __FUNCTION__, __LINE__);
		return TRUE;
	}
	if(DbgSclrFlgTkr.adaptive_stream_pre != bOnOff) {
	#if 0
		unsigned int *pulTemp;
		unsigned int i = 0, ulItemCount = 0;
		SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *sm_info_pkg = NULL;
		SMOOTH_TOGGLE_UPDATE_FWINFO_PKG update_info;
		sm_info_pkg = (SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *)Scaler_GetShareMemVirAddr(SCALERIOC_SMOOTHTOGGLE_SHARE_INFO);
		if (sm_info_pkg)
			{
			memcpy(&update_info, sm_info_pkg, sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG));
			ulItemCount = sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG) /  sizeof(UINT32);
			pulTemp = (unsigned int *)&update_info;
			for (i = 0; i < ulItemCount; i++)
				pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
			update_info.sm_info[SLR_MAIN_DISPLAY].vodma_plane = get_vo_plane_flag(SLR_MAIN_DISPLAY);
			}
	#endif
#if /*defined(CONFIG_REALTEK_2K_MODEL_ENABLED) &&*/ defined(ENABLE_IMD_PST_SMOOTHTOGGLE)//k5ap and enable force frame rate
		if(get_MEMC_bypass_status_refer_platform_model() == TRUE)
		drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));
#endif
		DbgSclrFlgTkr.adaptive_stream = bOnOff;
		DbgSclrFlgTkr.adaptive_stream_pre = bOnOff;
		if (0 != (ret = Scaler_SendRPC(SCALERIOC_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
			rtd_pr_vsc_err("ret=%d, SCALERIOC_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
				}
		}
		return TRUE;

}
unsigned char (*fp_rtk_hal_vsc_SetAdaptiveStream)(unsigned char bOnOff) = rtk_hal_vsc_SetAdaptiveStream;

unsigned char rtk_hal_vsc_SetAdaptiveStreamEX(VIDEO_WID_T wid,unsigned char bOnOff)
{
	int ret = -1;
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_notice("file=%s, function=%s, line=%d,bOnOff=%d,DbgSclrFlgTkr.adaptive_stream_pre=%d\n", __FILE__, __FUNCTION__, __LINE__, bOnOff,DbgSclrFlgTkr.adaptive_stream_pre);
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
	if (wid == VIDEO_WID_0) {

		if(scaler_vsc_get_force_pst_lowdelay_mode() == TRUE){
			bOnOff = TRUE;
		}

		if(DbgSclrFlgTkr.adaptive_stream_pre != bOnOff) {
		#if 0
			unsigned int *pulTemp;
			unsigned int i = 0, ulItemCount = 0;
			SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *sm_info_pkg = NULL;
			SMOOTH_TOGGLE_UPDATE_FWINFO_PKG update_info;
			sm_info_pkg = (SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *)Scaler_GetShareMemVirAddr(SCALERIOC_SMOOTHTOGGLE_SHARE_INFO);
			if (sm_info_pkg) {
				memcpy(&update_info, sm_info_pkg, sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG));
				ulItemCount = sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG) /  sizeof(UINT32);
				pulTemp = (unsigned int *)&update_info;
				for (i = 0; i < ulItemCount; i++)
					pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
				update_info.sm_info[SLR_MAIN_DISPLAY].vodma_plane = get_vo_plane_flag(SLR_MAIN_DISPLAY);
			}
		#endif

#if /*defined(CONFIG_REALTEK_2K_MODEL_ENABLED) &&*/ defined(ENABLE_IMD_PST_SMOOTHTOGGLE)//k5ap and enable force frame rate
		if(get_MEMC_bypass_status_refer_platform_model() == TRUE)
			drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));
#endif

			DbgSclrFlgTkr.adaptive_stream = bOnOff;
			DbgSclrFlgTkr.adaptive_stream_pre = bOnOff;
			if (0 != (ret = Scaler_SendRPC(SCALERIOC_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
				rtd_pr_vsc_err("ret=%d, SCALERIOC_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
			}
		}
	}else if(wid == VIDEO_WID_1){
		if(DbgSclrFlgTkr.sub_adaptive_flag != bOnOff)
		{
			DbgSclrFlgTkr.sub_adaptive_flag = bOnOff;
			if (0 != (ret = Scaler_SendRPC(SCALERIOC_SUB_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
				rtd_pr_vsc_err("ret=%d, SCALERIOC_SUB_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
			}
		}
	}

	return TRUE;

}
unsigned char (*fp_rtk_hal_vsc_SetAdaptiveStreamEX)(VIDEO_WID_T wid, unsigned char bOnOff) = rtk_hal_vsc_SetAdaptiveStreamEX;

EXPORT_SYMBOL(rtk_hal_vsc_SetAdaptiveStreamEX);
#endif
static bool is_adaptive_stream_source(unsigned char display)
{
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(display);


#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	return 0;
#endif

	return srctype == VSC_INPUTSRC_VDEC;
}

unsigned char vsc_get_adaptivestream_flag(unsigned char display)
{
	bool had_adaptive_stream = is_adaptive_stream_source(display);

	if(display == SLR_MAIN_DISPLAY)
		return (had_adaptive_stream) ? Get_Val_main_adaptive_stream_flag() : 0;
	else
		return (had_adaptive_stream) ? Get_Val_sub_adaptive_stream_flag() : 0;
}
#ifndef BUILD_QUICK_SHOW
#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
unsigned char vsc_decide_timingframesync(unsigned char display)
{
	if(display==SLR_MAIN_DISPLAY){
		if (Scaler_InputSrcGetType(display) == _SRC_VO){

			if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)&& vbe_disp_get_adaptivestream_fs_mode())
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		else {
			return FALSE;
		}
	}
	else if (display==SLR_SUB_DISPLAY){
			return FALSE;
	}

	return FALSE;


}
#endif

void Scaler_DualChannelRpc(unsigned char flag)
{
	int ret = 0;
	unsigned char *pulTemp = NULL;

	pulTemp = (unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_DUAL_CHANNEL_FLAG);

	// copy to RPC share memory
	//memcpy(pulTemp, &DbgSclrFlgTkr.dvo_dual_decoder_flag, sizeof(unsigned char));

	//pulTemp[0] = htonl(pulTemp[0]);
	if (pulTemp) {
		*pulTemp = flag;
		if (0 != (ret = Scaler_SendRPC(SCALERIOC_DUAL_CHANNEL_FLAG,0,0)))
		{
			rtd_pr_vsc_debug("ret=%d, set dual channel fail !!!\n", ret );
			return;
		}
	}
}

unsigned char dualdecoder_notchange_flag;
void scaler_Setdualdecoder_notchange(unsigned char flag)
{
	dualdecoder_notchange_flag = flag;
}
unsigned char scaler_Getdualdecoder_notchange(void)
{
	return dualdecoder_notchange_flag;
}

void rtk_hal_vsc_Setdualdecoder(unsigned char enable)
{
	rtd_pr_vsc_info("file=%s, function=%s, enable=%d\n", __FILE__, __FUNCTION__, enable);

	DbgSclrFlgTkr.dvo_dual_decoder_flag = enable;
	if ( 0== enable) {
		if (0 ==scaler_Getdualdecoder_notchange()) {
			rtk_hal_vsc_Setdualdecoder_run(0);
			Scaler_DualChannelRpc(0);
		}
	} else {
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
			rtk_hal_vsc_Setdualdecoder_run(1);
			Scaler_DualChannelRpc(1);
			rtd_pr_vsc_info("dual decoder start to run 1\n");
		}
	}
}

unsigned char rtk_hal_vsc_Getdualdecoder(void)
{
	return DbgSclrFlgTkr.dvo_dual_decoder_flag;
}

void  rtk_hal_vsc_Setdualdecoder_run(unsigned char flag)
{
	DbgSclrFlgTkr.dvo_dual_decoder_run = flag;
}
unsigned char rtk_hal_vsc_Getdualdecoder_run(void)
{
	return DbgSclrFlgTkr.dvo_dual_decoder_run;
}


unsigned char 	rtk_hal_vsc_SetSOCOutputFMT(KADP_VIDEO_UD_MODE_T videoUDMode)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}
unsigned char (*fp_rtk_hal_vsc_SetSOCOutputFMT)(KADP_VIDEO_UD_MODE_T videoUDMode) = rtk_hal_vsc_SetSOCOutputFMT;

unsigned char 	rtk_hal_vsc_SetFRCType(unsigned char frcType)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}
unsigned char (*fp_rtk_hal_vsc_SetFRCType)(unsigned char frcType) = rtk_hal_vsc_SetFRCType;

unsigned char 	rtk_hal_vsc_GetFRCType(unsigned char frcType)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}
unsigned char (*fp_rtk_hal_vsc_GetFRCType)(unsigned char frcType) = rtk_hal_vsc_GetFRCType;

unsigned char	rtk_hal_vsc_GetMVOPStatus(VIDEO_WID_T wId, BOOLEAN *bMVOPEnable)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}
unsigned char (*fp_rtk_hal_vsc_GetMVOPStatus)(VIDEO_WID_T wId, BOOLEAN *bMVOPEnable) = rtk_hal_vsc_GetMVOPStatus;
/*api which have protect by forcebg_semaphore*/
void set_ATV_passthrought_output_flag(unsigned char display, unsigned char flag)
{
	if(display == SLR_MAIN_DISPLAY)
		DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag = flag;
}
#ifndef UT_flag

unsigned int osdsample_addr = 0;
#if 0
unsigned char rtk_hal_vsc_showosdsample(unsigned char bonoff)
{

	GRAPHIC_LAYERS_OBJECT grahpic_obj;
	GDMA_LAYER_OBJECT *picObj;

	memset(&grahpic_obj, 0, sizeof(GRAPHIC_LAYERS_OBJECT));
	picObj = &grahpic_obj.layer[0];
	grahpic_obj.layer_num = 1;

	picObj->src_type = SRC_NORMAL;
	picObj->format = VO_OSD_COLOR_FORMAT_ARGB8888_LITTLE;
	/*picObj->plane = VO_GRAPHIC_OSD1;*/
	picObj->colorkey = -1;
	picObj->alpha = 0;
	picObj->x = 0;
	picObj->y = 0;
	picObj->width = 260;				// image width
	picObj->height = 200;				// image height
	picObj->pitch = picObj->width*4;

	if(bonoff == TRUE)
	{
		osdsample_addr = (unsigned int)dvr_malloc(1024*1024*3);
	}

	//picObj->address = (unsigned int)virt_to_phys((void*)osdsample_addr);	// set image address
	picObj->address = (unsigned int)dvr_to_phys((void*)osdsample_addr);	// set image address
	picObj->dst_x = 0;
	picObj->dst_y = 0;
	picObj->dst_width = 260;	 // image width
	picObj->dst_height = 200; // image height
	picObj->plane_ar.value = 0xffffffff;
	picObj->plane_gb.value = 0xffffffff;
	picObj->clear_x.value = 0;
	picObj->clear_y.value = 0;
	picObj->syncstamp = 0;
	picObj->show = bonoff;	  // always show the picture by normal update pic flow
	picObj->compressed = 0;
	/*picObj->layer_used = 1;*/
	/*osd_comp_receive_picture(&com_picObj);*/
#ifdef CONFIG_RTK_KDRV_GDMA
	GDMA_ReceiveGraphicLayers(&grahpic_obj);
#endif

	if(bonoff == FALSE)
	{
		dvr_free((void *)osdsample_addr);
		osdsample_addr = 0;
	}
	return 0;
}
#endif

// Dolby Vision IDMA enable control

#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
// HDR10 IDMA enable control
unsigned char rtk_hal_vsc_SetHdr10IdmaEnable(unsigned char bEnable)
{
	rtd_pr_vsc_debug("[HDR10] %s.%d\n", __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("en=%d, type/idma=%d/%d\n", bEnable, DisplayModeInputInfo.type, Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA));
	if(bEnable){
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
		{
			 vfe_hdmi_timing_info_t vfehdmitiminginfo;
			 DisplayModeInputInfo.type = (KADP_VSC_INPUT_TYPE_T)VSC_INPUTSRC_VDEC;
			 DisplayModeInputInfo.resourceIndex = 0;
			if(0!=vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, SLR_MAIN_DISPLAY))
				return FALSE;
			Scaler_SET_VSCDispinfo_WithVFEHMDI(SLR_MAIN_DISPLAY, vfehdmitiminginfo);

			set_HDMI_HDR_mode(HDR_HDR10_HDMI);
			drvif_I3DDMA_Init();
			Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, true);
			drivf_I3DDMA_3D_config();
			DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;

			if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
			down(&VSC_Semaphore);
	  		rtk_output_connect(SLR_MAIN_DISPLAY);
			if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
	   		up(&VSC_Semaphore);

			return TRUE;
		}else{
			rtd_pr_vsc_debug("[WARN][HDR10][%d] Not in HDMI source\n", DisplayModeInputInfo.type);
		}
	}
	else if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC){
		if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == true)
		{
			I3DDMA_3DDMA_CTRL_T *p_i3ddmaCtrl = NULL;
			p_i3ddmaCtrl = Get_Val_i3ddmaCtrl_addr();
			if(IoReg_Read32(H3DDMA_I3DDMA_enable_reg) & _BIT0){
				rtd_pr_vsc_debug("[HDR10] Disable IDMA HW\n");
				if(p_i3ddmaCtrl)
					I3DDMA_Setup3DDMA(p_i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
				msleep(40/*100*/); // wait DMA write done

				// [IDMA] allocate/release IDMA memory dynamic
				if(I3DDMA_Get3DAllocReleaseMemoryDynamic() == TRUE)
					drvif_I3DDMA_DeInit();
			}

			Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, false);
			DisplayModeInputInfo.type = KADP_VSC_INPUTSRC_HDMI;
			DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
		}
		if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
		down(&VSC_Semaphore);
  		rtk_output_connect(SLR_MAIN_DISPLAY);
		if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
   		up(&VSC_Semaphore);
	}

	if(!bEnable)
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	return 0;
}
#endif

#endif
unsigned char rtk_hal_vsc_SetZorder(VSC_SET_ZORDER_T zOrderMain,VSC_SET_ZORDER_T zOrderSub)//(unsigned char uZorder,unsigned char uAlpha)
{
	unsigned int main_blendingFactor = zOrderMain.uAlpha;
	unsigned int sub_blendingFactor = zOrderSub.uAlpha;

	//rtd_pr_vsc_err("[hal] zorder main:%d, sub:%d\n",zOrderMain.uZorder,zOrderSub.uZorder);
	//rtd_pr_vsc_err("[hal] alpha main:%d, sub:%d\n",main_blendingFactor,sub_blendingFactor);
	if((zOrderMain.uAlpha + zOrderSub.uAlpha) == 0)
	{
		rtd_pr_vsc_err("[error] blending factor is all zero \n");
		return FALSE;
	}

	main_blendingFactor = zOrderMain.uAlpha * 256 / (zOrderMain.uAlpha + zOrderSub.uAlpha);
	sub_blendingFactor = zOrderSub.uAlpha * 256 / (zOrderMain.uAlpha + zOrderSub.uAlpha);

	rtd_pr_vsc_info("[vsc] blending factor main:%d, sub:%d\n",main_blendingFactor,sub_blendingFactor);

	if((sub_blendingFactor + main_blendingFactor) != 256){
		if((sub_blendingFactor + main_blendingFactor) > 256){
			rtd_pr_vsc_err("[ERROR]wrong blending factor(%d, %d) @func:%s, line:%d\n",main_blendingFactor,sub_blendingFactor,__FUNCTION__,__LINE__);
			return FALSE;
		}
		sub_blendingFactor = 256 - main_blendingFactor;
	}

	if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		&&(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
	{
		//int ret = 0;
		//drvif_color_setpiprgbcontrastbrightness(zOrderMain.uAlpha);
		drvif_color_setBrightnessDualplayOverlay(main_blendingFactor,sub_blendingFactor);
		/*if (0 != (ret =Scaler_SendRPC(SCALERIOC_SENDZORDER, ((zOrderMain.uZorder<<8) + zOrderSub.uZorder), RPC_SEND_VALUE_ONLY))) {
			rtd_pr_vsc_emerg("ret=%d, rtk_hal_vsc_SetZorder SCALERIOC_SENDZORDER fail !!!\n", ret);
			return FALSE;
		}*/
	}
	return TRUE;
}

unsigned char rtk_hal_vsc_set_localDimmingCtrlDemoMode(unsigned char bType, unsigned char bCtrl)
{
	LocalDimmingDemoCtrlType = bType;
	LocalDimmingDemoCtrlMode = bCtrl;
	rtd_pr_vsc_notice("rtk_hal_vsc_set_localDimmingCtrlDemoMode (type:%d. ctrl:%d) \n", bType,bCtrl);
	return _TRUE;
}


unsigned char rtk_hal_vsc_makeColoredVideo(KADP_VSC_VIDEO_COLOR_TYPE_T videoColor)
{
	osdovl_mixer_ctrl2_RBUS mixer_ctrl2_reg;
	ppoverlay_main_background_color1_RBUS main_background_color1_reg;
	ppoverlay_main_background_color2_RBUS main_background_color2_reg;
	ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
	ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
	ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
	ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
	ppoverlay_double_buffer_ctrl2_RBUS double_buffer_ctrl_reg;
	static unsigned char m_memc_bg_en = 0;

	static KADP_VIDEO_RECT_T originalSize={0,0,0,0};
	unsigned int timeout=0x3fffff;
	rtd_pr_vsc_notice("rtk_hal_vsc_makeColoredVideo (%d) \n", videoColor);

	if(videoColor == KADP_VSC_VIDEO_COLOR_WHITE){

		rtd_pr_vsc_notice("rtk_hal_vsc_makeColoredVideo KADP_VSC_VIDEO_COLOR_WHITE \n");
		if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
			rtk_hal_vsc_GetOutputRegion((KADP_VIDEO_WID_T)VIDEO_WID_0, &originalSize);
			if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
				rtd_pr_vsc_notice("no originalSize,reset to default.\n");
				originalSize.x = 0;
				originalSize.y = 0;
				originalSize.w = _DISP_WID;
				originalSize.h = _DISP_LEN;
			}
			rtd_pr_vsc_notice("originalSize (%d.%d.%d.%d) \n", originalSize.x, originalSize.y, originalSize.w, originalSize.h);
		}
		down(Get_Val_VPQ_ld_running_Semaphore());
		drvif_HAL_VPQ_LED_LDEnable(1);
		up(Get_Val_VPQ_ld_running_Semaphore());
        Set_Val_OutpuLocalDimmingPatMode(TRUE);
		//set free run timing
		drivf_scaler_reset_freerun_60Hz();
		// turn off osd mixer
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 0;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);

		//frank@0220 check memc bg status and clear memc bg
		memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
		m_memc_bg_en = memc_mux_ctrl_reg.memc_out_bg_en;
		if(m_memc_bg_en){
			//enable UZU DTG double buffer.
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
			double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 1;
			double_buffer_ctrl_reg.uzudtg_dbuf_vsync_sel = 3;//using uzudtg vsync
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
			memc_mux_ctrl_reg.memc_out_bg_en = 0;
			IoReg_Write32(PPOVERLAY_MEMC_MUX_CTRL_reg, memc_mux_ctrl_reg.regValue);
			//set apply
			double_buffer_ctrl_reg.uzudtgreg_dbuf_set = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
		}

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

		main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
		main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
		main_background_color1_reg.m_bg_b = 0x3fff;
		main_background_color1_reg.m_bg_g = 0x3fff;
		main_background_color2_reg.m_bg_r = 0x3fff;
		IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
		IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);
		down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
		main_display_control_rsv_reg.m_force_bg = 1;
		IoReg_Write32(PPOVERLAY_Main_Display_Control_RSV_reg, main_display_control_rsv_reg.regValue);
		up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}
/*
		int x=0;
		VIDEO_RECT_T output_region;

		while(1){
			output_region.x= x;
			output_region.y = 0;
			output_region.w = 150;
			output_region.h = 2160;

			rtk_hal_vsc_SetOutputRegion(0, output_region);

			if(x<=3690){
				x+=20;
			}else
				x=0;
		}
*/
	}else{
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 1;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
		main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
		main_background_color1_reg.m_bg_b = 0;
		main_background_color1_reg.m_bg_g = 0;
		main_background_color2_reg.m_bg_r = 0;
		IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
		IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);


		//frank@0220 revert memc bg
		if(m_memc_bg_en){
			//disable UZU DTG double buffer.
			double_buffer_ctrl_reg.regValue =  IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
			double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
			memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
			memc_mux_ctrl_reg.memc_out_bg_en = m_memc_bg_en;
			m_memc_bg_en = 0;
			IoReg_Write32(PPOVERLAY_MEMC_MUX_CTRL_reg, memc_mux_ctrl_reg.regValue);
		}
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}
		rtd_pr_vsc_notice("recovery originalSize (%d.%d.%d.%d) \n", originalSize.x, originalSize.y, originalSize.w, originalSize.h);
        Set_Val_OutpuLocalDimmingPatMode(FALSE);

		if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
			//do nothing
		}else{
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, originalSize, 0, 0);
		}
		memset((void*)&originalSize, 0, sizeof(VIDEO_RECT_T));
		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		scaler_disp_smooth_variable_settingByDisp(0);

        //frank@01062016 add below flow to avoid demo mode exit will have garbage
        if(!Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY)){
            if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
            {
                mute_control(SLR_MAIN_DISPLAY, FALSE);/*disable forcebg*/
            }
        }
	}
	return 1;
}


unsigned char rtk_hal_vsc_dm_open(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	//rtd_pr_vsc_emerg("pinyen======DM open\n");
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_open, It is OTT, so return true!");
		up(&DM_HDR_Semaphore);
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_open, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_OPEN);
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}


unsigned char rtk_hal_vsc_dm_close(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	rtd_maskl(H3DDMA_I3DDMA_MDP_CR_reg,~(_BIT3|_BIT4), 0);
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_close, It is OTT, so return true!");
		up(&DM_HDR_Semaphore);
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_close, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
	DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}



void Share_Memory_Set_DM_Connect_Flag(unsigned char enable)
{
	unsigned int *dm_connect_flag = NULL;
	unsigned int *pulTemp = NULL;
	unsigned int i = 0, ulItemCount = 0;

	dm_connect_flag = (unsigned int *)Scaler_GetShareMemVirAddr(SCALERIOC_DM_CONNECT_FLAG);
    if(dm_connect_flag)
    {
        *dm_connect_flag = enable;
    	ulItemCount = sizeof(unsigned int) /  sizeof(UINT32);
    	pulTemp = dm_connect_flag;
    	for (i = 0; i < ulItemCount; i++)
    		pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
    }
    else
    {
        rtd_pr_vsc_debug("[ERR]dm_connect_flag is null");
    }
}

unsigned char rtk_hal_vsc_dm_connect(unsigned char display, KADP_VSC_HDR_TYPE_T eHdrMode)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case

	if(Get_Val_main_vsc_hdrtype() == eHdrMode)
	{
		rtd_pr_vsc_emerg("[%s %d]hdr type not change, no need run dm connect eHdrMode:%d\n", __FUNCTION__, __LINE__, eHdrMode);
		return TRUE;
	}
	
	rtd_pr_vsc_emerg("[%s %d]eHdrMode:%d\n", __FUNCTION__, __LINE__, eHdrMode);

	down(&DM_HDR_Semaphore);

	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	#ifdef CONFIG_RTK_KDRV_DV
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
		dolby_adapter_Check_DV_Mode();
#else
		Check_DV_Mode();//Check dolby mode again. Dolby 64 patch
#endif
	#endif
#endif
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_connect, It is OTT, so so return true!");
		Share_Memory_Set_DM_Connect_Flag(true);
		up(&DM_HDR_Semaphore);

        if(get_OTT_HDR_mode() != HDR_DOLBY_COMPOSER)
        {
        	switch(eHdrMode)
        	{
				case KADP_VSC_HDR_DOLBY:
					break;
				case KADP_VSC_HDR_HDR10:
				case KADP_VSC_HDR_VP9:
				case KADP_VSC_HDR_HLG:
				case KADP_VSC_HDR_PRIME:
				case KADP_VSC_HDR_HDR10_PLUS:
				case KADP_VSC_HDR_AUTO://old dm connect parameter. decide dolby or hdr
            		set_OTT_HDR_mode(HDR_HDR10_VDEC);
					break;
				case KADP_VSC_HDR_DOLBY_LL:
					rtd_pr_vsc_err("rtk_hal_vsc_dm_connect, vdec mode hdrtype dolbyLL error");
					break;
				default:
					break;

        	}
        }
		Set_Val_main_vsc_hdrtype(eHdrMode);
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_connect, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

	if(eHdrMode == KADP_VSC_HDR_AUTO)
	{//auto detetck hdrtype for demo board
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		if(Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
		{
			DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE;
		}
		else
		{
#ifdef CONFIG_SUPPORT_DOLBY_VSIF
			/*HDR10 flow*/
			if(get_HDMI_Dolby_VSIF_mode() != DOLBY_HDMI_VSIF_DISABLE)
			{
				DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE; // DOLBY VSIF STD OR LL also need to set as Dolby_Hdmi_mode
			}
			else
			{
		      	DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;//in HDR10 HDMI, disable Dolby version flag @Crixus 20160313
			}
#else
		     DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;//in HDR10 HDMI, disable Dolby version flag @Crixus 20160313
#endif
		}
#else
		DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
#endif
	}
	else
	{
		if((eHdrMode == KADP_VSC_HDR_DOLBY) || (eHdrMode == KADP_VSC_HDR_DOLBY_LL))
			DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE;
		else
			DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
	}
	Set_Val_main_vsc_hdrtype(eHdrMode);
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CLOSE)//dm not open or not connect
	{
		rtd_pr_vsc_debug("hdmi hdr10 is not open\n");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CONNECT);

	if ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_HDMI))
	{
		rtd_pr_vsc_debug("sub hdmi hdr, so no enable hdr\n");
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
#endif



	/*hdmi dolby detect ok, set dolby_vision_flag=true*/
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
	{

		//set_HDMI_HDR_mode(HDR_DOLBY_HDMI);
		set_force_i3ddma_enable(true);
	}
	else{
		/*HDR10 flow*/
		set_HDMI_HDR_mode(HDR_HDR10_HDMI);
		#if 1 //hw interlace hdr clockgen has problem ,cannot run hdmi->hdr->vgip flow
		set_force_hdmi_hdr_flow_enable(true);
		#endif
	}


	if(!DbgSclrFlgTkr.hdmi_dolby_vision_flag)//HDMI HDR10 case. Wait OTT dolby run. should no wait
	{
#ifdef CONFIG_RTK_KDRV_DV
		unsigned char timeout = 10;
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
		while(dolby_adapter_check_ott_dolby_update_run() && timeout)
#else
		while(check_ott_dolby_update_run() && timeout)
#endif
		{
			msleep(1);
			timeout --;
		}
#endif
	}

#ifdef CONFIG_HDR_SDR_SEAMLESS
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(get_HDMI_HDR_mode() == HDR_HDR10_HDMI && Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)//only connect case can trigger seamless
#else
	if(get_HDMI_HDR_mode() == HDR_HDR10_HDMI)
#endif
	{
		unsigned char hdr_type = HDR_DM_MODE_NONE;//typedef enum PQ_HDR_TYPE
		switch(eHdrMode)
    	{
			case KADP_VSC_HDR_DOLBY:
			case KADP_VSC_HDR_DOLBY_LL:
				hdr_type = HDR_DM_DOLBY;
				break;
			case KADP_VSC_HDR_HDR10:
			case KADP_VSC_HDR_VP9:
			case KADP_VSC_HDR_PRIME:
				hdr_type = HDR_DM_HDR10;
				break;

			case KADP_VSC_HDR_HLG:
				hdr_type = HDR_DM_HLG;
				break;

			case KADP_VSC_HDR_HDR10_PLUS:
				hdr_type = HDR_DM_ST2094;
				break;

			case KADP_VSC_HDR_AUTO://old dm connect parameter. decide dolby or hdr
			default:
        		hdr_type = HDR_DM_HDR10;
				break;

    	}
#ifndef CONFIG_FORCE_RUN_I3DDMA
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, true);
#endif
		down(&HDR_Setting_Semaphore);
		if(get_hdr_semaless_active())
		{
			//set_target_i3ddma_color_format(decide_i3ddma_output_foramt(get_backup_hdmi_info()));
			trigger_seamless_flow((VSC_INPUT_TYPE_T)KADP_VSC_INPUTSRC_HDMI, TRUE, hdr_type);
			//recode current hdr mode for seamless change @Crixus 20170110
			set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());
		}
		up(&HDR_Setting_Semaphore);
	}
	else
	{
#ifdef CONFIG_RTK_KDRV_DV
		if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_DV_HDMI_Init();
#else
			DV_HDMI_Init();
#endif
		}
#endif
#ifdef CONFIG_FORCE_RUN_I3DDMA
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
#else//need to rerun
		//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, true);
		DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
#endif
	}
#else
	if(!get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY))
		Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,255);

#ifdef CONFIG_RTK_KDRV_DV
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_DV_HDMI_Init();
#else
		DV_HDMI_Init();
#endif
	}
#endif
	//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, true);
	DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
#endif
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
	{

		set_HDMI_HDR_mode(HDR_DOLBY_HDMI);
	}
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CONNECT);
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}

unsigned char rtk_hal_vsc_dm_disconnect(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	//reset Dolby HDR
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) || get_HDMI_HDR_mode() == HDR_DOLBY_HDMI){
		//Scaler_Dolby_HDR_reset(); //Mark by will. Move to scaler
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_disconnect, reset Dolby HDR\n");
	}

	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_disconnect, It is OTT, so return true!");
		Share_Memory_Set_DM_Connect_Flag(false);
		up(&DM_HDR_Semaphore);
        if(get_OTT_HDR_mode() == HDR_HDR10_VDEC)
        {
            set_OTT_HDR_mode(HDR_MODE_DISABLE);
        }
		Set_Val_main_vsc_hdrtype(KADP_VSC_HDR_MAXN);//reset hdr type
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_disconnect, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
	Set_Val_main_vsc_hdrtype(KADP_VSC_HDR_MAXN);//reset hdr type
	//if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == true)
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
	{
		//DV_Stop(void)
		Scaler_HDR_DolbyVision_Hdmi_SetDisplaytEnable(_DISABLE);
	}
#endif
	set_force_hdmi_hdr_flow_enable(false);

#ifdef CONFIG_HDR_SDR_SEAMLESS
	if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) ==VSC_INPUTSRC_HDMI) {
			Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

			set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);
			mute_control(SLR_SUB_DISPLAY, TRUE);
		}

		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) {
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);
			mute_control(SLR_MAIN_DISPLAY, TRUE);
		}
		//willychou add WOSQRTK-8674/WOSQRTK-9024,HDMI clock change -> _MODE_STATE_SEARCH -> stop rtk_check_signal and HDMI_set_detect_flag(TRUE)
		//-> no signal happen -> util HDMI_set_detect_flag(TRUE) again
		down(get_hdmi_detectsemaphore());
		if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
		up(get_hdmi_detectsemaphore());
	}

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_OPEN);
#endif
#ifndef CONFIG_FORCE_RUN_I3DDMA
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, false);
	Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 255);
#endif
	if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
	{
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	}
	else
	{
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
		down(&HDR_Setting_Semaphore);
		if(get_hdr_semaless_active())
		{
			set_target_i3ddma_color_format(decide_i3ddma_output_foramt(get_backup_hdmi_info()));
			trigger_seamless_flow((VSC_INPUT_TYPE_T)KADP_VSC_INPUTSRC_HDMI, FALSE, HDR_DM_MODE_NONE);
			//recode current hdr mode for seamless change @Crixus 20170110
			set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());
		}
		up(&HDR_Setting_Semaphore);
	}


#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	Scaler_HDR_DolbyVision_Hdmi_SetDetectEnable(_ENABLE, _DISABLE);
#endif


#else
	if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_HDMI) {
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

		set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);
		mute_control(SLR_SUB_DISPLAY, TRUE);
	}

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);
	mute_control(SLR_MAIN_DISPLAY, TRUE);

	//willychou add WOSQRTK-8674/WOSQRTK-9024,HDMI clock change -> _MODE_STATE_SEARCH -> stop rtk_check_signal and HDMI_set_detect_flag(TRUE)
	//-> no signal happen -> util HDMI_set_detect_flag(TRUE) again
	down(get_hdmi_detectsemaphore());
	if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
	up(get_hdmi_detectsemaphore());

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
#endif

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, false);
	DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 255);

#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	Scaler_HDR_DolbyVision_Hdmi_SetDetectEnable(_ENABLE, _DISABLE);
#endif
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}

unsigned char (*p_rtk_hal_vsc_dm_open)(unsigned char) = rtk_hal_vsc_dm_open;
unsigned char (*p_rtk_hal_vsc_dm_close)(unsigned char) = rtk_hal_vsc_dm_close;
unsigned char (*p_rtk_hal_vsc_dm_connect)(unsigned char, KADP_VSC_HDR_TYPE_T) = rtk_hal_vsc_dm_connect;
unsigned char (*p_rtk_hal_vsc_dm_disconnect)(unsigned char) = rtk_hal_vsc_dm_disconnect;


void scaler_dolby_hdmi_smooth_toggle(UINT8 isSDRtoEDR)/*1==SDR->EDR   0==EDR->SDR*/
{
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(isSDRtoEDR)
	{
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CONNECT);
	}
	else
	{
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
	}
#endif

	set_main_scaler_stop_flag(FALSE);
	DbgSclrFlgTkr.Main_Run_Scaler_flag =TRUE;
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
}

extern void I3DDMA_Set_Metadata_Vgip(void);

#endif
unsigned char scaler_force_run_idma_impl(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)
{
#ifndef BUILD_QUICK_SHOW
	if(get_main_scaler_stop_flag())
		return FALSE;

	set_force_change_vo_flag(0, TRUE);//force update vo info

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  255);
	else
#endif
	{
		Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  0xfa);
	}

	down(&VSC_Semaphore);
	drvif_mode_resetmode(display);
#endif
	drvif_I3DDMA_Init();
#ifndef BUILD_QUICK_SHOW
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG))
	{
		rtd_pr_vsc_emerg("vo source,return\n");
		up(&VSC_Semaphore);
		return TRUE;
	}
	else if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
    {
		down(get_adc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_ADC_Dispinfo());//now for test, only for ypp timing info
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_adc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_err("adc vsc_timinginfo_check error\n");
			return FALSE;
		}
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 2000)//mean 4095 no support
		{
			up(get_adc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_err("scaler_force_run_idma adc vsc_timinginfo_check no support error\n");
			return FALSE;
		}
		ADC_set_detect_flag(FALSE);
		up(get_adc_detectsemaphore());

		// Scart RGB
		if(get_ADC_Input_Source() == _SRC_SCART_RGB)
		{
			if(!drivf_i3ddma_config(display, VGIP_SRC_ATV))
			{
				up(&VSC_Semaphore);
				rtd_pr_vsc_emerg("adc drivf_i3ddma_config error\n");
				return FALSE;
			}
		}
		// YPP and VGA
		else
		{
			if(!drivf_i3ddma_config(display, VGIP_SRC_ADC))
			{
				up(&VSC_Semaphore);
				rtd_pr_vsc_emerg("adc drivf_i3ddma_config error\n");
				return FALSE;
			}
			fw_scaler_set_sample(display, _ENABLE);
		}
		if(!check_verify_mode_enable()){
			rtd_pr_vsc_notice("#####[%s(%d)] call ADC_VSC_Setting\n",__func__,__LINE__);
			ADC_VSC_Setting(get_ADC_Input_Source());//if ADC verify mode no need this
		}
		fw_scaler_adc_nolock_wdg_ctrl(display, FALSE);//Disable adc_nolock_wdg
		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
	}
	else if(inputSrctype == VSC_INPUTSRC_AVD)
	{
		down(get_vdc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_AVD_ScalerDispinfo());
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_vdc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("avd vsc_timinginfo_check error\n");
			return FALSE;
		}
		up(get_vdc_detectsemaphore());
		if(!drivf_i3ddma_config(display, VGIP_SRC_ATV))
		{
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("avd drivf_i3ddma_config error\n");
			return FALSE;
		}
		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
	}
	else if(inputSrctype == VSC_INPUTSRC_HDMI)
#else
    if(inputSrctype == VSC_INPUTSRC_HDMI)
#endif
	{

		vfe_hdmi_timing_info_t vfehdmitiminginfo;
		down(get_hdmi_detectsemaphore());
		if(0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, display))
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("vfe_hdmi_drv_get_display_timing_info error\n");
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_WithVFEHMDI(display, vfehdmitiminginfo);
		#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		Scaler_HDR10_Hdmi_Set_Input_ACT_WID_info(vfehdmitiminginfo.active.w);
		#endif

		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("hdmi vsc_timinginfo_check error\n");
			return FALSE;
		}
#ifndef BUILD_QUICK_SHOW
		HDMI_set_detect_flag(FALSE);
#endif
		up(get_hdmi_detectsemaphore());
		if((drvif_Hdmi_GetRawColorSpace() == COLOR_YUV420) && (drvif_Hdmi_GetFrlMode() == 0))
		{//hdmi2.0 and color yuv420
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
			{
				drvif_Hdmi_EnableBypassYUV420Engine(1);//bypass hmdi yuv420 to yuv444
			}
			else
			{
				drvif_Hdmi_EnableBypassYUV420Engine(0);//orignal hmdi yuv420 to yuv444
			}
		}
		if(!drivf_i3ddma_config(display, VGIP_SRC_TMDS))
		{
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("hdmi drivf_i3ddma_config error\n");
			return FALSE;
		}

		#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
		{
			Scaler_HDR_DolbyVision_Hdmi_SetDisplaytEnable(_DISABLE);
			Scaler_HDR_DolbyVision_Hdmi_SetDisplaytEnable(_ENABLE);
		}
		#endif
		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
		save_online_enable_time(SLR_MAIN_DISPLAY);//save online enable time
	}
	up(&VSC_Semaphore);
#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME:  %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif
	return TRUE;
}

#ifndef BUILD_QUICK_SHOW
unsigned char scaler_atv_force_run_idma(void)
{
	if (ATV_forcei3ddma == 1)
		;	//	ATV will force i3ddma scaler flow
	set_force_change_vo_flag(0, TRUE);//force update vo info
	Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  0xfa);
	down(&VSC_Semaphore);
	drvif_mode_resetmode(SLR_MAIN_DISPLAY);
	drvif_I3DDMA_Init();

	down(get_vdc_detectsemaphore());
	Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_AVD_ScalerDispinfo());
	if(vsc_timinginfo_check() == FALSE)
	{
		up(get_vdc_detectsemaphore());
		up(&VSC_Semaphore);
		rtd_pr_vsc_emerg("avd vsc_timinginfo_check error\n");
		return FALSE;
	}
	up(get_vdc_detectsemaphore());
	if(!drivf_i3ddma_config(SLR_MAIN_DISPLAY, VGIP_SRC_ATV))
	{
		up(&VSC_Semaphore);
		rtd_pr_vsc_emerg("atv drivf_i3ddma_config error\n");
		return FALSE;
	}
	drvif_mode_enable_dma_onlinemeasure();//Enable online measure

	up(&VSC_Semaphore);
	return TRUE;
}

#ifdef CONFIG_PST_ENABLE
extern unsigned char Scaler_sub_md_pst_get_enable(void);
void rtk_hal_vsc_pst_enable(unsigned char enable){
	//Eric@20170904 move pst initial to vsc initial
	if(enable == _ENABLE){
		//enable main pst
		Scaler_main_md_pst_set_enable(_ENABLE);
		//enable sub pst
		Scaler_sub_md_pst_set_enable(_ENABLE);
	}
	else{
		//disable main pst
		Scaler_main_md_pst_set_enable(_DISABLE);
		//disable sub pst
		Scaler_sub_md_pst_set_enable(_DISABLE);
	}
}
#endif


#ifdef CONFIG_I2RND_B05_ENABLE
unsigned char rtk_hal_vsc_i2rnd_b05_enable(unsigned char enable)
{
	if(enable == _ENABLE) {
	//               rtd_pr_vsc_info("in_b05_initial\n");
		drvif_scaler_i2rnd_b05_initial();
		Scaler_I2rnd_b05_set_enable(_ENABLE);
	//                drvif_scaler_i2rnd_b05_vodma_setting(SLR_MAIN_DISPLAY);
	} else {
		drvif_scaler_i2rnd_b05_uninitial();
		Scaler_I2rnd_b05_set_enable(_DISABLE);//uninitial i2rnd_b05  to disable I2rnd flag
		//rtd_pr_vsc_info("in_b05_uninitial\n");
	}
	return TRUE;
}
#endif

static bool video_delay_task_flag = FALSE;
static struct task_struct *p_video_delay_tsk = NULL;
extern void set_smooth_toggle_update_flag(unsigned char display, unsigned int flag);
void video_delay_wakeup(void)
{
	video_delay_trigger_flag = TRUE;
	wake_up(&VIDEO_DELAY_WAIT_QUEUE);
}

#ifndef UT_flag
static int video_delay_task(void *p)//This task run se proc
{

	rtd_pr_vsc_debug("video_delay_task()\n");

#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif

	while (1)
	{
		wait_event_freezable(VIDEO_DELAY_WAIT_QUEUE, video_delay_trigger_flag);
		down(&VIDEO_DELAY_Semaphore);
		if(video_delay_trigger_flag && Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_VideoDelay, TRUE);
			mute_control(SLR_MAIN_DISPLAY, TRUE);
			video_delay_trigger_flag = FALSE;
			Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
			set_smooth_toggle_update_flag(SLR_MAIN_DISPLAY, 1);
                    if(MDOMAIN_CAP_Cap_In1_enable_get_in1_cap_enable(rtd_inl(MDOMAIN_CAP_Cap_In1_enable_reg)))
                    {
        			drv_memory_capture_multibuffer_switch_buffer();
        			drv_memory_display_multibuffer_switch_buffer();
        			if(drv_memory_Get_multibuffer_flag())
        				drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, drv_memory_Get_multibuffer_number()-1, FALSE);
        			else if(drv_memory_Get_multibuffer_changed())
        				drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, drv_memory_Get_multibuffer_number_pre()-1, FALSE);
                    }
			drv_memory_Set_multibuffer_changed(false);
			set_smooth_toggle_update_flag(SLR_MAIN_DISPLAY, 0);
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_VideoDelay, FALSE);
			trigger_mute_off(SLR_MAIN_DISPLAY, 1);
			//mute_control(SLR_MAIN_DISPLAY, FALSE);

		}


		up(&VIDEO_DELAY_Semaphore);

		// to prevent STR/Snapshot fail
		if (freezing(current))
		{
			try_to_freeze();
		}

		if (kthread_should_stop()){
			rtd_pr_vsc_debug("video_delay_task stop!!\n");
			break;
		}

	}

    rtd_pr_vsc_debug("\r\n####video_delay_task: exit...####\n");
    do_exit(0);
    return 0;
}


static void create_video_delay_task(void)
{
	int err;
	if (video_delay_task_flag == FALSE) {
		p_video_delay_tsk = kthread_create(video_delay_task, NULL, "video_delay_task");

		if (p_video_delay_tsk) {
			wake_up_process(p_video_delay_tsk);
			video_delay_task_flag = TRUE;
		} else {
			err = PTR_ERR(p_video_delay_tsk);
			rtd_pr_vsc_debug("Unable to start create_video_delay_task (err_id = %d)./n", err);
		}
	}
}


static void delete_video_delay_task(void)
{

	int ret;
	if (video_delay_task_flag) {
		ret = kthread_stop(p_video_delay_tsk);
		if (!ret) {
			p_video_delay_tsk = NULL;
			video_delay_task_flag = FALSE;
			rtd_pr_vsc_debug("video_delay_task thread stopped\n");
		}
	}

}
#endif

unsigned char rtk_hal_vsc_SetDelayBuffer(VIDEO_WID_T wId, UINT8 buffer)
{
#if 1//def CONFIG_REALTEK_2K_MODEL_ENABLED
	unsigned int timeoutcnt = 100;
	rtd_pr_vsc_emerg("function=%s,buffernub=%d\n",__FUNCTION__,buffer);
	if(wId == VIDEO_WID_0){
		if((Scaler_get_data_framesync(SLR_MAIN_DISPLAY) == TRUE))
		{
			rtd_pr_vsc_emerg("[%s]data fs can't enable mdomain video delay\n",__FUNCTION__);
			return TRUE;
		}
		if((buffer + 3) == drv_memory_Get_multibuffer_number())
		{
			rtd_pr_vsc_emerg("[%s]delay buf no changed\n",__FUNCTION__);
			return TRUE;
		}

		if(buffer >=1 && buffer <=5)
		{
			if(scaler_memory_alloc_multibuf() == 1)
			{
				rtd_pr_vsc_emerg("[MultiBuf]M-domain Multi-buffer 4K alloc buf fail,run triple buf!!!\n");
				drv_memory_Set_multibuffer_flag(_DISABLE);
				return TRUE;
			}

			down(&VIDEO_DELAY_Semaphore);
			drv_memory_Set_multibuffer_number_pre(drv_memory_Get_multibuffer_number());
			drv_memory_Set_multibuffer_number(buffer + 3);

			drv_memory_Set_multibuffer_flag(_ENABLE);
			drv_memory_Set_multibuffer_changed(true);
			up(&VIDEO_DELAY_Semaphore);
			rtd_pr_vsc_emerg("trigger video_delay on task\n");
			video_delay_wakeup();
		}
		else
		{

			down(&VIDEO_DELAY_Semaphore);
			drv_memory_Set_multibuffer_number_pre(drv_memory_Get_multibuffer_number());
			drv_memory_Set_multibuffer_number(3);

			drv_memory_Set_multibuffer_flag(_DISABLE);
			drv_memory_Set_multibuffer_changed(true);
			up(&VIDEO_DELAY_Semaphore);
			rtd_pr_vsc_emerg("trigger video_delay off task\n");
			video_delay_wakeup();
			while((drv_memory_Get_multibuffer_changed() == TRUE) && (--timeoutcnt))
			{
				if(!MDOMAIN_CAP_Cap_In1_enable_get_in1_cap_enable(rtd_inl(MDOMAIN_CAP_Cap_In1_enable_reg)))
					break;
				msleep(0); //wait switch buffer done,then release memory
			}
			if(timeoutcnt == 0)
				rtd_pr_vsc_emerg("function=%s,wait switch buffer timeout!\n",__FUNCTION__);

			scaler_memory_free_multibuf();
		}
		drv_memory_send_multibuffer_number_to_smoothtoogh();

	}
#endif
	return TRUE;
}


#ifndef UT_flag

SMOOTH_TOGGLE_INFO temp_info_main;
void scaler_save_main_info(void)
{
	temp_info_main.IMD_SMOOTH_H_ACT_WID_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE);
	temp_info_main.IMD_SMOOTH_H_ACT_STA_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_V_ACT_LEN_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE);
	temp_info_main.IMD_SMOOTH_V_ACT_STA_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_H_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID);
	temp_info_main.IMD_SMOOTH_H_ACT_STA= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA);
	temp_info_main.IMD_SMOOTH_V_ACT_LEN= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN);
	temp_info_main.IMD_SMOOTH_V_ACT_STA= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA);
	temp_info_main.IMD_SMOOTH_FRAMESYNC = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC);
	temp_info_main.IMD_SMOOTH_DI_WID= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID);

	temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN);
	temp_info_main.IMD_SMOOTH_CapWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID);
	temp_info_main.IMD_SMOOTH_CapLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN);
	temp_info_main.IMD_SMOOTH_MEM_ACT_HSTA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA);
	temp_info_main.IMD_SMOOTH_MEM_ACT_VSTA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA);
	temp_info_main.IMD_SMOOTH_MEM_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN);
	temp_info_main.IMD_SMOOTH_MEM_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID);
	temp_info_main.IMD_SMOOTH_DispLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN);
	temp_info_main.IMD_SMOOTH_DispWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID);
	temp_info_main.IMD_SMOOTH_DISP_RTNR =Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR);
	temp_info_main.IMD_SMOOTH_DISP_10BIT = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT);
	temp_info_main.IMD_SMOOTH_DISP_THRIP = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP);
	temp_info_main.IMD_SMOOTH_DISP_MA3A = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A);
	temp_info_main.IMD_SMOOTH_DISP_422CAP= Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP);
	temp_info_main.IMD_SMOOTH_DISP_422= Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422);
}
void scaler_update_struct_info(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY) {
		rtd_pr_vsc_emerg("update main scaler struct info\n");
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE, temp_info_main.IMD_SMOOTH_H_ACT_WID_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_H_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE, temp_info_main.IMD_SMOOTH_V_ACT_LEN_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_V_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID, temp_info_main.IMD_SMOOTH_H_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA, temp_info_main.IMD_SMOOTH_H_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN, temp_info_main.IMD_SMOOTH_V_ACT_LEN);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA, temp_info_main.IMD_SMOOTH_V_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC, temp_info_main.IMD_SMOOTH_FRAMESYNC);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID, temp_info_main.IMD_SMOOTH_DI_WID);

		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE, temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE, temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA, temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA, temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID, temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN, temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID, temp_info_main.IMD_SMOOTH_CapWid);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN, temp_info_main.IMD_SMOOTH_CapLen);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA, temp_info_main.IMD_SMOOTH_MEM_ACT_HSTA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA, temp_info_main.IMD_SMOOTH_MEM_ACT_VSTA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN, temp_info_main.IMD_SMOOTH_MEM_ACT_LEN );
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID, temp_info_main.IMD_SMOOTH_MEM_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN, temp_info_main.IMD_SMOOTH_DispLen);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID, temp_info_main.IMD_SMOOTH_DispWid);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, temp_info_main.IMD_SMOOTH_DISP_RTNR);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT, temp_info_main.IMD_SMOOTH_DISP_10BIT);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP, temp_info_main.IMD_SMOOTH_DISP_THRIP);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A, temp_info_main.IMD_SMOOTH_DISP_MA3A);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP, temp_info_main.IMD_SMOOTH_DISP_422CAP);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422, temp_info_main.IMD_SMOOTH_DISP_422);
	} else {
		rtd_pr_vsc_emerg("update sub scaler struct info\n");
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_WID,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_FRAMESYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DI_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID));

		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_LEN,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_HSTA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_VSTA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_MA3A, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	}
}

/*//no used
unsigned int VSC_PM_REGISTER_DATA[][2]
=
{
	//VGIP
	{SUB_VGIP_VGIP_CHN2_DELAY_reg, 0},
	{SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg, 0},
	{SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg, 0},
	{SUB_VGIP_VGIP_CHN2_CTRL_reg, 0},

	{VGIP_VGIP_CHN1_MISC_reg, 0},
	{VGIP_Data_Path_Select_reg, 0},
	{VGIP_VGIP_CHN1_DELAY_reg, 0},
	{VGIP_VGIP_CHN1_ACT_HSTA_Width_reg, 0},
	{VGIP_VGIP_CHN1_ACT_VSTA_Length_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL1_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL2_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL3_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL4_reg, 0},
	{VGIP_FRAMEPACKING_CTRL1_reg, 0},
	{VGIP_FRAMEPACKING_CTRL2_reg, 0},
	{VGIP_VGIP_CHN1_CTRL_reg, 0},
	{VGIP_INT_CTL_reg, 0},

	//RGB2YUV
	{RGB2YUV_Tab1_M11_M12_reg, 0},
	{RGB2YUV_Tab1_M13_M21_reg, 0},
	{RGB2YUV_Tab1_M22_M23_reg, 0},
	{RGB2YUV_Tab1_M31_M32_reg, 0},
	{RGB2YUV_Tab1_M33_YGain_reg,0},
	{RGB2YUV_Tab1_Yo_reg, 0},
	{RGB2YUV_ICH1_422to444_CTRL_reg, 0},
	{RGB2YUV_ICH1_RGB2YUV_CTRL_reg, 0},

	{RGB2YUV_Tab2_M11_M12_reg, 0},
	{RGB2YUV_Tab2_M13_M21_reg, 0},
	{RGB2YUV_Tab2_M22_M23_reg, 0},
	{RGB2YUV_Tab2_M31_M32_reg, 0},
	{RGB2YUV_Tab2_M33_Y_Gain_reg, 0},
	{RGB2YUV_Tab2_Yo_reg, 0},
	{RGB2YUV_ICH2_422to444_CTRL_reg, 0},
	{RGB2YUV_ICH2_RGB2YUV_CTRL_reg, 0},
	//UZD
	{SCALEDOWN_ICH1_sdnr_444to422_CTRL_reg, 0},
	{SCALEDOWN_ICH1_IBUFF_CTRLI_BUFF_CTRL_reg, 0},
	{SCALEDOWN_ICH1_UZD_FIR_Coef_Tab1_C0_reg, 0},
	{SCALEDOWN_ICH1_UZD_FIR_Coef_Tab2_C0_reg, 0},
	{SCALEDOWN_ICH1_hsd_3d_boundary_reg, 0},
	{SCALEDOWN_ICH1_UZD_Scale_Hor_Factor_reg, 0},
	{SCALEDOWN_ICH1_UZD_Scale_Ver_Factor_reg, 0},
	{SCALEDOWN_ICH1_UZD_Initial_Value_reg, 0},
	{SCALEDOWN_ICH1_UZD_Hor_Segment_reg, 0},
	{SCALEDOWN_ICH1_UZD_Hor_Delta1_reg, 0},
	{SCALEDOWN_ICH1_UZD_Ctrl0_reg, 0},
	{SCALEDOWN_ICH1_UZD_Ctrl1_reg, 0},

	{HSD_DITHER_DI_UZD_FIR_Coef_Tab1_C0_reg, 0},
	{HSD_DITHER_DI_HSD_Scale_Hor_Factor_reg, 0},
	{HSD_DITHER_DI_HSD_Initial_Value_reg, 0},
	{HSD_DITHER_DI_HSD_Hor_Delta1_reg, 0},
	{HSD_DITHER_DI_HSD_Hor_Segment_reg, 0},
	{HSD_DITHER_DI_HSD_Ctrl0_reg, 0},

	{SCALEDOWN_ICH2_UZD_H_Output_Size_reg, 0},
	{SCALEDOWN_ICH2_UZD_Scale_Hor_Factor_reg, 0},
	{SCALEDOWN_ICH2_UZD_Scale_Ver_Factor_reg, 0},
	{SCALEDOWN_ICH2_UZD_Initial_Value_reg, 0},
	{SCALEDOWN_ICH2_UZD_Ctrl0_reg, 0},
	{SCALEDOWN_ICH2_UZD_Ctrl1_reg, 0},
	//DI
	//{EXSRAM_CTRL_reg, 0},
	{DI_Color_Recovery_Option_reg, 0},
	{DI_DI_DMA_Multi_Req_Num_reg, 0},
	{DI_IM_DI_WEAVE_WINDOW_CONTROL_reg, 0},
	{DI_db_reg_ctl_reg, 0},
	{DI_IM_DI_DMA_reg, 0},
	{DI_DDR_RDATDMA_WTLENNUM_reg, 0},
	{DI_DDR_RINFDMA_WTLENNUM_reg, 0},
	{DI_DDR_WDATDMA_WTLENNUM_reg, 0},
	{DI_DDR_DATDMA_RM_reg, 0},
	{DI_DDR_WINFDMA_WTLENNUM_reg, 0},
	{DI_DDR_INFDMA_RM_reg, 0},
	{DI_DI_DATMemoryStartAdd1_reg, 0},
	{DI_DI_DATMemoryStartAdd2_reg, 0},
	{DI_DI_DATMemoryStartAdd3_reg, 0},
	{DI_DI_DATMemoryStartAdd4_reg, 0},
	{DI_DI_INFMemoryStartAdd1_reg, 0},
	{DI_DI_INFMemoryStartAdd2_reg, 0},
	{DI_DI_DATMemoryStartAdd1_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd2_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd3_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd4_3D_reg, 0},
	{DI_DI_INFMemoryStartAdd1_3D_reg, 0},
	{DI_DI_INFMemoryStartAdd2_3D_reg, 0},
	{DI_IM_DI_ACTIVE_WINDOW_CONTROL_reg, 0},
	{DI_IM_DI_BTR_CONTROL_reg, 0},
	{DI_IM_DI_MPEG_SEQUENCE_APP_reg, 0},
	{DI_IM_DI_FRAMESOBEL_STATISTIC_reg, 0},
	{DI_IM_DI_CONTROL_reg, 0},
	//MTG:
	{PPOVERLAY_MAIN_DEN_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_DEN_V_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Background_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Background_V_Start_End_reg, 0},
	{PPOVERLAY_Main_Background_Color1_reg, 0},
	{PPOVERLAY_Main_Background_Color2_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color1_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color2_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color3_reg, 0},
	{PPOVERLAY_MAIN_Active_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Active_V_Start_End_reg, 0},

	{PPOVERLAY_SUB_DEN_H_Start_Width_reg, 0},
	{PPOVERLAY_SUB_DEN_V_Start_Length_reg, 0},
	{PPOVERLAY_SUB_Background_H_Start_End_reg, 0},
	{PPOVERLAY_SUB_Background_V_Start_End_reg, 0},
	{PPOVERLAY_SUB_Background_Color1_reg, 0},
	{PPOVERLAY_SUB_Background_Color2_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color1_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color2_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color3_reg, 0},
	{PPOVERLAY_SUB_Active_H_Start_End_reg, 0},
	{PPOVERLAY_SUB_Active_V_Start_End_reg, 0},

	//UZU
	{SCALEUP_DM_UZUMAIN_H_PARTIAL_DROP_reg, 0},
	{SCALEUP_DM_UZUMAIN_V_PARTIAL_DROP_reg, 0},
	//{SCALEUP_DM_UZUMAIN_Adapt12tap_reg, 0},
	{SCALEUP_DM_UZU_8tap_deringv_reg, 0},
	{SCALEUP_DM_UZU_V8CTRL_reg, 0},
	//{SCALEUP_DM_UZU_AdaptV8CTRL_reg, 0},
	{SCALEUP_DM_UZU_Scale_Hor_Factor_reg, 0},
	{SCALEUP_DM_UZU_Scale_Ver_Factor_reg, 0},
	{SCALEUP_DM_UZU_Hor_Delta1_reg, 0},
	{SCALEUP_DM_UZU_Hor_Delta2_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment1_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment2_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment3_reg, 0},
	{SCALEUP_DM_UZU_Initial_Value_reg, 0},
	{SCALEUP_DM_UZU_Input_Size_reg, 0},
	{SCALEUP_D_UZU_Globle_Ctrl_reg, 0},
	{SCALEUP_DM_UZU_Ctrl_reg, 0},

	{SCALEUP_DS_UZU_Scale_Ver_Factor_reg, 0},
	{SCALEUP_DS_UZU_Scale_Hor_Factor_reg, 0},
	{SCALEUP_DS_UZU_Initial_Value_reg, 0},
	{SCALEUP_DS_UZU_Input_Size_reg, 0},
	{SCALEUP_DS_UZU_Ctrl_reg, 0},
	//Data FRC:m cap
	{MDOMAIN_CAP_Main_SDNR_cxxto64_reg, 0},
	{MDOMAIN_CAP_DDR_In1WTLVL_Num_reg, 0},
	{MDOMAIN_CAP_DDR_In1WrLen_Rem_reg, 0},
	{MDOMAIN_CAP_DDR_In1Addr_reg, 0},
	{MDOMAIN_CAP_DDR_In1LineStep_reg, 0},
	{MDOMAIN_CAP_DDR_In1BlkStep_reg, 0},
	{MDOMAIN_CAP_DDR_In1_2ndAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In1_3rdAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In1LineNum_reg, 0},
	{MDOMAIN_CAP_DDR_In1Ctrl_reg, 0},
	{MDOMAIN_CAP_CapMain_BoundaryAddr1_reg, 0},
	{MDOMAIN_CAP_CapMain_BoundaryAddr2_reg, 0},
	{MDOMAIN_CAP_CapMain_SBS_VSD_CAP_CTRL_reg, 0},
	{MDOMAIN_CAP_CapMain_SBS_VSD_CAP_OFFSET_reg, 0},
	{MDOMAIN_CAP_Capture1_byte_swap_reg, 0},
	{MDOMAIN_CAP_Cap_In1_enable_reg, 0},

	{MDOMAIN_CAP_Sub_SDNR_cxxto64_reg, 0},
	{MDOMAIN_CAP_DDR_In2WTLVL_reg, 0},
	{MDOMAIN_CAP_DDR_In2WrLen_Rem_reg, 0},
	{MDOMAIN_CAP_DDR_In2Addr_reg, 0},
	{MDOMAIN_CAP_DDR_In2LineStep_reg, 0},
	{MDOMAIN_CAP_DDR_In2BlkStep_reg, 0},
	{MDOMAIN_CAP_DDR_In2_2ndAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In2LineNum_reg, 0},
	{MDOMAIN_CAP_DDR_In2Ctrl_reg, 0},
	{MDOMAIN_CAP_CapSub_BoundaryAddr1_reg, 0},
	{MDOMAIN_CAP_CapSub_BoundaryAddr2_reg, 0},
	{MDOMAIN_CAP_Cap_In2_enable_reg, 0},
	//m disp
	{MDOMAIN_DISP_DDR_MainPreVStart_reg, 0},
	{MDOMAIN_DISP_DDR_MainNumWTL_reg, 0},
	{MDOMAIN_DISP_DDR_MainRdNumLenRem_reg, 0},
	{MDOMAIN_DISP_DDR_MainAddr_reg, 0},
	{MDOMAIN_DISP_DDR_MainAddrDropBits_reg, 0},
	{MDOMAIN_DISP_DDR_MainLineStep_reg, 0},
	{MDOMAIN_DISP_DDR_MainBlkStep_reg, 0},
	{MDOMAIN_DISP_DDR_MainLineNum_reg, 0},
	{MDOMAIN_DISP_DDR_MainCtrl_reg, 0},
	{MDOMAIN_DISP_DDR_Main2ndAddr_reg, 0},
	{MDOMAIN_DISP_DDR_Main3rdAddr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_1ST_Addr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_2ND_Addr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_3RD_Addr_reg, 0},
	{MDOMAIN_DISP_Display_byte_channel_swap_reg, 0},
	{MDOMAIN_DISP_Disp_main_enable_reg, 0},

	{MDOMAIN_DISP_DDR_SubPreVStart_reg, 0},
	{MDOMAIN_DISP_DDR_SubPixNumWTL_reg, 0},
	{MDOMAIN_DISP_DDR_SubRdNumLenRem_reg, 0},
	{MDOMAIN_DISP_DDR_SubAddr_reg, 0},
	{MDOMAIN_DISP_DDR_SubAddrDropBits_reg, 0},
	{MDOMAIN_DISP_DDR_SubLineStep_reg, 0},
	{MDOMAIN_DISP_DDR_SubBlkStep_reg, 0},
	{MDOMAIN_DISP_DDR_SubLineNum_reg, 0},
	{MDOMAIN_DISP_DDR_SubCtrl_reg, 0},
	{MDOMAIN_DISP_DDR_Sub2ndAddr_reg, 0},
	{MDOMAIN_DISP_Disp_sub_enable_reg, 0},

};
*/

#ifdef CONFIG_PM
static int vsc_suspend (struct device *p_dev)
{
#if 0//No need vsc suspend
	int i,size;

	/*rtd_pr_vsc_debug("func=%s line=%d \n", __FUNCTION__, __LINE__);*/

	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		VSC_PM_REGISTER_DATA[i][1] = rtd_inl(VSC_PM_REGISTER_DATA[i][0]);
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
//Eric@20171127 Disable i2rnd & pst when DC off
#ifdef CONFIG_I2RND_ENABLE
	//Initial Main path & Sub path stage
	vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
	vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
	vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_DISABLE;
	rtd_pr_vsc_emerg("[%s]I2RND close\n", __FUNCTION__);
#endif
    pm_runtime_disable(&vsc_platform_devs->dev);//disable runtime PM
    VSC_PM_LOG("info", "video", (&vsc_platform_devs->dev), "stop", "ok", "realtek", "device STR PM disable");

#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
	scaler_pst_suspend();
#endif
	return 0;
}

static int vsc_resume (struct device *p_dev)
{
#if 0//No need vsc resume
	int i, size;
	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		IoReg_Write32(VSC_PM_REGISTER_DATA[i][0],VSC_PM_REGISTER_DATA[i][1]);
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
#ifdef CONFIG_I2RND_ENABLE
	//Eric@20171127I2rnd & pst init
	drvif_scaler_i2rnd_initial();
	drvif_scaler_pst_initial(_MAIN_MD);
	drvif_scaler_pst_initial(_SUB_MD);
#endif
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
	scaler_pst_resume();
#endif
	reset_any_srcrect(&main_dispwin_for_only_xy);
	reset_any_srcrect(&main_dispwin_pre);
#ifdef CONFIG_DUAL_CHANNEL
	reset_any_srcrect(&sub_dispwin_pre);
#endif
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#ifdef CONFIG_DUAL_CHANNEL
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#endif
	//update game_mode_cmd_pre and st_game_mode_cmd_pre flag
	game_mode_cmd_pre = Get_Val_game_mode_cmd_check();
	Set_Val_st_game_mode_cmd_pre(Get_Val_smooth_toggle_game_mode_check_cnt());
	DbgSclrFlgTkr.adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
	Set_Val_vpq_ld_running_flag(FALSE);
	DbgSclrFlgTkr.vpq_ld_first_boot = TRUE;
	sub_mode_type = KADP_VSC_SUB_MODE_PIP;//reset sub mode.
	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();
	data_access_enable = 0;//avoid access the register
	pm_runtime_enable(&vsc_platform_devs->dev);//enable runtime PM
	VSC_PM_LOG("info", "video", (&vsc_platform_devs->dev), "start", "ok", "realtek", "device STR PM enable");
	return 0;
}
#ifdef CONFIG_HIBERNATION
static int vsc_resume_std (struct device *p_dev)
{
#if 0//No need vsc resume
	int i, size;
	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		IoReg_Write32(VSC_PM_REGISTER_DATA[i][0],VSC_PM_REGISTER_DATA[i][1]);
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
	ResetShareMem();//reset share memory to 0
	Set_send_panel_para_flag(TRUE);//Need to send panel parameter
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#ifdef CONFIG_DUAL_CHANNEL
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#endif
	game_mode_cmd_pre = Get_Val_game_mode_cmd_check();	//Update game_mode_cmd_pre to avoid fll task break.
	Set_Val_st_game_mode_cmd_pre(Get_Val_smooth_toggle_game_mode_check_cnt());
	DbgSclrFlgTkr.adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
	Set_Val_vpq_ld_running_flag(FALSE);
	DbgSclrFlgTkr.vpq_ld_first_boot = TRUE;
	sub_mode_type = KADP_VSC_SUB_MODE_PIP;//reset sub mode.
	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();
	data_access_enable = 0;//avoid access the register
	pm_runtime_enable(&vsc_platform_devs->dev);//enable runtime PM
	VSC_PM_LOG("info", "video", (&vsc_platform_devs->dev), "start", "ok", "realtek", "device STD PM enable");
	return 0;
}
#endif
#endif
int vsc_open(struct inode *inode, struct file *filp) {
	return 0;
}

ssize_t  vsc_read(struct file *filep, char *buffer, size_t count, loff_t *offp)
{
	return 0;

}

ssize_t vsc_write(struct file *filep, const char *buffer, size_t count, loff_t *offp)
{
	long ret = count;
	char cmd_buf[100] = {0};
	StructRect active_size = {0}, ori_size = {0};

	#ifndef CONFIG_ARM64
	rtd_pr_vsc_notice("%s(): count=%d, buf=0x%08lx\n", __func__, count, (long)buffer);
	#endif

	if (count >= 100)
		return -EFAULT;

	if (copy_from_user(cmd_buf, buffer, count)) {
		ret = -EFAULT;
	}

	if(count > 0) {
	   cmd_buf[count] = '\0';
	}

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
	if ((cmd_buf[0] == 't') && (cmd_buf[1] == 'e') && (cmd_buf[2] == 's') && (cmd_buf[3] == 't') && (cmd_buf[4] == 'm')
            && (cmd_buf[5] == 'o') && (cmd_buf[6] == 'd') && (cmd_buf[7] == 'e') && (cmd_buf[8] == '='))

    {
            // shell command as: echo testmode=1 testresult=/tmp/var/log/xxxxx > /dev/vodev
            if((cmd_buf[9] == '1') && (cmd_buf[11] == 't') && (cmd_buf[20] == 't') && (cmd_buf[21] == '=')){
			rtd_pr_vsc_notice("\n=== rtkscaler: enable dump CRC =============\n");
                   rtkscaler_dumpCRC_enable(&cmd_buf[22], (count-22)-1);
			rtd_pr_vsc_notice("\n=======================================\n");
            } // shell command as: echo testmode=1 /tmp/var/log/xxxxx > /dev/vodev
		else if ((cmd_buf[9] == '1') && (cmd_buf[11] == '/')) {
			rtd_pr_vsc_notice("\n=== rtkvo: enable dump CRC =============\n");
                   rtkscaler_dumpCRC_enable(&cmd_buf[11], (count-11)-1);
			rtd_pr_vsc_notice("\n=======================================\n");
            } // shell command as: echo testmode=0 > /dev/vodev
		else if (cmd_buf[9] == '0') {
			rtd_pr_vsc_notice("\n=== rtkvo: disable dump CRC =============\n");
			rtkscaler_dumpCRC_disable();
			rtd_pr_vsc_notice("\n=======================================\n");
		}
		else {
			rtd_pr_vsc_notice("%s\n", cmd_buf);
		}
	}
        else {
		rtd_pr_vsc_notice("%s\n", cmd_buf);
	}
#endif

	// shell command : echo test_videolatency=1 > /dev/vscdev
	if(strcmp(cmd_buf, "test_videolatency=1\n") == 0){
		set_latency_pattern_self_test(1);
		rtd_pr_vsc_emerg("enable test_videolatency \n");
	}else if(strcmp(cmd_buf, "test_videolatency=0\n") == 0){
		set_latency_pattern_self_test(0);
		rtd_pr_vsc_emerg("disable test_videolatency \n");
	}
    else if(strcmp(cmd_buf, "vsc_runtime_suspend\n") == 0){// shell command : echo vsc_runtime_suspend > /dev/vscdev
        if(vsc_platform_devs)
        {
        	//set_low_power_skip_video_cmd_flag(TRUE);//skip command
        	msleep(100);//wait skip commanpm
        	rtk_video_pm_rumtime_suspend(&vsc_platform_devs->dev);
        }
    }else if(strcmp(cmd_buf, "vsc_runtime_resume\n") == 0){// shell command : echo vsc_runtime_resume > /dev/vscdev
        if(vsc_platform_devs)
        {
        	rtk_video_pm_rumtime_resume(&vsc_platform_devs->dev);
        	//set_low_power_skip_video_cmd_flag(FALSE);//no skip command
        }
    }else if(strcmp(cmd_buf, "bbd_wakeup_ori\n") == 0){// shell command : echo bbd_wakeup_ori > /dev/vscdev
        ori_size.width = 1920;
        ori_size.height = 1080;
        active_size.width = 1920;
        active_size.height = 1080;
        bbd_active_win_event_update_wakeup(SLR_SUB_DISPLAY, active_size, ori_size);
    }else if(strcmp(cmd_buf, "bbd_wakeup_1_2\n") == 0){// shell command : echo bbd_wakeup_1_2 > /dev/vscdev
        ori_size.width = 1920;
        ori_size.height = 1080;
        active_size.width = 960;
        active_size.height = 540;
        active_size.x = 480;
        active_size.y = 270;
        bbd_active_win_event_update_wakeup(SLR_SUB_DISPLAY, active_size, ori_size);
    }else if(strcmp(cmd_buf, "bbd_wakeup_3_4\n") == 0){// shell command : echo bbd_wakeup_3_4 > /dev/vscdev
        ori_size.width = 1920;
        ori_size.height = 1080;
        active_size.width = 1440;
        active_size.height = 810;
        active_size.x = 240;
        active_size.y = 135;
        bbd_active_win_event_update_wakeup(SLR_SUB_DISPLAY, active_size, ori_size);
    }else if(strcmp(cmd_buf, "bbd_wakeup_4_5\n") == 0){// shell command : echo bbd_wakeup_4_5 > /dev/vscdev
        ori_size.width = 1920;
        ori_size.height = 1080;
        active_size.width = 1536;
        active_size.height = 864;
        active_size.x = 192;
        active_size.y = 108;
        bbd_active_win_event_update_wakeup(SLR_SUB_DISPLAY, active_size, ori_size);
    }else if(strcmp(cmd_buf, "bbd_wakeup_cust_1\n") == 0){// shell command : echo bbd_wakeup_cust_1 > /dev/vscdev
        ori_size.width = 1920;
        ori_size.height = 1080;
        active_size.width = 490;
        active_size.height = 1080;
        active_size.x = 715;
        bbd_active_win_event_update_wakeup(SLR_SUB_DISPLAY, active_size, ori_size);
    }else if(strcmp(cmd_buf, "bbd_wakeup_cust_2\n") == 0){// shell command : echo bbd_wakeup_cust_2 > /dev/vscdev
        ori_size.width = 1920;
        ori_size.height = 1080;
        active_size.width = 1532;
        active_size.height = 850;
        active_size.x = 225;
        active_size.y = 115;
        bbd_active_win_event_update_wakeup(SLR_SUB_DISPLAY, active_size, ori_size);
    }

	return ret;
}

int vsc_release(struct inode *inode, struct file *filep)
{
	return 0;
}

#endif //#ifndef UT_flag
unsigned char vsc_set_vd_ptg(unsigned char bOnOff)
{
	//rtd_pr_vsc_emerg( "function=%s, line=%d\n", __FUNCTION__, __LINE__);

	if(bOnOff == _ENABLE) {
		//Set VD PatternGen
		IoReg_SetBits(VDTOP_PATTERN_CONTROL_reg,_BIT0);
		IoReg_Write32(VDTOP_AD_SW_CTRL0_reg, 0x0);
		//Set VGIP PatternGen
		IoReg_SetBits(SUB_VGIP_VGIP_CHN2_CTRL_reg,_BIT27);
	}
	else {
		//Clear VD PatternGen
		IoReg_ClearBits(VDTOP_PATTERN_CONTROL_reg,_BIT0);
		IoReg_Write32(VDTOP_AD_SW_CTRL0_reg, 0xc9);
		//Clear VGIP PatternGen
		IoReg_ClearBits(SUB_VGIP_VGIP_CHN2_CTRL_reg,_BIT27);
	}
	return TRUE;
}

unsigned char vsc_get_uzu_crc(VIDEO_WID_T wid, unsigned int *CRC_Rsult)
{
	//rtd_pr_vsc_emerg( "function=%s, line=%d\n", __FUNCTION__, __LINE__);
	unsigned int iResult = 0x00;
	unsigned int golden = 0x3d8e33a2;

	//Set M-Domain CRC Bits
	if(wid == VIDEO_WID_0) {
		IoReg_SetBits(SCALEUP_DM_MEM_CRC_CTRL_reg,_BIT1|_BIT0);
	}
	else if(wid == VIDEO_WID_1) {
		IoReg_SetBits(SCALEUP_DS_MEM_CRC_CTRL_reg,_BIT1|_BIT0);
	}
	msleep(1000);
	//Get M-Domain CRC Result
	if(wid == VIDEO_WID_0) {
		iResult = IoReg_Read32(SCALEUP_DM_MEM_CRC_Result_reg);
	}
	else if(wid == VIDEO_WID_1) {
		iResult = IoReg_Read32(SCALEUP_DS_MEM_CRC_Result_reg);
	}

	if(CRC_Rsult)
	{
		if(iResult == golden)
			*CRC_Rsult = TRUE;
		else
			*CRC_Rsult = FALSE;
	}

	return TRUE;
}

unsigned char i3dma_uzd_flag=1;
void set_i3dma_uzd(unsigned char i3dma_uzd)
{
	i3dma_uzd_flag=i3dma_uzd;
}

unsigned char get_i3dma_uzd(void)
{
	return i3dma_uzd_flag;
}

unsigned char vsc_set_uzd_path(unsigned char i3dma_uzd)
{
	//rtd_pr_vsc_emerg( "function=%s, line=%d\n", __FUNCTION__, __LINE__);

	set_i3dma_uzd(i3dma_uzd);

	return TRUE;
}

unsigned int vsc_ioctl_cmd = 0;
void Set_Val_vsc_ioctl_cmd(unsigned int cmd_id){
	vsc_ioctl_cmd = cmd_id;
}

unsigned int Get_Val_vsc_ioctl_cmd(void){
	return vsc_ioctl_cmd;
}

long vsc_ioctl(struct file *file, unsigned int cmd,  unsigned long arg)
{
	extern KADP_VFE_AVD_TIMING_INFO_T *Get_AVD_LGETiminginfo(void);
	unsigned int before_time = 0;
	unsigned int after_time = 0;
	KADP_VFE_AVD_TIMING_INFO_T *ptLGETimingInfo = NULL;
	StructDisplayInfo * p_adc_dispinfo = NULL;
	//HDMI_TIMING_T hdmi_timing_info = {0, COLOR_RGB, HDMI_COLORIMETRY_NOSPECIFIED, 0 ,HDMI3D_2D_ONLY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	vfe_hdmi_timing_info_t hdmi_timing_info;

	int retval = 0;
	//rtd_pr_vsc_debug("VSC: vsc_ioctl, %x;;agr:%x\n", cmd, *((unsigned int *)arg));

	if (_IOC_TYPE(cmd) != VSC_IOC_MAGIC || _IOC_NR(cmd) >= VSC_IOC_MAXNR) return -ENOTTY ;

	switch (cmd)
	{
		case VSC_IOC_INITIALIZE:
		{
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			Set_Val_vsc_ioctl_cmd(cmd);
			if(fp_rtk_hal_vsc_initialize()==FALSE)
				retval =  -1;
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_pr_vsc_debug("VSC intial time=%d ms", (after_time-before_time));
			break;
		}
		case VSC_IOC_UNINITIALIZE:
		{
			Set_Val_vsc_ioctl_cmd(cmd);
			if(fp_rtk_hal_vsc_uninitialize()==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_OPEN:
		{
			VIDEO_WID_T widid;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_OPEN copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_open(widid) == FALSE)
					retval =  -1;
				after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
				rtd_pr_vsc_debug("VSC open time=%d ms", (after_time-before_time));
			}
			break;
		}
		case VSC_IOC_CLOSE:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CLOSE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_close(widid)==FALSE)
					retval =  -1;
			}
			break;

		}
		case VSC_IOC_CONNECT:
		{
			VSC_CONNECT_PARA_T connectPara;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(copy_from_user((void *)&connectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
                if(connectPara.vsc_input.type == KADP_VSC_INPUTSRC_VDEC)
                {
                    if(connectPara.connectwid == KADP_VIDEO_WID_0)//current sub always live zoom case. Need to add livezoom condition later
                    {
                        if(!vdo0_connect)//means no call vdo connect
                        {
                            vdo_connect(connectPara.connectwid, connectPara.vsc_input.resourceIndex);
                        }
                    } else {
                        if(!vdo1_connect)//means no call vdo connect
                        {
                            vdo_connect(connectPara.connectwid, connectPara.vsc_input.resourceIndex);
                        }
                    }
                }
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_Connect((VIDEO_WID_T)connectPara.connectwid, connectPara.vsc_input, connectPara.outputmode)==FALSE)
				{
					retval =  -1;
				}
				after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
				rtd_pr_vsc_debug("VSC connect time=%d ms",(after_time-before_time));

			}
			break;
		}
		case VSC_IOC_DISCONNECT:
		{
			VSC_CONNECT_PARA_T disconnectPara;
			if(copy_from_user((void *)&disconnectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_Disconnect((VIDEO_WID_T)disconnectPara.connectwid, disconnectPara.vsc_input, disconnectPara.outputmode) == FALSE)
				{
					retval =  -1;
				}
                if(disconnectPara.vsc_input.type == KADP_VSC_INPUTSRC_VDEC)
                {
                    if(disconnectPara.connectwid == KADP_VIDEO_WID_0)//current sub always live zoom case. Need to add livezoom condition later
                    {
                        if(vdo0_connect)//means no call vdo connect
                        {
                            vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                        }
                    } else {
                        if(vdo1_connect)//means no call vdo connect
                        {
                            vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                        }
                    }
                }
			}
			break;
		}
		case VSC_IOC_SET_WINBLANK:
		{
			VSC_WINBLANK_PARA_T winblankpara;
			if(copy_from_user((void *)&winblankpara, (const void __user *)arg, sizeof(VSC_WINBLANK_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_WINBLANK copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_debug("winblankpara.winblankwid=%d,winblankpara.winblankbonoff=%d,winblankpara.winblankcolor=%d\n", winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor);
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetWinBlank((VIDEO_WID_T)winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_ADAPTIVE_INPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			VIDEO_DDI_RECT_T inregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(VSC_GET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_ADAPTIVE_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(rtk_hal_vsc_GetInputRegion_ForAdaptive((VIDEO_WID_T)pframeregion.setframewid, &inregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &inregion, sizeof(VIDEO_DDI_RECT_T)) )
					{
						rtd_pr_vsc_err("[ERR] VSC_IOC_GET_INPUTREGION copy_to_user error \n");
						retval = -EFAULT;
					}
				}

			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVE_INPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVE_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(rtk_hal_vsc_SetInputRegion_ForAdaptive((VIDEO_WID_T)frameregion.setframewid, frameregion.inregion) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_INPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			KADP_VIDEO_RECT_T inregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(KADP_VIDEO_RECT_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_GetInputRegion(pframeregion.setframewid, &inregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &inregion, sizeof(KADP_VIDEO_RECT_T)) )
					{
						rtd_pr_vsc_err("[ERR] VSC_IOC_GET_INPUTREGION copy_to_user error \n");
						retval = -EFAULT;
	            	}
				}

			}
			break;
		}
		case VSC_IOC_SET_INPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetInputRegion(frameregion.setframewid, frameregion.inregion) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_OUTPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			KADP_VIDEO_RECT_T outregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(VSC_GET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_GetOutputRegion(pframeregion.setframewid, &outregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &outregion, sizeof(VIDEO_DDI_RECT_T)) )
					{
						rtd_pr_vsc_err("[ERR] VSC_IOC_GET_OUTPUTREGION copy_to_user error \n");
						retval = -EFAULT;
	            	}
				}
			}
			break;
		}
		case VSC_IOC_SET_OUTPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				virtual_w = true_wide;
				virtual_h = true_high;

				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)frameregion.setframewid, frameregion.inregion, virtual_w, virtual_h)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_WINFREEZE:
		{
			VSC_FREEZE_ACTION_T freezeact;
			if(copy_from_user((void *)&freezeact, (const void __user *)arg, sizeof(VSC_FREEZE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_WINFREEZE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_emerg( "freezeact.freezewid=%d,freezeact.freezeonoff=%d\n", freezeact.freezewid, freezeact.freezeonoff);
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetWinFreeze((VIDEO_WID_T)freezeact.freezewid, freezeact.freezeonoff)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_FREEZE_VIDEOFRAMEBUFFER:
		{
			VSC_FREEZE_ACTION_T freezeact;
			if(copy_from_user((void *)&freezeact, (const void __user *)arg, sizeof(VSC_FREEZE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_FREEZE_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Factory_SelfDiagnosis_Mode = TRUE;
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_FreezeVideoFrameBuffer((VIDEO_WID_T)freezeact.freezewid, freezeact.freezeonoff)==FALSE)
					retval =  -1;
				Factory_SelfDiagnosis_Mode = FALSE;
			}
			break;
		}
		case VSC_IOC_READ_VIDEOFRAMEBUFFER:
		{
			VSC_READ_BUFFER_ACTION_T readaction;
			if(copy_from_user((void *)&readaction, (const void *)arg, sizeof(VSC_READ_BUFFER_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				VIDEO_RECT_T kernelInregion;
				KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *kernelPRead;
				KADP_VIDEO_DDI_COLOR_STANDARD_T Color_standard ;
				KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T PixelColorFormat;
				Factory_SelfDiagnosis_Mode = TRUE;

				if(copy_from_user((void *)&kernelInregion, (const void *)to_user_ptr(readaction.pinregion), sizeof(VIDEO_DDI_RECT_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER kernelInregion copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				kernelPRead = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);

				Color_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
				PixelColorFormat = KADP_VIDEO_DDI_PIXEL_8BIT;
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_ReadVideoFrameBuffer((VIDEO_WID_T)readaction.bufferwid, &kernelInregion, kernelPRead, &Color_standard, &PixelColorFormat) == FALSE)
					retval =  -1;

				if(copy_to_user(to_user_ptr(readaction.pcolor_standard), (void *)&Color_standard, sizeof(KADP_VIDEO_DDI_COLOR_STANDARD_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER pcolor_standard copy_to_user failed!!!!!!!!!!!!!!!\n");
				}

				if(copy_to_user(to_user_ptr(readaction.ppixelcolorformat), (void *)&PixelColorFormat, sizeof(KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER ppixelcolorformat copy_to_user failed!!!!!!!!!!!!!!!\n");
				}

				if(copy_to_user(to_user_ptr(readaction.pRead), (void *)kernelPRead, kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER pRead copy_to_user failed!!!!!!!!!!!!!!!\n");
				}
				dvr_free((void *)kernelPRead);
				Factory_SelfDiagnosis_Mode = FALSE;
			}
			break;
		}
		case VSC_IOC_WRITE_VIDEOFRAMEBUFFER:
		{
			VSC_WRITE_BUFFER_ACTION_T writeaction;
			if(copy_from_user((void *)&writeaction, (const void *)arg, sizeof(VSC_WRITE_BUFFER_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				KADP_VIDEO_RECT_T kernelInregion;
				KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *kernelPWrite;
				Factory_SelfDiagnosis_Mode = TRUE;
				if(copy_from_user((void *)&kernelInregion, (const void __user *)to_user_ptr(writeaction.pinregion), sizeof(VIDEO_DDI_RECT_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER kernelInregion copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				kernelPWrite = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);

				if(copy_from_user((void *)kernelPWrite, (const void __user *)to_user_ptr(writeaction.pWrite), kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER kernelPWrite copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_WriteVideoFrameBuffer(writeaction.bufferwid, &kernelInregion, kernelPWrite) == FALSE)
					retval =  -1;

				dvr_free((void *)kernelPWrite);
				Factory_SelfDiagnosis_Mode = FALSE;
			}

			break;
		}
		case VSC_IOC_CAPTURE_VIDEOFRAME:
		{
			VSC_CAPTURE_FRAME_ACTION_T capaction;
			if(copy_from_user((void *)&capaction, (const void __user *)arg, sizeof(VSC_CAPTURE_FRAME_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CAPTURE_VIDEOFRAME copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
#if 0//now have VT,no use vsc capture,but these code must keep:qiang_zhou
				if(rtk_hal_vsc_CaptureVideoFrame(capaction.place, capaction.pcaptureinfo) == FALSE)
					retval =  -1;
#endif
			}
			break;
		}
		case VSC_IOC_SET_RGB444MODE:
		{
			bool boffon;
			if(copy_from_user((void *)&boffon, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_RGB444MODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_debug("VSC_IOC_SET_RGB444MODE=%x\n", boffon);
				Set_Val_vsc_ioctl_cmd(cmd);
				if( (0 != HAL_VPQ_MEMC_SetRGBYUVMode(boffon)) || (fp_rtk_hal_vsc_SetRGB444Mode(boffon)==FALSE) )
					retval =  -1;
			}
			break;
		}

#if 0//no 3d application
		case VSC_IOC_SET_3DFORSCALER:
		{

			TRIDTV_SCALER_CTRL_T p3dcfginfo;
			if(copy_from_user((void *)&p3dcfginfo, (const void __user *)arg, sizeof(TRIDTV_SCALER_CTRL_T )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_3DFORSCALER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Set3DForScaler(&p3dcfginfo) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_3DAUTODETECTMODE:
		{
			VSC_3DAUTODET_ACTION_T autodet;
			KADP_VIDEO_DDI_3D_FORMAT_TYPE_T threedtype = KADP_VIDEO_DDI_3D_FORMAT_MAX;
			if(copy_from_user((void *)&autodet, (const void __user *)arg, sizeof(VSC_3DAUTODET_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_3DAUTODETECTMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Get3DAutoDetectmode((VIDEO_WID_T)autodet.wid, &threedtype) == FALSE)
				{
					retval =  -1;
				}
				if (copy_to_user(to_user_ptr(autodet.pvideo3dtype), (void *)&threedtype, sizeof(KADP_VIDEO_DDI_3D_FORMAT_TYPE_T)) )
				{
                	rtd_pr_vsc_err("[ERR] VSC_IOC_GET_3DAUTODETECTMODE copy_to_user error \n");
					retval = EFAULT;
            	}
			}
			break;
		}
		case VSC_IOC_SET_3DPATTERNMODE:
		{
			VSC_3DPATTERNMODE_ACTION_T patternaction;
			if(copy_from_user((void *)&patternaction, (const void __user *)arg, sizeof(VSC_3DPATTERNMODE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_3DPATTERNMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Set3Dpatternmode((VIDEO_WID_T)patternaction.wid, patternaction.video3dtype) == FALSE)
					retval =  -1;
			}
			break;
		}
#endif

		case VSC_IOC_SET_VENCMODE:
		{
			VSC_SET_VENCMODE_ACTION_T venc;
			if(copy_from_user((void *)&venc, (const void __user *)arg, sizeof(VSC_SET_VENCMODE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_VENCMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetVENEMode(venc.framerate,venc.scantype)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_OPENV2G:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_OPENV2G copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_OpenV2G(widid)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_CLOSEV2G:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CLOSEV2G copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_CloseV2G(widid)==FALSE)
					retval =  -1;
			}

			break;
		}
		case VSC_IOC_GET_V2GFRAMEBUFFER:
		{
			VSC_GET_V2GFRAMEBUFFER_T v2gbf;
			if(copy_from_user((void *)&v2gbf, (const void __user *)arg, sizeof(VSC_GET_V2GFRAMEBUFFER_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_V2GFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
#if 0//now have VT,no use V2G,but these code must keep:qiang_zhou
				if(fp_rtk_hal_vsc_GetV2GFramebuffer(v2gbf.wid,v2gbf.pCaptureInfo) == FALSE)
					retval =  -1;
#endif
			}
			break;
		}
		case VSC_IOC_SET_UDINPUT:
		{
			KADP_VIDEO_UD_MODE_T udmode;
			if(copy_from_user((void *)&udmode, (const void __user *)arg, sizeof(udmode)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_UDINPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetUDInput(udmode)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_UDOUTPUT:
		{
			KADP_VIDEO_DDI_DIS_FMT_T disfmt;
			if(copy_from_user((void *)&disfmt, (const void __user *)arg, sizeof(KADP_VIDEO_DDI_DIS_FMT_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_UDOUTPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetUDOutput(disfmt)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_VIDEODELAYEDTIME:
		{
			VSC_GET_VIDEODELAYEDTIME_T vddelaytime;
			unsigned short delaytime = 0;
			if(copy_from_user((void *)&vddelaytime, (const void __user *)arg, sizeof(VSC_GET_VIDEODELAYEDTIME_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_VIDEODELAYEDTIME copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_GetVideoDelayedTime((VIDEO_WID_T)vddelaytime.wid, &delaytime) == FALSE)
				{
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(vddelaytime.pDelayedTime) , (void *)&delaytime, sizeof(unsigned short)) )
					{
						rtd_pr_vsc_err("[ERR] VSC_IOC_GET_VIDEODELAYEDTIME copy_to_user error \n");
						retval = -EFAULT;
	            	}
				}
			}
			break;
		}
		case VSC_IOC_SET_TITLEMODE:
		{
			bool bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_TITLEMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetTileMode(bonoff)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_TILEMAXROWVAL:
		{
			VSC_SET_TILEMAXROWVAL_T titlerowval;
			if(copy_from_user((void *)&titlerowval, (const void __user *)arg, sizeof(VSC_SET_TILEMAXROWVAL_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_TILEMAXROWVAL copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetTileMaxRowVal(titlerowval.uMaxRow,titlerowval.uMaxCol)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_TILEID:
		{
			unsigned char titleid;
			if(copy_from_user((void *)&titleid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_TILEID copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetTileID(titleid)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVESTREAM:
		{
			bool bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVESTREAM copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetAdaptiveStream(bonoff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVESTREAMEX:
		{
			VSC_ADAPTIVESTREAM_PARA_T adpstream;

			if(copy_from_user((void *)&adpstream, (const void __user *)arg, sizeof(VSC_ADAPTIVESTREAM_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVESTREAMEX copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetAdaptiveStreamEX((VIDEO_WID_T)adpstream.adaptivestreamwid,adpstream.adaptivestreambonoff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_SOCOUTPUTFMT:
		{
			KADP_VIDEO_UD_MODE_T socoutputfmt;
			if(copy_from_user((void *)&socoutputfmt, (const void __user *)arg, sizeof(KADP_VIDEO_UD_MODE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SOCOUTPUTFMT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetSOCOutputFMT(socoutputfmt) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_FRCTYPE:
		{
			unsigned char  frctype;
			if(copy_from_user((void *)&frctype, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_FRCTYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_SetFRCType(frctype) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_FRCTYPE:
		{
			unsigned char frctypeget;
			if(copy_from_user((void *)&frctypeget, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_FRCTYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_GetFRCType(frctypeget) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_GETMVOPSTATUS:
		{
			VSC_GET_GETMVOPSTATUS_T mvopstatus;
			BOOLEAN MVOPEnable = FALSE;
			if(copy_from_user((void *)&mvopstatus, (const void __user *)arg, sizeof(VSC_GET_GETMVOPSTATUS_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_GETMVOPSTATUS copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				if(fp_rtk_hal_vsc_GetMVOPStatus((VIDEO_WID_T)mvopstatus.wid, &MVOPEnable) == FALSE)//Current not use
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_VENCI3DDMA:
		{
			IDMA_DISPD_CAPTURE_INFO capInfo;
			if(copy_from_user((void *)&capInfo, (const void __user *)arg, sizeof(IDMA_DISPD_CAPTURE_INFO)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_VENCI3DDMA copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(cmd);
				drvif_I3DDMA_dispD_to_IdmaVI_idmaConfig(capInfo);
			}
			break;
		}
		case VSC_IOC_STOPVO:
		{
			/*
			down(get_vo_infosemaphore());
			set_vo_change_flag(TRUE);
   			memset(Get_VO_Dispinfo(), 0, sizeof(StructDisplayInfo));
			up(get_vo_infosemaphore());
			*/
			Set_Val_vsc_ioctl_cmd(cmd);
			break;
		}
		case VSC_IOC_GETINPUTINFO:
		{
			VSC_GET_INPUT_INFO info;
			SCALER_INPUT_INFO input_info = {0, 0, 0, 0, 0, 0};
			if(copy_from_user((void *)&info, (const void __user *)arg, sizeof(VSC_GET_INPUT_INFO )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GETINPUTINFO copy_from_user failed!!!!!!!!!!!!!!!\n");
				break;
			}

			rtd_pr_vsc_err("[FRANK]iINFO1 VSC_IOC_GETINPUTINFO %x \n",info.wid);
			Set_Val_vsc_ioctl_cmd(cmd);
			if (info.wid == KADP_VIDEO_WID_0) {
				state_update_disp3d_info();
				I3DDMA_Parse_HDMI3D_pattern();
				switch(Get_DisplayMode_Src(SLR_MAIN_DISPLAY))
				{
					case KADP_VSC_INPUTSRC_ADC:
						down(get_adc_detectsemaphore());
						p_adc_dispinfo = Get_ADC_Dispinfo();
						input_info.inputWid = p_adc_dispinfo->IPH_ACT_WID_PRE;
						input_info.inputLen = p_adc_dispinfo->IPV_ACT_LEN_PRE;
		           		input_info.capWid = p_adc_dispinfo->IPH_ACT_WID_PRE;
		           		input_info.capLen = p_adc_dispinfo->IPV_ACT_LEN_PRE;
						input_info.inputFramerate = p_adc_dispinfo->IVFreq;
						input_info.interlace = (p_adc_dispinfo->disp_status&_BIT8)>>8;
						up(get_adc_detectsemaphore());
						break;

					case KADP_VSC_INPUTSRC_HDMI:
/*
						newbase_hdmi_get_timing(newbase_hdmi_get_current_display_port(), &hdmi_timing_info);
						input_info.inputWid = hdmi_timing_info.h_act_len;
						input_info.inputLen = hdmi_timing_info.v_act_len;
		           		input_info.capWid = hdmi_timing_info.h_act_len;
		           		input_info.capLen = hdmi_timing_info.v_act_len;
						input_info.inputFramerate = hdmi_timing_info.v_freq;
*/
						hdmi_timing_info.port = drvif_Hdmi_GetCurrentPhysicalPort();
						vfe_hdmi_drv_get_port_timing_info(&hdmi_timing_info);
						input_info.inputWid = hdmi_timing_info.active.w;
						input_info.inputLen = hdmi_timing_info.active.h;
				           	input_info.capWid = hdmi_timing_info.active.w;
				           	input_info.capLen = hdmi_timing_info.active.h;
						input_info.inputFramerate = hdmi_timing_info.v_freq;
						input_info.interlace = !hdmi_timing_info.scan_type;
						break;

					case KADP_VSC_INPUTSRC_AVD:
						ptLGETimingInfo = Get_AVD_LGETiminginfo();
						input_info.inputWid = ptLGETimingInfo->active.w;
						input_info.inputLen = ptLGETimingInfo->active.h/2;
						input_info.capWid = ptLGETimingInfo->active.w;
						input_info.capLen = ptLGETimingInfo->active.h/2;
						input_info.inputFramerate = ptLGETimingInfo->vFreq;
						input_info.interlace = !ptLGETimingInfo->scanType;
						break;

					default:
						rtd_pr_vsc_err("[FRANK]iINFO2 VSC_IOC_GETINPUTINFO \n");
						input_info.inputWid = 0;
						input_info.inputLen = 0;
		           		input_info.capWid = 0;
		           		input_info.capLen = 0;
						input_info.inputFramerate = 0;
						input_info.interlace = 0;
						break;
				}
				if (copy_to_user(to_user_ptr(info.inputInfo), (void *)&input_info, sizeof(SCALER_INPUT_INFO)) )
				{
					rtd_pr_vsc_err("[ERR] VSC_IOC_GETINPUTINFO main copy_to_user error \n");
					retval = -EFAULT;
	            }
			}
#ifdef CONFIG_DUAL_CHANNEL
            else {
				if(DbgSclrFlgTkr.Sub_OutputVencMode && (Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)) {
					ptLGETimingInfo = Get_AVD_LGETiminginfo();
					input_info.inputWid = ptLGETimingInfo->active.w;
					input_info.inputLen = ptLGETimingInfo->active.h/2;
					input_info.capWid = sub_dispwin.src_wid;
					input_info.capLen = sub_dispwin.src_height;
					input_info.inputFramerate = ptLGETimingInfo->vFreq;
					input_info.interlace = !ptLGETimingInfo->scanType;
				} else {
					rtd_pr_vsc_err("[FRANK]iINFO3 VSC_IOC_GETINPUTINFO %x, %x\n",DbgSclrFlgTkr.Sub_OutputVencMode, (Get_DisplayMode_Src(SLR_SUB_DISPLAY)));
					input_info.inputWid = 0;
					input_info.inputLen = 0;
					input_info.capWid = 0;
					input_info.capLen = 0;
					input_info.inputFramerate = 0;
					input_info.interlace = 0;
				}
				if (copy_to_user(to_user_ptr(info.inputInfo), (void *)&input_info, sizeof(SCALER_INPUT_INFO)) )
				{
					rtd_pr_vsc_err("[ERR] VSC_IOC_GETINPUTINFO sub copy_to_user error \n");
					retval = -EFAULT;
	            }
			}
#endif
			break;
		}
		case VSC_IOC_SHOWOSDSAMPLE:
		{
			// Sync from Demo version.
#if 0
			unsigned char bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SHOWOSDSAMPLE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_showosdsample(bonoff) == FALSE)
					retval =  -1;
			}
#endif
			break;
		}
		case VSC_IOC_GETPANELSIZE:
		{
			VSC_PANEL_SIZE_T  panel_size;
			panel_size.display_wid = _DISP_WID;
			panel_size.display_len = _DISP_LEN;
			if(copy_to_user((void __user *)arg, (void *)&panel_size, sizeof(VSC_PANEL_SIZE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GETPANELSIZE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			break;
		}
		case VSC_IOC_SET_DOLBYVISION_IDMA_ENABLE:
		{
			break;
		}
		case VSC_IOC_SETZORDER:
		{
			VSC_SET_ZORDER_T zorderNO[2];
			if(copy_from_user((void *)zorderNO, (const void __user *)arg, 2*sizeof(VSC_SET_ZORDER_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SETZORDER);
				if(rtk_hal_vsc_SetZorder(zorderNO[0],zorderNO[1]) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_MAKECOLOREDVIDEO:
		{
			KADP_VSC_VIDEO_COLOR_TYPE_T colorType;

			rtd_pr_vsc_debug("Scaler vsc disp: Get VSC_IOC_MAKECOLOREDVIDEO!!!!!!!\n");

			if(copy_from_user((void *) &colorType, (const void __user *)arg, sizeof(KADP_VSC_VIDEO_COLOR_TYPE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_MAKECOLOREDVIDEO copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_MAKECOLOREDVIDEO);
				rtk_hal_vsc_makeColoredVideo(colorType);
			}
			break;
		}
		case VSC_IOC_DM_OPEN:
		{
			Set_Val_vsc_ioctl_cmd(VSC_IOC_DM_OPEN);
			if(p_rtk_hal_vsc_dm_open(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_CLOSE:
		{
			Set_Val_vsc_ioctl_cmd(VSC_IOC_DM_CLOSE);
			if(p_rtk_hal_vsc_dm_close(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_CONNECT:
		{
			Set_Val_vsc_ioctl_cmd(VSC_IOC_DM_CONNECT);
			if(p_rtk_hal_vsc_dm_connect(SLR_MAIN_DISPLAY, KADP_VSC_HDR_AUTO) == FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_DISCONNECT:
		{
			Set_Val_vsc_ioctl_cmd(VSC_IOC_DM_DISCONNECT);
			if(p_rtk_hal_vsc_dm_disconnect(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_ISDOLBYHDR:
		{

			unsigned char isdolbyHdr = 0;
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
			if(Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
				isdolbyHdr = 1;
			else
				isdolbyHdr = 0;
#endif
			Set_Val_vsc_ioctl_cmd(VSC_IOC_ISDOLBYHDR);
			if(copy_to_user((void __user *)arg, (void *)&isdolbyHdr, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler hdcp2 ioctl code=VSC_IOC_ISDOBLYHDR copy_to_user failed!!!!!!!!!!!!!!!\n");
				break;
			}

			break;
		}

		case VSC_IOC_UPDATE_ADAPTIVE_STREAMING_INFO:
		{//no use
			break;
		}

		case VSC_IOC_NOTICE_GST_VO_UPDATE:
		{
			VSC_NOTICE_GST_VO_UPDATE_INFO temp_vsc_notice_gst_vo_update;
			unsigned char update_flag = TRUE;
			if(copy_from_user((void *)&temp_vsc_notice_gst_vo_update, (const void __user *)arg, sizeof(VSC_NOTICE_GST_VO_UPDATE_INFO)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_NOTICE_GST_VO_UPDATE copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			update_flag = TRUE;
			Set_Val_vsc_ioctl_cmd(VSC_IOC_NOTICE_GST_VO_UPDATE);
			if(temp_vsc_notice_gst_vo_update.update_flag)
			{
				if (copy_to_user(to_user_ptr(temp_vsc_notice_gst_vo_update.update_flag), (void *)&update_flag, sizeof(unsigned char)) )
				{
					rtd_pr_vsc_err("[ERR] VSC_IOC_NOTICE_GST_VO_UPDATE copy_to_user error 1 \n");
					retval = -EFAULT;
				}
			}
			break;
		}

		case VSC_IOC_APP_CONTRO_FORCEBG:
		{//no used
			break;
		}

		case VSC_IOC_HDR_OPEN:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_HDR_OPEN copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			Set_Val_vsc_ioctl_cmd(VSC_IOC_HDR_OPEN);
			if(wid == KADP_VIDEO_WID_0)
			{
				if(p_rtk_hal_vsc_dm_open(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				p_rtk_hal_vsc_dm_open(SLR_SUB_DISPLAY);
			}
			break;

		}
		case VSC_IOC_HDR_CLOSE:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_HDR_CLOSE copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			Set_Val_vsc_ioctl_cmd(VSC_IOC_HDR_CLOSE);
			if(wid == KADP_VIDEO_WID_0)
			{
				if(p_rtk_hal_vsc_dm_close(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				p_rtk_hal_vsc_dm_close(SLR_SUB_DISPLAY);
			}
			break;
		}
		case VSC_IOC_HDR_CONNECT:
		{
			KADP_VSC_HDR_INFO_T VSC_HDR_INFO;
			if(copy_from_user((void *)&VSC_HDR_INFO, (const void __user *)arg, sizeof(KADP_VSC_HDR_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_HDR_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			Set_Val_vsc_ioctl_cmd(VSC_IOC_HDR_CONNECT);
			if(VSC_HDR_INFO.winid == KADP_VIDEO_WID_0)
			{
				if(p_rtk_hal_vsc_dm_connect(SLR_MAIN_DISPLAY, VSC_HDR_INFO.hdrtype) == FALSE)
					return -1;
			}
			else
			{
				p_rtk_hal_vsc_dm_connect(SLR_SUB_DISPLAY, VSC_HDR_INFO.hdrtype);
			}
			break;
		}
		case VSC_IOC_HDR_DISCONNECT:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_HDR_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			Set_Val_vsc_ioctl_cmd(VSC_IOC_HDR_DISCONNECT);

			if(wid == KADP_VIDEO_WID_0)
			{
				if(p_rtk_hal_vsc_dm_disconnect(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				p_rtk_hal_vsc_dm_disconnect(SLR_SUB_DISPLAY);
			}
			break;
		}

		case VSC_IOC_SET_SubWinShape:
		{
			//Evance->VSC_SUB_SHAPE_INFO_T
			KADP_VSC_SUB_SHAPE_INFO_T shape_info;
	//		VIDEO_RECT_T  shape_region;
	//		int shape_type;
			if(copy_from_user((void *)&shape_info, (const void __user *)arg, sizeof(KADP_VSC_SUB_SHAPE_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=KADP_VSC_SUB_SHAPE_INFO_T copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_SubWinShape);
				{
					//virtual_x =shape_info.rect.x;
					//virtual_y =shape_info.rect.y;
					true_wide =shape_info.rect.w;
					true_high=shape_info.rect.h;
					if (shape_info.shapeinfo == KADP_VSC_MGF_TYPE_CIRCLE)
						sub_shape_type = KADP_VSC_MGF_TYPE_CIRCLE;
					else if (shape_info.shapeinfo == KADP_VSC_MGF_TYPE_RECTANGLE)
						sub_shape_type = KADP_VSC_MGF_TYPE_RECTANGLE;
					else
						sub_shape_type = KADP_VSC_MGF_TYPE_RECTANGLE;
					//				subWin_LGowner =1;
#if 0
					rtd_pr_vsc_info("\n ***************************virtual_x = %d", virtual_x);
					rtd_pr_vsc_info("\n ***************************virtual_y = %d", virtual_y);
					rtd_pr_vsc_info("\n ***************************virtual_w = %d", virtual_w);
					rtd_pr_vsc_info("\n ***************************virtual_h = %d", virtual_h);
					rtd_pr_vsc_info("\n ***************************sub_shape_type = %d", sub_shape_type);
#endif
				}
			}
			break;
		}

		case  VSC_IOC_SET_SetSubWinModeEx:
		{
			VSC_SET_SUB_WINDOW_MODE_TYPE vsc_set_sub_win_mode;
			//                     int mode_type = 0;
			//if(copy_from_user((void *)&mode_type, (const void __user *)arg, sizeof(VSC_SUB_MODE_T)))
			if(copy_from_user((void *)&vsc_set_sub_win_mode, (const void __user *)arg, sizeof(VSC_SET_SUB_WINDOW_MODE_TYPE)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SetSubWinMode copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				/*for testing
				vsc_set_sub_win_mode.mode = VSC_SUB_MODE_PIP;
				vsc_set_sub_win_mode.connectType = VSC_SUB_CONNECT_TYPE_MIRROR;
				vsc_set_sub_win_mode.memoryUse = VSC_SUB_MEMORY_USE_MULTI;

				rtd_pr_vsc_emerg("[%s][crixus]@@VSC_IOC_SET_SetSubWinMode,mode = %d, connectType = %d, memoryUse = %d\n", __FUNCTION__, vsc_set_sub_win_mode.mode, vsc_set_sub_win_mode.connectType, vsc_set_sub_win_mode.memoryUse);
				*/
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_SetSubWinModeEx);
				sub_mode_type = vsc_set_sub_win_mode.mode;//get sub mode

				if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_MIRROR){

					//disable ST game mode timeout checking task when enter livezoom for quickly switching case @Crixus 20170726
					down(&GameMode_Check_Semaphore);
					if(drv_memory_get_game_mode() == _ENABLE){
						Set_Val_smooth_toggle_game_mode_timeout_trigger_flag(_DISABLE);
						//smooth_toggle_game_mode_check_cnt = 0;
						rtd_pr_new_game_mode_notice("Disable ST game mode timeout tsk!!(before sub scaler)\n");
					}
					up(&GameMode_Check_Semaphore);
				}
#if 0//no used
				else if((vsc_set_sub_win_mode.mode == VSC_SUB_MODE_EX_NONE) && (vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NONE)
				&& (vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_NONE)){
				//exit PIP or PBP app.
				}
#endif
			}
			break;
		}

		case  VSC_IOC_SET_SetSubWinMode:
		{
			int mode_type = 0;


			if(copy_from_user((void *)&mode_type, (const void __user *)arg, sizeof(KADP_VSC_SUB_MODE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SetSubWinMode copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_emerg("[%s][crixus]@@VSC_IOC_SET_SetSubWinMode, mode_type = %d\n", __FUNCTION__, (unsigned int)mode_type);
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_SetSubWinMode);
				sub_mode_type = mode_type;//get sub mode
#if 0//def CONFIG_I2RND_ENABLE
				if((i2rnd_test_done == 0) && (sub_mode_type == VSC_SUB_MODE_PBP)){
					i2rnd_test_done = 1;
					rtk_hal_vsc_i2rnd_enable(_ENABLE);
					rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
				}else if((i2rnd_test_done == 1) && (sub_mode_type == VSC_SUB_MODE_PIP)){
					i2rnd_test_done = 0;
					rtk_hal_vsc_i2rnd_enable(_DISABLE);
					rtd_pr_vsc_emerg("[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
				}
#endif
			}
			break;
		}

		case  VSC_IOC_SET_SetSubWinPurpose:
		{
			KADP_VSC_SUB_PURPOSE_T purpose_type;


			if(copy_from_user((void *)&purpose_type, (const void __user *)arg, sizeof(KADP_VSC_SUB_PURPOSE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SetSubWinPurpose copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_emerg("[qiangzhou]@@VSC_IOC_SET_SetSubWinPurpose, purpose_type = %d\n", (unsigned int)purpose_type);

			}
			break;
		}

		case  VSC_IOC_SET_SetDelayBuffer:
		{
			VSC_SET_DELAY_BUFFER_TYPE delay_buffer_type;


			if(copy_from_user((void *)&delay_buffer_type, (const void __user *)arg, sizeof(VSC_SET_DELAY_BUFFER_TYPE)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_SET_DELAY_BUFFER_TYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_SetDelayBuffer);
				rtk_hal_vsc_SetDelayBuffer(delay_buffer_type.window, delay_buffer_type.buffer);
				rtd_pr_vsc_info("VSC_SET_DELAY_BUFFER_TYPE, delay_buffer_type.window = %d\n", (unsigned int)delay_buffer_type.window);
				rtd_pr_vsc_info("VSC_SET_DELAY_BUFFER_TYPE, delay_buffer_type.buffer = %d\n", (unsigned int)delay_buffer_type.buffer);

			}
			break;
		}

		case VSC_IOC_GET_BLACDETECTION_INFO_T:
		{
#if 0
			//static unsigned int cnt;
			//rtd_pr_vsc_info("Enter VSC_IOC_GET_BLACDETECTION_INFO_T\n");
			VSC_GET_BLACDETECTION_INFO_T BLACKDETECTION_INFO;
			VIP_BlackDetectionInfo vip_info;

			BLACKDETECTION_INFO.ready_flag = fwif_color_get_black_detection_info_tv006(&vip_info);

			memcpy(&(BLACKDETECTION_INFO.window.original), &(vip_info.OriRegion), sizeof(VIDEO_RECT_T));
			memcpy(&(BLACKDETECTION_INFO.window.active), &(vip_info.ActRegion), sizeof(VIDEO_RECT_T));
			BLACKDETECTION_INFO.connectwid = BLK_WID;//Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL);

			if (copy_to_user((void __user *)arg, (void *)&BLACKDETECTION_INFO, sizeof(VSC_GET_BLACDETECTION_INFO_T))) {
				retval = -EFAULT;
				rtd_pr_vsc_err("kernel VSC_IOC_GET_BLACDETECTION_INFO_T fail\n");
			}
			#if 0
			if (cnt % 600 == 0)
				rtd_pr_vsc_info("BLACKDETECTION_INFO.window = %d, %d %d %d, %d %d %d %d\n", BLACKDETECTION_INFO.window.original.x,BLACKDETECTION_INFO.window.original.y,BLACKDETECTION_INFO.window.original.w,BLACKDETECTION_INFO.window.original.h,BLACKDETECTION_INFO.window.active.x,BLACKDETECTION_INFO.window.active.y,BLACKDETECTION_INFO.window.active.w,BLACKDETECTION_INFO.window.active.h);
			cnt ++;
			#endif
#endif
			break;

		}
		case VSC_IOC_SET_BLACDETECTION_EN:
		{
#if 0
			VSC_SET_BLACDETECTION_INFO_T BLK_Info;
			unsigned char bEnable_main = 0;
			unsigned char bEnable_sub = 0;
			if(copy_from_user((void *)&BLK_Info, (const void __user *)arg, sizeof(VSC_SET_BLACDETECTION_INFO_T))) {
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_BLACDETECTION_EN copy_from_user failed!!!!!!!!!!!!!!!\n");
			} else {
				rtd_pr_vsc_info("1. wId=%d, EN=%d, bEnable_main=%d, bEnable_sub=%d",BLK_Info.connectwid,BLK_Info.enable,bEnable_main,bEnable_sub);
				if (BLK_Info.enable == TRUE) {
					if (BLK_Info.connectwid == VIDEO_WID_0) {
						bEnable_main = 1;
						BLK_WID = VIDEO_WID_0;
					}
					else if (BLK_Info.connectwid == VIDEO_WID_1) {
						BLK_WID = VIDEO_WID_1;
						bEnable_sub = 1;
					}
					else
						retval = -EFAULT;
				} else {

					if (BLK_Info.connectwid == VIDEO_WID_0)
						bEnable_main = 0;
					else if (BLK_Info.connectwid == VIDEO_WID_1)
						bEnable_sub = 0;
					else
						retval = -EFAULT;

				}
				rtd_pr_vsc_info("2. wId=%d, EN=%d, bEnable_main=%d, bEnable_sub=%d",BLK_Info.connectwid,BLK_Info.enable,bEnable_main,bEnable_sub);
				scalerVIP_Set_BlackDetection_EN(bEnable_main, bEnable_sub);
			}
#endif
			break;

		}
		case VSC_IOC_RotateVideo:
		{
			KADP_VSC_ROTATE_T rotate_type;
			if(copy_from_user((void *)&rotate_type, (const void __user *)arg, sizeof(KADP_VSC_ROTATE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_RotateVideo copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_RotateVideo);
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
				down(&SetMainOutPutRegion_Semaphore);
				main_rotate_mode_pre = Get_Val_ap_roate_mode();
				Set_Val_ap_rotate_mode((DIRECT_VO_FRAME_ORIENTATION)rotate_type);
				up(&SetMainOutPutRegion_Semaphore);
#endif
			}
			break;
		}

		case VSC_IOC_SetVideoPattern:
		{
			VSC_VIDEO_PATTERN_LOCATION_TYPE vsc_pattern_type;
			if(copy_from_user((void *)&vsc_pattern_type, (const void __user *)arg, sizeof(VSC_VIDEO_PATTERN_LOCATION_TYPE))) {
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SetVideoPattern copy_from_user failed!!!!!!!!!!!!!!!\n");
			} else {
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SetVideoPattern);
				rtk_hal_vsc_SetPattern(vsc_pattern_type.on_off, vsc_pattern_type.window, vsc_pattern_type.pattern_location);
			}
			break;
		}

		case VSC_IOC_GetLimitedWindow:
		{
			VSC_GET_LIMIT_WINDOW_T info;
			KADP_VSC_SCALER_RATIO_T input_info = {0, 0, 0, 0};

			if(copy_from_user((void *)&info, (const void __user *)arg, sizeof(VSC_GET_LIMIT_WINDOW_T )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GetLimitedWindow copy_from_user failed!!!!!!!!!!!!!!!\n");
				return  retval;
			}
			Set_Val_vsc_ioctl_cmd(VSC_IOC_GetLimitedWindow);
			input_info.h_scaledown_ratio = 32;
			input_info.v_scaledown_ratio = 32;
			input_info.h_scaleup_ratio = 256;
			input_info.v_scaleup_ratio = 256;

			if (copy_to_user(to_user_ptr(info.limit_window), (void *)&input_info, sizeof(KADP_VSC_SCALER_RATIO_T)) )
			{
	            rtd_pr_vsc_err("[ERR] VSC_IOC_GetLimitedWindow main copy_to_user error \n");
				retval = -EFAULT;
	        }
			break;
		}

		case VSC_IOC_SET_INPUTREGION_EX:
		{
			VSC_SET_FRAME_REGION_EX_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_EX_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_INPUTREGION_EX copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_INPUTREGION_EX);
				if(rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)frameregion.setframewid, frameregion.inregion, frameregion.originalInput) == FALSE)
					retval =  -1;
			}
			break;
		}

		case VSC_IOC_SET_UZD_PATH:
		{
			unsigned char i3dma_uzd = 0;
			if(copy_from_user((void *)&i3dma_uzd, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_SET_UZD_PATH copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_UZD_PATH);
				vsc_set_uzd_path(i3dma_uzd);
			}
			break;
		}

		case VSC_IOC_WAIT_MUTEOFF_QUEUE:
		{
			unsigned char winid = 0;
			wait_event_freezable(MUTEOFF_CB_WAIT_QUEUE, sub_muteoff_cb_trigger || main_muteoff_cb_trigger);
			Set_Val_vsc_ioctl_cmd(VSC_IOC_WAIT_MUTEOFF_QUEUE);
			if(main_muteoff_cb_trigger)
			{
				down(&muteoff_cb_sem);
				main_muteoff_cb_trigger = FALSE;
				up(&muteoff_cb_sem);
				winid |= WIN_MAIN_ONLY;//main path mute off
			}
			if(sub_muteoff_cb_trigger)
			{
				down(&muteoff_cb_sem);
				sub_muteoff_cb_trigger = FALSE;
				up(&muteoff_cb_sem);
				winid |= WIN_SUB_ONLY;//sub path mute off
			}
			if(copy_to_user((void __user *)arg, (void *)&winid, sizeof(unsigned char)))
			{
				rtd_pr_vsc_err("[ERR] VSC_IOC_WAIT_MUTEOFF_QUEUE copy_to_user error \n");
				retval = -EFAULT;
			}
#ifdef CONFIG_RTK_SRE_AATS_UCT_AT
			//AT V6.2 Patch 2022/03/31 - START
			//Added by David Kuo, 20220327 to move 1st de-black from VGIP_ISR to here
			if (g_ScalerApplyPQLinear == 1)
			{
				unsigned int hour, minute, second, millisecond;
#if defined(CONFIG_TRACEPOINTS) && defined(CONFIG_ANDROID_VENDOR_HOOKS) && (IS_ENABLED(CONFIG_REALTEK_LOGBUF))
				struct tm time;
				if(str_status == 0){
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0))
					struct timespec64 ts;
					ktime_get_real_ts64(&ts);
#else
					struct timeval ts;
					do_gettimeofday(&ts);
#endif
					second = ts.tv_sec;
					millisecond = (ts.tv_nsec/1000000);
					second -= (sys_tz.tz_minuteswest * 60);
					time64_to_tm(second, 0, &time);
					hour = time.tm_hour;
					minute = time.tm_min;
					second = time.tm_sec;
				}
#else
				get_local_time(&hour,&minute,&second,&millisecond);
#endif
				if(g_ActiveAATS_UCT_GD_On == 0)
				{
					g_ActiveAATS_UCT_GD_On = 1;
#if defined(CONFIG_TRACEPOINTS) && defined(CONFIG_ANDROID_VENDOR_HOOKS) && (IS_ENABLED(CONFIG_REALTEK_LOGBUF))
					if(str_status == 0){
						printk(KERN_EMERG "####[David][2]  notify GD on, jiffies: %lu, rtc[ms]: %lu, sys-time: %02d:%02d:%02d.%03d\n", jiffies,jiffies*1000/HZ,hour,minute,second,millisecond);
					}else{
						printk(KERN_NOTICE "####[David][2]  notify GD on, jiffies: %lu, rtc[ms]: %lu, str_status: %01d\n", jiffies,jiffies*1000/HZ,str_status);
					}
#else
					printk(KERN_EMERG "####[David][2]  notify GD on, jiffies: %lu, rtc[ms]: %lu, sys-time: %02d:%02d:%02d.%03d\n", jiffies,jiffies*1000/HZ,hour,minute,second,millisecond);
#endif
				}
				//Added by David Kuo, 20220301 to inspect frame sync register
				// addr : 0x18022218 (VGIP_CHN1_ACT_HSTA_Width)  bit 0~13 and
				// addr : 0x1802221C (VGIP_CHN1_ACT_VSTA_Length) bit 0~14
				g_vGipChn1_Act_Hsta_Width = (IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg)& 0x00003fff);
				g_vGipChn1_Act_Vsta_Length = (IoReg_Read32(VGIP_VGIP_CHN1_ACT_VSTA_Length_reg)& 0x00007fff);
#if defined(CONFIG_TRACEPOINTS) && defined(CONFIG_ANDROID_VENDOR_HOOKS) && (IS_ENABLED(CONFIG_REALTEK_LOGBUF))
				if(str_status == 0){
					printk(KERN_NOTICE "####[David] notify FSC init on vGipChn1_Act_Hsta_Width: 0x%x, vGipChn1_Act_Vsta_Len: 0x%x, jiffies: %lu, rtc[ms]: %lu, sys-time: %02d:%02d:%02d.%03d", g_vGipChn1_Act_Hsta_Width,g_vGipChn1_Act_Vsta_Length,jiffies,jiffies*1000/HZ,hour,minute,second,millisecond);
				}else{
					printk(KERN_NOTICE "####[David] notify FSC init on vGipChn1_Act_Hsta_Width: 0x%x, vGipChn1_Act_Vsta_Len: 0x%x, jiffies: %lu, rtc[ms]: %lu, str_status: %01d", g_vGipChn1_Act_Hsta_Width,g_vGipChn1_Act_Vsta_Length,jiffies,jiffies*1000/HZ,str_status);
				}
#else
					printk(KERN_NOTICE "####[David] notify FSC init on vGipChn1_Act_Hsta_Width: 0x%x, vGipChn1_Act_Vsta_Len: 0x%x, jiffies: %lu, rtc[ms]: %lu, sys-time: %02d:%02d:%02d.%03d", g_vGipChn1_Act_Hsta_Width,g_vGipChn1_Act_Vsta_Length,jiffies,jiffies*1000/HZ,hour,minute,second,millisecond);
#endif
			}
			//AT V6.2 Patch 2022/03/31 - END
#endif
			break;
		}

		case VSC_IOC_VDO_CONNECT:
		{
			VSC_CONNECT_PARA_T connectPara;
			rtd_pr_vsc_debug("\033[10;32m [%s:%d]:VSC_IOC_VDO_CONNECT \033[0m \n", __FUNCTION__, __LINE__);
			if(copy_from_user((void *)&connectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_VDO_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_VDO_CONNECT);
				if(!vdo_connect((unsigned char)connectPara.connectwid, (unsigned char)connectPara.vsc_input.resourceIndex))
				{
					retval =  -1;
				}

			}
			break;
		}

		case VSC_IOC_VDO_DISCONNECT:
		{
			VSC_CONNECT_PARA_T disconnectPara;
			rtd_pr_vsc_debug("\033[10;32m [%s:%d]:VSC_IOC_VDO_DISCONNECT \033[0m \n", __FUNCTION__, __LINE__);
			if(copy_from_user((void *)&disconnectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_VDO_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_VDO_DISCONNECT);
				vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
			}
			break;
		}

		case VSC_IOC_SetVideoLatencyPattern:
		{
			VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern;

			if(copy_from_user((void *)&set_video_latency_pattern, (const void __user *)arg, sizeof(VSC_VIDEO_LATENCY_PATTERN_T )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SetVideoLatencyPattern copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SetVideoLatencyPattern);
				set_latency_pattern_info(set_video_latency_pattern);
			}
			break;
		}

		case VSC_IOC_Set_VD_PTG:
		{
			unsigned char bOnOff = 0;
			if(copy_from_user((void *)&bOnOff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_Set_VD_PTG copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_Set_VD_PTG);
				vsc_set_vd_ptg(bOnOff);
			}
			break;
		}
		case VSC_IOC_GET_UZD_CRC:
		{
			VSC_UZD_CRC pUZD_CRC;
			unsigned int iCRC_Result = 0;
			if(copy_from_user((void *)&pUZD_CRC, (const void __user *)arg, sizeof(VSC_UZD_CRC)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_GET_UZD_CRC copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_GET_UZD_CRC);
				vsc_get_uzu_crc((VIDEO_WID_T)pUZD_CRC.wid, &iCRC_Result);
				pUZD_CRC.CRC_Result = iCRC_Result;
				if(copy_to_user((void __user *)arg, &pUZD_CRC, sizeof(VSC_UZD_CRC)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_GET_UZD_CRC copy_to_user failed!!!!!!!!!!!!!!!\n");
				}
			}
			break;
		}
		case VSC_IOC_SET_DRIVER_PATTERN:
		{
			break;

		}
		case VSC_IOC_SET_DRIVER_TABLE:
		{
			break;

		}

		case VSC_IOC_SET_WINBLANK_SYNC_MEMC:
		{//this is for mute on to sync memc ready
			VSC_WINBLANK_PARA_T winblankpara;
			if(copy_from_user((void *)&winblankpara, (const void __user *)arg, sizeof(VSC_WINBLANK_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_WINBLANK_SYNC_MEMC copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_debug("winblankpara.winblankwid=%d,winblankpara.winblankbonoff=%d,winblankpara.winblankcolor=%d\n", winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor);
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_WINBLANK_SYNC_MEMC);

				//These are for mute on to wait memc already blck video
				sync_memc_ready = TRUE;//if TRUE. when mute on to wait memc buffer

				if(rtk_hal_vsc_SetWinBlank((VIDEO_WID_T)winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor) == FALSE)
					retval =  -1;
				//These are for mute on to wait memc already blck video
				sync_memc_ready = FALSE;//if TRUE. when mute on to wait memc buffer
			}
			break;
		}



		case VSC_IOC_SET_INPUT_OUTPUT:
		{//this is for new input output hal
			KADP_ARC_INFO_T ARC_info;
			if(copy_from_user((void *)&ARC_info, (const void __user *)arg, sizeof(KADP_ARC_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl code=VSC_IOC_SET_INPUT_OUTPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_INPUT_OUTPUT);
				rtk_hal_vsc_SetInputRegion_OutputRegion(ARC_info.wid, ARC_info.rotation, ARC_info.input, ARC_info.original_input, ARC_info.ouput, ARC_info.null_input, ARC_info.null_output);
			}
			break;
		}


		case VSC_IOC_SetSplitInfoForHDMI:
		{
#if 0
			KADP_HAL_VSC_SPLIT_INFO_T splitInfo;
			if(copy_from_user((void *)&splitInfo, (const void __user *)arg, sizeof(KADP_HAL_VSC_SPLIT_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl code=VSC_IOC_SetSplitInfoForHDMI copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetSplitInfoForHDMI() == FALSE)
					retval =  -1;
			}
#endif
			break;

		}
		case VSC_IOC_WAIT_NOTIFY_WIN_DELAY:
		{
			KADP_SCALER_WIN_CALLBACK_DELAY_INFO scaler_win_delay_cb_info = {0};
			unsigned long flags = 0;
			Set_Val_vsc_ioctl_cmd(VSC_IOC_WAIT_NOTIFY_WIN_DELAY);
			wait_event_freezable(WIN_DELAY_CB_WAIT_QUEUE, delay_info_cb_trigger);
			if(delay_info_cb_trigger)
			{
				spin_lock_irqsave(get_delay_info_cb_spin_lock(), flags);
				delay_info_cb_trigger = FALSE;
				spin_unlock_irqrestore(get_delay_info_cb_spin_lock(), flags);
				update_win_apply_delay_info_for_cb(SLR_MAIN_DISPLAY, &scaler_win_delay_cb_info);
			}
			if(copy_to_user((void __user *)arg, (void *)&scaler_win_delay_cb_info, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO)))
			{
				rtd_pr_vsc_err("[ERR] VSC_IOC_WAIT_NOTIFY_WIN_DELAY copy_to_user error \n");
				retval = -EFAULT;
			}

			break;
		}

		case VSC_IOC_SET_HFRMode:
		{
			unsigned char bOnOff = 0;
			if(copy_from_user((void *)&bOnOff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_HFRMode copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_HFRMode);
				set_HFR_mode(bOnOff);
			}
			break;
		}
		case VSC_IOC_SET_DUALDECODER:
		{
			unsigned char dual_decoder_flag = 0;
			if(copy_from_user((void *)&dual_decoder_flag, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_SET_DUALDECODER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SET_DUALDECODER);
				rtk_hal_vsc_Setdualdecoder(dual_decoder_flag);
			}
			break;
		}

		case VSC_IOC_SUBSCRIBE_VIDEO_DELAY:
        {
			VSC_GET_SCALER_VIDEO_DELAY_T delay_result;
			unsigned int video_delay = 0;
			if(copy_from_user((void *)&delay_result, (const void __user *)arg, sizeof(VSC_GET_SCALER_VIDEO_DELAY_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SUBSCRIBE_VIDEO_DELAY copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Set_Val_vsc_ioctl_cmd(VSC_IOC_SUBSCRIBE_VIDEO_DELAY);
				rtk_hal_vsc_scaler_check_video_delay((VIDEO_WID_T)delay_result.wid, &video_delay);
				delay_result.get_delay_Result = video_delay;
				if (copy_to_user((void __user *)arg, &delay_result, sizeof(VSC_GET_SCALER_VIDEO_DELAY_T)) )
				{
					rtd_pr_vsc_err(	"[ERR] VSC_IOC_SUBSCRIBE_VIDEO_DELAY copy_to_user error \n");
					retval = -EFAULT;
				}

			}
			break;
		}

        case VSC_IOC_SUBSCRIBE_BBD_EVENT:
		{//ap subscribe or not
            KADP_BBD_SUBSCRIBE_INFO bbd_ctrl_info;
            if(copy_from_user((void *)&bbd_ctrl_info, (const void __user *)arg, sizeof(KADP_BBD_SUBSCRIBE_INFO)))
            {
                retval = -EFAULT;
                rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SUBSCRIBE_BBD_EVENT copy_from_user failed!!!!!!!!!!!!!!!\n");
            }
            else
            {
                Set_Val_vsc_ioctl_cmd(VSC_IOC_SUBSCRIBE_BBD_EVENT);
                if(bbd_ctrl_info.wid == KADP_VIDEO_WID_0)//main
                {
                    rtd_pr_vsc_info("### main VSC_IOC_SUBSCRIBE_BBD_EVENT enable(%d) ###\r\n", bbd_ctrl_info.bbd_subscribe_event);

                    if(bbd_ctrl_info.bbd_subscribe_event)
                    {//enable
                        Set_Val_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_REQ_ENABLE);
                        Set_Val_bbd_enable(SLR_MAIN_DISPLAY, 1);
                    }
                    else
                    {//disable
                        Set_Val_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_DONE);
                        Set_Val_bbd_enable(SLR_MAIN_DISPLAY, 0);
                    }
                }
                else//sub
                {
                    rtd_pr_vsc_info("### sub VSC_IOC_SUBSCRIBE_BBD_EVENT enable(%d) ###\r\n", bbd_ctrl_info.bbd_subscribe_event);

                    if(bbd_ctrl_info.bbd_subscribe_event)
                    {//enable
                        Set_Val_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_REQ_ENABLE);
                        Set_Val_bbd_enable(SLR_SUB_DISPLAY, 1);
                    }
                    else
                    {//disable
                        Set_Val_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_DONE);
                        Set_Val_bbd_enable(SLR_SUB_DISPLAY, 0);
                    }
                }
            }
            break;
		}

        case VSC_IOC_WAIT_BBD_INFO_QUEUE:
		{//wait bbd event wake up
            BBD_UPDATE_INFO bbd_info[2] = {{0, {0, 0, 0, 0}, {0, 0, 0, 0}}, {0, {0, 0, 0, 0}, {0, 0, 0, 0}}};
            KADP_BBD_RESULT_INFO bbd_result_info[2] = {{0, {0, 0, 0, 0}, {0, 0, 0, 0}}, {0, {0, 0, 0, 0}, {0, 0, 0, 0}}};
            Set_Val_vsc_ioctl_cmd(VSC_IOC_WAIT_BBD_INFO_QUEUE);
            wait_bbd_queue();//wait wake up
            if(check_bbd_info_update())
            {//need to update
                int i;
                copy_bbd_active_win_info(bbd_info);
                for(i = 0; i < 2 ; i++)
                {
                    bbd_result_info[i].update = bbd_info[i].update;
                    bbd_result_info[i].active_size.x = bbd_info[i].active_size.x;
                    bbd_result_info[i].active_size.y = bbd_info[i].active_size.y;
                    bbd_result_info[i].active_size.w = bbd_info[i].active_size.width;
                    bbd_result_info[i].active_size.h = bbd_info[i].active_size.height;
                    bbd_result_info[i].ori_size.x = bbd_info[i].ori_size.x;
                    bbd_result_info[i].ori_size.y = bbd_info[i].ori_size.y;
                    bbd_result_info[i].ori_size.w = bbd_info[i].ori_size.width;
                    bbd_result_info[i].ori_size.h = bbd_info[i].ori_size.height;
                }
            }

            if(copy_to_user((void __user *)arg, (void *)&bbd_result_info, sizeof(bbd_result_info)))
            {//copy to user
                rtd_pr_vsc_err("[ERR] VSC_IOC_WAIT_MUTEOFF_QUEUE copy_to_user error \n");
                retval = -EFAULT;
            }
            break;
		}

		default:
			rtd_pr_vsc_debug("Scaler vsc disp: ioctl code = %d is invalid!!!!!!!!!!!!!!!1\n", cmd);
			retval = -EFAULT;
			break ;
		}
	return retval;


}

#ifndef UT_flag
#if defined(CONFIG_COMPAT) && defined(CONFIG_ARM64)
long vsc_compat_ioctl(struct file *file, unsigned int cmd,  unsigned long arg)
{
	return vsc_ioctl(file,cmd,arg);
}
#endif
#endif //UT_flag

#define REGULAR_PST_VIDEO_DELAY 1

void Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region(KADP_VIDEO_RECT_T  OutputRegion)
{
	UINT32 framePeriod = 0;
	framePeriod =16;

	g_scaler_win_delay_cb_info.wid = 0;
	g_scaler_win_delay_cb_info.delayTime = framePeriod;
	g_scaler_win_delay_cb_info.OutputRegion.x = OutputRegion.x;
	g_scaler_win_delay_cb_info.OutputRegion.y = OutputRegion.y;
	g_scaler_win_delay_cb_info.OutputRegion.w = OutputRegion.w;
	g_scaler_win_delay_cb_info.OutputRegion.h = OutputRegion.h;
	g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 1;

	rtd_pr_vsc_notice("[Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region] (%x.%x.%x.%x.%d)\n", g_scaler_win_delay_cb_info.OutputRegion.x,g_scaler_win_delay_cb_info.OutputRegion.y,
		g_scaler_win_delay_cb_info.OutputRegion.w, g_scaler_win_delay_cb_info.OutputRegion.h, framePeriod);

	wakeup_window_delay_info_callback(SLR_MAIN_DISPLAY,FALSE);
}


void Scaler_Reset_ForceUpdate_Callback_Delay_Info(void)
{
	g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 0;
	memset((void*) &g_scaler_win_delay_cb_info, 0, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO));
}

void Scaler_Fulfill_Callback_Delay_Info(KADP_SCALER_WIN_CALLBACK_DELAY_INFO *pCallBack_info)
{
	SCALER_WIN_CALLBACK_DELAY_INFO* pPstDelaySetting = NULL;
	UINT32 framePeriod = 0;
	SLR_VOINFO* pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
	extern SCALER_WIN_CALLBACK_DELAY_INFO* Scaler_Get_Pst_Window_Delay_Setting(void);
	extern void Scaler_Reset_Pst_Window_Delay_Setting(void);

	pPstDelaySetting = Scaler_Get_Pst_Window_Delay_Setting();

	if((pPstDelaySetting)&&(pPstDelaySetting->validinfo) && (pVOInfo && (pVOInfo->v_freq))){
		Scaler_Reset_Pst_Window_Delay_Setting();

		//rtd_pr_vsc_notice("pVOInfo->v_freq=%d \n", pVOInfo->v_freq);

		framePeriod = ((100000/pVOInfo->v_freq)*REGULAR_PST_VIDEO_DELAY)/10;

		if(pCallBack_info){
			pCallBack_info->wid = 0;
			pCallBack_info->delayTime = framePeriod;
			pCallBack_info->OutputRegion.x = pPstDelaySetting->region_x;
			pCallBack_info->OutputRegion.y = pPstDelaySetting->region_y;
			pCallBack_info->OutputRegion.w = pPstDelaySetting->region_w;
			pCallBack_info->OutputRegion.h = pPstDelaySetting->region_h;
		}
		#if 0
		rtd_pr_vsc_notice("[Scaler_Fulfill_Callback_Delay_Info] (%x.%x.%x.%x.%d)\n", pPstDelaySetting->region_x,pPstDelaySetting->region_y,
			pPstDelaySetting->region_w, pPstDelaySetting->region_h, framePeriod);
		#endif
	}
}

void Convert_Timing_To_fs_Depend_datafs(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY) {
		if ((drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC)
			&& (1==Scaler_get_data_framesync(SLR_MAIN_DISPLAY)))
		{ //data frc change to data fs,display timing need change
			modestate_set_fll_running_flag(_DISABLE);
                    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC,TRUE);
			rtd_pr_vsc_info("Convert_Timing_To_fs_Depend_datafs:framesync\n");
		}
	}
}

#ifndef UT_flag
static bool vsc_tsk_running_flag = FALSE;//Record vsc_scaler_tsk status. True: Task is running
static struct task_struct *p_vsc_tsk = NULL;
#endif
static int vsc_scaler_tsk(void *p)//This task run scaler or check signal stable or not
{
	StructSrcRect winSrcRect;
	VSC_INPUT_TYPE_T srctype;
	int timeout;
#ifdef CONFIG_ENABLE_SUB_NN
	unsigned int sub_nn_YAddr = 0, sub_nn_CAddr = 0;
#endif
	int filmDetect_timeout;
	unsigned char port;
#ifdef CONFIG_ENABLE_HDMI_NN
	unsigned ulNNYAddr = 0, ulNNCAddr = 0;
#endif

#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
	rtd_pr_vsc_debug("vsc_scaler_tsk()\n");
#endif

    while (1)
    {
        if(p_Get_Val_Tsk_Status(TSK_NAME_VSC) != _low_power_tsk_no_pending)
        {
            if(p_Get_Val_Tsk_Status(TSK_NAME_VSC) == _low_power_tsk_request_pending)
                 p_Set_Val_Tsk_Status(TSK_NAME_VSC, _low_power_tsk_pending_finish);
            msleep(10); //wait 100ms
            if (freezing(current))
            {
                try_to_freeze();
            }
            continue;
        }

		//msleep(10);
		if(wait_for_completion_timeout(&vsc_scaler_tsk_completion, (HZ * 10) / 1000))       // 10ms, jiffies_to_usecs((HZ * 10) / 1000) = 10000
        {
            // wakedup by complete(&vsc_scaler_tsk_completion)
            RUTIL_TM_LOG(eRUtilTM_VSC_Unmute, "vsc_scaler_tsk: waked up");
        }

#if defined(CONFIG_ENABLE_HDMI_NN) && defined(CONFIG_FORCE_RUN_I3DDMA)
		i3ddma_nn_buffer_dump_debug();//dump nn to file
#endif

#ifdef CONFIG_ENABLE_SUB_NN
		decide_do_sub_capture_path_for_nn_data();//config sub path for nn data capture 
#endif

		output_data_access_data();//print data access data

		decide_to_change_timing_freerun();//hdmi user change edid will disbalee hdmi output sometimes watchdog is not realtime. So change free run before hdmi disable outbput


#ifdef MSPG_AUTO_TEST
		decide_do_mspg_auto_test();//mspg auto test
#endif

		if(p_OutpuLocalDimmingPatMode() == TRUE){
			rtd_pr_vsc_debug("#Enter LocalDimming debug mode#\n");
			continue;
		}

		if(Get_tv006_wb_pattern() == TRUE){
			if(decide_do_reset_mode(SLR_MAIN_DISPLAY))
			{
				rtd_pr_vsc_debug("#Enter WB Pattern and do reset mode#\n");
			}
			continue;
		}

#ifdef CONFIG_RTK_KDRV_PWM
		vpq_led_ld_ctrl();
#endif

#ifdef BRING_UP_I2RND
		//Eric@20180518 for i2rnd bring up HW verify
		if((IoReg_Read32(0xb8022288) & _BIT9) && (i2rnd_brungup_setting_done == 0)){
			i2rnd_bring_up_verify();
			i2rnd_brungup_setting_done = 1;
		}
#endif
		#if 1
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE){
#ifdef CONFIG_I2RND_ENABLE
			if(Scaler_I2rnd_get_timing_enable() && (Scaler_main_md_pst_get_enable() == _DISABLE)){
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = _DISABLE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = _DISABLE;
			}
#endif
			zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//update vo smooth toggle info
			if (rtk_hal_vsc_Getdualdecoder() && (0 == rtk_hal_vsc_Getdualdecoder_run()))
			{
				rtk_hal_vsc_Setdualdecoder_run(1);
				Scaler_DualChannelRpc(1);
				rtd_pr_vsc_info("dual decoder start to run\n");
			}
			if(Get_Val_DbgSclrFlgTkr(MAIN_SMT_SET_IDX) || Get_Val_DbgSclrFlgTkr(MAIN_SMT_IS_FROM_MUTEOFF_IDX)) {
				unsigned char Main_smoothtoggle_forcebg_flag = 0;
				unsigned char Main_smoothtoggle_from_mute_off = FALSE;//if TRUE, means mute off trigger smooth toggle
				srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
				down(&SetMainOutPutRegion_Semaphore);
				if(Get_Val_DbgSclrFlgTkr(MAIN_SMT_IS_FROM_MUTEOFF_IDX))
					Main_smoothtoggle_from_mute_off = TRUE;//if TRUE, means mute off trigger smooth toggle
				DbgSclrFlgTkr.smoothtoggle_start_flag = TRUE;
                Set_Val_DbgSclrFlgTkr(MAIN_SMT_SET_IDX, false);
                Set_Val_DbgSclrFlgTkr(MAIN_SMT_IS_FROM_MUTEOFF_IDX, false);
				if (Get_Val_DbgSclrFlgTkr(MAIN_REQUEST_SMT_FROM_MUTEOFF_IDX)) {
					Main_smoothtoggle_forcebg_flag = TRUE;
                    Set_Val_DbgSclrFlgTkr(MAIN_REQUEST_SMT_FROM_MUTEOFF_IDX, false);
				}

				Scaler_DispWindowSet(main_dispwin);
				//Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
				/*if(srctype != KADP_VSC_INPUTSRC_AVD) {
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height, ZOOM_CROP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
				}*/
				up(&SetMainOutPutRegion_Semaphore);
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY)) {
					ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
					main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
					timeout = 30;
					while(!main_display_control_rsv_reg.m_force_bg && timeout) {
						timeout -- ;
						msleep(10);
						main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
					}
					rtd_pr_vsc_info("before smoothtoggle,need wait forcebg ok timeout=%d\n",timeout);
				}
				//when change to data fs,need change timing to fs
				Convert_Timing_To_fs_Depend_datafs(SLR_MAIN_DISPLAY);
				if(srctype == VSC_INPUTSRC_AVD)
				{
					//if(get_AVD_Input_Source() != _SRC_TV)no atv case
					{//do h v start compensation
						avd_start_compensation();//compensation h v start
					}
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					winSrcRect = Scaler_DispWindowGet();
					//zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, winSrcRect.srcx, winSrcRect.srcy, winSrcRect.src_wid, winSrcRect.src_height, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
					up(&VSC_Semaphore);
#endif

				}
				else
				{
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					winSrcRect = Scaler_DispWindowGet();
					//zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, winSrcRect.srcx, winSrcRect.srcy, winSrcRect.src_wid, winSrcRect.src_height, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
					up(&VSC_Semaphore);
				}

				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
				{
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//display arc ready mask, becasue we already apply ARC
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);//wait smooth toggle ready to avoid to see ARC change
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
					down(&SetMainOutPutRegion_Semaphore);
					if(!get_main_scaler_stop_flag() && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
					{
						down(&new_input_output_main_sem);
						reset_pst_sharemem_buffer(SLR_MAIN_DISPLAY);//reset pst buffer data
						set_pst_active_state(SLR_MAIN_DISPLAY, TRUE);//update to enable PST
						up(&new_input_output_main_sem);
					}
					up(&SetMainOutPutRegion_Semaphore);
#endif

				}
				if(judge_main_mute_off_trigger_smoothtoggle() == FALSE){
					rtd_pr_vsc_debug("\r\n#####open forcebg after smoothtoggle\r\n");
					if((Main_smoothtoggle_forcebg_flag == TRUE)/*&&(srctype == VSC_INPUTSRC_VDEC)*/&&(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_VSC)))
					{
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
						if (srctype == VSC_INPUTSRC_ADC) {//componet 5A wait at least two frame in case of shaking
							int timingMode = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MODE_CURR);
							if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) && (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_YPBPR))
							{
							    if(((timingMode == _MODE_480I)||(timingMode == _MODE_576I)))
							    {
								    unsigned int waitsec = 0;
    								waitsec = (unsigned int)Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
    								if(waitsec)
    								{
    									waitsec = 30000/waitsec;//3 frame
    								}
    								msleep(waitsec);
							    }

							}
						}
					}

					if(srctype == VSC_INPUTSRC_VDEC)
					{
						// [K5LG-828] wait for VO film mode detect done
						unsigned int cur_stc;
						cur_stc = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);//current system time
						filmDetect_timeout = FILM_DETECT_TO;
						port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
						timeout = 30;
						while((((get_vo_avsync_flag(port) == FALSE) && timeout)|| ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout)) && Main_smoothtoggle_from_mute_off)
						{
							timeout -- ;
							filmDetect_timeout--;
							if(judge_main_mute_off_trigger_smoothtoggle() || get_main_scaler_stop_flag())
								break;
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								break;
							msleep(1);
						}
						if(filmDetect_timeout != FILM_DETECT_TO)
						{
						    rtd_pr_vsc_notice("[FILM] P[%d] Wait Detect Done[%d]=%d ms\n",  port, filmDetect_timeout, drvif_report_cost_time_by_counter(cur_stc));
						}

						rtd_pr_vsc_notice("\r\n### smooth toggle vo wait sync & film detect done timeout:%d, %d####\r\n", timeout, filmDetect_timeout);
						//Set FLL flag when DTV channel changing
						if(vbe_disp_get_adaptivestream_fs_mode() == 1){
							//drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							modestate_set_fll_running_flag(_DISABLE);
							//rtd_pr_vsc_emerg("@@@@@@@@@@@FLL disable for adaptive stream\n");
						}else{
							if (Main_smoothtoggle_forcebg_flag && DbgSclrFlgTkr.check_only_xy_shift_same_region) {//only the same timing DTV exchange need reset_freerun
								#ifdef CONFIG_I2RND_ENABLE
								if(Scaler_I2rnd_get_timing_enable() == _DISABLE)
								#endif

#ifdef ENABLE_VR360_DATA_FS_FLOW
								if(get_vt_EnableFRCMode() != FALSE)	//VR360 cannot set freerun
#endif
								{
									if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC) == FALSE) {
										//for enter fixlastline condition, reset timing to freerun
										drivf_scaler_reset_freerun();
									}
								}
								if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC) == FALSE) {
									if((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))
										modestate_set_fll_running_flag(_DISABLE);
									else
										modestate_set_fll_running_flag(_ENABLE);
								}
							}
						}
					}
					DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
					if((judge_main_mute_off_trigger_smoothtoggle() == FALSE) &&
						(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
						if (!Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_VSC)) {
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);
						}
					}
				}
			} else {
			#if 0
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)&& (Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_VDEC)) {
					onms_onms1_ctrl_RBUS onms_onms1_ctrl_reg;
					onms_onms1_ctrl_reg.regValue =  IoReg_Read32(ONMS_onms1_ctrl_reg);
					if(!onms_onms1_ctrl_reg.on1_start_ms) {
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
						drvif_mode_enableonlinemeasure(SLR_MAIN_DISPLAY);
						drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_VO, TRUE, FALSE);
					}
				}
			#endif
			}
		}else{
			if(Get_Val_DbgSclrFlgTkr(MAIN_SMT_SET_IDX)) {
				down(&SetMainOutPutRegion_Semaphore);
                Set_Val_DbgSclrFlgTkr(MAIN_SMT_SET_IDX, FALSE);
				up(&SetMainOutPutRegion_Semaphore);
			}
		}

		#endif

		if(DbgSclrFlgTkr.run_iv2dv_slow_tuning_flag)
		{
			rtd_pr_vsc_notice("\r\n#drv_run_GameMode_iv2dv_slow_tuning#\r\n");
			down(&Iv2dv_Slow_Tuning_Semaphore);
			drv_run_GameMode_iv2dv_slow_tuning();
			up(&Iv2dv_Slow_Tuning_Semaphore);
		}

		decide_do_reset_mode(SLR_MAIN_DISPLAY);//decie to do reset mode or not

		if((DbgSclrFlgTkr.memc_realcinema_run_flag)&&((IoReg_Read32(VGIP_Smooth_tog_ctrl_reg)&_BIT0)==0)) //wait smooth toggle finish
		{
			down(&Memc_Realcinema_Semaphore);
			DbgSclrFlgTkr.memc_realcinema_run_flag=FALSE;
			up(&Memc_Realcinema_Semaphore);


			down(&VSC_Semaphore);
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			if((scaler_vsc_get_adaptive_pst_lowdelay_mode()==1)&&((vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))||scaler_vsc_get_force_pst_lowdelay_mode()==1)){
				scaler_vsc_set_adaptive_pst_lowdelay_mode(1);
			}else{
				memc_realcinema_framerate();
			}
#else
			memc_realcinema_framerate();
#endif
			up(&VSC_Semaphore);
		}

		if ((DbgSclrFlgTkr.rotate_run_scaler_flag || Get_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX) || decide_auto_scaler_run(SLR_MAIN_DISPLAY)) && (get_main_scaler_stop_flag() == FALSE) && (DbgSclrFlgTkr.Main_Reset_Mode_flag == FALSE) && check_bbd_condition_complete(SLR_MAIN_DISPLAY)//wait vsc close reset mode ready
			) {
			set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
			srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
			if((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) || (srctype == VSC_INPUTSRC_VDEC) || (srctype == VSC_INPUTSRC_JPEG) || ((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV)))
			{
				if(!decide_auto_scaler_run(SLR_MAIN_DISPLAY))
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
				rtd_pr_vsc_notice("######[%s(%d)] run scaler start:%d %d#####\n", __func__, __LINE__, DbgSclrFlgTkr.Main_Run_Scaler_flag, decide_auto_scaler_run(SLR_MAIN_DISPLAY));

				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
				set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode(SLR_MAIN_DISPLAY));
				set_rotate_mode(SLR_MAIN_DISPLAY, Get_Val_ap_roate_mode());
				up(&SetMainOutPutRegion_Semaphore);
				if(srctype == VSC_INPUTSRC_AVD)
					set_avd_start_need_compensation(TRUE);
			}

			port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
			rtd_pr_vsc_emerg("[%s]I2RND_MAIN_S0_TABLE!!!!\n",__FUNCTION__);
#endif
#ifdef CONFIG_HDR_SDR_SEAMLESS
			reset_seamless_trigger_flag();//reset trigger flag when run scaler flow. avoid keep previous source trigger flag
#endif
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
			set_pst_active_state(SLR_MAIN_DISPLAY, FALSE);//reste activer state
#endif

            switch(srctype)
            {
                case VSC_INPUTSRC_AVD:
                if(get_AVD_Input_Source() != _SRC_TV)
                    rtd_pr_vsc_notice("####Main path VSC_Src:KADP_VSC_INPUTSRC_AVD(AV)#####\r\n");
                break;

                case VSC_INPUTSRC_ADC:
                    rtd_pr_vsc_notice("####Main path VSC_Src:KADP_VSC_INPUTSRC_ADC#####\r\n");
                break;

                case VSC_INPUTSRC_HDMI:
                    set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());//recode current hdr mode
                    rtd_pr_vsc_notice("####Main path VSC_Src:KADP_VSC_INPUTSRC_HDMI#####\r\n");
                break;

                case VSC_INPUTSRC_VDEC:
                    rtd_pr_vsc_notice("####Main path VSC_Src:VSC_INPUTSRC_VDEC#####\r\n");
                break;

                case VSC_INPUTSRC_JPEG:
                    rtd_pr_vsc_notice("####Main path VSC_Src:VSC_INPUTSRC_JPEG#####\r\n");
                break;

                case VSC_INPUTSRC_DP:
                    rtd_pr_vsc_notice("####Main path VSC_Src:VSC_INPUTSRC_DP#####\r\n");
                break;

                default:
                case VSC_INPUTSRC_MAXN:
                case VSC_INPUTSRC_HDD:
                case VSC_INPUTSRC_VBY1RX:
                break;
            }

			wait_game_mode_finish();//wait game mode finish

#if 1//defined(CONFIG_FORCE_RUN_I3DDMA) || defined (CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT) || defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH)
			{
				//rtd_pr_vsc_emerg("######fw_set_vsc_GameMode(0) Line=%d #######\n", __LINE__);
				fw_set_vsc_GameMode(0);
                           Set_Val_vsc_run_pc_mode(rtk_hal_vsc_GetRGB444Mode());//save vsc run pc mode or not
				/*main path always run i3ddma->vodma->scaler*/
			#ifdef CONFIG_FORCE_RUN_I3DDMA
				if(((srctype == VSC_INPUTSRC_HDMI) && (get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1))
				|| (srctype == VSC_INPUTSRC_ADC) || ((srctype == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))
			#else //defined (CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT) || defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				#if defined (CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT) || defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				if(((srctype == VSC_INPUTSRC_HDMI) && (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT))
					&& (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == FALSE))
				#else
				if(((srctype == VSC_INPUTSRC_HDMI) && (Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == true))
					&& (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == FALSE))
				#endif
			#endif
				{
				    down(&Force_Run_Idma_Semaphore);
					set_force_i3ddma_enable(TRUE);
					if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
					{
						set_i3ddma_4k120_flag(1);//hdmi2.0 4k120 case
					}
					else
					{
						set_i3ddma_4k120_flag(0);//not hdmi2.0 4k120 case
					}

					if(scaler_force_run_idma(SLR_MAIN_DISPLAY, srctype) == FALSE)
					{
						I3DDMA_3DDMA_CTRL_T *p_i3ddmaCtrl = NULL;
						p_i3ddmaCtrl = Get_Val_i3ddmaCtrl_addr();
						set_force_i3ddma_enable(false);
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
						up(&Force_Run_Idma_Semaphore);
						rtd_pr_vsc_err("######scaler_force_run_idma fail fail fail!!!#######\n");
						reset_ARC_cmd(SLR_MAIN_DISPLAY);
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre);
						up(&SetMainOutPutRegion_Semaphore);
#ifdef CONFIG_FORCE_RUN_I3DDMA//ifndef no adc run i3ddma case
                        if(srctype  == VSC_INPUTSRC_HDMI)
#endif
                        {//Need to rerun scaler
                            reset_hdmi_timing_ready();
                            vfe_hdmi_drv_handle_on_line_measure_error(0);
                            down(get_hdmi_detectsemaphore());
                            if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
                                Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
                                HDMI_set_detect_flag(TRUE);
                            }
                            up(get_hdmi_detectsemaphore());
                        }
#ifdef CONFIG_FORCE_RUN_I3DDMA//ifndef no adc run i3ddma case
                        else if(srctype  == VSC_INPUTSRC_ADC)
                        {//Need to rerun scaler
                            StructDisplayInfo  *p_timing = NULL;
                            down(get_adc_detectsemaphore());
                            reset_adc_timing_ready();
                            p_timing = Get_ADC_Dispinfo();

                            if(p_timing!=NULL)
                            {
                                p_timing->IPH_ACT_WID_PRE = 0;
                                p_timing->IPV_ACT_LEN_PRE = 0;
                                p_timing->IVFreq = 0;
                                p_timing->IHFreq = 0;
                                p_timing->IHTotal = 0;
                                p_timing->IVTotal = 0;
                                p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
                            }
                            if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
                                ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
                                Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
                                ADC_set_detect_flag(TRUE);
                            }

                            up(get_adc_detectsemaphore());
                        }
                        else if(srctype  == VSC_INPUTSRC_AVD)
                        {//Need to rerun scaler
                            /*//no need because AVD don't stop detect task
                            down(get_vdc_detectsemaphore());
                            if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {
                            VDC_set_detect_flag(TRUE);
                            }
                            up(get_vdc_detectsemaphore());
                            */
                            reset_avd_timing_ready();
                            Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
                        }
                        else
                        {
                            rtd_pr_vsc_err("### not forcei3ddma case wrong source ###\n");
                        }
#endif
						if(p_i3ddmaCtrl)
							I3DDMA_Setup3DDMA(p_i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
						continue;
					}
					else
					{
						/*stored for iv2pv delay(i3ddma and vodma) setting at gamemode*/
						//rtd_pr_vsc_info("[qiangzhou22]SLR_INPUT_MODE_CURR = %d\n",Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						Set_GamemodeSaveI3ddmaGetcurMode(Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
					    up(&Force_Run_Idma_Semaphore);
						rtd_pr_vsc_notice("\r\n########func:%s force i3ddma_success (modeidx: %d)##########\r\n", __FUNCTION__, Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						port = 0;
					}
				}
				else
				{
				    
					if (!is_2k_memory_buffer_source(SLR_MAIN_DISPLAY))
					{//m odmain using 4k size need to borrow the memory from i3ddma
					    if (1==scaler_borrowmemory_from_i3ddma_for_mdomain()) {//borrow fail
                                        continue;
					    }
					}
					else if(srctype != VSC_INPUTSRC_AVD)	//for vdec, jpeg case
						set_force_i3ddma_enable(false);
					if(srctype == VSC_INPUTSRC_HDMI)
					{
						vbe_disp_set_freesync_mode_flag(drvif_Hdmi_GetAMDFreeSyncEnable());//save current freesync mode
						Set_Val_VRR_timingMode_flag(drvif_Hdmi_GetVRREnable());//save current vrr mode
					}
					else
					{
						vbe_disp_set_freesync_mode_flag(0);//save current freesync mode
						Set_Val_VRR_timingMode_flag(0);//save current vrr mode
					}
					set_i3ddma_4k120_flag(0);//not hdmi2.0 4k120 case
				}
			}
			sync_pc_mode_info();//this position  scaler info is from input source

			if(srctype == VSC_INPUTSRC_HDMI)
			{
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				set_source_info_forPQ(SLR_MAIN_DISPLAY);
				up(&SetMainOutPutRegion_Semaphore);
			}
#endif


#if defined (CONFIG_FORCE_RUN_I3DDMA) || defined (CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT) || defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			if(((srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG))
				|| (((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) || (srctype == VSC_INPUTSRC_AVD && (get_AVD_Input_Source() != _SRC_TV))) && get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
				)
#else
			if ((srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG))
#endif
			{
				if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
					timeout = 300;
				else
					timeout = 200;
				while (timeout--) {
					if(get_main_scaler_stop_flag()) {
						rtd_pr_vsc_notice("\r\n####VO already disconnet#####\r\n");
						break;
					}
					if(get_vo_change_flag(port)) {
						break;
					}
					if((get_ori_rotate_mode(SLR_MAIN_DISPLAY) != get_rotate_mode(SLR_MAIN_DISPLAY))&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE)==_MODE_STATE_ACTIVE)){
						break;
					}
					if(drv_memory_Get_multibuffer_changed())
						break;
					msleep(10);
				}

                if((srctype == VSC_INPUTSRC_VDEC) || (srctype == VSC_INPUTSRC_JPEG))
                {
                    rtd_pr_vsc_notice("####Go VO case. timeout:%d#####\r\n", timeout);
                }
                else if(timeout <= 0)
                {
                    rtd_pr_vsc_notice("####Go i3ddma case. timeout err#####\r\n");
                }

                if((srctype == VSC_INPUTSRC_VDEC) && !get_main_scaler_stop_flag())
                {
                    DbgSclrFlgTkr.Main_during_scalerflow_flag = TRUE;//WOSQRTK-7524 patch. Avoid webos call mute off during scaler flow
                }
			}

			if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{
				// If signal is locked, needs to wait VDC_DETECT_STAGE_FINAL
				if((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (drvif_video_status_reg(VDC_no_signal)==1)
					|| 	decide_auto_scaler_run(SLR_MAIN_DISPLAY)
					) // Need wait detect ready. (0 == drvif_module_vdc_GetLockStatus()) means snow screen

				{
					if(!get_main_scaler_stop_flag() && !Scaler_AVD_GetIsChannelChange())
					{
						if (0 == drvif_video_status_reg(VDC_no_signal))
						{
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
							{
								if(check_atv_mode_id_change()||Scaler_AVD_CheckATVTimingChange(SLR_MAIN_DISPLAY)) {
									Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
									if(get_AVD_Input_Source() == _SRC_TV)
										rtd_pr_vsc_info("#######[%s(%d)] Switch ATV different format##########\n",__func__,__LINE__);
								} else {
									if(get_AVD_Input_Source() == _SRC_TV)
										rtd_pr_vsc_info("#######[%s(%d)] Switch ATV same format########## \n",__func__,__LINE__);

									modestate_set_fll_running_flag(_ENABLE);
								}
							}
						}
						else
						{
							rtd_pr_vsc_debug("vsc_scaler_tsk  ATV no-signal\n");
						}

						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
							if(!get_main_scaler_stop_flag())
							{
#ifdef CONFIG_FORCE_RUN_I3DDMA
								if(get_AVD_Input_Source() == _SRC_TV)
								{
									rtd_pr_vsc_notice("####[%s(%d)] Main path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\n",__func__,__LINE__);
									Set_Val_vsc_run_pc_mode(0);//save vsc run pc mode or not
									down(&Force_Run_Idma_Semaphore);
									set_force_i3ddma_enable(TRUE);
									if(scaler_atv_force_run_idma()) {
										up(&Force_Run_Idma_Semaphore);
										port = 0;
										timeout = 200;
										while (timeout--) {
											if(get_main_scaler_stop_flag())
											{
												rtd_pr_vsc_info("####[%s(%d)]avd already disconnet#####\r\n",__func__,__LINE__);
												break;
											}
											if(get_vo_change_flag(port)) {
												rtd_pr_vsc_info("####[%s(%d)]vo change flag#####\r\n",__func__,__LINE__);
												break;
											}
											msleep(1);
										}
#ifdef CONFIG_I2RND_ENABLE
										//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
										if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
											vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_I3DDMA_RPC;
											//rtd_pr_vsc_emerg("[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
										}
#endif
										if(timeout <= 0)
											rtd_pr_vsc_notice("#####[%s(%d)]Go ATV VO case. timeout err#####\r\n",__func__,__LINE__);

									} else {
										if(!get_main_scaler_stop_flag()) {	//if not disconnected
											set_force_i3ddma_enable(FALSE);
											Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
											rtd_pr_vsc_info("####[%s(%d)]Main_Scaler_Stop_flag is false.#####\r\n",__func__,__LINE__);
										}
										up(&Force_Run_Idma_Semaphore);
									}
									//if(DbgSclrFlgTkr.Main_Scaler_Stop_flag)
										//set_force_i3ddma_enable(FALSE);
								}
								if(!get_main_scaler_stop_flag() && get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
								{
									set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
									rtd_pr_vsc_notice("#####[%s(%d)] run scaler start:%d %d#####\n", __func__, __LINE__, Get_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX), decide_auto_scaler_run(SLR_MAIN_DISPLAY));

									down(&SetMainOutPutRegion_Semaphore);
									DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
									up(&SetMainOutPutRegion_Semaphore);
									set_avd_start_need_compensation(TRUE);
									down(&VSC_Semaphore);
									rtd_pr_vsc_debug("\r\n####atv run scaler flow#####\r\n");

									rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
#ifdef CONFIG_I2RND_ENABLE
									//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
									if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_I3DDMA_RPC)){
										vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_RERUN_MAIN_DONE;
										//rtd_pr_vsc_emerg("[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
									}

									//send RPC let video fw do not write to memory after i2rnd donw @Crixus 20160808
									//i2rnd_send_table_idx(I2RND_TABLE_OFF);
#endif
									up(&VSC_Semaphore);
								}
								else if((get_main_scaler_stop_flag() == FALSE) && Get_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX)) {
									Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
								}
#else//#ifdef CONFIG_FORCE_RUN_I3DDMA
								if(get_AVD_Input_Source() == _SRC_TV)
									rtd_pr_vsc_notice("####[%s(%d)] Main path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\n",__func__,__LINE__);
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
								rtd_pr_vsc_notice("###[%s(%d)] run scaler start:%d %d#####\r\n",__func__,__LINE__, Get_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX), decide_auto_scaler_run(SLR_MAIN_DISPLAY));
								down(&SetMainOutPutRegion_Semaphore);
								DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
								up(&SetMainOutPutRegion_Semaphore);
								set_avd_start_need_compensation(TRUE);
								down(&VSC_Semaphore);
								rtd_pr_vsc_debug("####atv run scaler flow#####\r\n");
								rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
								up(&VSC_Semaphore);
#endif//#ifdef CONFIG_FORCE_RUN_I3DDMA
							}
						} else {
							if(((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (drvif_video_status_reg(VDC_no_signal) == 1)) && !get_main_scaler_stop_flag())
							{
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
								down(&SetMainOutPutRegion_Semaphore);
								Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, FALSE);
								Set_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX, FALSE);
								Scaler_DispWindowSet(main_dispwin);
								up(&SetMainOutPutRegion_Semaphore);
								set_avd_start_need_compensation(TRUE);
								avd_start_compensation();

								if(!Get_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX) && !get_main_scaler_stop_flag() && !Get_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX)){
									rtd_pr_vsc_debug("####atv run smooth toggle flow#####\r\n");
									down(&VSC_Semaphore);
									Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
									//before ATV smooth toggle flow, sync start address. @Crixus 20161019
									//send_memory_mapping_for_adaptive_streaming();
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
									//Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
									//zoom_imd_smooth_toggle_config(VIDEO_WID_0, main_dispwin.srcx, main_dispwin.srcy,
										//main_dispwin.src_wid, main_dispwin.src_height, ZOOM_DISP);
									zoom_imd_smooth_toggle_config(VIDEO_WID_0, hal_main_InputRegionType, main_input_size, main_input_timing, main_dispwin);
#else
									//zoom_imd_smooth_toggle_config(VIDEO_WID_0, main_dispwin.srcx, main_dispwin.srcy,
									//	main_dispwin.src_wid, main_dispwin.src_height, ZOOM_DISP);
									zoom_imd_smooth_toggle_config(VIDEO_WID_0, hal_main_InputRegionType, main_input_size, main_input_timing, main_dispwin);
#endif
									up(&VSC_Semaphore);


									if (FALSE == CheckAVDandWebOSInfo(SLR_MAIN_DISPLAY))
									{
										rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
										rtd_pr_vsc_debug("CheckAVDandWebOSInfo() fail\n");

										if (0xff == DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount)
										{
											rtd_pr_vsc_debug("Set DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0\n");
											DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0;
										}

										DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount++;

										if(get_main_scaler_stop_flag() == FALSE && DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount < CHECK_AVD_WEBOS_INFO_TIMEOUT){
											Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
										}
										else
										{
											rtd_pr_vsc_debug("DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount timeout\n");
											DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
										}
									}
									else
									{
										rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
										rtd_pr_vsc_debug("CheckAVDandWebOSInfo ok, DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount=%d\n", DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount);
										DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
									}


									if(!get_main_scaler_stop_flag() && !Get_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX) && !Get_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX))
									{
										if(wait_atv_stable_for_bg(SLR_MAIN_DISPLAY) == FALSE)
										{
											if((get_main_scaler_stop_flag() == FALSE) && Get_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX)){
												rtd_pr_vsc_info("####[%s(%d)] #####\r\n",__FUNCTION__, __LINE__);
												Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
											}

											if((get_main_scaler_stop_flag() == FALSE)
												/*&&(get_AVD_Input_Source() == _SRC_TV)*/ //no need to check because this is atv case
												&&((drvif_module_vdc_GetLockStatus() == 0)||(drvif_module_vdc_OutputStable()==FALSE)||(Scaler_AVD_GetDetectStage() != VDC_DETECT_STAGE_FINAL))
												&&(0 == drvif_video_status_reg(VDC_no_signal))){
                                                Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);
											}
										} else {
											if(!get_main_scaler_stop_flag()) {
												Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

												if (/*(get_AVD_Input_Source() == _SRC_TV) &&*/ //no need to check because this is atv case
													(DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange == TRUE)
													&&(Scaler_AVD_GetVDPreMode() != _MODE_UNKNOWN)
													&&(drvif_module_vdc_OutputStable() == FALSE)
													&&(1 == drvif_module_vdc_GetLockStatus())){
													rtd_pr_vsc_notice("#####[%s(%d)] set output again\n", __func__, __LINE__);
													Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
												}else{
													if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
													{
														rtd_pr_vsc_info("####[%s(%d)] ###\r\n",__func__, __LINE__);
														set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//display arc ready mask, becasue we already apply ARC
													}
													trigger_mute_off(SLR_MAIN_DISPLAY, 1);
												}
											}

#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
											cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90 - cost_time;
											rtd_pr_vsc_debug("\r\n####vsc cost time:%d ms after mute off atv smooth toggle####\r\n", cost_time);
#endif
										}
									} else if((get_main_scaler_stop_flag() == FALSE) && Get_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX)) {
										Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
									}

								}
								else if((get_main_scaler_stop_flag() == FALSE) && Get_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX)) {
									Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
								}
							}
						}
					} else {
						if((get_main_scaler_stop_flag() == FALSE) && Get_Val_DbgSclrFlgTkr(MAIN_OUTPUT_SET_IDX))
							Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
					}
				} else {
					if(get_main_scaler_stop_flag() == FALSE)
						Set_Val_DbgSclrFlgTkr(MAIN_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
				}

			} else {
				if(!get_main_scaler_stop_flag()) {
					down(&VSC_Semaphore);
					rtk_output_connect(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
					//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
					if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_I3DDMA_RPC)){
						vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_RERUN_MAIN_DONE;
						//rtd_pr_vsc_emerg("[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
					}

					//send RPC let video fw do not write to memory after i2rnd donw @Crixus 20160808
					//i2rnd_send_table_idx(I2RND_TABLE_OFF);
#endif
					up(&VSC_Semaphore);
				}
			}
			if (DbgSclrFlgTkr.main_winfreeze) {
				Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.main_winfreeze);
			}
			DbgSclrFlgTkr.main_winfreeze=0;
		} else if ((DbgSclrFlgTkr.OuputDisplayMode == TRUE)  && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
#ifndef BRING_UP_AUTO_FLOW
			//down(&VSC_Semaphore);//Remove by Will
			rtk_check_signal(SLR_MAIN_DISPLAY);
			//up(&VSC_Semaphore);//Remove by Will
#endif
		}

		if (freezing(current))
        {
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
#ifdef CONFIG_DUAL_CHANNEL
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
#endif
			try_to_freeze();
        }

#ifdef CONFIG_DUAL_CHANNEL
		decide_do_reset_mode(SLR_SUB_DISPLAY);

		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) != VSC_INPUTSRC_MAXN)
		{
			msleep(10);
		#if 1//sub
			// for sub smooth toggle test
			if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE){
				if(DbgSclrFlgTkr.Sub_smooth_toggle_set_flag) {
					down(&SetSubOutPutRegion_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);
					DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
					//DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
					//DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
					up(&SetSubOutPutRegion_Semaphore);

					down(&VSC_Semaphore);
					set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
					Scaler_SubDispWindowSet(sub_dispwin);
					zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, hal_sub_InputRegionType, sub_input_size, sub_input_timing, sub_dispwin);
					up(&VSC_Semaphore);
					//if(!DbgSclrFlgTkr.Sub_OutputVencMode)//no need 
					{
						drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
						trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
				}
			}
		#endif
			if (Get_Val_DbgSclrFlgTkr(SUB_RUN_SCALER_IDX) && (Get_Val_DbgSclrFlgTkr(SUB_SCALER_STOP_IDX) == FALSE) && (DbgSclrFlgTkr.Sub_Reset_Mode_flag == FALSE) && check_bbd_condition_complete(SLR_SUB_DISPLAY)//wait vsc close reset mode ready
#ifdef CONFIG_I2RND_ENABLE
				&& ((((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH))	//[K3LG-1721]Eric@0413 Fix sub not rerun scaler when NTSC switch to PAL
				//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
				&& ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)/* && (get_AVD_Input_Source() == _SRC_TV)*/ && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE)))
				//Eric@0606 Dual VDEC Needs to Run Sub Path
				|| ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))
				//PIP run sub-scaler path
				|| ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH)))
#endif
				) {

				KADP_VIDEO_RECT_T tOutRegion, tInputRegion;
				set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
				down(&SetSubOutPutRegion_Semaphore);
				Set_Val_DbgSclrFlgTkr(SUB_RUN_SCALER_IDX, FALSE);
				Set_Val_DbgSclrFlgTkr(SUB_OUTPUT_SET_IDX, FALSE);

#ifdef CONFIG_I2RND_ENABLE
				Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
				rtd_pr_vsc_emerg("[%s]I2RND_SUB_S1_TABLE!!!!\n",__FUNCTION__);
#endif
				set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
				set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
				set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
				Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,hal_sub_InputRegionType);
				Scaler_SubDispWindowSet(sub_dispwin);

				rtk_hal_vsc_GetInputRegion((KADP_VIDEO_WID_T)SLR_SUB_DISPLAY, &tInputRegion);
				rtk_hal_vsc_GetOutputRegion((KADP_VIDEO_WID_T)SLR_SUB_DISPLAY, &tOutRegion);

				up(&SetSubOutPutRegion_Semaphore);
				srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

                switch(srctype)
                {
                    case VSC_INPUTSRC_AVD:
                    if(get_AVD_Input_Source() != _SRC_TV)
                        rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_AVD(AV)#####\r\n");
                    break;

                    case VSC_INPUTSRC_ADC:
                        rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_ADC#####\r\n");
                    break;

                    case VSC_INPUTSRC_HDMI:
                        rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_HDMI#####\r\n");
                    break;

                    case VSC_INPUTSRC_VDEC:
                        rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_VDEC#####\r\n");
                    break;

                    case VSC_INPUTSRC_JPEG:
                        rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_JPEG#####\r\n");
                    break;

                    case VSC_INPUTSRC_DP:
                        rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_DP#####\r\n");
                    break;

                    default:
                    case VSC_INPUTSRC_MAXN:
                    case VSC_INPUTSRC_HDD:
                    case VSC_INPUTSRC_VBY1RX:
                    break;
                }

				if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
				{
					if((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (0 == drvif_module_vdc_GetLockStatus()))
					{//If APVR, need to wait main ready
						if(!Get_Val_DbgSclrFlgTkr(SUB_OUTPUT_SET_IDX) && !Get_Val_DbgSclrFlgTkr(SUB_SCALER_STOP_IDX) && !Get_Val_DbgSclrFlgTkr(SUB_RUN_SCALER_IDX)) {
							rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\r\n");
							#if 0
							rtd_pr_vsc_emerg( "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
							rtd_pr_vsc_emerg( "rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);
							rtd_pr_vsc_emerg( "rtk_hal_vsc_GetOutputRegion OutputRegion_x=%d, y=%d, w=%d, h=%d\n", tOutRegion.x, tOutRegion.y, tOutRegion.w, tOutRegion.h);

							rtd_pr_vsc_emerg( "Pre InputRegion_x=%d, y=%d, w=%d, h=%d\n", DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre);
							rtd_pr_vsc_emerg( "Pre OutputRegion_x=%d, y=%d, w=%d, h=%d\n", DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre);

							rtd_pr_vsc_emerg( "DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
							rtd_pr_vsc_emerg( "CompareATVInputOutputRegion()=%x\n", CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion));
							#endif

							rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
							rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
							rtd_pr_vsc_debug("CompareATVInputOutputRegion()=%x\n", CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion));


							if (DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag && CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion))
							{
								rtd_pr_vsc_debug("vsc_scaler_task ATV sub path don't run scaler flow\n");
								//rtd_pr_vsc_emerg( "vsc_scaler_task ATV sub path don't run scaler flow\n");
							}
							else
							{
								rtd_pr_vsc_debug("Set ATV output/input pre\n");
								//rtd_pr_vsc_emerg( "Set ATV output/input pre\n");

								DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre = tOutRegion.x;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre = tOutRegion.y;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre = tOutRegion.w;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre = tOutRegion.h;

								DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre = tInputRegion.x;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre = tInputRegion.y;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre = tInputRegion.w;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre = tInputRegion.h;


								rtd_pr_vsc_debug("\r\n####atv run sub scaler flow#####\r\n");
								down(&VSC_Semaphore);
								rtk_output_connect(SLR_SUB_DISPLAY); // different format to go normal scaler
								if(!DbgSclrFlgTkr.Sub_OutputVencMode)
									drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
								Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
								//I2rnd sub=>vo RPC
								if(vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE){
									vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
									rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
									//Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
									//i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
									//drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, srctype);
									drivf_Sub_I2rnd_SetupVODMA();
									//i2rnd_debug();
									rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
								}
#endif
								up(&VSC_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
								//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
								if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE)){
									vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
								}
#endif
							}
						} else if((Get_Val_DbgSclrFlgTkr(SUB_SCALER_STOP_IDX) == FALSE) && Get_Val_DbgSclrFlgTkr(SUB_OUTPUT_SET_IDX)) {
							Set_Val_DbgSclrFlgTkr(SUB_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
						}
					} else {

						if(Get_Val_DbgSclrFlgTkr(SUB_SCALER_STOP_IDX) == FALSE)
							Set_Val_DbgSclrFlgTkr(SUB_RUN_SCALER_IDX, TRUE);// Set output again, switch channel
					}
				} else {
					if(!Get_Val_DbgSclrFlgTkr(SUB_SCALER_STOP_IDX)) {
						down(&VSC_Semaphore);
						rtk_output_connect(SLR_SUB_DISPLAY);
						if(!DbgSclrFlgTkr.Sub_OutputVencMode)
							drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
						Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
						if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_CONNECT)) && (Get_Val_DbgSclrFlgTkr(SUB_RUN_SCALER_IDX)== FALSE)){
							vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1;
							rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1@@@@@@@@@@\n");
							//check timing enable
							Scaler_I2rnd_wait_timing_enable();
							//disable s0 db_en when i2r timing enable @Crixus 20171219
							Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
							set_zoom_reset_double_state(_DISABLE, SLR_MAIN_DISPLAY);//always disable double buffer
							//check di setting
							i2rnd_default_register_setting();
							//rtd_pr_vsc_emerg("[%s][sub connect]I2RND default setting done\n", __FUNCTION__);
							scaler_i2rnd_run_main();

							//before disable sub fbg, need to check sub disconnect or not @Crixus 20180110
							if(Get_Val_DbgSclrFlgTkr(SUB_SCALER_STOP_IDX)){
								rtd_pr_vsc_emerg("[I2RND]sub already disconnect, do not disable fbg!!\n");
							}
							else{
								//Disable main force cmd buffer flag after sub done because i2r enable at vo. @Crixus 20171128
								down(&I2RND_Semaphore);
								Scaler_I2rnd_set_force_cmd(_DISABLE);
								up(&I2RND_Semaphore);
								rtd_pr_vsc_emerg("[I2RND]Disable main force cmd buffer flag after sub done.\n");
								if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_DONE)){
									vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH;
									rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH@@@@@@@@@@\n");
								}

								set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
								trigger_mute_off(SLR_SUB_DISPLAY, 1);

								//down(get_forcebg_semaphore());
								//scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, FALSE);
								//up(get_forcebg_semaphore());
								rtd_pr_vsc_emerg("[I2RND] DualVO rerun main path done, disable fbg!!\n");
							}

							if ((vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)) && (vo_timing_change_for_adaptive == 1)) {
								//Eric@20170922 update main structure info for adaptive stream
								Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_VO_Dispinfo(DisplayModeInputInfo.resourceIndex));
								vo_timing_change_for_adaptive = 0;
							}
						}

						//I2rnd sub=>vo RPC
						if(vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE){
							vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
							rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
							//Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
							//i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
							//drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, srctype);
							drivf_Sub_I2rnd_SetupVODMA();
							//i2rnd_debug();
							rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
						}
#endif
						up(&VSC_Semaphore);
					}
				}
			} else if ((DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				&& (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
#ifndef BRING_UP_AUTO_FLOW

				//down(&VSC_Semaphore);//Remove by Will
				rtk_check_signal(SLR_SUB_DISPLAY);
				//up(&VSC_Semaphore);//Remove by Will
#endif
			}
		}
		if (freezing(current))
       	{
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
			try_to_freeze();
        }
#endif

#ifdef MEMC_DYNAMIC_ONOFF
		Scaler_MEMC_Dynamic_OnOff();
#endif
		if (kthread_should_stop()) {
         	break;
      	}
    }
    rtd_pr_vsc_debug("\r\n####vsc_scaler_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

/* for sub path support non-vo source NN data capture (NV12)*/
#ifdef CONFIG_ENABLE_SUB_NN

unsigned char sub_path_allocate_nv12_memory(UINT32 width,UINT32 height,unsigned char buffernub)
{
	unsigned int size = 0;
	unsigned long malloccacheaddr = 0;
	int i;
	size = _ALIGN((MAX_SUB_NN_WIDTH*MAX_SUB_NN_HEIGHT + MAX_SUB_NN_WIDTH*MAX_SUB_NN_HEIGHT/2),__4KPAGE);

	if(gt_SubNN_Cap_Buffer[0].phyaddr != 0)
	{
		sub_path_free_nv12_memory(buffernub);
	}

	malloccacheaddr = (unsigned long)dvr_malloc_specific(size * buffernub, GFP_DCU2_FIRST);
	if((unsigned long)NULL == malloccacheaddr)
	{
		//rtd_pr_vsc_notice("[error]:alloc memory failed\n");
		return FALSE;
	}
	else
	{
		for(i = 0; i < buffernub; i++)
		{
			if(gt_SubNN_Cap_Buffer[i].cache == NULL)
			{
				gt_SubNN_Cap_Buffer[i].cache = (void*)(malloccacheaddr+i*size);
				//gt_SubNN_Cap_Buffer[i].phyaddr =  (unsigned int)virt_to_phys((void*)gt_SubNN_Cap_Buffer[i].cache);
				gt_SubNN_Cap_Buffer[i].phyaddr = (unsigned int)dvr_to_phys((void*)gt_SubNN_Cap_Buffer[i].cache);
				gt_SubNN_Cap_Buffer[i].size = size;
				rtd_pr_vsc_notice("[Sub NN]memory allocate] buf[%d]=(%d KB), phy(%lx) \n", i, gt_SubNN_Cap_Buffer[i].size >> 10, (unsigned long)gt_SubNN_Cap_Buffer[i].phyaddr);
		   }
		}


		for(i = 0; i < buffernub; i++)
		{
			rtd_pr_vsc_notice("[Sub NN]cap_buf[%d]_y = 0x%x\n", i, gt_SubNN_Cap_Buffer[i].phyaddr);
			rtd_pr_vsc_notice("[Sub NN]cap_buf[%d]_c = 0x%x\n", i, (gt_SubNN_Cap_Buffer[i].phyaddr + /*_ALIGN((VT_CAP_FRAME_WIDTH_2K1k*VT_CAP_FRAME_HEIGHT_2K1k),__4KPAGE)*/MAX_SUB_NN_WIDTH*MAX_SUB_NN_HEIGHT));
		}

		return TRUE;
	}
}
void sub_path_free_nv12_memory(unsigned int buffernum)
{
	int i;
	if (gt_SubNN_Cap_Buffer[0].cache)
	{
		dvr_free(gt_SubNN_Cap_Buffer[0].cache);
	}

	for (i = 0; i < buffernum; i++)
	{
		if (gt_SubNN_Cap_Buffer[i].cache)
		{
			gt_SubNN_Cap_Buffer[i].cache = NULL;
			gt_SubNN_Cap_Buffer[i].phyaddr = (unsigned long)NULL;
			gt_SubNN_Cap_Buffer[i].size = 0;
		}
	}
	rtd_pr_vsc_notice("[Sub NN][memory free] Deinit done!\n");
}
void config_sub_vgip_for_NN_capture(unsigned char src, unsigned char mode)
{
	sub_vgip_vgip_chn2_double_buffer_ctrl_RBUS sub_vgip_vgip_chn2_double_buffer_ctrl_Reg;
	sub_vgip_vgip_chn2_ctrl_RBUS vgip_chn2_ctrl_reg;
	sub_vgip_vgip_chn2_act_hsta_width_RBUS vgip_chn2_act_hsta_width_reg;
	sub_vgip_vgip_chn2_act_vsta_length_RBUS vgip_chn2_act_vsta_length_reg;
	sub_vgip_vgip_chn2_delay_RBUS sub_vgip_vgip_chn2_delay_reg;
	sub_vgip_vgip_chn2_misc_RBUS vgip_chn2_misc_reg;

	vgip_data_path_select_RBUS data_path_select_reg;
	vgip_vgip_chn1_misc_RBUS vgip_chn1_misc_reg;
	vgip_vgip_chn1_ctrl_RBUS vgip_chn1_ctrl_reg;

	iedge_smooth_format_convert_RBUS main_sub_iedge_smooth_format_convert_reg;
	iedge_smooth_edsm_db_ctrl_RBUS iedge_smooth_edsm_db_ctrl_reg;

	unsigned char need_update = FALSE;

	/*close sub vgip double buffer*/
	sub_vgip_vgip_chn2_double_buffer_ctrl_Reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_DOUBLE_BUFFER_CTRL_reg);
	sub_vgip_vgip_chn2_double_buffer_ctrl_Reg.ch2_db_en = 0;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_DOUBLE_BUFFER_CTRL_reg, sub_vgip_vgip_chn2_double_buffer_ctrl_Reg.regValue);

	// Disable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_clk_en = 0;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	vgip_chn1_ctrl_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_CTRL_reg);
	// determine the input source
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_sel = src;
	//vgip_chn2_ctrl_reg.ch2_digital_mode = mode;
	vgip_chn2_ctrl_reg.ch2_digital_mode = vgip_chn1_ctrl_reg.ch1_digital_mode;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	//sub vgip size sync from main

	vgip_chn2_act_hsta_width_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg);
	if(vgip_chn2_ctrl_reg.ch2_digital_mode == 1)
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_sta = 0;
	else
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_sta = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA);

	vgip_chn2_act_hsta_width_reg.ch2_ih_act_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg, vgip_chn2_act_hsta_width_reg.regValue);

	vgip_chn2_act_vsta_length_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg);
	if(vgip_chn2_ctrl_reg.ch2_digital_mode == 1)
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_sta = 0;
	else
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_sta = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA);

	vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg, vgip_chn2_act_vsta_length_reg.regValue);

	//vgip ch2 prochnum
	vgip_chn1_misc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_MISC_reg);
	vgip_chn2_misc_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_MISC_reg);

	vgip_chn2_misc_reg.ch2_hporch_num = vgip_chn1_misc_reg.ch1_hporch_num;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_MISC_reg, vgip_chn2_misc_reg.regValue);


	sub_vgip_vgip_chn2_delay_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_DELAY_reg);
	sub_vgip_vgip_chn2_delay_reg.ch2_ihs_dly = 0;//reset 0
	sub_vgip_vgip_chn2_delay_reg.ch2_ivs_dly = 0;//reset 0
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_DELAY_reg, sub_vgip_vgip_chn2_delay_reg.regValue);


	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_field_det_en = _DISABLE;		//bit16
	vgip_chn2_ctrl_reg.ch2_field_sync_edge = _ENABLE;	//bit17
	vgip_chn2_ctrl_reg.ch2_field_inv = _ENABLE;		//bit18
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	// enable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_ivrun = 1;
	vgip_chn2_ctrl_reg.ch2_in_clk_en= 1;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);
	mdelay(2);

	//config sub vgip data path
	data_path_select_reg.regValue = IoReg_Read32(VGIP_Data_Path_Select_reg);
	if(data_path_select_reg.uzd1_in_sel == 0)
	{
		rtd_pr_vsc_notice("[Sub NN]NO DI source, Capture will fail!;%s=%d \n", __FUNCTION__, __LINE__);
		//return FALSE;
	}
	if(data_path_select_reg.xcdi_clk_en == 0)
	{
		need_update = TRUE;
		data_path_select_reg.xcdi_clk_en = 1;
	}

	if(data_path_select_reg.s2_clk_en == 0)
	{
		need_update = TRUE;
		data_path_select_reg.s2_clk_en = 1;
	}
	if(need_update)
		IoReg_Write32(VGIP_Data_Path_Select_reg, data_path_select_reg.regValue);

 //disable sub 4422 to 444
	iedge_smooth_edsm_db_ctrl_reg.regValue = IoReg_Read32(IEDGE_SMOOTH_EDSM_DB_CTRL_reg);
	main_sub_iedge_smooth_format_convert_reg.regValue = IoReg_Read32(IEDGE_SMOOTH_FORMAT_CONVERT_reg);
	if(main_sub_iedge_smooth_format_convert_reg.sub_422_to_444_en)
	{
		if(iedge_smooth_edsm_db_ctrl_reg.edsm_db_en) //db on
		{
			iedge_smooth_edsm_db_ctrl_reg.edsm_db_en = 0;
			IoReg_Write32(IEDGE_SMOOTH_EDSM_DB_CTRL_reg, iedge_smooth_edsm_db_ctrl_reg.regValue);

			main_sub_iedge_smooth_format_convert_reg.sub_422_to_444_en = 0;
			IoReg_Write32(IEDGE_SMOOTH_FORMAT_CONVERT_reg, main_sub_iedge_smooth_format_convert_reg.regValue);
		}
		else
		{
			main_sub_iedge_smooth_format_convert_reg.sub_422_to_444_en = 0;
			IoReg_Write32(IEDGE_SMOOTH_FORMAT_CONVERT_reg, main_sub_iedge_smooth_format_convert_reg.regValue);
		}
	}

}

void config_sub_rgb2yuv_for_NN_capture(void)
{
	unsigned short *table_index = NULL;
	rgb2yuv_ich2_rgb2yuv_ctrl_RBUS	ich2_RGB2YUV_CTRL_REG;

	rgb2yuv_tab2_m11_m12_RBUS tab2_m11_m12_reg;
	rgb2yuv_tab2_m13_m21_RBUS tab2_m13_m21_reg;
	rgb2yuv_tab2_m22_m23_RBUS tab2_m22_m23_reg;
	rgb2yuv_tab2_m31_m32_RBUS tab2_m31_m32_reg;
	rgb2yuv_tab2_m33_y_gain_RBUS tab2_m33_ygain_reg;
	rgb2yuv_tab2_yo_RBUS tab2_yo_reg;

	unsigned char table_num = RGB2YUV_COEF_MATRIX_MODE_Max;

	// calculate table_index
	table_num = RGB2YUV_COEF_YCC601_0_255_TO_YCC709_0_255;
	table_index = &(tRGB2YUV_COEF[table_num][0]);

	IoReg_SetBits(RGB2YUV_ICH1_RGB2YUV_CTRL_reg, RGB2YUV_ICH1_RGB2YUV_CTRL_sub_rgb2yuv_db_en_mask); // sub DB en
	ich2_RGB2YUV_CTRL_REG.en_rgb2yuv = 0;
	IoReg_Write32(RGB2YUV_ICH2_RGB2YUV_CTRL_reg, ich2_RGB2YUV_CTRL_REG.regValue);

	/*sub  all tab-2*/
	tab2_m11_m12_reg.m11 = table_index[_RGB2YUV_m11];
	tab2_m11_m12_reg.m12 = table_index[_RGB2YUV_m12];
	IoReg_Write32(RGB2YUV_Tab2_M11_M12_reg, tab2_m11_m12_reg.regValue);
	tab2_m13_m21_reg.m13 = table_index[_RGB2YUV_m13];
	tab2_m13_m21_reg.m21 = table_index[_RGB2YUV_m21];
	IoReg_Write32(RGB2YUV_Tab2_M13_M21_reg, tab2_m13_m21_reg.regValue);
	tab2_m22_m23_reg.m22 = table_index[_RGB2YUV_m22];
	tab2_m22_m23_reg.m23 = table_index[_RGB2YUV_m23];
	IoReg_Write32(RGB2YUV_Tab2_M22_M23_reg, tab2_m22_m23_reg.regValue);
	tab2_m31_m32_reg.m31 = table_index[_RGB2YUV_m31];
	tab2_m31_m32_reg.m32 = table_index[_RGB2YUV_m32];
	IoReg_Write32(RGB2YUV_Tab2_M31_M32_reg, tab2_m31_m32_reg.regValue);
	tab2_m33_ygain_reg.m33 = table_index[_RGB2YUV_m33];
	tab2_m33_ygain_reg.y_gain = table_index[_RGB2YUV_Y_gain];
	IoReg_Write32(RGB2YUV_Tab2_M33_Y_Gain_reg, tab2_m33_ygain_reg.regValue);

	tab2_yo_reg.yo_even = table_index[_RGB2YUV_Yo_even];
	tab2_yo_reg.yo_odd = table_index[_RGB2YUV_Yo_odd];
	IoReg_Write32(RGB2YUV_Tab2_Yo_reg, tab2_yo_reg.regValue);


	ich2_RGB2YUV_CTRL_REG.sel_rgb = table_index[_RGB2YUV_sel_RGB];
	ich2_RGB2YUV_CTRL_REG.set_r_in_offset = table_index[_RGB2YUV_set_Yin_offset];
	ich2_RGB2YUV_CTRL_REG.set_uv_out_offset = table_index[_RGB2YUV_set_UV_out_offset];
	ich2_RGB2YUV_CTRL_REG.sel_uv_off = table_index[_RGB2YUV_sel_UV_off];
	ich2_RGB2YUV_CTRL_REG.matrix_bypass = table_index[_RGB2YUV_Matrix_bypass];
	ich2_RGB2YUV_CTRL_REG.sel_y_gain = table_index[_RGB2YUV_Enable_Y_gain];

	//ich2_RGB2YUV_CTRL_REG.sel_table = 1;//mac7p pq compile fix, mac7p HW remove sel_table
	ich2_RGB2YUV_CTRL_REG.en_rgb2yuv = 0;

	IoReg_Write32(RGB2YUV_ICH2_RGB2YUV_CTRL_reg, ich2_RGB2YUV_CTRL_REG.regValue);
	IoReg_SetBits(RGB2YUV_ICH2_RGB2YUV_CTRL_reg, RGB2YUV_ICH2_RGB2YUV_CTRL_sub_rgb2yuv_db_apply_mask); // sub DB apply
}

void config_sub_uzd_for_NN_capture(SIZE* pin_Size, SIZE* pout_Size)
{
	/*Scale down Setup for Channel 2*/
	scaledown_ich2_uzd_ctrl0_RBUS ich2_uzd_Ctrl0_REG;
	scaledown_ich2_ibuff_ctrli_buff_ctrl_RBUS ich2_ibuff_ctrl_BUFF_CTRL;
	scaledown_ich2_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
	scaledown_ich2_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
	scaledown_ich2_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
	scaledown_ich2_uzd_channel_swap_RBUS scaledown_ich2_uzd_channel_swap_Reg;

	scaledown_ich2_uzd_db_ctrl_RBUS scaledown_ich2_uzd_db_ctrl_Reg;

	/*close sub uzd double buffer*/
	scaledown_ich2_uzd_db_ctrl_Reg.regValue = IoReg_Read32(SCALEDOWN_ICH2_UZD_DB_CTRL_reg);
	scaledown_ich2_uzd_db_ctrl_Reg.h_db_en = 0;
	scaledown_ich2_uzd_db_ctrl_Reg.v_db_en = 0;
	IoReg_Write32(SCALEDOWN_ICH2_UZD_DB_CTRL_reg, scaledown_ich2_uzd_db_ctrl_Reg.regValue);

	ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg);
	ich1_sdnr_cutout_range_hor_reg.hor_front= 0;
	ich1_sdnr_cutout_range_hor_reg.hor_back= pin_Size->nWidth+1; // chip setting need to +1
	IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

	ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg);
	ich1_sdnr_cutout_range_ver0_reg.ver_front= 0;
	ich1_sdnr_cutout_range_ver0_reg.ver_back= pin_Size->nLength+1;	// chip setting need to +1
	IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);

	ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg);
	ich1_sdnr_cutout_range_ver1_reg.ver_mid_top=0;	// inregion.y;
	ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot=0;	// inregion.y;
	IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);

	scaledown_ich2_uzd_channel_swap_Reg.regValue = IoReg_Read32(SCALEDOWN_ICH2_UZD_channel_swap_reg);
	scaledown_ich2_uzd_channel_swap_Reg.rgb_ch_swap = 0;//YUV	1:VUY-YUV
	IoReg_Write32(SCALEDOWN_ICH2_UZD_channel_swap_reg, scaledown_ich2_uzd_channel_swap_Reg.regValue);

	ich2_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH2_UZD_Ctrl0_reg);
	if (pin_Size->nLength > pout_Size->nLength)
		ich2_uzd_Ctrl0_REG.v_zoom_en = 1;
	else
		ich2_uzd_Ctrl0_REG.v_zoom_en = 0;
	ich2_uzd_Ctrl0_REG.buffer_mode = 0;

	if (pin_Size->nWidth > pout_Size->nWidth)
		ich2_uzd_Ctrl0_REG.h_zoom_en = 1;
	else
		ich2_uzd_Ctrl0_REG.h_zoom_en = 0;

	ich2_uzd_Ctrl0_REG.cutout_en = 1;
	ich2_uzd_Ctrl0_REG.output_fmt = 0; //422  1: 444
	ich2_uzd_Ctrl0_REG.video_comp_en = 0;
	IoReg_Write32(SCALEDOWN_ICH2_UZD_Ctrl0_reg, ich2_uzd_Ctrl0_REG.regValue);

	ich2_ibuff_ctrl_BUFF_CTRL.regValue = IoReg_Read32(SCALEDOWN_ICH2_IBUFF_CTRLI_BUFF_CTRL_reg);
	ich2_ibuff_ctrl_BUFF_CTRL.ibuf_h_size = pout_Size->nWidth;
	ich2_ibuff_ctrl_BUFF_CTRL.ibuf_v_size = pin_Size->nLength;
	IoReg_Write32(SCALEDOWN_ICH2_IBUFF_CTRLI_BUFF_CTRL_reg, ich2_ibuff_ctrl_BUFF_CTRL.regValue);

	drvif_vt_color_ultrazoom_set_scale_down(pin_Size, pout_Size);

}

void config_sub_mdomain_vi_for_NN_capture(unsigned int capWid, unsigned int capLen)
{
	mdomain_cap_sub_sdnr_cxxto64_RBUS mdomain_cap_sub_sdnr_cxxto64_reg;
	mdomain_cap_ddr_in2ctrl_RBUS mdomain_cap_ddr_in2ctrl_reg;
	mdomain_vi_sub_mdom_sub_vi_addcmd_transform_RBUS mdomain_vi_sub_mdom_sub_vi_addcmd_transform_reg;
	mdomain_vi_sub_sub_v1_output_fmt_RBUS mdomain_vi_sub_sub_v1_output_fmt_reg;
	mdomain_vi_sub_sub_cwvh1_RBUS mdomain_vi_sub_sub_cwvh1_reg;
	mdomain_vi_sub_sub_cwvh1_2_RBUS mdomain_vi_sub_sub_cwvh1_2_reg;
	mdomain_vi_sub_mdom_sub_vi_c_line_step_RBUS mdomain_vi_sub_mdom_sub_vi_c_line_step_reg;
	mdomain_vi_sub_sub_y1buf_RBUS mdomain_vi_sub_sub_y1buf_reg;
	mdomain_vi_sub_sub_c1buf_RBUS mdomain_vi_sub_sub_c1buf_reg;

	//mdomain_vi_sub_sub_inten_RBUS mdomain_vi_sub_sub_inten_reg; //sub m domain vi interrupt enable
	//mdomain_vi_sub_sub_intst_RBUS mdomain_vi_sub_sub_intst_reg; //sub m domain vi int status

	mdomain_vi_sub_sub_dmactl_RBUS vi_dmactl_reg;//dmaen  //MDOM_VI_DMACTL_reg
	mdomain_vi_sub_sub_gctl_RBUS vi_gctl_reg;//vsce1 //MDOM_VI_GCTL_reg
	mdomain_vi_sub_mdom_sub_vi_ads_start_y_RBUS mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg;
	mdomain_vi_sub_mdom_sub_vi_ads_start_c_RBUS mdomain_vi_sub_mdom_sub_vi_ads_start_c_reg;

	unsigned int LineSize = 0;
	mdomain_cap_cap_reg_doublbuffer_RBUS cap_reg_doublbuffer_reg;
	//disable M-cap double buffer - sub
	cap_reg_doublbuffer_reg.regValue = rtd_inl(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap2_db_en = 0;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);

	mdomain_cap_sub_sdnr_cxxto64_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Sub_SDNR_cxxto64_reg);
	mdomain_cap_sub_sdnr_cxxto64_reg.sub_sort_fmt = 1;//0:422,1:444
	mdomain_cap_sub_sdnr_cxxto64_reg.sub_out_bit = 0;//sub only support 8 bit
	IoReg_Write32(MDOMAIN_CAP_Sub_SDNR_cxxto64_reg, mdomain_cap_sub_sdnr_cxxto64_reg.regValue);

	//boundary set
	IoReg_Write32(MDOMAIN_CAP_CapSub_BoundaryAddr_BLK0_reg, (gt_SubNN_Cap_Buffer[0].phyaddr & 0x7ffffff0));
	IoReg_Write32(MDOMAIN_CAP_CapSub_BoundaryAddr2_BLK0_reg, (gt_SubNN_Cap_Buffer[0].phyaddr+gt_SubNN_Cap_Buffer[0].size) & 0x7ffffff0);
	IoReg_Write32(MDOMAIN_CAP_CapSub_BoundaryAddr_BLK1_reg, (gt_SubNN_Cap_Buffer[1].phyaddr & 0x7ffffff0));
	IoReg_Write32(MDOMAIN_CAP_CapSub_BoundaryAddr2_BLK1_reg, (gt_SubNN_Cap_Buffer[1].phyaddr+gt_SubNN_Cap_Buffer[1].size) & 0x7ffffff0);

	IoReg_Write32(MDOMAIN_CAP_CapSub_BoundaryAddr_BLK2_reg, (gt_SubNN_Cap_Buffer[2].phyaddr & 0x7ffffff0));
	IoReg_Write32(MDOMAIN_CAP_CapSub_BoundaryAddr2_BLK2_reg, (gt_SubNN_Cap_Buffer[2].phyaddr+gt_SubNN_Cap_Buffer[2].size) & 0x7ffffff0);

	mdomain_cap_ddr_in2ctrl_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In2Ctrl_reg);
	//single buffer
	mdomain_cap_ddr_in2ctrl_reg.in2_en_vs_rst = 1;
	mdomain_cap_ddr_in2ctrl_reg.in2_double_enable = 0; //single buffer
	mdomain_cap_ddr_in2ctrl_reg.in2_v_flip_3buf_en = 0;
	mdomain_cap_ddr_in2ctrl_reg.in2_bufnum = 0;
	mdomain_cap_ddr_in2ctrl_reg.in2_disp2cap_distance = 0;

	IoReg_Write32(MDOMAIN_CAP_DDR_In2Ctrl_reg, mdomain_cap_ddr_in2ctrl_reg.regValue);

	//set_mdomain_sub_vi_cap_nv12_for_vt(capWid, capLen, 0); //420

	//sub vi register setting
    vi_dmactl_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_DMACTL_reg);
    vi_dmactl_reg.dmaen1 = 0;
    IoReg_Write32(MDOMAIN_VI_SUB_SUB_DMACTL_reg, vi_dmactl_reg.regValue);

	mdomain_vi_sub_sub_v1_output_fmt_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_V1_OUTPUT_FMT_reg);
	mdomain_vi_sub_sub_v1_output_fmt_reg.swap_1byte = 0;
	mdomain_vi_sub_sub_v1_output_fmt_reg.swap_2byte = 0;
	mdomain_vi_sub_sub_v1_output_fmt_reg.swap_4byte = 0;
	mdomain_vi_sub_sub_v1_output_fmt_reg.swap_8byte = 0;
	mdomain_vi_sub_sub_v1_output_fmt_reg.data_format = 0;
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_V1_OUTPUT_FMT_reg,mdomain_vi_sub_sub_v1_output_fmt_reg.regValue);

	mdomain_vi_sub_sub_cwvh1_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_CWVH1_reg);
	mdomain_vi_sub_sub_cwvh1_reg.hsize = capWid;
	mdomain_vi_sub_sub_cwvh1_reg.vsize = capLen;
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_CWVH1_reg, mdomain_vi_sub_sub_cwvh1_reg.regValue);

	mdomain_vi_sub_sub_cwvh1_2_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_CWVH1_2_reg);
	mdomain_vi_sub_sub_cwvh1_2_reg.vsize_c = (capLen >> 1);
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_CWVH1_2_reg, mdomain_vi_sub_sub_cwvh1_2_reg.regValue);

	LineSize = capWid * 8 / 64;
	if(LineSize % 2)
		LineSize += 1;
	rtd_pr_vsc_notice("[Sub NN][vi]LineSize:%d\n",LineSize);

	mdomain_vi_sub_mdom_sub_vi_c_line_step_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_mdom_sub_vi_c_line_step_reg);
	mdomain_vi_sub_mdom_sub_vi_c_line_step_reg.c_line_step = LineSize;
	mdomain_vi_sub_mdom_sub_vi_c_line_step_reg.common_line_step_en = 0;
	IoReg_Write32(MDOMAIN_VI_SUB_mdom_sub_vi_c_line_step_reg, mdomain_vi_sub_mdom_sub_vi_c_line_step_reg.regValue);

	mdomain_vi_sub_mdom_sub_vi_addcmd_transform_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_mdom_sub_vi_addcmd_transform_reg);
	mdomain_vi_sub_mdom_sub_vi_addcmd_transform_reg.line_step = LineSize;
	//mdomain_vi_sub_mdom_sub_vi_addcmd_transform_reg.vi_addcmd_trans_en = 1;
	IoReg_Write32(MDOMAIN_VI_SUB_mdom_sub_vi_addcmd_transform_reg, mdomain_vi_sub_mdom_sub_vi_addcmd_transform_reg.regValue);

	mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = gt_SubNN_Cap_Buffer[0].phyaddr;
	IoReg_Write32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_y_reg, mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue);

	mdomain_vi_sub_mdom_sub_vi_ads_start_c_reg.regValue = (gt_SubNN_Cap_Buffer[0].phyaddr + MAX_SUB_NN_WIDTH*MAX_SUB_NN_HEIGHT /*_ALIGN((VT_CAP_FRAME_WIDTH_2K1k*VT_CAP_FRAME_HEIGHT_2K1k),__4KPAGE)*/);
	IoReg_Write32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_c_reg, mdomain_vi_sub_mdom_sub_vi_ads_start_c_reg.regValue);

	//rtd_pr_vsc_notice("sub_vi_ads_start_y_reg = 0x%x\n", IoReg_Read32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_y_reg));
	//rtd_pr_vsc_notice("sub_vi_ads_start_c_reg = 0x%x\n", IoReg_Read32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_c_reg));

	// water lvl
	mdomain_vi_sub_sub_y1buf_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_Y1BUF_reg);
	mdomain_vi_sub_sub_y1buf_reg.y_water_lvl = 64; //120; //120*64bits
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_Y1BUF_reg, mdomain_vi_sub_sub_y1buf_reg.regValue);

	mdomain_vi_sub_sub_c1buf_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_C1BUF_reg);
	mdomain_vi_sub_sub_c1buf_reg.c_water_lvl = 64; //120; //120*64bits
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_C1BUF_reg, mdomain_vi_sub_sub_c1buf_reg.regValue);

	vi_gctl_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_GCTL_reg);
	vi_gctl_reg.vsce1 = 1;
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_GCTL_reg, vi_gctl_reg.regValue);


	//mdomain_vi_sub_sub_intst_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_INTST_reg);
	/*mdomain_vi_sub_sub_intst_reg.dmaerrints = 1; //wclr_out
	mdomain_vi_sub_sub_intst_reg.dma_fifo_of = 1; //wclr_out
	mdomain_vi_sub_sub_intst_reg.dma_fifo_uf = 1; //wclr_out
	mdomain_vi_sub_sub_intst_reg.video_in_last_wr_c_flag = 1; //wclr_out*/
	//mdomain_vi_sub_sub_intst_reg.video_in_last_wr_y_flag = 1; //wclr_out
	//mdomain_vi_sub_sub_intst_reg.vsints1 = 1; //wclr_out
	//IoReg_Write32(MDOMAIN_VI_SUB_SUB_INTST_reg, mdomain_vi_sub_sub_intst_reg.regValue);

	//mdomain_vi_sub_sub_inten_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_INTEN_reg);
	////mdomain_vi_sub_sub_inten_reg.dmaerrinte = 1;
	//mdomain_vi_sub_sub_inten_reg.vsinte1 = 1;
	//mdomain_vi_sub_sub_inten_reg.video_in_last_wr_y_flag_ie = 1;
	//IoReg_Write32(MDOMAIN_VI_SUB_SUB_INTEN_reg, mdomain_vi_sub_sub_inten_reg.regValue);

	vi_dmactl_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_DMACTL_reg);
	vi_dmactl_reg.bstlen = 6; //2^6 * 64 bits = 64*64 bits
	vi_dmactl_reg.dmaen1 = 1;
	vi_dmactl_reg.seq_blk_sel = 1; //select block mode DMA
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_DMACTL_reg, vi_dmactl_reg.regValue);
	rtd_pr_vsc_notice("[Sub NN] %s\n",__FUNCTION__);
	IoReg_SetBits(MDOMAIN_CAP_Cap_In2_enable_reg, _BIT0);

}

void sub_set_NN_buffer_freeze(unsigned char enable)
{

	if(TRUE == enable){
	  mdomain_vi_sub_mdom_sub_vi_ads_start_y_RBUS mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg;
	  //mdomain_vi_sub_mdom_sub_vi_ads_start_c_RBUS mdomain_vi_sub_mdom_sub_vi_ads_start_c_reg;

	  unsigned int lastcapbufferaddr = 0;

	  mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_y_reg);

	  if(mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == gt_SubNN_Cap_Buffer[0].phyaddr)
		  lastcapbufferaddr = gt_SubNN_Cap_Buffer[2].phyaddr;
	  else if(mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == gt_SubNN_Cap_Buffer[1].phyaddr)
		  lastcapbufferaddr = gt_SubNN_Cap_Buffer[0].phyaddr;
	  else if(mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == gt_SubNN_Cap_Buffer[2].phyaddr)
		  lastcapbufferaddr = gt_SubNN_Cap_Buffer[1].phyaddr;

	  if(lastcapbufferaddr == sub_vi_FreezeRegAddr)
	  {
		 if(lastcapbufferaddr == gt_SubNN_Cap_Buffer[0].phyaddr){
				 lastcapbufferaddr = gt_SubNN_Cap_Buffer[2].phyaddr;
		 }else if (lastcapbufferaddr == gt_SubNN_Cap_Buffer[1].phyaddr){
				 lastcapbufferaddr = gt_SubNN_Cap_Buffer[0].phyaddr;
		 }else if (lastcapbufferaddr == gt_SubNN_Cap_Buffer[2].phyaddr){
				 lastcapbufferaddr = gt_SubNN_Cap_Buffer[1].phyaddr;
		 }
	 }

	 if(lastcapbufferaddr == gt_SubNN_Cap_Buffer[0].phyaddr){
			 sub_NN_freeze_buffer_idx = 0;
	 }else if (lastcapbufferaddr == gt_SubNN_Cap_Buffer[1].phyaddr){
			 sub_NN_freeze_buffer_idx = 1;
	 }else if (lastcapbufferaddr == gt_SubNN_Cap_Buffer[2].phyaddr){
			 sub_NN_freeze_buffer_idx = 2;
	 }
	sub_vi_FreezeRegAddr = lastcapbufferaddr;
	}
	else
		sub_vi_FreezeRegAddr = 0;
}

void sub_get_NN_buffer_addr(unsigned int *pYAddr, unsigned int *pCAddr)
{

	if(sub_vi_bFreezed == TRUE)
	{
		sub_set_NN_buffer_freeze(FALSE);
		sub_vi_bFreezed = FALSE;
		//rtd_pr_vsc_notice("[Sub NN] sub_vi_bFreezed=%d\n",sub_vi_bFreezed);
	}

	if(sub_vi_bFreezed == FALSE)
	{
		sub_set_NN_buffer_freeze(TRUE);
		sub_vi_bFreezed = TRUE;
		//rtd_pr_vsc_notice("[Sub NN] sub_vi_bFreezed+=%d\n",sub_vi_bFreezed);
	}

	if(sub_vi_bFreezed == TRUE)
	{
		*pYAddr = gt_SubNN_Cap_Buffer[sub_NN_freeze_buffer_idx].phyaddr;
		*pCAddr = (gt_SubNN_Cap_Buffer[sub_NN_freeze_buffer_idx].phyaddr + MAX_SUB_NN_WIDTH*MAX_SUB_NN_HEIGHT);
		sub_NN_dump_data_to_file(sub_NN_freeze_buffer_idx, SUB_NN_RAW_DATA_SIZE);
		rtd_pr_vsc_notice("[Sub NN] dump raw NN data\n");
	}
}
int sub_NN_dump_data_to_file(unsigned int bufferindex, unsigned int size)
{
	struct file* filp = NULL;
	unsigned long outfileOffset = 0;
	static unsigned int g_ulFileCount = 0;
	char y_path[30];
	sprintf(y_path, "/tmp/nn_dump_%d_%d.raw", g_ulFileCount,bufferindex);
	rtd_pr_vsc_notice("[Sub NN]path = %s\n", y_path);

	if (gt_SubNN_Cap_Buffer[bufferindex].cache != NULL) {
		//rtd_pr_vsc_emerg("\n\n\n\n *****************  dump_data_to_file start  ******%lx***************\n\n\n\n",(unsigned long)gt_SubNN_Cap_Buffer[bufferindex].cache);
		filp = file_open(y_path/*VT_FILE_PATH*/, O_RDWR | O_CREAT, 0);
		if (filp == NULL) {
			//rtd_pr_vsc_notice("file open fail\n");
			return FALSE;
		}
		file_write(filp, outfileOffset, (unsigned char*)gt_SubNN_Cap_Buffer[bufferindex].cache, size);
		file_sync(filp);
		file_close(filp);
		g_ulFileCount++;
		//rtd_pr_vsc_emerg("\n\n\n\n *****************  dump_data_to_file end  *********************\n\n\n\n");
		return TRUE;
	} else {
		//rtd_pr_vsc_emerg("\n\n\n\n *****************  dump_data_to_file NG for null buffer address  *********************\n\n\n\n");
		return FALSE;
	}
}

void sub_mdomain_vi_for_NN_cap_isr(void)
{
	//unsigned int wr_index = 0;
	mdomain_vi_sub_mdom_sub_vi_ads_start_y_RBUS mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg;
	mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_y_reg);

	if(mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == (UINT32)gt_SubNN_Cap_Buffer[0].phyaddr){
	   mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = (UINT32)gt_SubNN_Cap_Buffer[1].phyaddr;
	  // wr_index = 1;
	}else if (mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == (UINT32)gt_SubNN_Cap_Buffer[1].phyaddr){
	   mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = (UINT32)gt_SubNN_Cap_Buffer[2].phyaddr;
	  // wr_index = 2;
	}else if (mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == (UINT32)gt_SubNN_Cap_Buffer[2].phyaddr){
	   mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = (UINT32)gt_SubNN_Cap_Buffer[0].phyaddr;
	  // wr_index = 0;
	}

	if(mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == sub_vi_FreezeRegAddr){
	   if(mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == (UINT32)gt_SubNN_Cap_Buffer[0].phyaddr){
		   mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = (UINT32)gt_SubNN_Cap_Buffer[1].phyaddr;
		  // wr_index = 1;
	   }else if (mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == (UINT32)gt_SubNN_Cap_Buffer[1].phyaddr){
		   mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = (UINT32)gt_SubNN_Cap_Buffer[2].phyaddr;
		  // wr_index = 2;
	   }else if (mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue == (UINT32)gt_SubNN_Cap_Buffer[2].phyaddr){
		   mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue = (UINT32)gt_SubNN_Cap_Buffer[0].phyaddr;
		  // wr_index = 0;
	   }
	}
	//rtd_pr_vsc_debug("[Sub NN]wr_index=%d\n",wr_index);
	IoReg_Write32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_y_reg, mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue);
	IoReg_Write32(MDOMAIN_VI_SUB_mdom_sub_vi_ads_start_c_reg, mdomain_vi_sub_mdom_sub_vi_ads_start_y_reg.regValue + /*_ALIGN((VT_CAP_FRAME_WIDTH_2K1k*VT_CAP_FRAME_HEIGHT_2K1k),__4KPAGE)*/MAX_SUB_NN_WIDTH*MAX_SUB_NN_HEIGHT);
}

void sub_path_capture_nv12_for_nn_data_config(unsigned int capWid, unsigned int capLen)
{
	SIZE insize;
	SIZE capsize;
	if(capWid > MAX_SUB_NN_WIDTH || capLen > MAX_SUB_NN_HEIGHT)
	{
		rtd_pr_vsc_emerg( "[error]unspport NN capture size\n");
		return;
	}

	if(FALSE == sub_path_allocate_nv12_memory(MAX_SUB_NN_WIDTH, MAX_SUB_NN_HEIGHT,3))
	{
		rtd_pr_vsc_emerg( "[error]Sub NN allocate memory failed!\n");
		return;
	}

	insize.nWidth = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DI_WID);
	insize.nLength = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_LEN);
	capsize.nWidth = capWid;
	capsize.nLength = capLen;
	rtd_pr_vsc_notice("[Sub NN]insize(%d,%d),capsize(%d,%d)\n", insize.nWidth, insize.nLength, capsize.nWidth, capsize.nLength);
	//config sub vgip
	config_sub_vgip_for_NN_capture(4, 0); //src:vodma1, VGIP_MODE_ANALOG
	//config sub rgb2yuv
	//config_sub_rgb2yuv_for_NN_capture();
	//config sub uzd
	config_sub_uzd_for_NN_capture(&insize, &capsize);

	//config sub mdomain vi capture
	config_sub_mdomain_vi_for_NN_capture(capWid, capLen);

}

void exit_sub_path_NN_capture(void)
{
	sub_vgip_vgip_chn2_ctrl_RBUS vgip_chn2_ctrl_reg;
	mdomain_vi_sub_sub_dmactl_RBUS vi_dmactl_reg;//dmaen  //MDOM_VI_DMACTL_reg

	vi_dmactl_reg.regValue = IoReg_Read32(MDOMAIN_VI_SUB_SUB_DMACTL_reg);
	vi_dmactl_reg.dmaen1 = 0;
	IoReg_Write32(MDOMAIN_VI_SUB_SUB_DMACTL_reg, vi_dmactl_reg.regValue);

	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_ivrun = 0;
	vgip_chn2_ctrl_reg.ch2_in_clk_en= 0;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);
	mdelay(2);

	rtd_pr_vsc_notice("[Sub NN]disable sub vgip data clk.\n");

	IoReg_ClearBits(MDOMAIN_CAP_Cap_In2_enable_reg, _BIT0);

	sub_path_free_nv12_memory(SUB_NN_CAP_BUF_NUM);
	sub_vi_bFreezed = FALSE;
	sub_vi_FreezeRegAddr = 0;
	sub_NN_freeze_buffer_idx = 0;
}
#endif
/* end  sub NN function */

/* Start
20170524 pinyen create new game mode tsk
*/
#ifdef BRING_UP_K4L_TEST
static bool new_game_mode_tsk_flag = FALSE;//Record new_game_mode_tsk status. True: Task is running
static struct task_struct *p_new_game_mode_tsk = NULL;

unsigned char get_new_game_mode_vdec_memc_bypass_condition(void){

	if( is_DTV_flag_get() && (!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))){
		// non vdec source need exclusive vdec_direct, so add  !adaptive stream flag
		return TRUE;
	}
	else
		return FALSE;
}

//to check the condition which can enter game mode or not
unsigned char get_new_game_mode_condition_impl(void){
	 VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	 mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl_reg;
	 ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
	 ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	 main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
	if (((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) ||((srctype == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))
		/*Only support HDMI and Component and AV*/
		&& !(vbe_disp_get_adaptivestream_fs_mode() && (ddr_mainctrl_reg.main_source_sel == 0x3))/*Adaptive stream & Data frame sync case do not set game mode!!*/
		&& !Get_Factory_SelfDiagnosis_Mode()/*factory self diagnosis grab pixel from third buffer,so not support single buffer mode*/
		/*&& !Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)*//*Data frame sync do not set game mode*/
		&& (get_HDMI_HDR_mode() != HDR_DOLBY_HDMI)/*20170908, pinyen add dolby hdmi case should set iv2pv delay default value*/
		&& !((main_active_v_start_end_reg.mv_act_end - main_active_v_start_end_reg.mv_act_sta) < _DISP_LEN)
	){
		return TRUE;
	}
	else{
		return FALSE;
	}
}
unsigned char (*get_new_game_mode_condition)(void) = get_new_game_mode_condition_impl;

void new_game_mode_tsk_ctrl_imd_buffer(void)
{
    I3DDMA_TIMING_T *pI3ddma_tx_timing;

    //I3DDMA and M-domain game mode
    if(drv_memory_get_game_mode() == _ENABLE) {
        if(drvif_i3ddma_triplebuf_flag())
            drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE); //Input fast case use 3-buffer
        else {
            pI3ddma_tx_timing = (I3DDMA_TIMING_T*) drvif_I3DDMA_Get_Input_Info_Vaule(I3DDMA_INFO_INPUT_TIMING);

#ifdef CONFIG_MEMC_BYPASS
            if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))&& pI3ddma_tx_timing && (pI3ddma_tx_timing->v_freq < 490))
                drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE); //vo freerun 3-buffer
            else
                drv_I3ddmaVodma_SingleBuffer_GameMode(_ENABLE); //I3DDMA 1-buffer
#else
            drv_I3ddmaVodma_SingleBuffer_GameMode(_ENABLE); //I3DDMA 1-buffer
#endif
        }

        //change M-domain to 1-buffer after iv2dv delay done
    } else {
        //I3DDMA 3 buffer
        drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
        //change M-domain to 3-buffer
        drv_memory_GameMode_Switch_TripleBuffer();
    }

    //D-domain game mode
    if(drv_memory_get_game_mode() == _ENABLE) {
        drv_game_mode_timing_Dynamic(_ENABLE);
        //after timing fs lock, switch to 1-buffer
        if((vbe_disp_gamemode_use_fixlastline()==FALSE) &&
            !(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))) {
            //if use game fll, switches to single buffer at fll tsk done.
            if ((Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO)
                || (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_HDMI)
                ||(0==Get_PANEL_VFLIP_ENABLE())) {
                drv_memory_GameMode_Switch_SingleBuffer();
            }
        } else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
                && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())){
                //VRR Game mode change to single buffer directly
                if(!((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI)))
                    drv_memory_GameMode_Switch_SingleBuffer();
        }
        //rtd_pr_vsc_emerg("[crixus]Enter D-domain game mode!!!\n");
    } else {
        drv_game_mode_timing_Dynamic(_DISABLE);
        //rtd_pr_vsc_emerg("[crixus]Exit D-domain game mode!!!\n");
    }
}

void new_game_mode_tsk_ctrl_memc_bypass_status(void)
{
    if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE) && (Get_DISPLAY_REFRESH_RATE() < 120)){
        if(drv_memory_get_game_mode_dynamic_flag()==TRUE){
            if(fw_get_vsc_GameMode() == FALSE){
                rtd_pr_new_game_mode_notice("[GameMode] %d: MEMC_BYPASS 1\n", __LINE__);
                vbe_disp_game_mode_memc_bypass(1);
                fw_set_vsc_GameMode(1);
            }
        }else{
            if(fw_get_vsc_GameMode() == TRUE){
                rtd_pr_new_game_mode_notice("[GameMode] %d: MEMC_BYPASS 0\n", __LINE__);
                vbe_disp_game_mode_memc_bypass(0);
                fw_set_vsc_GameMode(0);
            }
        }
    }
}

static int new_game_mode_tsk(void *p)//This task run new_game_mode_tsk
{
    // int ret = 0;
    rtd_pr_new_game_mode_debug("new_game_mode_tsk()\n");

#ifndef UT_flag
    current->flags &= ~PF_NOFREEZE;
#endif

    while (1)
    {
        if(p_Get_Val_Tsk_Status(TSK_NAME_GAME_MODE) != _low_power_tsk_no_pending)
        {
            if(p_Get_Val_Tsk_Status(TSK_NAME_GAME_MODE) == _low_power_tsk_request_pending)
                 p_Set_Val_Tsk_Status(TSK_NAME_GAME_MODE, _low_power_tsk_pending_finish);
            msleep(10); //wait 100ms
            if (freezing(current))
            {
                try_to_freeze();
            }
            continue;
        }
        msleep(10);//need to switch

        if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE && (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE)){
            //if(0) //mark this condition, no need this flow
            //{
                //if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
                //{
                //    drv_memory_set_game_mode_dynamic(_DISABLE);
                //   game_mode_cmd_pre = Get_Val_game_mode_cmd_check();	//Update game_mode_cmd_pre to avoid fll task break.
                //   Set_Val_st_game_mode_cmd_pre(Get_Val_smooth_toggle_game_mode_check_cnt());
                //}
            //}

            if(Get_Val_smooth_toggle_game_mode_timeout_trigger_flag() == _ENABLE)
            {
                rtd_pr_vsc_debug("gamemode task break for scaler trigger smooth toggle\n");
                continue;
            }

            //game mode dynamic checking
            if(drv_memory_get_game_mode_dynamic() != drv_memory_get_game_mode_flag())
            {
                drv_memory_set_game_mode(drv_memory_get_game_mode_dynamic());

                if (get_new_game_mode_condition())
                {/*qiangzhou:only need run av hdmi ypp, DTV ATV Playback,CP no need run these*/
                    /*
                        New Game Mode Flow: Seprate the game mode setting with scaler flow.
                        Enter game mode:
                            change to timing frame sync => Iv2dv delay done => change to 1-buffer.

                        Exit game mode:
                            change to timing free run => change to 3-buffer => Iv2dv delay => change to timing FLL
                    */

                    rtd_pr_new_game_mode_emerg("[Started]New game mode flow!!\n");

                    down(&GameMode_Check_Semaphore);

                    //check smooth toggle already done
                    Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

                    //re-enter game mode flow, need to disable timeout tsk.
                    Set_Val_smooth_toggle_game_mode_timeout_trigger_flag(_DISABLE);
                    //smooth_toggle_game_mode_check_cnt = 0;

                                        //set the game mode dynamic flag.
                    down(&GameMode_SCALER_SYNC_Semaphore);
                    if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
                    {
                        DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
                    }
                    else
                    {
                        up(&GameMode_SCALER_SYNC_Semaphore);
                        up(&GameMode_Check_Semaphore);
                        continue;
                    }
                    up(&GameMode_SCALER_SYNC_Semaphore);

                    //mute on
                    set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, TRUE);
                    down(get_forcebg_semaphore());
                    scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
                    up(get_forcebg_semaphore());
                    //rtd_pr_new_game_mode_emerg("Mute on\n");
#if 1/*config for game mode*/
                    //timing free run
                    if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
                        drivf_scaler_reset_freerun();
                    //DI game mode
                    fw_scalerip_set_di_gamemode_setting(fw_scalerip_get_di_gamemode());
                    //game mode use line mode, other use frame mode for compression setting
                    if(drv_memory_get_game_mode() == _ENABLE || (Get_PANEL_VFLIP_ENABLE())){
                        dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);
                        //rtd_pr_vsc_emerg("[crixus]compression line mode\n");
                    }
                    else{
                        dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);
                        //rtd_pr_vsc_emerg("[crixus]compression frame mode\n");
                    }
                    //send RPC to video fw
                    //drvif_memory_compression_rpc();//no need send rpc to video fw, keep 3-buffer when smooth toggle.

                    zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//sync smooth toggle timing info

                    //change line or frame mode for PQC
                    if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
                        dvrif_memory_handler();

                    new_game_mode_tsk_ctrl_imd_buffer();
                    //MEMC game mode
                    new_game_mode_tsk_ctrl_memc_bypass_status();
                    //switch between line mode and frame mode need to wait frame delay done
                    //20171018 pinyen add to fix ML3RTANDN-418
                    if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
                        wait_game_mode_frame_delay_done();

#endif
                    //Disable the game mode dynamic flag.
                    DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;
                    up(&GameMode_Check_Semaphore);

                    rtd_pr_new_game_mode_emerg("[End]New game mode flow!!\n");
                }
                else{
                    rtd_pr_new_game_mode_emerg("[Started]New game mode flow - VDEC!!\n");

                    down(&GameMode_Check_Semaphore);

                    //reset timeout tsk.
                    Set_Val_smooth_toggle_game_mode_timeout_trigger_flag(_DISABLE);
                    //smooth_toggle_game_mode_check_cnt = 0;

                    //set the game mode dynamic flag.
                    down(&GameMode_SCALER_SYNC_Semaphore);
                    if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
                    {
                        DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
                    }
                    else
                    {
                        up(&GameMode_SCALER_SYNC_Semaphore);
                        up(&GameMode_Check_Semaphore);
                        rtd_pr_vsc_err("\r\n### func:%s line:%d break####\r\n",__FUNCTION__,__LINE__);
                        continue;
                    }
                    up(&GameMode_SCALER_SYNC_Semaphore);
#if 1
                    //mute on
                    set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, TRUE);
                    down(get_forcebg_semaphore());
                    scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
                    up(get_forcebg_semaphore());
#endif
                    Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
                    //MEMC bypass
                    zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//sync smooth toggle timing info
                    if(get_new_game_mode_vdec_memc_bypass_condition() == TRUE) {
                        new_game_mode_tsk_ctrl_memc_bypass_status();
                    }

                    //Disable the game mode dynamic flag.
                    DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;

                    up(&GameMode_Check_Semaphore);

                    rtd_pr_new_game_mode_emerg("[End]New game mode flow-VDEC!!\n");
                }
            }
        }

        if (freezing(current))
        {
            try_to_freeze();
        }

        if (kthread_should_stop())
            break;
    }

    rtd_pr_new_game_mode_debug("\r\n####new_game_mode_tsk: exit...####\n");
    //rtd_pr_vsc_emerg("\r\n####new_game_mode_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

#ifndef UT_flag
static void create_new_game_mode_tsk(void)
{
    int err;
	if (new_game_mode_tsk_flag == FALSE) {
		p_new_game_mode_tsk = kthread_create(new_game_mode_tsk, NULL, "new_game_mode_tsk");

	    if (p_new_game_mode_tsk) {
			wake_up_process(p_new_game_mode_tsk);
			new_game_mode_tsk_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_new_game_mode_tsk);
		rtd_pr_vsc_debug("Unable to start new_game_mode_tsk (err_id = %d)./n", err);
	    }
	}
}
#endif
/* End
20170524 pinyen create new game mode tsk
*/
#ifndef UT_flag
static void create_vsc_tsk(void)
{
	int err;
	if (vsc_tsk_running_flag == FALSE) {
		p_vsc_tsk = kthread_create(vsc_scaler_tsk, NULL, "vsc_tsk");

	    if (p_vsc_tsk) {
			wake_up_process(p_vsc_tsk);
			vsc_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_vsc_tsk);
	    	rtd_pr_vsc_debug("Unable to start create_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_vsc_tsk(void)
{
	int ret;
	if (vsc_tsk_running_flag) {
 		ret = kthread_stop(p_vsc_tsk);
 		if (!ret) {
 			p_vsc_tsk = NULL;
 			vsc_tsk_running_flag = FALSE;
			rtd_pr_vsc_debug("vsc_scaler_tsk thread stopped\n");
 		}
	}
}


void trigger_mute_on_by_isr(unsigned char display)
{//use spin lock for ISR
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock(&muteoff_main_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_main_ctrl_flag_Spinlock);
		wake_up(&FORCEBG_WAIT_QUEUE);
		//rtd_pr_vsc_notice("\r\n#### func:%s line:%d trigger mute off####\r\n",__FUNCTION__,__LINE__);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock(&muteoff_sub_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_sub_ctrl_flag_Spinlock);
		wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}


void trigger_mute_off_by_isr(unsigned char display, unsigned char no_delay)
{//use spin lock for ISR
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock(&muteoff_main_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_main_ctrl_flag_Spinlock);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
		//rtd_pr_vsc_notice("\r\n#### func:%s line:%d trigger mute off####\r\n",__FUNCTION__,__LINE__);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock(&muteoff_sub_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_sub_ctrl_flag_Spinlock);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}


#endif
void trigger_mute_off(unsigned char display, unsigned char no_delay)
{//trigger to call mute off flow at video_muteoff_tsk
	unsigned long flags = 0;//for spin_lock_irqsave
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}



unsigned char get_request_ForceBG_ctrl(unsigned char display)
{
	unsigned long flags = 0;//for spin_lock_irqsave
	unsigned char result = FALSE;
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		result = DbgSclrFlgTkr.Main_Request_ForceBG_ctrl;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		result = DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
	}
#endif
	return result;
}

#ifndef UT_flag
static bool forcebg_tsk_running_flag = FALSE;//Record forcebg_scaler_tsk status. True: Task is running
static struct task_struct *p_forcebg_tsk = NULL;

static int video_muteoff_tsk(void *p)
{//for disable forcebg
#define DEBUG_PRINT_CONTER 20
	unsigned long flags;//for spin_lock_irqsave
#if 0
	struct cpumask vsc_cpumask;
#endif
	char main_debug_counter = DEBUG_PRINT_CONTER;//when the value is 0. print error message
#ifdef CONFIG_DUAL_CHANNEL
    char sub_debug_counter = DEBUG_PRINT_CONTER;//when the value is 0. print error message
#endif
    rtd_pr_vsc_debug( "video_muteoff_tsk()\n");
#if 0
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
#endif
	current->flags &= ~PF_NOFREEZE;
	while (1)
	{
        if(p_Get_Val_Tsk_Status(TSK_NAME_MUTE_OFF) != _low_power_tsk_no_pending)
        {
            if(p_Get_Val_Tsk_Status(TSK_NAME_MUTE_OFF) == _low_power_tsk_request_pending)
                 p_Set_Val_Tsk_Status(TSK_NAME_MUTE_OFF, _low_power_tsk_pending_finish);
            msleep(10); //wait 100ms
            if (freezing(current))
            {
                try_to_freeze();
            }
            continue;
        }
#ifdef CONFIG_DUAL_CHANNEL
		wait_event_freezable_timeout(FORCEBG_WAIT_QUEUE, get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY) || get_request_ForceBG_ctrl(SLR_SUB_DISPLAY) || (p_Get_Val_Tsk_Status(TSK_NAME_MUTE_OFF) != _low_power_tsk_no_pending), 30);//Timeout is 300ms
#else
		wait_event_freezable_timeout(FORCEBG_WAIT_QUEUE, get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY) || (p_Get_Val_Tsk_Status(TSK_NAME_MUTE_OFF) != _low_power_tsk_no_pending), 30);//Timeout is 300ms
#endif

#ifdef CONFIG_DUAL_CHANNEL
		if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY) || get_request_ForceBG_ctrl(SLR_SUB_DISPLAY))
#else
		if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY))
#endif
		{
			if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY)) {
				spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
				DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = FALSE;
				spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
				{
					mute_control(SLR_MAIN_DISPLAY, TRUE);//mute on
				}
				else if(Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, TRUE) == FALSE)
				{
					mute_control(SLR_MAIN_DISPLAY, FALSE);
				}
			}
#ifdef CONFIG_DUAL_CHANNEL
			if(get_request_ForceBG_ctrl(SLR_SUB_DISPLAY)) {
				spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
				DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = FALSE;
				spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
				{
					mute_control(SLR_SUB_DISPLAY, TRUE);//mute on
				}
				else if(Check_ForceBG_Mask_Enable(SLR_SUB_DISPLAY, TRUE) == FALSE)
				{
					mute_control(SLR_SUB_DISPLAY, FALSE);
				}
			}

#endif
		}
		if(!DbgSclrFlgTkr.Main_Request_ForceBG_ctrl && !Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, FALSE))
		{
			if(!main_debug_counter)
			{
				main_debug_counter = DEBUG_PRINT_CONTER;
				check_abnormal_mute_on_condition(SLR_MAIN_DISPLAY);//check and print abnormal condition
			}
			else
				main_debug_counter --;
		}
		else
		{
			main_debug_counter = DEBUG_PRINT_CONTER;
		}
#ifdef CONFIG_DUAL_CHANNEL
		if(!DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl && !Check_ForceBG_Mask_Enable(SLR_SUB_DISPLAY, FALSE))
		{
			if(!sub_debug_counter)
			{
				sub_debug_counter = DEBUG_PRINT_CONTER;
				check_abnormal_mute_on_condition(SLR_SUB_DISPLAY);//check and print abnormal condition
			}
			else
				sub_debug_counter --;
		}
		else
		{
			sub_debug_counter = DEBUG_PRINT_CONTER;
		}
#endif
		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
	}

	rtd_pr_vsc_debug( "\r\n####video_muteoff_tsk: exit...####\n");
	do_exit(0);
	return 0;
}



static void create_forcebg_tsk(void)
{
	int err;
	if (forcebg_tsk_running_flag == FALSE) {
		p_forcebg_tsk = kthread_create(video_muteoff_tsk, NULL, "forcebg_tsk");

	    if (p_forcebg_tsk) {
			wake_up_process(p_forcebg_tsk);
			forcebg_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_forcebg_tsk);
	    	rtd_pr_vsc_debug("Unable to start video_muteoff_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_forcebg_tsk(void)
{
	int ret;
	if (forcebg_tsk_running_flag) {
 		ret = kthread_stop(p_forcebg_tsk);
 		if (!ret) {
 			p_forcebg_tsk = NULL;
 			forcebg_tsk_running_flag = FALSE;
			rtd_pr_vsc_debug("video_forcebg_tsk thread stopped\n");
 		}
	}
}

void isr_control_hdmi_avmute(unsigned char display)
{//hdmi av mute flow use
	unsigned char av_mute_status;
	if(Get_DisplayMode_Src(display) == VSC_INPUTSRC_HDMI)
	{
		av_mute_status = drvif_Hdmi_IsAvmute();
		if(av_mute_status)
		{
			if(!Get_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
			{
				set_display_forcebg_mask_by_isr(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, TRUE);
				trigger_mute_on_by_isr(display);
				//mute on
			}
		}
		else
		{
			if(Get_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
			{
				set_display_forcebg_mask_by_isr(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, FALSE);
				trigger_mute_off_by_isr(display, 1);//mute off
			}
		}
	}
}
#endif
#define FLL_UZUDTG_VSYNC_LINE_DELAY 63
#define FLL_UZUDTG_WAIT_LINE_RANGE 20
#define FLL_LOWER_DOUNDARY_PERCENT 22//lower boundary is total line * 2.2%
#define FLL_UPPER_DOUNDARY_PERCENT 44 //upper boundary is total line * 4.4%
#ifndef UT_flag
static bool fix_lastline_tsk_running_flag = FALSE;//Record fixlastline_scaler_tsk status. True: Task is running
static struct task_struct *p_fix_lastline_tsk = NULL;
static bool localDimmingDemoCtrl_tsk_running_flag = FALSE;
static struct task_struct *p_localDimmingDemoCtrl_tsk	= NULL;

extern void drvif_scaler_set_frc2fsync_vtotal_protect_on_without_den_shift(void);
extern void drvif_scaler_set_fixlastline_vtotal_speedup_protect_on(void);
extern void drvif_scaler_set_frc2fsync_vtotal_protect_off(void);
extern void drvif_scaler_set_frc2fsync_recovery_vtotal(unsigned int u32_vtotal);


unsigned char vsc_decide_fixlastline_speedup_enable(void)
{
	unsigned char b_enable = 1;

	if(drvif_scaler_get_display_mode() == DISPLAY_MODE_FRAME_SYNC){
		b_enable = 0;
	}
	//if(Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) != 1){
	//	b_enable = 0;
	//}
	return b_enable;
}
/*
typedef struct{
	int  x;
	int  y;
}ORBIT_PIXEL_SHIFT_STRUCT;
*/
extern ORBIT_PIXEL_SHIFT_STRUCT vbe_disp_calculate_orbit_position(unsigned int MaxPixelShift, unsigned int MaxLineShift, unsigned int index);

static int localDimmingDemoCtrl_tsk(void *p)
{

	KADP_VIDEO_RECT_T outputRegion;

	outputRegion.x = 0;
	outputRegion.y = 0;
	outputRegion.w = 768;
	outputRegion.h = 2160;

	current->flags &= ~PF_NOFREEZE;

	while(1){
            if(p_Get_Val_Tsk_Status(TSK_NAME_LOCAL_DIMMING) != _low_power_tsk_no_pending)
            {
                if(p_Get_Val_Tsk_Status(TSK_NAME_LOCAL_DIMMING) == _low_power_tsk_request_pending)
                     p_Set_Val_Tsk_Status(TSK_NAME_LOCAL_DIMMING, _low_power_tsk_pending_finish);
                msleep(10); //wait 100ms
                if (freezing(current))
                {
                    try_to_freeze();
                }
                continue;
            }
			latency_pattern_self_test_run();

			if(vbe_disp_orbit_get_vo_overscan()==1 && !main_arc_change_flag){
				//vbe_disp_orbit_set_vo_overscan(0);
				if(!(IoReg_Read32(0xb8022288)&_BIT26)){
					vbe_disp_orbit_vo_overscan();
				}
			}
			if(vbe_disp_orbit_get_frc_overscan()==1 && !main_arc_change_flag){
				vbe_disp_orbit_set_frc_overscan(0);
				vbe_disp_orbit_frc_overscan();
			}

			if(LocalDimmingDemoCtrlMode){
				rtk_hal_vsc_makeColoredVideo(1);

				do{
					outputRegion.x +=20;
					rtk_hal_vsc_SetOutputRegion(0, outputRegion, 0,0);
					if(outputRegion.x+outputRegion.w >= 3840){
						outputRegion.x=0;
					}
				}while(LocalDimmingDemoCtrlMode);

				rtk_hal_vsc_makeColoredVideo(0);
				outputRegion.x = 0;
				outputRegion.y = 0;
				outputRegion.w = 768;
				outputRegion.h = 2160;
			}

			if (freezing(current))
			{
				try_to_freeze();
			}
			if (kthread_should_stop()) {
				break;
			}
			msleep(10);

	}

	rtd_pr_vsc_debug( "\r\n####localDimmingDemoCtrl_tsk: exit...####\n");
	do_exit(0);
	return 0;

}
unsigned char b_adaptive_pst_lowdelay_mode = 0;
extern void drivf_scaler_reset_fraction_ratio(void);

void scaler_vsc_set_adaptive_pst_lowdelay_mode(UINT8 bOnOff)
{
	int ret = -1;
	unsigned int targetLowBound = 0;
	extern unsigned int drvif_scaler_voFrameRateControl_get_lowBound(DISP_MODE flag_3d);

	rtd_pr_vsc_notice("function=%s, bOnOff=%d \n", __FUNCTION__, bOnOff);

	if((Scaler_MEMC_GetMotionType() == VPQ_MEMC_TYPE_55_PULLDOWN) &&(fwif_color_get_cinema_mode_en() == 1)){ //tru-motion off + real cinema
		targetLowBound = DEFAULT_LOW_BOUND;
	}else{
		targetLowBound = 49000;
	}

	if((drvif_scaler_voFrameRateControl_get_lowBound(0)== targetLowBound) && (b_adaptive_pst_lowdelay_mode == bOnOff)){
		rtd_pr_vsc_notice("function=%s, no need update, return. \n", __FUNCTION__);
		return;
	}
	b_adaptive_pst_lowdelay_mode = bOnOff;

	drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));

#if 0	//[KTASKWBS-11949] This will cause Youtube 24Hz video garbage at playback start, mark it.
	if(bOnOff){
        down(&VBE_LowDelay_Semaphore);
		drivf_scaler_reset_fraction_ratio();
        up(&VBE_LowDelay_Semaphore);
	}
#endif
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_PST_RERUN_VO_FLAG, bOnOff, 1))){
		rtd_pr_vsc_err("ret=%d, SCALERIOC_PST_RERUN_VO_FLAG RPC fail !!!\n", ret);
	}
}
EXPORT_SYMBOL(scaler_vsc_set_adaptive_pst_lowdelay_mode);

UINT8 scaler_vsc_get_adaptive_pst_lowdelay_mode(void)
{
	return b_adaptive_pst_lowdelay_mode;
}
#endif
unsigned char b_force_pst_lowdelay_mode = 0;

void scaler_vsc_set_force_pst_lowdelay_mode(UINT8 bOnOff)
{
	rtd_pr_vsc_err("scaler_vsc_set_force_pst_lowdelay_mode = %d\n", bOnOff);
	b_force_pst_lowdelay_mode = bOnOff;
}

EXPORT_SYMBOL(scaler_vsc_set_force_pst_lowdelay_mode);

UINT8 scaler_vsc_get_force_pst_lowdelay_mode(void)
{
	return b_force_pst_lowdelay_mode;
}
#endif
#endif
#ifdef BRING_UP_K4L_TEST

#ifndef UT_flag
static UINT8 stVR360_block_mdomain_db_flag = 0;

void scaler_vsc_set_vr360_block_mdomain_doublebuffer(UINT8 bEnable)
{
	stVR360_block_mdomain_db_flag = bEnable;

}

UINT8 scaler_vsc_get_vr360_block_mdomain_doublebuffer(void)
{
	return stVR360_block_mdomain_db_flag;
}
#endif
#endif
#ifndef BUILD_QUICK_SHOW
#ifdef BRING_UP_K4L_TEST

#ifndef UT_flag
void scaler_vsc_vr360_enter_datafs_proc(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS ddr_mainsubctrl_reg;
	mdomain_cap_cap_reg_doublbuffer_RBUS cap_reg_doublbuffer_reg;
	vodma_vodma_clkgen_RBUS vodma_vodma_clkgen_reg;
	mdomain_cap_cap_pq_cmp_RBUS mdomain_cap_cap_pq_cmp_reg;
	mdomain_disp_dispm_main_pq_decmp_RBUS mdomain_disp_dispm_main_pq_decmp_reg;
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	mdomain_cap_main_sdnr_cxxto64_RBUS mdomain_cap_main_sdnr_cxxto64_reg;
	UINT32 count = 0x3ffffff;
	UINT8 record_422CAP_flag = 0;

	rtd_pr_vsc_notice("[%s] [line %d] \n", __FUNCTION__, __LINE__);

	record_422CAP_flag = Scaler_DispGetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP);

	scaler_vsc_set_vr360_block_mdomain_doublebuffer(TRUE);

	//timing free run
	drivf_scaler_reset_freerun();
	modestate_set_fll_running_flag(FALSE);
	Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, TRUE);

	Scaler_DispSetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP, FALSE);
    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
	IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg,_BIT14);  //close watch dog for data framesync flow
	vbe_disp_set_dtgM2uzu_lowdelay_mode(1);

	//enable full gating
	vodma_vodma_clkgen_reg.regValue = IoReg_Read32(VODMA_VODMA_CLKGEN_reg);
	vodma_vodma_clkgen_reg.en_fifo_full_gate = 1;
	IoReg_Write32(VODMA_VODMA_CLKGEN_reg, vodma_vodma_clkgen_reg.regValue);

	//enable m-domain double buffer
	cap_reg_doublbuffer_reg.regValue =IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_en=1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg, cap_reg_doublbuffer_reg.regValue);
	ddr_mainsubctrl_reg.regValue =IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	ddr_mainsubctrl_reg.disp1_double_enable=1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);


	fw_scalerdisplay_handler(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
	drvif_color_ultrazoom_config_scaling_up(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));
	dvrif_memory_setting_for_data_fs();
	drvif_memory_set_fs_display_fifo();
	dvrif_memory_comp_setting(FALSE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN), dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));

	//disable compression
	mdomain_cap_cap_pq_cmp_reg.regValue = IoReg_Read32(MDOMAIN_CAP_CAP_PQ_CMP_reg);
	mdomain_cap_cap_pq_cmp_reg.cmp_en = 0;
	IoReg_Write32(MDOMAIN_CAP_CAP_PQ_CMP_reg, mdomain_cap_cap_pq_cmp_reg.regValue);
	mdomain_disp_dispm_main_pq_decmp_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DISPM_MAIN_PQ_DECMP_reg);
	mdomain_disp_dispm_main_pq_decmp_reg.decmp_en = 0;
	IoReg_Write32(MDOMAIN_DISP_DISPM_MAIN_PQ_DECMP_reg, mdomain_disp_dispm_main_pq_decmp_reg.regValue);


	mdomain_disp_ddr_mainctrl_reg.regValue = 0;
	mdomain_disp_ddr_mainctrl_reg.main_source_sel = 3;
	mdomain_disp_ddr_mainctrl_reg.main_decompression_clk_en = 1;
	mdomain_disp_ddr_mainctrl_reg.main_in_format = 1;
	mdomain_disp_ddr_mainctrl_reg.main_bit_num = (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_10BIT)?1:0);
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, mdomain_disp_ddr_mainctrl_reg.regValue);
	mdomain_cap_main_sdnr_cxxto64_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Main_SDNR_cxxto64_reg);
	mdomain_cap_main_sdnr_cxxto64_reg.out_bit = Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT);
	mdomain_cap_main_sdnr_cxxto64_reg.sort_fmt = Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_422CAP) ? 0 : 1;
	IoReg_Write32(MDOMAIN_CAP_Main_SDNR_cxxto64_reg, mdomain_cap_main_sdnr_cxxto64_reg.regValue);
	IoReg_ClearBits(MDOMAIN_CAP_Cap_In1_enable_reg, MDOMAIN_CAP_Cap_In1_enable_in1_cap_enable_mask);
	IoReg_ClearBits(MDOMAIN_DISP_Disp_main_enable_reg,	MDOMAIN_DISP_Disp_main_enable_main_disp_en_mask);

	//M-domain DB_apply
	cap_reg_doublbuffer_reg.cap1_db_apply=1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg, cap_reg_doublbuffer_reg.regValue);
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);
	count = 0x3ffffff;
	while((ddr_mainsubctrl_reg.disp1_double_apply)&&--count){
		ddr_mainsubctrl_reg.regValue =IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	}

	// restore flags
	Scaler_DispSetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP, record_422CAP_flag);
	scaler_vsc_set_vr360_block_mdomain_doublebuffer(FALSE);
}

#define APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA 400

void scaler_vsc_vr360_enter_datafrc_proc(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS ddr_mainsubctrl_reg;
	mdomain_cap_cap_reg_doublbuffer_RBUS cap_reg_doublbuffer_reg;
	mdomain_cap_ddr_in1status_RBUS mdomain_cap_ddr_in1status_reg;
	mdomain_disp_ddr_mainprevstart_RBUS mdomain_ddr_mainprevstart_reg;
	mdomain_cap_ddr_in1ctrl_RBUS mdomain_cap_ddr_in1ctrl_reg;
//	mdomain_cap_cap_ddr_fifostatus_RBUS mdomain_cap_cap_ddr_fifostatus_reg;
	mdomain_disp_ddr_mainstatus_RBUS mdomain_disp_ddr_mainstatus_reg;
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	vgip_vgip_chn1_lc_RBUS vgip_vgip_chn1_lc_reg;
	UINT32 count = 0x3ffffff;

	rtd_pr_vsc_notice("[%s] [line %d] \n", __FUNCTION__, __LINE__);

	scaler_vsc_set_vr360_block_mdomain_doublebuffer(TRUE);

	Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);

	//enable m-cap double buffer
	cap_reg_doublbuffer_reg.regValue = IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_en = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);
	//enable m-disp double buffer
	ddr_mainsubctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	ddr_mainsubctrl_reg.disp1_double_enable = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg,ddr_mainsubctrl_reg.regValue);

	IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg,_BIT14);  //close watch dog for data framesync flow

	dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);

	dvrif_memory_handler();

	mdomain_ddr_mainprevstart_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainPreVStart_reg);
	mdomain_ddr_mainprevstart_reg.main_pre_rd_v_start = 17;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainPreVStart_reg, mdomain_ddr_mainprevstart_reg.regValue);

	mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	mdomain_disp_ddr_mainctrl_reg.main_double_en = 0;
	mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en = 0;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, mdomain_disp_ddr_mainctrl_reg.regValue);

	mdomain_cap_ddr_in1ctrl_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Ctrl_reg);
	mdomain_cap_ddr_in1ctrl_reg.in1_double_enable = 0;
	mdomain_cap_ddr_in1ctrl_reg.in1_v_flip_3buf_en = 0;
	IoReg_Write32(MDOMAIN_CAP_DDR_In1Ctrl_reg, mdomain_cap_ddr_in1ctrl_reg.regValue);

	IoReg_SetBits(MDOMAIN_CAP_Cap_In1_enable_reg, MDOMAIN_CAP_Cap_In1_enable_in1_cap_enable_mask);


	//apply m-cap double buffer
	cap_reg_doublbuffer_reg.cap1_db_apply = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);
	//apply m-disp double buffer
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);

	//wait above settings apply
	count = 0x3ffffff;
	while(count--){
		cap_reg_doublbuffer_reg.regValue = IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
		ddr_mainsubctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		if((cap_reg_doublbuffer_reg.cap1_db_apply == 0) && (ddr_mainsubctrl_reg.disp1_double_apply == 0))
			break;
	}

	// <<<====================	single buffer , compressio line mode //////////////////////////

	dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);

	count = 0x3ffffff;
	while(--count){
		vgip_vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
		if((vgip_vgip_chn1_lc_reg.ch1_line_cnt) < APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA)
			break;
	}

	dvrif_memory_handler();

	//switch to 3 buffers
	mdomain_cap_ddr_in1ctrl_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Ctrl_reg);
	mdomain_cap_ddr_in1ctrl_reg.in1_v_flip_3buf_en = 1;
	mdomain_cap_ddr_in1ctrl_reg.in1_double_enable = 1;
	IoReg_Write32(MDOMAIN_CAP_DDR_In1Ctrl_reg,mdomain_cap_ddr_in1ctrl_reg.regValue);

	cap_reg_doublbuffer_reg.regValue =IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_apply = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);

	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select, mdomain_disp_ddr_mainstatus_reg.main_block_select);

	count = 0x3ffffff;
	while((cap_reg_doublbuffer_reg.cap1_db_apply == 1) && (--count)){
		cap_reg_doublbuffer_reg.regValue = rtd_inl(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
//		if((count&0xfff)==0)
//			rtd_pr_vsc_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}
	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)--- apply cap 3 buf done (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));

	count = 0x3ffffff;
	while(--count){
		vgip_vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
		if((vgip_vgip_chn1_lc_reg.ch1_line_cnt) > APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA)
			break;
	}
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)--- check vgip protect (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));


	//change M-disp.
	mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	mdomain_disp_ddr_mainctrl_reg.main_double_en = 1;
	mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg,mdomain_disp_ddr_mainctrl_reg.regValue);
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg,ddr_mainsubctrl_reg.regValue);

	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);

	count = 0x3ffffff;
	while((ddr_mainsubctrl_reg.disp1_double_apply == 1) && (count--)){
		ddr_mainsubctrl_reg.regValue =rtd_inl(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
//		if((count&0xfff)==0)
//			rtd_pr_vsc_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}

//	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
//	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)---  Mdisp apply 3 buf done (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));

/*
	//check cap/disp block select is correct
	count = 0x3ffffff;
	mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
	mdomain_cap_cap_ddr_fifostatus_reg.in1_cap_last_wr_flag = 1;
	IoReg_Write32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg, mdomain_cap_cap_ddr_fifostatus_reg.regValue);

	mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
	while(!(mdomain_cap_cap_ddr_fifostatus_reg.in1_cap_last_wr_flag) && --count){
		mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
		if((count&0xfff)==0)
			rtd_pr_vsc_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}
	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)---  check write done frame 1 (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
																						count,
																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
*/
	scaler_vsc_set_vr360_block_mdomain_doublebuffer(FALSE);
}
#endif
#define NEW_FLL_SPEEDUP_BY_HW_MODE 1
#define NEW_FLL_PHASE_ERROR_THRESHOLD FLL_UZUDTG_WAIT_LINE_RANGE/2
#define NEW_FLL_24HZ_PHASE_ERROR_THRESHOLD  FLL_UZUDTG_WAIT_LINE_RANGE*5/2

#define NEW_FLL_I2D_DLY_ADD_LINE_MAX 10
#define NEW_FLL_I2D_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX 21
#define NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX 900
#define NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX 450
#define NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX 0
#define NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX 450
#define NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX 200
#define NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX 0

#define NEW_FLL_FHD_I2D_2_5_DLY_ADD_LINE_MAX 450
#define NEW_FLL_FHD_I2D_2_5_DLY_SUB_LINE_MAX 0
#define NEW_FLL_FHD_I2D_1_2_30HZ_DLY_ADD_LINE_MAX 225
#define NEW_FLL_FHD_I2D_1_2_30HZ_DLY_SUB_LINE_MAX 0
#define NEW_FLL_FHD_I2D_1_2_25HZ_DLY_ADD_LINE_MAX 0
#define NEW_FLL_FHD_I2D_1_2_25HZ_DLY_SUB_LINE_MAX 225
#define NEW_FLL_FHD_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX 100
#define NEW_FLL_FHD_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX 0


unsigned char fix_last_line_need_break_condition(void)
{//retunr TRUE: break    Return False: no break
	if(get_scaler_stop_flag(SLR_MAIN_DISPLAY) == TRUE)
	{
		rtd_pr_vsc_notice("### FLL break for scaler stop flag##\n");
		return TRUE;
	}
	else if(DbgSclrFlgTkr.smoothtoggle_start_flag == TRUE)
	{
		rtd_pr_vsc_notice("### FLL break for smt trigger##\n");
		return TRUE;
	}
	else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
	{
		rtd_pr_vsc_notice("### FLL break for search state#\n");
		return TRUE;
	}
	else if(Get_Val_smooth_toggle_game_mode_check_cnt() != Get_Val_st_game_mode_cmd_pre())
	{
		rtd_pr_vsc_notice("### FLL break for scaler_trigger smooth toggle in game mode# %d,%d\n",smooth_toggle_game_mode_check_cnt,st_game_mode_cmd_pre);
		return TRUE;
	}
	else if(Get_Val_vbe_disp_smooth_variable_setting_flag() == _ENABLE)
	{
		rtd_pr_vsc_notice("### FLL break for running disp_smooth_variable_setting#\n");
		return TRUE;
	}
	else if(Scaler_get_film_mode_change_type() == 1)
	{
		rtd_pr_vsc_notice("### FLL break for film mode change type#\n");
		return TRUE;
	}
	else if(Get_Val_game_mode_cmd_check() != game_mode_cmd_pre)
	{
		rtd_pr_vsc_notice("### FLL break for game mode cmd again# %d,%d\n",Get_Val_game_mode_cmd_check(),game_mode_cmd_pre);
		return TRUE;
	}
	else if((DbgSclrFlgTkr.game_mode_dynamic_flag) || (drv_memory_get_game_mode_dynamic() != drv_memory_get_game_mode_flag()))
	{
		rtd_pr_vsc_notice("### FLL break for waiting game mode ready#\n");
		return TRUE;
	}
	else if(modestate_decide_display_timing() != DISPLAY_MODE_NEW_FLL_MODE)
	{
		rtd_pr_vsc_notice("### FLL break for display timing mode isn't FLL#\n");
		return TRUE;
	}
	return FALSE;
}

unsigned char bEnableI2DTracking_in_realcinema = 0;

void scaler_set_I2D_tracking_in_realcinema(unsigned char bEnable)
{
	bEnableI2DTracking_in_realcinema = bEnable;
}

unsigned char scaler_get_I2D_tracking_in_realcinema(void)
{
	return bEnableI2DTracking_in_realcinema;
}

unsigned char bEnableI2DFreq_UpdateInISR = 0;

void scaler_set_I2D_pwm_frequency_update_in_isr(unsigned char bEnable)
{
	bEnableI2DFreq_UpdateInISR = bEnable;
}

unsigned char scaler_get_I2D_pwm_frequency_update_in_isr(void)
{
	return bEnableI2DFreq_UpdateInISR;
}

unsigned char bEnableVRRFreq_UpdateInISR = 0;

void scaler_set_VRR_pwm_frequency_update_in_isr(unsigned char bEnable)
{
	bEnableVRRFreq_UpdateInISR = bEnable;
}

unsigned char scaler_get_VRR_pwm_frequency_update_in_isr(void)
{
	return bEnableVRRFreq_UpdateInISR;
}

unsigned char bEnableI2DTracking_in_slow_mode = 0;

void scaler_set_I2D_tracking_in_slow_mode(unsigned char bEnable)
{
	bEnableI2DTracking_in_slow_mode = bEnable;
}

unsigned char scaler_get_I2D_tracking_in_slow_mode(void)
{
	return bEnableI2DTracking_in_slow_mode;
}

unsigned int scaler_get_I2D_tracking_phase_error_threadhold(void)
{
	if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 495)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<505)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 595)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<605)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 995)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<1005)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 1195)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<1205))
		)
	{
		return NEW_FLL_PHASE_ERROR_THRESHOLD;
	}
	else
		return NEW_FLL_24HZ_PHASE_ERROR_THRESHOLD;
}
#ifndef UT_flag
void scaler_pwm_frequency_update_by_dvs(void)
{
	unsigned int frameRates = 0;
	unsigned int dvs_xtal = 0;
	unsigned int vtotal = 0;

	dvs_xtal = PPOVERLAY_DVS_cnt_get_dvs_cnt(IoReg_Read32(PPOVERLAY_DVS_cnt_reg));
	frameRates = 2700000000UL / dvs_xtal;
	vtotal = Get_DISPLAY_CLOCK_TYPICAL() / ((Get_DISP_HORIZONTAL_TOTAL()/100)*frameRates);
#ifdef CONFIG_RTK_KDRV_PWM
	rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(vtotal-1)*100, 2, FALSE);
#endif
}

unsigned int scaler_get_I2D_tracking_vtotal_by_frameidx(unsigned char frameIdx)
{
	unsigned int vtotal = 0;

	if(!frameIdx)
		return 0;

	switch(frameIdx){
		case 1:
			vtotal = PPOVERLAY_I2D_MEAS_0_get_i2d_tune_res0(IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg));
			break;
		case 2:
			vtotal = PPOVERLAY_I2D_MEAS_0_get_i2d_tune_res1(IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg));
			break;
		case 3:
			vtotal = PPOVERLAY_I2D_MEAS_1_get_i2d_tune_res2(IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg));
			break;
		case 4:
			vtotal = PPOVERLAY_I2D_MEAS_1_get_i2d_tune_res3(IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg));
			break;
		case 5:
			vtotal = PPOVERLAY_I2D_MEAS_2_get_i2d_tune_res4(IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg));
			break;
		case 6:
			vtotal = PPOVERLAY_I2D_MEAS_2_get_i2d_tune_res5(IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg));
			break;
		case 7:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res6(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
			break;
		case 8:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res7(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
			break;
		default:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res7(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
	}
	return vtotal;
}
#endif
unsigned char pre_I2D_frameIdx=0;

void scaler_set_I2D_previous_frameIdx(unsigned char frameIdx)
{
#if 0	//debug by gpio trigger
	{
		IoReg_SetBits(0xb8060238, _BIT23|_BIT22|_BIT21|_BIT20);
		IoReg_Write32(0xb8061104, _BIT30|_BIT0);//GPIO

		if(frameIdx){
			IoReg_Write32(0xb806110c, _BIT30|_BIT0);//high
		}else{
			IoReg_Write32(0xb806110c, _BIT30);//low
		}
	}
#endif
	pre_I2D_frameIdx = frameIdx;
	rtd_pr_vsc_notice("[I2D]scaler_set_I2D_previous_frameIdx =%d\n", frameIdx);
}

unsigned char scaler_get_I2D_previous_frameIdx(void)
{
	return pre_I2D_frameIdx;
}
#ifndef UT_flag
void scaler_I2D_pwm_frequency_update(void)
{
	if(PPOVERLAY_I2D_CTRL_0_get_i2d_special_dly_en(IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg))==1){
		unsigned char cur_FrameIdx = (PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)));

		if(cur_FrameIdx!=0){
			unsigned int vtotal = 0;
			scaler_set_I2D_previous_frameIdx(cur_FrameIdx);
			vtotal = scaler_get_I2D_tracking_vtotal_by_frameidx(cur_FrameIdx);
#ifdef CONFIG_RTK_KDRV_PWM
			rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),vtotal*100, 2, FALSE);
#endif
			rtd_pr_vsc_notice("[I2D][T]frameIdx=%d,vtotal=%x\n", PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)),vtotal);
		}else if(scaler_get_I2D_previous_frameIdx()!=0){
#ifdef CONFIG_RTK_KDRV_PWM
			unsigned int vtotal = PPOVERLAY_DV_total_get_dv_total(IoReg_Read32(PPOVERLAY_DV_total_reg));
			rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),vtotal*100, 2, FALSE);
#endif
			scaler_set_I2D_previous_frameIdx(0);
			rtd_pr_vsc_notice("[I2D][F]frameIdx=%d\n", PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)));
		}
	}
}
#endif
void scaler_set_I2D_dly_offset(void)
{
	ppoverlay_i2d_ctrl_1_RBUS ppoverlay_i2d_ctrl_1_reg;

	ppoverlay_i2d_ctrl_1_reg.regValue = 0;

    if(scaler_get_I2D_tracking_in_slow_mode() == 1)
    {

		if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 235) && 		//24hz
			(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 245)){
	        if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
				//24hz to 60hz
	            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
	            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
	        }
		}else{
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
        }
    }else{
		if((get_panel_res() == PANEL_RES_FHD)||(get_panel_res() == PANEL_RES_HD)||(Get_DISPLAY_REFRESH_RATE() > 120)){
			//2k panel
        if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 235) && 		//24hz
			(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 245)){
            if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
				if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
					//24hz to 60hz
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
				}else{
					//24hz to 120hz
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
				}
            }else{
				if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
					//24hz to 60hz
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX;
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX;
				}else{
					//24hz to 120hz
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX;
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX;
				}
            }
        }
		else if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 245) && 		//25hz
			(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 255)){
			if(Get_DISPLAY_REFRESH_RATE() > 120){
				//25hz to 125hz or 25hz to 150hz
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
			}
			else{
				//25hz to 50hz or 25hz to 100hz
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX;
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX;
			}
		}
		else if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 295) && 		//30hz
			(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 305))
		{
			if(Get_DISPLAY_REFRESH_RATE() > 144){
				//30hz to 150hz
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
			}
			else{
				//30hz to 60hz or 30hz to 120hz
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX;
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX;
			}
		}
        else{  //50/60hz case
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
        }
    }
		else if((get_panel_res() == PANEL_RES_UHD)||(get_panel_res() == PANEL_RES_8K)){
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 	 //24hz
						 (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245)){
						 if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
							 if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
								 //24hz to 60hz
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
							 }else{
								 //24hz to 120hz
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
							 }
						 }else{
							 if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
								 //24hz to 60hz
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX;
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX;
							 }else{
								 //24hz to 120hz
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX;
								 ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX;
							 }
						 }
					 }
					 else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 245) &&		 //25hz
						 (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 255)){
						 //25hz to 50hz or 25hz to 100hz
						 ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX;
						 ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX;
					 }
					 else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 295) &&		 //30hz
						 (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 305))
					 {
						 //30hz to 60hz or 30hz to 120hz
						 ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX;
						 ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX;
					 }
					 else{	//50/60hz case
						 ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
						 ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
					 }
				 }
			 }
	IoReg_Write32(PPOVERLAY_I2D_CTRL_1_reg, ppoverlay_i2d_ctrl_1_reg.regValue);
	rtd_pr_vsc_notice("scaler_set_I2D_dly_offset = %x \n", IoReg_Read32(PPOVERLAY_I2D_CTRL_1_reg));
}

unsigned char Get_Val_scaler_DumpCRC_Config_enable(void)
{
    return scaler_DumpCRC_Config.enable;
}

void Set_Val_scaler_DumpCRC_Config_enable(unsigned char enable)
{
    scaler_DumpCRC_Config.enable = enable;
}

static UINT8 checkStableCnt=0;
void Set_Val_checkStableCnt(UINT8 stableCnt)
{
	checkStableCnt = stableCnt;
}
UINT8 Get_Val_checkStableCnt(void)
{
	return checkStableCnt;
}

static int fixlast_line_tsk(void *p)
{
 //   struct cpumask vsc_cpumask;
	//static UINT8 checkStableCnt=0;
	unsigned int count2 = 0x3fffff;
	unsigned int ch1_line_cnt_lower = 0;
	unsigned int ch1_line_cnt_upper = 0;
	//ppoverlay_dtg_frame_cnt1_RBUS dtg_frame_cnt1_reg;
	//ppoverlay_new_meas0_linecnt_real_RBUS ppoverlay_new_meas0_linecnt_real_reg;
#ifndef NEW_FLL_SPEEDUP_BY_HW_MODE
	vgip_vgip_chn1_lc_RBUS vgip_chn1_lc_reg;
	UINT32 timeout=0;
	ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;
	ppoverlay_uzudtg_dv_total_RBUS uzudtg_dv_total_reg;
#endif
	unsigned int vtotal = 0;
#if 1 //#ifndef NEW_FLL_SW_MODE for verify RL6641-929 FLL SW Mode
	unsigned int uzudtg_line_lower = FLL_UZUDTG_VSYNC_LINE_DELAY;
	unsigned int uzudtg_line_upper = FLL_UZUDTG_VSYNC_LINE_DELAY + FLL_UZUDTG_WAIT_LINE_RANGE;
#endif
#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE
	ppoverlay_dv_total_RBUS dv_total_reg;
	ppoverlay_i2d_ctrl_0_RBUS ppoverlay_i2d_ctrl_0_reg;
	ppoverlay_i2d_ctrl_1_RBUS ppoverlay_i2d_ctrl_1_reg;
	ppoverlay_i2d_meas_phase_RBUS ppoverlay_i2d_meas_phase_reg;
	UINT32 lineDelay = 0;
#if 0 //#ifdef NEW_FLL_SW_MODE for verify RL6641-929 FLL SW Mode
	ppoverlay_fix_last_line_mode_lock_wde_RBUS fix_last_line_mode_lock_wde_reg;
	UINT32 targetcount = 0;
#endif
#endif
	ppoverlay_dtg_m_remove_input_vsync_RBUS dtg_m_remove_input_vsync_reg;
	ppoverlay_dtg_m_multiple_vsync_RBUS dtg_m_multiple_vsync_reg;
	unsigned char multiple_ratio=0, remove_ratio=0;
#ifndef CONFIG_HW_SUPPORT_MEMC
		unsigned short input_framerate = 0;
#endif

	rtd_pr_vsc_debug("fixlast_line_tsk()\n");
/*
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
*/
#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif

	while (1)
	{
        if(p_Get_Val_Tsk_Status(TSK_NAME_FIX_LAST_LINE) != _low_power_tsk_no_pending)
        {
            if(p_Get_Val_Tsk_Status(TSK_NAME_FIX_LAST_LINE) == _low_power_tsk_request_pending)
                 p_Set_Val_Tsk_Status(TSK_NAME_FIX_LAST_LINE, _low_power_tsk_pending_finish);
            msleep(10); //wait 100ms
            if (freezing(current))
            {
                try_to_freeze();
            }
            continue;
        }
#if 1
		if(IoReg_Read32(0xb8022288)&_BIT18){
			extern void gamemode_delaytime_print_msg(void);
			gamemode_delaytime_print_msg();
			drv_framesync_on_fixlastline_phaseErr_verify();
			msleep(20);
			IoReg_ClearBits(0xb8022288, _BIT18);
		}
		//for fixlastline phaseErr realtime debug
		//drv_framesync_on_fixlastline_phaseErr_verify();

//#ifdef UZU_60_24_MEMC_BYPASS_ENABLE
		if(IoReg_Read32(0xb8022288)&_BIT25) {
			#ifndef CONFIG_MEMC_BYPASS
			extern void drivf_scaler_set_memc_bypass(void);
			drivf_scaler_set_memc_bypass();
			#endif
			msleep(20);
			IoReg_ClearBits(0xb8022288, _BIT25);
		}
//#endif
		down(get_scaler_fll_running_semaphore());

		if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)&& (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE)){
#ifndef CONFIG_HW_SUPPORT_MEMC
			input_framerate = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
#endif
			//down(&GameMode_Check_Semaphore);
			//VRR flow
			//if(IoReg_Read32(0xb8022288) & _BIT9)
				//rtd_pr_vsc_notice("###[VRR] vbe_disp_get_VRR_timingMode_flag = %d, vbe_disp_get_VRR_ALLM_flag = %d###\n",vbe_disp_get_VRR_timingMode_flag(),vbe_disp_get_pre_VRR_ALLM_flag());
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && vbe_disp_get_VRR_timingMode_flag()){
				modestate_set_fll_running_flag(_DISABLE);
				if(!fix_last_line_need_break_condition()){
					if(vbe_disp_get_VRR_ALLM_flag() && drv_memory_get_mbuffer_setting()){
						//VRR low delay mode
						drv_memory_GameMode_Switch_SingleBuffer();
						rtd_pr_vsc_notice("###[VRR] enter VRR low delay mode, set to M-domain single buffer###\n");
					}
					dtg_m_multiple_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_multiple_vsync_reg);
					dtg_m_remove_input_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_Remove_input_vsync_reg);
					remove_ratio = dtg_m_remove_input_vsync_reg.remove_half_ivs_mode2 + 1;
					multiple_ratio = dtg_m_multiple_vsync_reg.dtg_m_multiple_vsync + 1;
					if(!((remove_ratio == 1) && (multiple_ratio == 1)))
						vbe_disp_set_VRR_fractional_framerate_mode();
					//Eric@20190103 VRR always go timing sync
	//				if(vbe_disp_check_support_VRR_framerate_range()==TRUE){
					if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						scaler_set_VRR_pwm_frequency_update_in_isr(TRUE);
						rtd_pr_vsc_notice("###[VRR] set VRR timing framesync###\n");
					}
				}
//				}
			}

			//Freesync flow
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && vbe_disp_get_freesync_mode_flag()){
				modestate_set_fll_running_flag(_DISABLE);
				if(drv_memory_get_mbuffer_setting()){
					dvrif_LowDelay_memory_handler(1);
					rtd_pr_vsc_notice("###[FreeSync/VRR] set to M-domain single buffer###\n");
				}
                dtg_m_multiple_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_multiple_vsync_reg);
                dtg_m_remove_input_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_Remove_input_vsync_reg);
				remove_ratio = dtg_m_remove_input_vsync_reg.remove_half_ivs_mode2 + 1;
				multiple_ratio = dtg_m_multiple_vsync_reg.dtg_m_multiple_vsync + 1;
				if(!((remove_ratio == 1) && (multiple_ratio == 1)))
					vbe_disp_set_VRR_fractional_framerate_mode();
				if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
					drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
					scaler_set_VRR_pwm_frequency_update_in_isr(TRUE);
					rtd_pr_vsc_notice("###[FreeSync/VRR] set VRR timing framesync###\n");
				}
			}

			if(modestate_get_fll_running_flag()){
				if(Get_Val_checkStableCnt()> 2){
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
					if (scaler_DumpCRC_Config.enable == 1) {
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						drivf_scaler_reset_freerun();
					}
#endif
					if((modestate_decide_display_timing() == DISPLAY_MODE_NEW_FLL_MODE) &&
						(drvif_scaler_get_display_mode() != DISPLAY_MODE_NEW_FLL_MODE)){

						framesync_fixlastline_set_precision_vtotal();

						//down(&VSC_Semaphore);
						Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
						vtotal = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN);
						ch1_line_cnt_lower = vtotal - (vtotal * FLL_LOWER_DOUNDARY_PERCENT / 1000);//lower boundary is total line * 2.2%
						ch1_line_cnt_upper = (vtotal * FLL_UPPER_DOUNDARY_PERCENT / 1000);//upper boundary is total line's 4.4%
						//rtd_pr_vsc_emerg("\n ch1_line_cnt_lower = %d, ch1_line_cnt_upper = %d\n", ch1_line_cnt_lower, ch1_line_cnt_upper);

						if((/*(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC)||*/(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_JPEG)) &&
							(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)== FALSE)){
							//change to FLL
							rtd_pr_vsc_notice("### set fll new mode 1.###\n");
							framesync_lastlinefinetune_at_new_mode();
							modestate_set_display_timing(0);
							modestate_set_fll_running_flag(FALSE);
							checkStableCnt=0;
						}
                        			else if((drv_memory_get_game_mode() == TRUE)&&(vbe_disp_gamemode_use_fixlastline()==TRUE) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) == Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO))){
							//check smooth toggle already done
							Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE
							//get game mode line delay
							lineDelay = drv_framesync_get_gamemode_iv2dv_linedelay();
							//AV Gamemode need increase iv2pv delay to avoid hw noise
							//if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)){
								//drv_AV_GameMode_reset_iv2pv_delay(lineDelay);
							//}

							//					 i2d_delay_lower |	 |i2d_delay_upper
							//		IVS 					 |---------------------------|
							//		DVS   |-----------------|-----------------|

							dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
							// FLL sync point parameters.
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 1; //continuous mode
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = (lineDelay-FLL_UZUDTG_WAIT_LINE_RANGE);
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = lineDelay;
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
                                                Scaler_wait_for_input_one_frame(SLR_MAIN_DISPLAY);//after adjusting i2d upper lower, need wait 1 frame to make phase error change
                                                // speed up direction and capability (about 2Hz variations)

							// 594M / (4400*58) = 2327, 2327-2250 ~= 80
							ppoverlay_i2d_ctrl_1_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_1_reg);
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
							if (scaler_DumpCRC_Config.enable == 1) {
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX;
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX;
							} else
#endif
							{
								//set I2D hw tracking offset
								scaler_set_I2D_dly_offset();
							}
							//control localdimming freq. offset
							IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1+NEW_FLL_I2D_DLY_ADD_LINE_MAX)/2)-1)<<19); // repeat local dimming vsync
							//control pwm freq. offset
							if(scaler_get_I2D_tracking_in_slow_mode() == 1){
#ifdef CONFIG_RTK_KDRV_PWM
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
							}else{
								if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 235) && 		//24hz
									(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 245))
								{
	                                if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
#ifdef CONFIG_RTK_KDRV_PWM
										rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
	                                    scaler_set_I2D_tracking_in_realcinema(FALSE);
	                                }else{
										scaler_set_I2D_previous_frameIdx(0);
									    scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
	                                }
								}else if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>245)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 255)) ||
			  							((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>295)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 305)))
								{
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
								}else{
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
								}
							}
							//enable FLL speed up by hw
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 1;
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							//wait i2d enable
							msleep(10);

							count2 = 300;
							while(count2){
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
          							rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								ppoverlay_i2d_meas_phase_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg);
								if(ppoverlay_i2d_meas_phase_reg.i2d_phase_err < scaler_get_I2D_tracking_phase_error_threadhold()){
									//check right phase and enable fixlastline
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//Disable I2D
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(FALSE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//change to 1-buffer after iv2dv done @Crixus 20170527
#if 1//ndef CONFIG_HW_SUPPORT_MEMC	//Eric@20180621 all framerate can support m domain single buffer without memc
									if(input_framerate >= 490)//50 60 framerate can support m domain single buffer without memc

#endif
									{//50 60 framerate can support m domain single buffer without memc
										down(&GameMode_Check_Semaphore);
										//avoid run smoothtoggle after scaler
										if(fix_last_line_need_break_condition()){
											modestate_set_fll_running_flag(FALSE);
											up(&GameMode_Check_Semaphore);
											break;
										}
										if ((Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) ||(0==Get_PANEL_VFLIP_ENABLE())) {
										drv_memory_GameMode_Switch_SingleBuffer();
											}
										up(&GameMode_Check_Semaphore);
									}
									checkStableCnt=0;
									rtd_pr_vsc_notice("### set fll new mode 3. (count=%d)(phase_err=%d)###\n", count2,ppoverlay_i2d_meas_phase_reg.i2d_phase_err);
									break;

								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _DISABLE){
									rtd_pr_vsc_notice("[FLL]game mode enable exit\n");
									//recovery
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								msleep(10);
								count2--;
							}

							if(count2==0){
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //continuous mode
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								rtd_pr_vsc_notice("func=%s, line=%d, timeout\n", __FUNCTION__, __LINE__);
								rtd_pr_vsc_notice("fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
									IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
							}

#else
							if(vsc_decide_fixlastline_speedup_enable() == TRUE){
								ppoverlay_dv_total_RBUS dv_total_reg;
								fwif_color_safe_od_enable(0);
								dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
								drvif_scaler_set_frc2fsync_recovery_vtotal(dv_total_reg.dv_total+1);
								rtd_pr_vsc_notice("fll set recovery vtotal = %x", dv_total_reg.dv_total+1);
								drvif_scaler_set_fixlastline_vtotal_speedup_protect_on();
								rtd_pr_vsc_notice("func=%s, line=%d\n", __FUNCTION__, __LINE__);
							}

							count2 = 0xa0000;

							while(count2){
								if(drv_framesync_check_iv2dv_phaseErr_on_fixlastline()==TRUE){
									//check right phase and enable fixlastline
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//wait speed up vtotal done
									timeout = 0x3fffff;
									new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
									while((new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt!=uzudtg_dv_total_reg.uzudtg_dv_total)&&(timeout--)){
										new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
									}
									if(timeout==0){
										rtd_pr_vsc_emerg("[drv_framesync_check_iv2dv_phaseErr_on_fixlastline] wait timeout. \n");
									}
									//recovory origin vtotal done
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									//change to 1-buffer after iv2dv done @Crixus 20170527
#ifndef CONFIG_HW_SUPPORT_MEMC
									if(input_framerate >= 490)//50 60 framerate can support m domain single buffer without memc

#endif
									{//50 60 framerate can support m domain single buffer without memc
									if ((Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) ||(0==Get_PANEL_VFLIP_ENABLE())) {
											down(&GameMode_Check_Semaphore);
										drv_memory_GameMode_Switch_SingleBuffer();
											up(&GameMode_Check_Semaphore);
									}
										}
									checkStableCnt=0;
									rtd_pr_vsc_notice("### set fll new mode 3.###\n");
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _DISABLE){
									rtd_pr_vsc_emerg( "[FLL]game mode Exit\n");
									//recovery
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}


								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}
								count2--;
							}
							if(count2 == 0){
								rtd_pr_vsc_notice("count timeout !!!\n");
								//rtd_pr_vsc_emerg("count timeout !!!\n");
								if(vsc_decide_fixlastline_speedup_enable() == TRUE){
									drvif_scaler_set_frc2fsync_vtotal_protect_off();
									fwif_color_safe_od_enable(1);
								}
							}
#endif

                        }else
						{
#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE

							//			  i2d_delay_lower | |i2d_delay_upper
							//		IVS 					|---------------------------|
							//		DVS   |-----------------|-----------------|

							dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
							// FLL sync point parameters.
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							//ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //one-time mode
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 1; //continuous mode
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = dv_total_reg.dv_total-uzudtg_line_upper;
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = dv_total_reg.dv_total-uzudtg_line_lower;
							//AV source normal mode 50Hz need fine tune i2d_dly
							//if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)){
								//if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 495) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 505)){
									//ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = dv_total_reg.dv_total-uzudtg_line_upper - 752;
									//ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = dv_total_reg.dv_total-uzudtg_line_lower - 752;
								//}
							//}
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
                                            Scaler_wait_for_input_one_frame(SLR_MAIN_DISPLAY);//after adjusting i2d upper lower, need wait 1 frame to make phase error change
                                            // speed up direction and capability (about 2Hz variations)

							// 594M / (4400*58) = 2327, 2327-2250 ~= 80

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
							if (scaler_DumpCRC_Config.enable == 1) {
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX;
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX;
							} else
#endif
							{
								//set I2D hw tracking offset
								scaler_set_I2D_dly_offset();
							}
							//control localdimming freq. offset
							IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1+NEW_FLL_I2D_DLY_ADD_LINE_MAX)/2)-1)<<19); // repeat local dimming vsync
							//control pwm freq. offset
							if(scaler_get_I2D_tracking_in_slow_mode() == 1){
#ifdef CONFIG_RTK_KDRV_PWM
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
							}else{
								if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 235) && 		//24hz
									(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 245))
								{
	                                if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
#ifdef CONFIG_RTK_KDRV_PWM
										rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
	                                    scaler_set_I2D_tracking_in_realcinema(FALSE);
	                                }else{
										scaler_set_I2D_previous_frameIdx(0);
									    scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
	                                }
								}else if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>245)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 255)) ||
			  							((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>295)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 305)))
								{
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
								}else{
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
								}
							}
							//enable FLL speed up by hw
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 1;
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							//wait i2d enable
							msleep(10);

							count2 = 300;
							while(count2){
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									break;
								}
								ppoverlay_i2d_meas_phase_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg);
								if(ppoverlay_i2d_meas_phase_reg.i2d_phase_err < scaler_get_I2D_tracking_phase_error_threadhold()){
									framesync_lastlinefinetune_at_new_mode();
									modestate_set_display_timing(0);
									//Disable I2D
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(FALSE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);

									checkStableCnt=0;
									//change to FLL
									rtd_pr_vsc_notice("### [HW] set fll new mode 1. (count=%d) ###\n", count2);
									//rtd_pr_vsc_emerg("\n new_meas1_linecnt_real_reg.uzudtg_line_cnt_rt = %x\n", IoReg_Read32(0xb8028258));
									//rtd_pr_vsc_emerg("\n vgip_chn1_lc_reg.ch1_line_cnt = %x\n", IoReg_Read32(0xb8022234));
									rtd_pr_vsc_notice("\n fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
										IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if((drv_memory_get_game_mode() == _ENABLE) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) == Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO))){
									rtd_pr_vsc_notice("[FLL]game mode enable break\n");
									//recovery
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									rtd_pr_vsc_notice("FUNC:%s, break due to scaler stop\n", __FUNCTION__);
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}
								msleep(10);
								count2--;
							}

							if(count2==0){
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //continuous mode
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								//control localdimming freq. offset
								IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
								//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
								rtd_pr_vsc_notice("func=%s, line=%d, timeout\n", __FUNCTION__, __LINE__);
								rtd_pr_vsc_notice("fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
									IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
							}

#else
							count2 = 0x3fffff;
							/*speedup*/
							if(vsc_decide_fixlastline_speedup_enable() == TRUE){
								ppoverlay_dv_total_RBUS dv_total_reg;
								fwif_color_safe_od_enable(0);
								dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
								drvif_scaler_set_frc2fsync_recovery_vtotal(dv_total_reg.dv_total+1);
								rtd_pr_vsc_notice("fll set recovery vtotal = %x", dv_total_reg.dv_total+1);
								drvif_scaler_set_fixlastline_vtotal_speedup_protect_on();
								rtd_pr_vsc_notice("func=%s, line=%d\n", __FUNCTION__, __LINE__);
							}
							while(count2){
								new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
								vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
								/*wait uzu dtg Vsync and wait the vgip line cnt*/
								if(((new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt >= uzudtg_line_lower) && (new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt < uzudtg_line_upper))
								&& ((vgip_chn1_lc_reg.ch1_line_cnt >= ch1_line_cnt_lower) || (vgip_chn1_lc_reg.ch1_line_cnt <= ch1_line_cnt_upper))){
									/*recover*/
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									framesync_lastlinefinetune_at_new_mode();
									modestate_set_display_timing(0);
									modestate_set_fll_running_flag(FALSE);
									checkStableCnt=0;
									//change to FLL
									rtd_pr_vsc_notice("### set fll new mode 1.###\n");

									//rtd_pr_vsc_emerg("\n new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt = %d\n", new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt);
									//rtd_pr_vsc_emerg("\n vgip_chn1_lc_reg.ch1_line_cnt = %d\n", vgip_chn1_lc_reg.ch1_line_cnt);
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if((drv_memory_get_game_mode() == _ENABLE) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) == Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO))){
									rtd_pr_vsc_notice("[FLL]game mode enable break\n");
									//recovery
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									rtd_pr_vsc_notice("FUNC:%s, break due to scaler stop\n", __FUNCTION__);
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}
								count2--;
							}
							//rtd_pr_vsc_emerg("count2 = %d\n", count2);

							if(count2 == 0){
								rtd_pr_vsc_notice("count timeout !!!\n");
								//rtd_pr_vsc_emerg("count timeout !!!\n");
								if(vsc_decide_fixlastline_speedup_enable() == TRUE){
									drvif_scaler_set_frc2fsync_vtotal_protect_off();
									fwif_color_safe_od_enable(1);
								}
							}
#endif
						}
						//up(&VSC_Semaphore);
					}
				}
				else{
					checkStableCnt++;
				}
			}else{
				//down(&VSC_Semaphore);
				if ((vbe_disp_get_adaptivestream_fs_mode() == 1) &&
					(Get_DISPLAY_PANEL_TYPE() != P_VBY1_TO_HDMI) &&
					(Get_DISPLAY_PANEL_TYPE() != P_VBY1_TO_LVDS_TO_HDMI)) {
					if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){

						rtd_pr_vsc_emerg("[fll]drvif_scaler_get_display_mode=%d\n", drvif_scaler_get_display_mode());
                        fwif_color_safe_od_enable(0);
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						fwif_color_safe_od_enable(1);
					}
				}
#if 0 //def ENABLE_IMD_PST_SMOOTHTOGGLE
				else if(1){
					if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
						rtd_pr_vsc_info("[%s][line:%d] PST smoothtoggle go fs\n", __FUNCTION__, __LINE__);
						fwif_color_safe_od_enable(0);
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						fwif_color_safe_od_enable(1);
					}
					modestate_set_fll_running_flag(_DISABLE);
				}
#endif
				if(Get_DISPLAY_PANEL_OLED_TYPE()==TRUE){
					if((drv_memory_get_game_mode_dynamic() == _ENABLE)&&(drv_memory_get_game_mode() == TRUE)){
						if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
							fwif_color_safe_od_enable(0);
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							fwif_color_safe_od_enable(1);
						}
					}
				}
				//up(&VSC_Semaphore);
				checkStableCnt = 0;
			}
			//up(&GameMode_Check_Semaphore);
		}else{
			checkStableCnt = 0;
		}
		up(get_scaler_fll_running_semaphore());
#endif

		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
		msleep(10);
	}

	rtd_pr_vsc_debug( "\r\n####fixlast_line_tsk: exit...####\n");
	do_exit(0);
	return 0;
}

void game_mode_set_ignore_cmd_check(unsigned char enable)
{
	game_mode_ignore_cmd_check = enable;
}
unsigned char Get_Val_game_mode_ignore_cmd_check(void)
{
	return game_mode_ignore_cmd_check;
}

#ifndef UT_flag
static void create_fixlast_line_tsk(void)
{
	int err;
	if (fix_lastline_tsk_running_flag == FALSE) {
		p_fix_lastline_tsk = kthread_create(fixlast_line_tsk, NULL, "fix_lastline_tsk");

	    if (p_fix_lastline_tsk) {
			wake_up_process(p_fix_lastline_tsk);
			fix_lastline_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_fix_lastline_tsk);
	    	rtd_pr_vsc_debug("Unable to start fixlast_line_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_fix_lastline_tsk(void)
{
	int ret;
	if (fix_lastline_tsk_running_flag) {
 		ret = kthread_stop(p_fix_lastline_tsk);
 		if (!ret) {
 			p_fix_lastline_tsk = NULL;
 			fix_lastline_tsk_running_flag = FALSE;
			rtd_pr_vsc_debug("fixlast_line_tsk thread stopped\n");
 		}
	}
}

static void create_localDimmingDemoCtrl_tsk(void)
{
	int err;
	if (localDimmingDemoCtrl_tsk_running_flag == FALSE) {
		p_localDimmingDemoCtrl_tsk = kthread_create(localDimmingDemoCtrl_tsk, NULL, "localDimmingDemoCtrl_tsk");

	    if (p_localDimmingDemoCtrl_tsk) {
			wake_up_process(p_localDimmingDemoCtrl_tsk);
			localDimmingDemoCtrl_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_localDimmingDemoCtrl_tsk);
	    	rtd_pr_vsc_debug("Unable to start localDimmingDemoCtrl_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_localDimmingDemoCtrl_tsk(void)
{
	int ret;
	if (localDimmingDemoCtrl_tsk_running_flag) {
 		ret = kthread_stop(p_localDimmingDemoCtrl_tsk);
 		if (!ret) {
 			p_localDimmingDemoCtrl_tsk = NULL;
 			localDimmingDemoCtrl_tsk_running_flag = FALSE;
			rtd_pr_vsc_debug("localDimmingDemoCtrl_tsk thread stopped\n");
 		}
	}
}
#endif

unsigned int Get_Val_smooth_toggle_game_mode_check_cnt(void)
{
    return smooth_toggle_game_mode_check_cnt;
}

void Set_Val_smooth_toggle_game_mode_check_cnt(unsigned int value)
{
    smooth_toggle_game_mode_check_cnt = value;
}

unsigned int Get_Val_st_game_mode_cmd_pre(void)
{
    return st_game_mode_cmd_pre;
}

void Set_Val_st_game_mode_cmd_pre(unsigned int value)
{
    st_game_mode_cmd_pre = value;
}

unsigned int Get_Val_game_mode_cmd_check(void)
{
    return game_mode_cmd_check;
}

void Set_Val_game_mode_cmd_check(unsigned int value)
{
    game_mode_cmd_check = value;
}

unsigned int gamemode_unmute_datafs_wait_golden_vsync_done(unsigned int timeout_count)
{
    ppoverlay_uzudtg_control1_RBUS uzudtg_control1_reg;
    ppoverlay_memcdtg_control3_RBUS memcdtg_control3_reg;
    ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
    
    memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
    if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) && drv_memory_get_game_mode_dynamic() && (memc_mux_ctrl_reg.memc_outmux_sel==0)){
        //rtd_pr_vsc_notice("[GAME MODE] HDMI wait game mode ready  %d\n",game_mode_wait_timeout);
        uzudtg_control1_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_control1_reg);
        memcdtg_control3_reg.regValue = IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg);
        while(timeout_count--){
            if((uzudtg_control1_reg.dtgm2uzuvs_line == 0) && (memcdtg_control3_reg.dtgm2goldenpostvs_line == 0)){
                break;
            }
            memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
            if (memc_mux_ctrl_reg.memc_outmux_sel!=0) {
                break;
            }
            uzudtg_control1_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_control1_reg);
            memcdtg_control3_reg.regValue = IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg);
            //wait 10ms
            msleep(10);
        }
        //rtd_pr_vsc_notice("[GAME MODE] HDMI wait game mode done  %d\n",game_mode_wait_timeout);
        if(timeout_count == 0)
            rtd_pr_vsc_notice("[GAME MODE] game mode wait golden vsync timeout = %d\n",timeout_count);
    }
    return timeout_count;
}

void game_mode_unmute_trigger_mute_off(void)
{
	/*K3LG-1445:sync crixus,willlin,qiangzhou,when gamemode re run scaler,open forcebg need check scaler status active*/
	if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
		trigger_mute_off(SLR_MAIN_DISPLAY, 1);
	}
}

unsigned char Get_game_mode_dynamic_flag_impl(void)
{
	return DbgSclrFlgTkr.game_mode_dynamic_flag;
}

unsigned char (*Get_game_mode_dynamic_flag)(void) = Get_game_mode_dynamic_flag_impl;

void game_mode_unmute_tsk_ctrl_disp_type(void){
	if((vbe_disp_gamemode_use_fixlastline()==TRUE) && !((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && vbe_disp_get_VRR_timingMode_flag())){
		down(&VSC_Semaphore);
		zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//sync smooth toggle timing info
		drv_game_mode_disp_smooth_variable_setting(GAME_MODE_NEW_FLL);
		up(&VSC_Semaphore);
	}else{
		//-> iv2dv delay -> frc2fsync  -> single buffer
		//update the iv2pv delay
		if(!Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)){
			drv_GameMode_iv2dv_delay(_ENABLE);
		}

		//change to timing sync
		down(&VSC_Semaphore);
		fwif_color_safe_od_enable(0);
		drv_game_mode_disp_smooth_variable_setting(GAME_MODE_FRAME_SYNC);
		fwif_color_safe_od_enable(1);
		up(&VSC_Semaphore);
	}
	//change to 1-buffer after iv2dv delay done
}

#define GAME_MODE_WAIT_GOLDEN_VSYNC_TIMEOUT     (40)    //400ms
static bool game_mode_unmute_tsk_running_flag = FALSE;
static struct task_struct *p_game_mode_unmute_tsk = NULL;
static int game_mode_unmute_tsk(void *p)
{
//	struct cpumask vsc_cpumask;
	static UINT8 checkStableCnt = 0;
	static UINT32 scaler_game_mode_cmd_pre = 0;

	static UINT8 CheckST_StableCnt = 0;
	static UINT32 ST_game_mode_cmd_pre = 0;
	unsigned int cmd_check_cnt = 0;
	unsigned int st_cmd_check_cnt = 0;
	rtd_pr_vsc_debug("game_mode_unmute_tsk()\n");
/*
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
*/
#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif
	while (1)
	{
        if(p_Get_Val_Tsk_Status(TSK_NAME_GAME_MODE_UNMUTE) != _low_power_tsk_no_pending)
        {
            if(p_Get_Val_Tsk_Status(TSK_NAME_GAME_MODE_UNMUTE) == _low_power_tsk_request_pending)
                 p_Set_Val_Tsk_Status(TSK_NAME_GAME_MODE_UNMUTE, _low_power_tsk_pending_finish);
            msleep(10); //wait 100ms
            if (freezing(current))
            {
                try_to_freeze();
            }
            continue;
        }
        
		cmd_check_cnt = Get_Val_game_mode_cmd_check();
		st_cmd_check_cnt = Get_Val_smooth_toggle_game_mode_check_cnt();
		//Game mode cmd checking flow @Cixus 20161204
		if ((Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode) == TRUE)
			&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			&& (drv_memory_get_game_mode_dynamic() == drv_memory_get_game_mode_flag())) {
			gamemode_unmute_datafs_wait_golden_vsync_done(GAME_MODE_WAIT_GOLDEN_VSYNC_TIMEOUT);
			down(&GameMode_Check_Semaphore);
			//after scaler flow, do not check cmd to reduce mute time
			if(Get_Val_game_mode_ignore_cmd_check() == _ENABLE){
				if(Get_game_mode_dynamic_flag() == FALSE){
					game_mode_set_ignore_cmd_check(_DISABLE);
					game_mode_cmd_pre = cmd_check_cnt;	//Update game_mode_cmd_pre to avoid fll task break.
					Set_Val_st_game_mode_cmd_pre(st_cmd_check_cnt);
					//smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
					game_mode_unmute_trigger_mute_off();
					rtd_pr_vsc_emerg("[crixus]after scaler do not check timeout, game mode unmute!!\n");
				}
			}
			else{
				if(scaler_game_mode_cmd_pre != cmd_check_cnt) {
					checkStableCnt = 0;
					scaler_game_mode_cmd_pre = cmd_check_cnt;
					rtd_pr_vsc_emerg("[crixus]game mode cmd again!! reset!! scaler_game_mode_cmd_pre = %d\n", scaler_game_mode_cmd_pre);
				}
				else {
					if(checkStableCnt++ >= 30) {
						if(Get_game_mode_dynamic_flag() == FALSE) {
							//game_mode_cmd_check = 0;	//Eric@20181113 No need to clear here, to avoid race condition
							game_mode_cmd_pre = cmd_check_cnt;	//Eric@20181113 No need to clear here, to avoid race condition
							checkStableCnt = 0;
							rtd_pr_vsc_emerg("[crixus]2. game mode cmd again!! reset!! game_mode_cmd_pre = %d\n", game_mode_cmd_pre);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
							game_mode_unmute_trigger_mute_off();
							rtd_pr_vsc_emerg("[crixus]game mode unmute!!\n");
						}
					}
				}
			}
			up(&GameMode_Check_Semaphore);
		}

		//check smooth toggle done
		if(Get_Val_smooth_toggle_game_mode_timeout_trigger_flag()){
			down(&GameMode_Check_Semaphore);
			//rtd_pr_vsc_emerg("[crixus]ST CheckST_StableCnt = %d\n", CheckST_StableCnt);
			//rtd_pr_vsc_emerg("[crixus]ST ST_game_mode_cmd_pre = %d\n", ST_game_mode_cmd_pre);
			//rtd_pr_vsc_emerg("[crixus]ST smooth_toggle_game_mode_check_cnt = %d\n", smooth_toggle_game_mode_check_cnt);
			if(CheckST_StableCnt++ < 100){
				if(ST_game_mode_cmd_pre != st_cmd_check_cnt){
					CheckST_StableCnt = 0;
					ST_game_mode_cmd_pre = st_cmd_check_cnt;
					rtd_pr_vsc_emerg("[crixus]ST game mode cmd again!! reset!! ST_game_mode_cmd_pre = %d\n", ST_game_mode_cmd_pre);
				}
			}
			else{
				//reture to game mode setting
				if(drv_memory_get_game_mode()){
					CheckST_StableCnt = 0;
					Set_Val_st_game_mode_cmd_pre(st_cmd_check_cnt);
					Set_Val_smooth_toggle_game_mode_timeout_trigger_flag(_DISABLE);
					game_mode_unmute_tsk_ctrl_disp_type();
					rtd_pr_vsc_emerg("[crixus]ST game mode resume done!!\n");
				}
			}
			up(&GameMode_Check_Semaphore);
		}
		else{
			if(Get_Val_st_game_mode_cmd_pre() != st_cmd_check_cnt){
				down(&GameMode_Check_Semaphore);
				Set_Val_st_game_mode_cmd_pre(st_cmd_check_cnt);
				up(&GameMode_Check_Semaphore);
			}
		}

		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
		msleep(10);
	}

	rtd_pr_vsc_debug( "\r\n####game_mode_unmute_tsk: exit...####\n");
	do_exit(0);
	return 0;
}
#ifndef UT_flag
static void create_game_mode_unmute_tsk(void)
{
	int err;
	if (game_mode_unmute_tsk_running_flag == FALSE) {
		p_game_mode_unmute_tsk = kthread_create(game_mode_unmute_tsk, NULL, "game_mode_unmute_tsk");

	    if (p_game_mode_unmute_tsk) {
			wake_up_process(p_game_mode_unmute_tsk);
			game_mode_unmute_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_game_mode_unmute_tsk);
	    	rtd_pr_vsc_debug("Unable to start game_mode_unmute_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_game_mode_unmute_tsk(void)
{
	int ret;
	if (game_mode_unmute_tsk_running_flag) {
 		ret = kthread_stop(p_game_mode_unmute_tsk);
 		if (!ret) {
 			p_game_mode_unmute_tsk = NULL;
 			game_mode_unmute_tsk_running_flag = FALSE;
			rtd_pr_vsc_debug("game_mode_unmute_tsk thread stopped\n");
 		}
	}
}


#ifdef BRING_UP_AUTO_FLOW/*This is only for bring up use demoap*/
#ifdef AUTO_BRINGUP_SOURCE
void vsc_source_bringup_force_connect(void)
{//force connect ADC source
	KADP_VSC_INPUT_SRC_INFO_T InputsourceInfo = {KADP_VSC_INPUTSRC_MAXN, 0 , 0};
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		return;
	}
#ifdef CONFIG_DUAL_CHANNEL
	if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		return;
	}
#endif

	switch(AUTO_BRINGUP_SOURCE)
	{
		case _SRC_YPBPR:
		case _SRC_VGA:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_ADC;
		break;

		case _SRC_TV:
		case _SRC_CVBS:
		case _SRC_SV:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_AVD;
		break;

		case _SRC_HDMI:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_HDMI;
		break;

		case _SRC_VO:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_VDEC;
		break;

		default:
			break;

	}

	rtk_hal_vsc_initialize();
	if(InputsourceInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		rtk_hal_vsc_open(VIDEO_WID_0);
		rtk_hal_vsc_Connect(VIDEO_WID_0, InputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
		rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
	}

#ifdef CONFIG_DUAL_CHANNEL
	switch(AUTO_BRINGUP_SOURCE_SUB)
	{
		case _SRC_YPBPR:
		case _SRC_VGA:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_ADC;
		break;

		case _SRC_TV:
		case _SRC_CVBS:
		case _SRC_SV:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_AVD;
		break;

		case _SRC_HDMI:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_HDMI;
		break;

		case _SRC_VO:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_VDEC;
		break;

		default:
			return;
	}
	rtk_hal_vsc_open(VIDEO_WID_1);
	rtk_hal_vsc_Connect(VIDEO_WID_1, InputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
#endif
}
#endif

unsigned char bringup_verify_timing_ready(unsigned char source)
{
	StructDisplayInfo *timing_info = NULL;
	switch(source)
	{
		case KADP_VSC_INPUTSRC_ADC:
			timing_info = Get_ADC_Dispinfo();
			if((timing_info->IPH_ACT_WID_PRE == 0) || (timing_info->IPV_ACT_LEN_PRE == 0) || (timing_info->IHFreq == 0) || (timing_info->IVFreq == 0))
				return FALSE;
			else
				return TRUE;

		break;

		case KADP_VSC_INPUTSRC_AVD:
			timing_info = Get_AVD_ScalerDispinfo();
			if((timing_info->IPH_ACT_WID_PRE == 0) || (timing_info->IPV_ACT_LEN_PRE == 0) || (timing_info->IHFreq == 0) || (timing_info->IVFreq == 0))
				return FALSE;
			else
				return TRUE;

		break;

		case KADP_VSC_INPUTSRC_HDMI:
			if((Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID) == 0) || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVHEIGHT) == 0)
				 || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHFREQ) == 0) || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVFREQ) == 0)
			)
				return FALSE;
			else
				return TRUE;
		break;

		default:
			return FALSE;
	}
}

static bool bring_up_vsc_running_flag = FALSE;
static struct task_struct *p_bring_up_vsc_tsk = NULL;

unsigned char rtk_bring_up_connect(void)
{/*This is for source check signal stable or not. Must be _MODE_STATE_ACTIVE*/
	VIDEO_RECT_T  inregion = {0, 0, 0, 0};
	KADP_VIDEO_RECT_T outregion = {0, 0, 0, 0};
	static int flag = 0;

	if(flag == 0)
	{
#ifdef CONFIG_DUAL_CHANNEL
		flag = 1;
#endif
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_MAXN)
		{
			return false;
		}
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC || DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_JPEG)
		{
			down(get_vo_infosemaphore());
			if(get_vo_change_flag(DisplayModeInputInfo.resourceIndex))
			{
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE,  _MODE_STATE_SEARCH);
			}
			else
			{
				up(get_vo_infosemaphore());
				return false;
			}
			up(get_vo_infosemaphore());
		}

		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_SEARCH)
		{
			//rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}

		switch(DisplayModeInputInfo.type)
		{
			case KADP_VSC_INPUTSRC_ADC:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_ADC)){
					rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_AVD:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_AVD)){
					rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_HDMI:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_HDMI))
					return false;
				break;

			default:

				break;

		}
		inregion.w = 3840;/*default*/
		inregion.h = 2160;/*default*/
		outregion.w = _DISP_WID;
		outregion.h = _DISP_LEN;
		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, inregion, inregion);
		//rtk_hal_vsc_SetInputRegion(KADP_VIDEO_WID_0, inregion);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, outregion, 0, 0);
		return rtk_hal_vsc_SetWinBlank(VIDEO_WID_0, 0, KADP_VIDEO_DDI_WIN_COLOR_BLACK);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		flag = 0;
		if(Sub_DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_MAXN)
		{
			//rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
			//rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}

		switch(Sub_DisplayModeInputInfo.type)
		{
			case KADP_VSC_INPUTSRC_ADC:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_ADC)){
					rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_AVD:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_AVD)){
					rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_HDMI:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_HDMI))
					return false;
				break;

			default:

				break;

		}

		inregion.w = 3840;/*default*/
		inregion.h = 2160;/*default*/
		outregion.w = _DISP_WID/2;
		outregion.h = _DISP_LEN/2;
		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, inregion, inregion);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, outregion, 0, 0);
		return rtk_hal_vsc_SetWinBlank(VIDEO_WID_1, 0, KADP_VIDEO_DDI_WIN_COLOR_BLACK);
	}
#else
	return TRUE;

#endif
}

static int bring_up_vsc_tsk(void *p)
{/* only for bring up test */
    rtd_pr_vsc_debug("bring_up_vsc_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
    	msleep(1000);

#ifdef AUTO_BRINGUP_SOURCE
		vsc_source_bringup_force_connect();
#endif

#ifdef CONFIG_DUAL_CHANNEL
		if ((DbgSclrFlgTkr.OuputDisplayMode == TRUE) || (DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)){
			//rtd_pr_vsc_emerg("#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			rtk_bring_up_connect();
		}
#else
		if (DbgSclrFlgTkr.OuputDisplayMode == TRUE)
			rtk_bring_up_connect();
#endif
		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
         	break;
      	}
    }

    rtd_pr_vsc_debug("\r\n####bring_up_vsc_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_bring_up_vsc_tsk(void)
{
	int err;
	if (bring_up_vsc_running_flag == FALSE) {
		p_bring_up_vsc_tsk = kthread_create(bring_up_vsc_tsk, NULL, "bring_up_vsc_tsk");

	    if (p_bring_up_vsc_tsk) {
			wake_up_process(p_bring_up_vsc_tsk);
			bring_up_vsc_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_bring_up_vsc_tsk);
	    	rtd_pr_vsc_debug("Unable to start bring_up_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_bring_up_vsc_tsk(void)
{
	int ret;
	if (bring_up_vsc_running_flag) {
 		ret = kthread_stop(p_bring_up_vsc_tsk);
 		if (!ret) {
 			p_bring_up_vsc_tsk = NULL;
 			bring_up_vsc_running_flag = FALSE;
			rtd_pr_vsc_debug("bring_up_vsc_tsk thread stopped\n");
 		}
	}
}
#endif// #ifdef BRING_UP_AUTO_FLOW/*This is only for bring up use demoap*/

#endif //UT_flag

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
#ifndef UT_flag
static bool arc_tsk_running_flag = FALSE;//for arc control tsk
static struct task_struct *p_arc_control_tsk = NULL;//for arc control tsk
#endif // UT_flag

static void update_arc_cmd_to_ring_buffer_sharemem(unsigned char display, KADP_VIDEO_RECT_T inregion, KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion)
{//update ara parameter to sharememory. for SCALERIOC_MAIN_INPUT_OUTPUT_BUFFER_INFO and SCALERIOC_SUB_INPUT_OUTPUT_BUFFER_INFO
	INPUT_OUTPUT_RINGBUFFER_INFO_T *p_ring_buffer_addr;
	unsigned short updateindex;
	unsigned char overflow_status = FALSE;

#ifdef WIN_DELAY_CALLBACK_PROFILE
	gCallback_profile.OutputRegion.x = outregion.x;
	gCallback_profile.OutputRegion.y = outregion.y;
	gCallback_profile.OutputRegion.w = outregion.w;
	gCallback_profile.OutputRegion.h = outregion.h;
	gCallback_profile._90k_cnt = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
	gCallback_profile.uzulcnt = PPOVERLAY_new_meas2_linecnt_real_get_uzudtg_dly_line_cnt_rt(IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg));
#endif

	if(display == SLR_MAIN_DISPLAY)
	{
		p_ring_buffer_addr = (INPUT_OUTPUT_RINGBUFFER_INFO_T *)Scaler_GetShareMemVirAddr(SCALERIOC_MAIN_INPUT_OUTPUT_BUFFER_INFO);
		if(((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE) == Scaler_ChangeUINT16Endian(p_ring_buffer_addr->read_idx))
		{//over flow case
			updateindex = Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx);
			overflow_status = TRUE;
		}
		else
			updateindex = ((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE);
		//update input region
		p_ring_buffer_addr->in_out_data[updateindex].input_x = Scaler_ChangeUINT16Endian(inregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].input_y = Scaler_ChangeUINT16Endian(inregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].input_w = Scaler_ChangeUINT16Endian(inregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].input_h = Scaler_ChangeUINT16Endian(inregion.h);

		//update output region
		p_ring_buffer_addr->in_out_data[updateindex].output_x = Scaler_ChangeUINT16Endian(outregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].output_y = Scaler_ChangeUINT16Endian(outregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].output_w = Scaler_ChangeUINT16Endian(outregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].output_h = Scaler_ChangeUINT16Endian(outregion.h);

		//update original input. input resolution
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_w = Scaler_ChangeUINT16Endian(originalInput.w);
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_h = Scaler_ChangeUINT16Endian(originalInput.h);

		p_ring_buffer_addr->write_idx = Scaler_ChangeUINT16Endian(updateindex);

		if(overflow_status)
			rtd_pr_vsc_err("\r\n#### update_arc_cmd_to_ring_buffer_sharemem over flow main path####\r\n");

	}
#ifdef CONFIG_DUAL_CHANNEL
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_SUPPORT_SUB
	else if(display == SLR_SUB_DISPLAY)
	{
		p_ring_buffer_addr = (INPUT_OUTPUT_RINGBUFFER_INFO_T *)Scaler_GetShareMemVirAddr(SCALERIOC_SUB_INPUT_OUTPUT_BUFFER_INFO);
		if(((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE) == Scaler_ChangeUINT16Endian(p_ring_buffer_addr->read_idx))
		{//over flow case
			updateindex = Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx);
			overflow_status = TRUE;
		}
		else
			updateindex = ((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE);
		//update input region
		p_ring_buffer_addr->in_out_data[updateindex].input_x = Scaler_ChangeUINT16Endian(inregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].input_y = Scaler_ChangeUINT16Endian(inregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].input_w = Scaler_ChangeUINT16Endian(inregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].input_h = Scaler_ChangeUINT16Endian(inregion.h);

		//update output region
		p_ring_buffer_addr->in_out_data[updateindex].output_x = Scaler_ChangeUINT16Endian(outregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].output_y = Scaler_ChangeUINT16Endian(outregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].output_w = Scaler_ChangeUINT16Endian(outregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].output_h = Scaler_ChangeUINT16Endian(outregion.h);

		//update original input. input resolution
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_w = Scaler_ChangeUINT16Endian(originalInput.w);
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_h = Scaler_ChangeUINT16Endian(originalInput.h);

		p_ring_buffer_addr->write_idx = Scaler_ChangeUINT16Endian(updateindex);

		if(overflow_status)
			rtd_pr_vsc_err("\r\n#### update_arc_cmd_to_ring_buffer_sharemem over flow sub path####\r\n");
	}
#endif
#endif
}

#ifndef UT_flag

static int arc_control_tsk(void *p)//control new input parameter
{/* for new input hal */
	KADP_VSC_ROTATE_T local_main_rotate_type_parm;//for new input output. /for main path
	VIDEO_RECT_T local_main_inregion_parm;//for new input output. main path ap parameter
	VIDEO_RECT_T local_main_originalInput_parm;//for new input output. main path ap input resolution parameter
	KADP_VIDEO_RECT_T local_main_outregion_parm;//for new input output. main path ap input resolution parameter
#ifdef CONFIG_DUAL_CHANNEL
	VIDEO_RECT_T local_sub_inregion_parm;//for new input output. sub path ap parameter
	VIDEO_RECT_T local_sub_originalInput_parm;//for new input output. sub path ap input resolution parameter
	KADP_VIDEO_RECT_T local_sub_outregion_parm;//for new input output. sub path ap input resolution parameter
#endif

    rtd_pr_vsc_debug("arc_control_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
#ifdef CONFIG_DUAL_CHANNEL
		wait_event_freezable(ARC_CONTROL_WAIT_QUEUE, main_arc_change_flag || sub_arc_change_flag);
#else
		wait_event_freezable(ARC_CONTROL_WAIT_QUEUE, main_arc_change_flag);
#endif
		if(main_arc_change_flag)
		{
			unsigned long flags;//for spin_lock_irqsave
			spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
			local_main_rotate_type_parm = ap_main_rotate_type_parm;//copy rotate type

			//copy input region
			local_main_inregion_parm.x = ap_main_inregion_parm.x;
			local_main_inregion_parm.y = ap_main_inregion_parm.y;
			local_main_inregion_parm.w = ap_main_inregion_parm.w;
			local_main_inregion_parm.h = ap_main_inregion_parm.h;

            //copy original input. input source resolution
			local_main_originalInput_parm.x = ap_main_originalInput_parm.x;
			local_main_originalInput_parm.y = ap_main_originalInput_parm.y;
			local_main_originalInput_parm.w = ap_main_originalInput_parm.w;
			local_main_originalInput_parm.h = ap_main_originalInput_parm.h;

			//copy output region
			local_main_outregion_parm.x = ap_main_outregion_parm.x;
			local_main_outregion_parm.y = ap_main_outregion_parm.y;
			local_main_outregion_parm.w = ap_main_outregion_parm.w;
			local_main_outregion_parm.h = ap_main_outregion_parm.h;
			main_arc_change_flag = FALSE;
			spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);


#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			//rotate part
			down(&SetMainOutPutRegion_Semaphore);
			main_rotate_mode_pre = Get_Val_ap_roate_mode();
			Set_Val_ap_rotate_mode((DIRECT_VO_FRAME_ORIENTATION)local_main_rotate_type_parm);
			up(&SetMainOutPutRegion_Semaphore);

			if(Get_Val_ap_roate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180
                            && (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == FALSE))
			{
				rtd_pr_vsc_emerg("1rotate 180, send vo vflip to vcpu\n");
				scaler_send_rotate_vflip_rpc(TRUE);
			}
			else
			{
				scaler_send_rotate_vflip_rpc(FALSE);
			}
#endif
			virtual_w = true_wide;//magnify and livezoom use
			virtual_h = true_high;//magnify and livezoom use
			if((vbe_disp_get_orbit_mode() ==_VBE_PANEL_ORBIT_AUTO_MODE || vbe_disp_get_orbit_mode() ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_get_orbit())
			{
                vbe_disp_orbit_set_vo_overscan_state
(1);
                rtd_pr_vsc_info("vbe_disp_orbit_set_vo_overscan_state enable\n");
			}
			rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, local_main_inregion_parm, local_main_originalInput_parm);
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, local_main_outregion_parm, virtual_w, virtual_h);
		}
#ifdef CONFIG_DUAL_CHANNEL
		if(sub_arc_change_flag)
		{
			unsigned long flags;//for spin_lock_irqsave
			spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
			//copy input region
			local_sub_inregion_parm.x = ap_sub_inregion_parm.x;
			local_sub_inregion_parm.y = ap_sub_inregion_parm.y;
			local_sub_inregion_parm.w = ap_sub_inregion_parm.w;
			local_sub_inregion_parm.h = ap_sub_inregion_parm.h;

            //copy original input. input source resolution
			local_sub_originalInput_parm.x = ap_sub_originalInput_parm.x;
			local_sub_originalInput_parm.y = ap_sub_originalInput_parm.y;
			local_sub_originalInput_parm.w = ap_sub_originalInput_parm.w;
			local_sub_originalInput_parm.h = ap_sub_originalInput_parm.h;

			//copy output region
			local_sub_outregion_parm.x = ap_sub_outregion_parm.x;
			local_sub_outregion_parm.y = ap_sub_outregion_parm.y;
			local_sub_outregion_parm.w = ap_sub_outregion_parm.w;
			local_sub_outregion_parm.h = ap_sub_outregion_parm.h;
			sub_arc_change_flag = FALSE;
			spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);

			virtual_w = true_wide;//magnify and livezoom use
			virtual_h = true_high;//magnify and livezoom use

			rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, local_sub_inregion_parm, local_sub_originalInput_parm);
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, local_sub_outregion_parm, virtual_w, virtual_h);
		}
#endif
		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
         	break;
      	}
    }

    rtd_pr_vsc_debug("\r\n####arc_control_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_arc_control_tsk(void)
{
	int err;
	if (arc_tsk_running_flag == FALSE) {
		p_arc_control_tsk = kthread_create(arc_control_tsk, NULL, "arc_control_tsk");

	    if (p_arc_control_tsk) {
			wake_up_process(p_arc_control_tsk);
			arc_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_arc_control_tsk);
	    	rtd_pr_vsc_err("Unable to start arc_control_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_arc_control_tsk(void)
{
	int ret;
	if (arc_tsk_running_flag) {
 		ret = kthread_stop(p_arc_control_tsk);
 		if (!ret) {
 			p_arc_control_tsk = NULL;
 			arc_tsk_running_flag = FALSE;
			rtd_pr_vsc_err("arc_control_tsk thread stopped\n");
 		}
	}
}
#endif //UT_flag

#endif// #ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task


/******************** debug task start****************************/
static unsigned char vsc_status_debug_tsk_flag = FALSE;
static struct task_struct *p_vsc_status_debug_tsk = NULL;

extern struct semaphore VPQ_DM_DMA_TBL_Semaphore;
static int vsc_status_debug_tsk(void *p)
{/* only for bring up test */
    unsigned int debug_print_count = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
    rtd_pr_vsc_debug("vsc_status_debug_tsk()\n");
#ifndef UT_flag
    current->flags &= ~PF_NOFREEZE;
#endif
    while (1)
    {
        wait_event_freezable_timeout(DEBUGTSK_WAIT_QUEUE, (p_Get_Val_Tsk_Status(TSK_NAME_VIDEO_DEBUG) != _low_power_tsk_no_pending), 20);//Timeout is 100ms
        if(p_Get_Val_Tsk_Status(TSK_NAME_VIDEO_DEBUG) != _low_power_tsk_no_pending)
        {
            if(p_Get_Val_Tsk_Status(TSK_NAME_VIDEO_DEBUG) == _low_power_tsk_request_pending)
            {
                check_bsp_error_event(Main_Mute_Time_Abnormal, TRUE);
                check_bsp_error_event(Sub_Mute_Time_Abnormal, TRUE);
                p_Set_Val_Tsk_Status(TSK_NAME_VIDEO_DEBUG, _low_power_tsk_pending_finish);//vsc_status_debug_tsk
            }
            msleep(10); //wait 100ms
            if (freezing(current))
            {
                try_to_freeze();
            }
            debug_print_count = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
            continue;
        }
        if(drvif_wait_timeout_check_by_counter(debug_print_count, 20000))//20 seconds
        {
            struct semaphore* p_force_bg_semaphore;
            struct semaphore* p_di_semaphore;
            struct semaphore* p_fll_semaphore;
            struct semaphore* p_vo_semaphore;
            p_force_bg_semaphore = get_forcebg_semaphore();
            p_di_semaphore = get_DI_semaphore();
            p_fll_semaphore = get_scaler_fll_running_semaphore();
            p_vo_semaphore = get_vo_infosemaphore();
            rtd_pr_vsc_info(" [debug]src:(%d %d) \n", Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY));
            rtd_pr_vsc_info(" [debug]Semaphore 1 status(%d %d %d %d) \n", VSC_Semaphore.count,  GameMode_SCALER_SYNC_Semaphore.count, DM_HDR_Semaphore.count, DATA_ACCESS_DEBUG_Semaphore.count);
            rtd_pr_vsc_info(" [debug]Semaphore 2 status(%d %d %d %d) \n", Force_Run_Idma_Semaphore.count, Low_Delay_Semaphore.count, Double_buffer_Semaphore.count, GameMode_Check_Semaphore.count);
            rtd_pr_vsc_info(" [debug]Semaphore 3 status(%d %d %d %d) \n", VBE_LowDelay_Semaphore.count, HDR_Setting_Semaphore.count, Orbit_algo_Semaphore.count, set_vsc_film_mode_semaphore.count);
            rtd_pr_vsc_info(" [debug]Semaphore 4 status(%d %d %d %d) \n", SetMainOutPutRegion_Semaphore.count, Main_ResetMode_Semaphore.count, new_input_output_main_sem.count, VPQ_DM_DMA_TBL_Semaphore.count);
            if(p_force_bg_semaphore && p_di_semaphore && p_fll_semaphore && p_vo_semaphore)
            {
                rtd_pr_vsc_info(" [debug]Semaphore 5 status(%d %d %d %d) \n", p_force_bg_semaphore->count, p_di_semaphore->count, p_fll_semaphore->count, p_vo_semaphore->count);
            }
            debug_print_count = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
        }

        check_bsp_error_event(Main_Mute_Time_Abnormal, (video_debug_tsk_pending != _low_power_tsk_no_pending) ? TRUE : FALSE);
        check_bsp_error_event(Sub_Mute_Time_Abnormal, (video_debug_tsk_pending != _low_power_tsk_no_pending) ? TRUE : FALSE);
        if (freezing(current))
        {
            try_to_freeze();
            debug_print_count = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
        }
        if (kthread_should_stop()) {
            break;
        }
    }

    rtd_pr_vsc_debug("\r\n####vsc_status_debug_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static int create_vsc_status_debug_tsk(void)
{
    int ret = 0;
    if (vsc_status_debug_tsk_flag == FALSE) {
        p_vsc_status_debug_tsk = kthread_create(vsc_status_debug_tsk, NULL, "vsc_status_debug_tsk");

        if (p_vsc_status_debug_tsk) {
            wake_up_process(p_vsc_status_debug_tsk);
            vsc_status_debug_tsk_flag = TRUE;
        } else {
            ret = -1;
            rtd_pr_vsc_debug("Unable to start vsc_status_debug_tsk. kthread_create fail./n");
        }
    }
    return ret;
}

static int delete_vsc_status_debug_tsk(void)
{
    int ret = 0;
    if (vsc_status_debug_tsk_flag) {
        if(p_vsc_status_debug_tsk){
            ret = kthread_stop(p_vsc_status_debug_tsk);
            if (!ret) {
                p_vsc_status_debug_tsk = NULL;
                vsc_status_debug_tsk_flag = FALSE;
                rtd_pr_vsc_debug("vsc_status_debug_tsk thread stopped\n");
            }
        }else{
            rtd_pr_vsc_debug("vsc_status_debug_tsk thread stopped already\n");
        }
    }
    return ret;
}
/******************** debug task end****************************/


#ifndef UT_flag
struct file_operations vsc_fops= {
	.owner =    THIS_MODULE,
	.open  =    vsc_open,
	.release =  vsc_release,
	.read  =    vsc_read,
	.write = 	vsc_write,
	.unlocked_ioctl =    vsc_ioctl,
#if defined(CONFIG_COMPAT) && defined(CONFIG_ARM64)
      .compat_ioctl = vsc_compat_ioctl,
#endif
	.poll  =    vsc_poll,
};

#ifdef CONFIG_DUMP_REGISTER
static bool dump_register_vsc_running_flag = FALSE;
static struct task_struct *p_dump_register_vsc_tsk = NULL;
extern void register_dump_test(void);
extern void register_dump_data_to_file(void);
static int dump_register_vsc_tsk(void *p)
{
    rtd_pr_vsc_debug("dump_register_vsc_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
		msleep(200);
	//rtd_pr_vsc_emerg("dump_register_vsc_tsk\n");
#ifdef CONFIG_DUMP_REGISTER
		register_dump_test();
		register_dump_data_to_file();
		//rtd_pr_vsc_emerg("test_vsc_tsk********\n");
		//rtd_pr_vsc_emerg("test_vsc_tsk********\n");
#endif

		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
			break;
		}
	}

    rtd_pr_vsc_debug("\r\n####dump_register_vsc_tsk: exit...####\n");
    do_exit(0);
    return 0;
}
static void create_dump_register_vsc_tsk(void)
{
	int err;
	if (dump_register_vsc_running_flag == FALSE) {
		p_dump_register_vsc_tsk = kthread_create(dump_register_vsc_tsk, NULL, "dump_register_vsc_tsk");

	    if (p_dump_register_vsc_tsk) {
			wake_up_process(p_dump_register_vsc_tsk);
			dump_register_vsc_running_flag = TRUE;
	    } else {
			err = PTR_ERR(p_dump_register_vsc_tsk);
			rtd_pr_vsc_debug("Unable to start dump_register_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}
static void delete_dump_register_vsc_tsk(void)
{
	int ret;
	if (dump_register_vsc_running_flag) {
		ret = kthread_stop(p_dump_register_vsc_tsk);
		if (!ret) {
			p_dump_register_vsc_tsk = NULL;
			dump_register_vsc_running_flag = FALSE;
			rtd_pr_vsc_debug("dump_register_vsc_tsk thread stopped\n");
		}
	}
}
#endif

int vsc_major   = VSC_MAJOR;
int vsc_minor   = 0 ;
int vsc_nr_devs = VSC_NR_DEVS;

module_param(vsc_major, int, S_IRUGO);
module_param(vsc_minor, int, S_IRUGO);
module_param(vsc_nr_devs, int, S_IRUGO);


static struct class *vsc_class = NULL;

#ifdef CONFIG_PM
static const struct dev_pm_ops vsc_pm_ops =
{
    .suspend    = vsc_suspend,
    .resume     = vsc_resume,
    .runtime_suspend = rtk_video_pm_rumtime_suspend,//runtime PM close case
    .runtime_resume = rtk_video_pm_rumtime_resume,//runtime PM open case
#ifdef CONFIG_HIBERNATION
    .freeze 	= vsc_suspend,
    .thaw		= vsc_resume_std,
    .poweroff	= vsc_suspend,
    .restore	= vsc_resume_std,
#endif

};
#endif

static struct platform_driver vsc_device_driver = {
    .driver = {
        .name       = VSC_DEVICE_NAME,
        .bus        = &platform_bus_type,
#ifdef CONFIG_PM
	.pm 		= &vsc_pm_ops,
#endif

    },
} ;

#if 0//removed
static char *vsc_devnode(struct device *dev, mode_t *mode)
{
	*mode = 0666;
	return NULL;
}
#endif
#ifdef CONFIG_RTK_KDRV_DC_MEMORY_TRASH_DETCTER
static void sb2_i3ddma_debug_info(void)
{
	dcmt_trap_info trap_info;
	//check trash module
	if(!isDcmtTrap("TVSB2_I3DDMA"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		rtd_pr_vsc_err("not TVSB2_I3DDMA module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_I3DDMA module trashed somewhere!\n");

	// i3ddma setting
	rtd_pr_vsc_err("i3ddma setting 0xb8025810=%x\n", IoReg_Read32(0xb8025810));
	// i3ddma status
	rtd_pr_vsc_err("Cap_Status 0xb8025838=%x\n", IoReg_Read32(0xb8025838));

	//Cap_BoundaryAddr & start address
	rtd_pr_vsc_err("Cap_BoundaryAddr1 0xb8025818=%x\n", IoReg_Read32(0xb8025818));
	rtd_pr_vsc_err("Cap_BoundaryAddr2 0xb802581c=%x\n", IoReg_Read32(0xb802581c));
	rtd_pr_vsc_err("Cap_L1_Start 0xb8025820=%x\n", IoReg_Read32(0xb8025820));
	rtd_pr_vsc_err("Cap_L2_Start 0xb8025824=%x\n", IoReg_Read32(0xb8025824));
	rtd_pr_vsc_err("Cap_R1_Start 0xb8025828=%x\n", IoReg_Read32(0xb8025828));
	rtd_pr_vsc_err("Cap_R2_Start 0xb802582c=%x\n", IoReg_Read32(0xb802582c));
	rtd_pr_vsc_err("Cap_L3_Start 0xb8025884=%x\n", IoReg_Read32(0xb8025884));
	rtd_pr_vsc_err("Cap_R3_Start 0xb8025888=%x\n", IoReg_Read32(0xb8025888));
	rtd_pr_vsc_err("Cap_L4_Start 0xb802588c=%x\n", IoReg_Read32(0xb802588c));
	rtd_pr_vsc_err("Cap_R4_Start 0xb8025890=%x\n", IoReg_Read32(0xb8025890));

	//md setting & start address
	rtd_pr_vsc_err("Cap_CTL2 0xb8025894=%x\n", IoReg_Read32(0xb8025894));
	rtd_pr_vsc_err("md_m1_Start 0xb8025898=%x\n", IoReg_Read32(0xb8025898));
	rtd_pr_vsc_err("md_m2_Start 0xb8025898=%x\n", IoReg_Read32(0xb802589c));
	rtd_pr_vsc_err("md_m3_Start 0xb8025898=%x\n", IoReg_Read32(0xb80258a0));
	rtd_pr_vsc_err("md_m4_Start 0xb8025898=%x\n", IoReg_Read32(0xb80258a4));

	return;
}

static void sb2_di_debug_info(void)
{
	dcmt_trap_info trap_info;
	unsigned int i = 0;
	//check trash module
	if(!isDcmtTrap("TVSB2_DIW"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		rtd_pr_vsc_err("not TVSB2_DIW module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_DIW module trashed somewhere!\n");
	rtd_pr_vsc_err("0xb8024000=%x\n", IoReg_Read32(0xb8024000));
	rtd_pr_vsc_err("0xb8024538=%x\n", IoReg_Read32(0xb8024538));

	for (i = 0xb8024400; i <=0xb8024440; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	return;
}

static void sb2_m_cap_debug_info(void)
{
	dcmt_trap_info trap_info;
	unsigned int i = 0;
	//check trash module
	if(!isDcmtTrap("TVSB2_M_CAP"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		rtd_pr_vsc_err("not TVSB2_M_CAP module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_M_CAP module trashed somewhere!\n");

	//m-cap address and control
	for (i = 0xb8027200; i <=0xb8027228; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}

	// Double buffer
	rtd_pr_vsc_err("Double buffer 0xb802726c=%x\n", IoReg_Read32(0xb802726c));

	// Boundary down limit
	rtd_pr_vsc_err("Boundary down limit 0xb8027278=%x\n", IoReg_Read32(0xb8027278));
	// Boundary up limit
	rtd_pr_vsc_err("Boundary up limit 0xb802727c=%x\n", IoReg_Read32(0xb802727c));

	// Boundary status
	rtd_pr_vsc_err("Boundary status 0xb8027280=%x\n", IoReg_Read32(0xb8027280));

	return;
}


static void sb2_vo1_y_debug_info(void)
{
	dcmt_trap_info trap_info;
	//check trash module
	if(!isDcmtTrap("TVSB2_VO1_Y"))
	{
		rtd_pr_vsc_err("not TVSB2_VO1_Y module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_VO1_Y module trashed somewhere!\n");

	rtd_pr_vsc_err("VODMA_V1_DCFG 0xb8005000=%x\n", IoReg_Read32(0xb8005000));
	rtd_pr_vsc_err("VODMA_REG_DB_CTRL 0xb8005054=%x\n", IoReg_Read32(0xb8005054));
	rtd_pr_vsc_err("VODMA_V1_DSIZE 0xb8005004=%x\n", IoReg_Read32(0xb8005004));
	rtd_pr_vsc_err("VODMA_V1_SEQ 0xb800500C=%x\n", IoReg_Read32(0xb800500C));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L1 0xb800501C=%x\n", IoReg_Read32(0xb800501C));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R1 0xb8005020=%x\n", IoReg_Read32(0xb8005020));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L2 0xb8005024=%x\n", IoReg_Read32(0xb8005024));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R2 0xb8005028=%x\n", IoReg_Read32(0xb8005028));
	rtd_pr_vsc_err("VODMA_V1_V_FLIP 0xb800502C=%x\n", IoReg_Read32(0xb800502C));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L3 0xb80051C0=%x\n", IoReg_Read32(0xb80051C0));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R3 0xb80051C4=%x\n", IoReg_Read32(0xb80051C4));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L4 0xb80051C8=%x\n", IoReg_Read32(0xb80051C8));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R4 0xb80051CC=%x\n", IoReg_Read32(0xb80051CC));
	rtd_pr_vsc_err("VODMA_TaBSbS_merge 0xb80050E0=%x\n", IoReg_Read32(0xb80050E0));
	rtd_pr_vsc_err("VODMA_TaBSbS_SEQ 0xb80050E4=%x\n", IoReg_Read32(0xb80050E4));
	rtd_pr_vsc_err("VODMA_3D_CS_1 0xb80050C4=%x\n", IoReg_Read32(0xb80050C4));
	rtd_pr_vsc_err("VODMA_3D_CS_2 0xb80050C8=%x\n", IoReg_Read32(0xb80050C8));
	rtd_pr_vsc_err("VODMA_dma_option 0xb80050DC=%x\n", IoReg_Read32(0xb80050DC));
	rtd_pr_vsc_err("DECOMP_CTRL0 0xb8005100=%x\n", IoReg_Read32(0xb8005100));
	rtd_pr_vsc_err("DECOMP_PIC_SET 0xb8005118=%x\n", IoReg_Read32(0xb8005118));
	rtd_pr_vsc_err("DECOMP_READ_Y 0xb800511C=%x\n", IoReg_Read32(0xb800511C));
	rtd_pr_vsc_err("DECOMP_READ_C 0xb8005120=%x\n", IoReg_Read32(0xb8005120));
	rtd_pr_vsc_err("DECOMP_X_WID_Y 0xb8005124=%x\n", IoReg_Read32(0xb8005124));
	rtd_pr_vsc_err("DECOMP_X_WID_C 0xb8005128=%x\n", IoReg_Read32(0xb8005128));
	rtd_pr_vsc_err("vodma_i2rnd 0xb8005200=%x\n", IoReg_Read32(0xb8005200));

	return;
}
#endif
/******************DCMT declare callback func******************/
DCMT_DEBUG_INFO_DECLARE(sb2_di_mdscpu, sb2_di_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_m_cap_mdscpu, sb2_m_cap_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info);
bool VSCModuleInitDone = 0;

bool Get_Val_VSCModuleInitDone(void)
{
	return VSCModuleInitDone;
}

int vsc_init_module(void)
{
	int result;
  	int devno;
	dev_t dev = 0;

#ifdef CONFIG_RTK_KDRV_DC_MEMORY_TRASH_DETCTER
	/******************DCMT register callback func in init flow******************/
	DCMT_DEBUG_INFO_REGISTER(sb2_di_mdscpu, sb2_di_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_di_mdscpu,sb2_di_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_m_cap_mdscpu, sb2_m_cap_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_m_cap_mdscpu, sb2_m_cap_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info)\n");
#endif

	rtd_pr_vsc_debug("\n\n\n\n *****************  vsc init module  *********************\n\n\n\n");
	if (vsc_major) {
		dev = MKDEV(vsc_major, vsc_minor);
		result = register_chrdev_region(dev, vsc_nr_devs, VSC_DEVICE_NAME);
	} else {
		result = alloc_chrdev_region(&dev, vsc_minor, vsc_nr_devs,VSC_DEVICE_NAME);
		vsc_major = MAJOR(dev);
	}
	if (result < 0) {
		rtd_pr_vsc_debug(KERN_WARNING "vsc: can't get major %d\n", vsc_major);
		return result;
	}

	rtd_pr_vsc_debug("vsc init module major number = %d\n", vsc_major);

	vsc_class = class_create(THIS_MODULE,VSC_DEVICE_NAME);

	if (IS_ERR(vsc_class))
	{
		rtd_pr_vsc_debug("scalevsc: can not create class...\n");
		result = PTR_ERR(vsc_class);
		goto fail_class_create;
	}

	// vsc_class->devnode = (void *)vsc_devnode;

	vsc_platform_devs = platform_device_register_simple(VSC_DEVICE_NAME, -1, NULL, 0);

	if((result = platform_driver_register(&vsc_device_driver)) != 0){
		rtd_pr_vsc_debug("scalevsc: can not register platform driver...\n");
		result = -ENOMEM;
		goto fail_platform_driver_register;
	}

    devno = MKDEV(vsc_major, vsc_minor);
    cdev_init(&vsc_cdev, &vsc_fops);
    vsc_cdev.owner = THIS_MODULE;
   	vsc_cdev.ops = &vsc_fops;
	result = cdev_add (&vsc_cdev, devno, 1);
	if (result<0)
	{
		rtd_pr_vsc_debug("scalevsc: can not add character device...\n");
		goto fail_cdev_init;
	}

    device_create(vsc_class, NULL, MKDEV(vsc_major, 0), NULL, VSC_DEVICE_NAME);
   	sema_init(&VSC_Semaphore, 1);
	sema_init(&SetMainOutPutRegion_Semaphore, 1);
	sema_init(&Main_ResetMode_Semaphore, 1);
	sema_init(&DM_HDR_Semaphore, 1);
	sema_init(&Force_Run_Idma_Semaphore, 1);
	sema_init(&Low_Delay_Semaphore, 1);
	sema_init(&Memc_Realcinema_Semaphore, 1);
	sema_init(&Iv2dv_Slow_Tuning_Semaphore, 1);
	sema_init(&VPQ_DeXC_MEM_Semaphore, 1);
	sema_init(&Double_buffer_Semaphore, 1);
	sema_init(&GameMode_Check_Semaphore, 1);
	sema_init(&muteoff_cb_sem, 1);
	sema_init(&GameMode_SCALER_SYNC_Semaphore, 1);//initial GameMode_SCALER_SYNC_Semaphore
	sema_init(&VIDEO_DELAY_Semaphore, 1);////For video delay protection
	//sema_init(&delay_info_cb_sem, 1);
	sema_init(&set_vsc_film_mode_semaphore, 1);
	sema_init(&DATA_ACCESS_DEBUG_Semaphore, 1);//initial DATA_ACCESS_DEBUG_Semaphore
	init_scaler_verifymode_semaphore();//initial scaler verify mode ctrl related semaphore
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	init_dolby_vision_dm_path_sem();
#endif

	sema_init(&HDR_Setting_Semaphore, 1);

#ifdef CONFIG_HDR_SDR_SEAMLESS
#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
	initial_i3ddma_reg_Semaphore();//init i3ddma_reg_Semaphore
#endif
#endif

#ifdef CONFIG_DUAL_CHANNEL
	sema_init(&SetSubOutPutRegion_Semaphore, 1);
	sema_init(&Sub_ResetMode_Semaphore, 1);
#endif
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
	sema_init(&Orbit_algo_Semaphore, 1);
#endif
	sema_init	(&I2RND_Semaphore, 1);
	sema_init(&vsc_src_verify_num_ctrl_sem, 1);//initial the Semaphore for vsc source verify
	sema_init	(&I2RND_display_Semaphore, 1);
	forcebg_semaphore_init();//Init force semaphore
	DI_semaphore_init();//Init force semaphore
	initial_sub_window_ctrl_semaphore();//initial sub window ctrl semaphore

    // for profiling
    RUTIL_TM_MODULE_INIT();
    RUTIL_TM_INIT_TOPIC("VSC Unmute", eRUtilTM_VSC_Unmute, 3, 300);

	DbgSclrFlgTkr.VSC_Device_Init_Done = TRUE;
	PcbSource_Init();
	drvif_memory_init();
	create_vsc_tsk();/*Create VSC task*/
	/*Panel_LVDS_To_Hdmi_Converter_Parameter();*/
#ifdef BRING_UP_AUTO_FLOW
	create_bring_up_vsc_tsk();/*Create bring up vsc tsk*/
#endif
	create_forcebg_tsk();//Create forcebg task
	create_fixlast_line_tsk(); //Create fix last line tsk
	create_localDimmingDemoCtrl_tsk();
	create_game_mode_unmute_tsk(); //Create game mode unmute tsk
#ifdef CONFIG_DUMP_REGISTER
	create_dump_register_vsc_tsk();
#endif
	create_scaler_verify_tsk();//creat scaler verify task
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
	create_arc_control_tsk();//create arc control tsk
#endif
    create_vsc_status_debug_tsk();//for debug using
	//create_film_mode_change_task();
	//create_hdmi_4k120_se_task();
	create_video_delay_task();

#if 1//FIXME @Crixus for K3L bringup
	IoReg_Write32(0xb8000118, _BIT24 | _BIT25 | _BIT0);
 	IoReg_Write32(0xb8000108, _BIT24 | _BIT25 | _BIT0);
#endif

#ifdef BRING_UP_K4L_TEST
       create_new_game_mode_tsk();//20170524 pinyen create new game mode tsk
#endif

	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
	// dump Scaler frame CRC info
	rtkscaler_dump_init();
#endif

sema_init(&new_input_output_main_sem, 1);//for main path new input out ap parameter semaphore
#ifdef CONFIG_DUAL_CHANNEL
sema_init(&new_input_output_sub_sem, 1);//for sub path new input out ap parameter semaphore
#endif
    sema_init(&vsc_initial_ctrl_semaphore, 1);//for call  rtk_hal_vsc_initialize use

    pm_runtime_forbid(&vsc_platform_devs->dev);
	pm_runtime_set_active(&vsc_platform_devs->dev);//runtime PM to set active
	pm_runtime_enable(&vsc_platform_devs->dev);//enable runtime PM
#ifdef CONFIG_RTK_LOW_POWER_MODE
	rtk_lpm_add_device(&vsc_platform_devs->dev);
#endif
	VSC_PM_LOG("info", "video", (&vsc_platform_devs->dev), "start", "ok", "realtek", "device init PM enable");
    vsc_runtime_pm_get();//defaul open
    VSCModuleInitDone = 1;

	return 0;	//success

fail_cdev_init:
	platform_driver_unregister(&vsc_device_driver);
fail_platform_driver_register:
	platform_device_unregister(vsc_platform_devs);
	vsc_platform_devs = NULL;
	class_destroy(vsc_class);
fail_class_create:
	vsc_class = NULL;
	unregister_chrdev_region(vsc_devno, 1);
	return result;
}



void __exit vsc_cleanup_module(void)
{
	dev_t devno = MKDEV(vsc_major, vsc_minor);
	rtd_pr_vsc_debug("rtice clean module vsc_major = %d\n", vsc_major);
	delete_vsc_tsk();/*Delete VSC task*/
	delete_forcebg_tsk();
	delete_fix_lastline_tsk();
	delete_localDimmingDemoCtrl_tsk();
	delete_game_mode_unmute_tsk();
	//delete_film_mode_change_task();
	//delete_hdmi_4k120_se_task();
	delete_video_delay_task();
    delete_vsc_status_debug_tsk();
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
	delete_arc_control_tsk();//delete arc control tsk
#endif

#ifdef BRING_UP_AUTO_FLOW
	delete_bring_up_vsc_tsk();/*Delete bring up vsc tsk*/
#endif
#ifdef CONFIG_DUMP_REGISTER
	delete_dump_register_vsc_tsk();
#endif
  	device_destroy(vsc_class, MKDEV(vsc_major, 0));
  	class_destroy(vsc_class);
	vsc_class = NULL;
	cdev_del(&vsc_cdev);
   	/* device driver removal */
	if(vsc_platform_devs) {
		platform_device_unregister(vsc_platform_devs);
		vsc_platform_devs = NULL;
	}
  	platform_driver_unregister(&vsc_device_driver);
	/* cleanup_module is never called if registering failed */
	unregister_chrdev_region(devno, vsc_nr_devs);
	DbgSclrFlgTkr.VSC_Device_Init_Done = FALSE;
	drvif_memory_release();
}
struct semaphore* get_vsc_semaphore(void)
{
	return &VSC_Semaphore;
}

unsigned char Get_AVD_display(unsigned char display)
{

	if (Get_DisplayMode_Src(display) == VSC_INPUTSRC_AVD)
		return TRUE;
	else
		return FALSE;
}


unsigned char VSC_Check_AVD_Connected(void)
{
	if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD
	  ||Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void fw_scalerip_set_di_gamemode_flag(unsigned char bflag)
{
	if(DbgSclrFlgTkr.DI_low_delay_flag != bflag) {

		down(&Low_Delay_Semaphore);
		DbgSclrFlgTkr.DI_low_delay_flag = bflag;
		up(&Low_Delay_Semaphore);

	}
}


unsigned char fw_scalerip_get_di_gamemode_flag(void)
{
	return DbgSclrFlgTkr.DI_low_delay_flag;
}
#endif

void fw_set_vsc_GameMode(unsigned char b_vscGameMode_OnOff)
{
	enable_VSC_GameMode = b_vscGameMode_OnOff;
}

unsigned char fw_get_vsc_GameMode(void)
{
	return enable_VSC_GameMode;
}

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO

unsigned int ORBIT_TIME = 180;//default 3min
static unsigned char orbit_shift_index=0;
static unsigned char start_orbit_algo=FALSE;

/*api which have protect by forcebg_semaphore*/
void Scaler_start_orbit_algo(unsigned char b_enable)
{

//	if((b_enable != start_orbit_algo)&&(b_enable)){
//		Scaler_reset_orbit();
//	}
	rtd_pr_vsc_debug("start_orbit_algo(%d)\n", b_enable);
	start_orbit_algo = b_enable;
}

unsigned char Scaler_get_orbit_algo_status(void)
{
	if(vbe_disp_get_orbit()== TRUE)
		return start_orbit_algo;
	else
		return FALSE;
}
/*api which have protect by forcebg_semaphore*/
void Scaler_reset_orbit(void)
{
	rtd_pr_vsc_debug("Scaler_reset_orbit\n");

	down(&Orbit_algo_Semaphore);
	orbit_shift_index = 0;
	vbe_disp_orbit_position_update(0xff); // force update

	if (!OrbitTimerList.function)
		Scaler_Orbit_Timer_Init();

	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
	up(&Orbit_algo_Semaphore);
}

#endif

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
void OrbitTimer(struct timer_list *t)
#else
void OrbitTimer(unsigned long data)
#endif
{
	rtd_pr_vsc_debug("OrbitTimer\n");

	//down(&Orbit_algo_Semaphore);
	if(Scaler_get_orbit_algo_status() == TRUE){
		if(orbit_shift_index < vbe_disp_orbit_get_max_table_index()){
			orbit_shift_index++;
		}else{
			orbit_shift_index=0;
		}
	}else{
		orbit_shift_index=0;
	}
	vbe_disp_orbit_position_update(orbit_shift_index);
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
	//up(&Orbit_algo_Semaphore);
	//OrbitTimerList.expires = jiffies + HZ;
	//add_timer(&OrbitTimerList);
}

void Scaler_Orbit_Timer_Init(void)
{
	rtd_pr_vsc_debug("Scaler_Orbit_Timer_Init\n");

	g_ucTimerInitCount++;

	if (timer_pending(&OrbitTimerList))
	{
		rtd_pr_vsc_emerg("Error! Scaler_Orbit_Timer_Init more than twice. g_ucTimerInitCount=%d\n", g_ucTimerInitCount);
		dump_stack();

		return;
	}

	BUG_ON(timer_pending(&OrbitTimerList));


#if 0
	/* timer init*/
	init_timer(&OrbitTimerList);
	OrbitTimerList.data = ((unsigned long) 0);
	OrbitTimerList.function = (void *)OrbitTimer;
	OrbitTimerList.expires = jiffies + ORBIT_TIME*HZ;
	/*add timer*/
	add_timer(&OrbitTimerList);
#else
	/** If only 1 instance is allowed, using mod_timer().
	 * Otherwise, add_timer() will trap the occurance of racing,
	 * with built-in timer_pending() check.
	 **/
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
#endif
}
#endif

#ifndef UT_flag
void Scaler_Orbit_Timer_Delete(void)
{
	rtd_pr_vsc_debug("Scaler_Orbit_Timer_Delete\n");
	/* delete timer */
	del_timer_sync(&OrbitTimerList);
}

//this is for verify mode used
static KADP_VSC_INPUT_SRC_INFO_T RecordModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};//record ap connect source for verify mode used
static unsigned char RecordVscInitdone_Flag = FALSE;
void verify_source_force_connect(void)
{//force connect ADC source
	KADP_VSC_INPUT_SRC_INFO_T verifyInputsourceInfo = {KADP_VSC_INPUTSRC_ADC, 0 , 0};
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		RecordModeInputInfo = DisplayModeInputInfo;
		rtk_hal_vsc_Disconnect(VIDEO_WID_0, DisplayModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
		rtk_hal_vsc_close(VIDEO_WID_0);
	}
	if(VscInitdone_Flag == FALSE)
	{
		RecordVscInitdone_Flag = FALSE;
		rtk_hal_vsc_initialize();
	}
	else
		RecordVscInitdone_Flag = TRUE;
	rtk_hal_vsc_open(VIDEO_WID_0);
	rtk_hal_vsc_Connect(VIDEO_WID_0, verifyInputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
}

void source_restore_from_verify_source(void)
{
	rtk_hal_vsc_Disconnect(VIDEO_WID_0, DisplayModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	rtk_hal_vsc_close(VIDEO_WID_0);
	//if(RecordVscInitdone_Flag == FALSE)
		//rtk_hal_vsc_uninitialize();
	if(RecordModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		rtk_hal_vsc_open(VIDEO_WID_0);
		rtk_hal_vsc_Connect(VIDEO_WID_0, RecordModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	}
}
#endif

#endif
//20171018 pinyen add to fix ML3RTANDN-418
void wait_game_mode_frame_delay_done(void)
{
       /*enter or exit game mode need to wait buffer write done to avoid garbage happen after unmute screen*/

       unsigned char game_mode_wait_frame = 1;// wait 1 frame to avoid gargabe happen when buffer switch
       rtd_pr_vsc_notice("[GameMode][M-doamin]wait buffer write done!!\n");

       //Update the M-domain last done
       drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, game_mode_wait_frame, TRUE);//game mode wait
}

#ifndef UT_flag
void enable_data_access(void)
{
	h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_RBUS h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg;
	h3ddma_hsd_i3ddma_accessdata_posctrl_uzd_RBUS h3ddma_hsd_i3ddma_accessdata_posctrl_uzd_reg;

	mpegnr_ich1_accessdata_posctrl_pk_RBUS mpegnr_ich1_accessdata_posctrl_pk_reg;
	mpegnr_ich1_accessdata_ctrl_pk_RBUS mpegnr_ich1_accessdata_ctrl_pk_reg;

	scaledown_accessdata_ctrl_uzd_RBUS  scaledown_accessdata_ctrl_uzd_reg;
	scaledown_accessdata_posctrl_uzd_RBUS scaledown_accessdata_posctrl_uzd_reg;

	scaleup_accessdata_ctrl_uzu_RBUS scaleup_accessdata_ctrl_uzu_reg;
	scaleup_accessdata_posctrl_uzu_RBUS scaleup_accessdata_posctrl_uzu_reg;
#if 0//non-existent in mac7p
	two_step_uzu_accessdata_posctrl_sr_RBUS two_step_uzu_accessdata_posctrl_sr_reg;
	two_step_uzu_accessdata_ctrl_sr_RBUS two_step_uzu_accessdata_ctrl_sr_reg;

	color_sharp_access_data_0_RBUS color_sharp_access_data_0_reg;
	color_sharp_access_data_1_RBUS color_sharp_access_data_1_reg;
#endif
	color_icm_dm_icm_accessdata_posctrl_RBUS color_icm_dm_icm_accessdata_posctrl_reg;
	color_icm_dm_icm_accessdata_ctrl_RBUS color_icm_dm_icm_accessdata_ctrl_reg;

	yuv2rgb_accessdata_ctrl_RBUS yuv2rgb_accessdata_ctrl_reg;
	yuv2rgb_accessdata_posctrl_RBUS yuv2rgb_accessdata_posctrl_reg;

	dm_hdr_access_data_ctrl0_RBUS dm_hdr_access_data_ctrl0_reg;
	dm_hdr_access_data_ctrl1_RBUS dm_hdr_access_data_ctrl1_reg;

	down(&DATA_ACCESS_DEBUG_Semaphore);

	//disable data access
	//i3ddma
	h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_AccessData_CTRL_UZD_reg);
	h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.read_en = 0;
	IoReg_Write32(H3DDMA_HSD_I3DDMA_AccessData_CTRL_UZD_reg, h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.regValue);

	//peaking
	mpegnr_ich1_accessdata_ctrl_pk_reg.regValue = IoReg_Read32(MPEGNR_ICH1_AccessData_CTRL_PK_reg);
	mpegnr_ich1_accessdata_ctrl_pk_reg.read_en = 0;
	IoReg_Write32(MPEGNR_ICH1_AccessData_CTRL_PK_reg, mpegnr_ich1_accessdata_ctrl_pk_reg.regValue);

	//uzd
	scaledown_accessdata_ctrl_uzd_reg.regValue = IoReg_Read32(SCALEDOWN_AccessData_CTRL_UZD_reg);
	scaledown_accessdata_ctrl_uzd_reg.read_en = 0;
	IoReg_Write32(SCALEDOWN_AccessData_CTRL_UZD_reg, scaledown_accessdata_ctrl_uzd_reg.regValue);

	//uzu
	scaleup_accessdata_ctrl_uzu_reg.regValue = IoReg_Read32(SCALEUP_AccessData_CTRL_UZU_reg);
	scaleup_accessdata_ctrl_uzu_reg.read_en = 0;
	IoReg_Write32(SCALEUP_AccessData_CTRL_UZU_reg, scaleup_accessdata_ctrl_uzu_reg.regValue);
#if 0//non-existent in mac7p
	//2step uzu
	two_step_uzu_accessdata_ctrl_sr_reg.regValue = IoReg_Read32(TWO_STEP_UZU_AccessData_CTRL_SR_reg);
	two_step_uzu_accessdata_ctrl_sr_reg.read_en = 0;
	IoReg_Write32(TWO_STEP_UZU_AccessData_CTRL_SR_reg, two_step_uzu_accessdata_ctrl_sr_reg.regValue);

	//color_sharp
	color_sharp_access_data_0_reg.regValue = IoReg_Read32(COLOR_SHARP_Access_Data_0_reg);
	color_sharp_access_data_0_reg.read_en = 0;
	IoReg_Write32(COLOR_SHARP_Access_Data_0_reg, color_sharp_access_data_0_reg.regValue);
#endif
	//ICM
	color_icm_dm_icm_accessdata_ctrl_reg.regValue = IoReg_Read32(COLOR_ICM_DM_ICM_AccessData_CTRL_reg);
	color_icm_dm_icm_accessdata_ctrl_reg.accessdata_read_en = 0;
	IoReg_Write32(COLOR_ICM_DM_ICM_AccessData_CTRL_reg, color_icm_dm_icm_accessdata_ctrl_reg.regValue);

	//Y2R
	yuv2rgb_accessdata_ctrl_reg.regValue = IoReg_Read32(YUV2RGB_AccessData_CTRL_reg);
	yuv2rgb_accessdata_ctrl_reg.read_en = 0;
	IoReg_Write32(YUV2RGB_AccessData_CTRL_reg, yuv2rgb_accessdata_ctrl_reg.regValue);

	//HDR
	dm_hdr_access_data_ctrl0_reg.regValue = IoReg_Read32(DM_HDR_ACCESS_DATA_CTRL0_reg);
	dm_hdr_access_data_ctrl0_reg.accessdata_rd_en = 0;
	IoReg_Write32(DM_HDR_ACCESS_DATA_CTRL0_reg, dm_hdr_access_data_ctrl0_reg.regValue);

	//i3ddma
	h3ddma_hsd_i3ddma_accessdata_posctrl_uzd_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_AccessData_PosCtrl_UZD_reg);
	h3ddma_hsd_i3ddma_accessdata_posctrl_uzd_reg.startx = 250;//read 250, 250 position
	h3ddma_hsd_i3ddma_accessdata_posctrl_uzd_reg.starty = 250;
	IoReg_Write32(H3DDMA_HSD_I3DDMA_AccessData_PosCtrl_UZD_reg, h3ddma_hsd_i3ddma_accessdata_posctrl_uzd_reg.regValue);

	h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_AccessData_CTRL_UZD_reg);
	h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.read_en = 1;//enabel i3ddma data access
	IoReg_Write32(H3DDMA_HSD_I3DDMA_AccessData_CTRL_UZD_reg, h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.regValue);

	//peaking
	mpegnr_ich1_accessdata_posctrl_pk_reg.regValue = IoReg_Read32(MPEGNR_ICH1_AccessData_PosCtrl_PK_reg);
	mpegnr_ich1_accessdata_posctrl_pk_reg.startx= 250;//read 250, 250 position
	mpegnr_ich1_accessdata_posctrl_pk_reg.starty = 250;
	IoReg_Write32(MPEGNR_ICH1_AccessData_PosCtrl_PK_reg, mpegnr_ich1_accessdata_posctrl_pk_reg.regValue);

	mpegnr_ich1_accessdata_ctrl_pk_reg.regValue = IoReg_Read32(MPEGNR_ICH1_AccessData_CTRL_PK_reg);
	mpegnr_ich1_accessdata_ctrl_pk_reg.read_en = 1;
	IoReg_Write32(MPEGNR_ICH1_AccessData_CTRL_PK_reg, mpegnr_ich1_accessdata_ctrl_pk_reg.regValue);

	//uzd
	scaledown_accessdata_posctrl_uzd_reg.regValue = IoReg_Read32(SCALEDOWN_AccessData_PosCtrl_UZD_reg);
	scaledown_accessdata_posctrl_uzd_reg.startx = 250;//read 250, 250 position
	scaledown_accessdata_posctrl_uzd_reg.starty = 250;
	IoReg_Write32(SCALEDOWN_AccessData_PosCtrl_UZD_reg, scaledown_accessdata_posctrl_uzd_reg.regValue);

	scaledown_accessdata_ctrl_uzd_reg.regValue = IoReg_Read32(SCALEDOWN_AccessData_CTRL_UZD_reg);
	scaledown_accessdata_ctrl_uzd_reg.read_en = 1;
	IoReg_Write32(SCALEDOWN_AccessData_CTRL_UZD_reg, scaledown_accessdata_ctrl_uzd_reg.regValue);

	//uzu
	scaleup_accessdata_posctrl_uzu_reg.regValue = IoReg_Read32(SCALEUP_AccessData_PosCtrl_UZU_reg);
	scaleup_accessdata_posctrl_uzu_reg.startx = 250;//read 250, 250 position
	scaleup_accessdata_posctrl_uzu_reg.starty = 250;
	IoReg_Write32(SCALEUP_AccessData_PosCtrl_UZU_reg, scaleup_accessdata_posctrl_uzu_reg.regValue);

	scaleup_accessdata_ctrl_uzu_reg.regValue = IoReg_Read32(SCALEUP_AccessData_CTRL_UZU_reg);
	scaleup_accessdata_ctrl_uzu_reg.read_en = 1;
	IoReg_Write32(SCALEUP_AccessData_CTRL_UZU_reg, scaleup_accessdata_ctrl_uzu_reg.regValue);
#if 0//non-existent in mac7p
	//2step uzu
	two_step_uzu_accessdata_posctrl_sr_reg.regValue = IoReg_Read32(TWO_STEP_UZU_AccessData_PosCtrl_SR_reg);
	two_step_uzu_accessdata_posctrl_sr_reg.startx = 250;//read 250, 250 position
	two_step_uzu_accessdata_posctrl_sr_reg.starty = 250;
	IoReg_Write32(TWO_STEP_UZU_AccessData_PosCtrl_SR_reg, two_step_uzu_accessdata_posctrl_sr_reg.regValue);

	two_step_uzu_accessdata_ctrl_sr_reg.regValue = IoReg_Read32(TWO_STEP_UZU_AccessData_CTRL_SR_reg);
	two_step_uzu_accessdata_ctrl_sr_reg.read_en = 1;
	IoReg_Write32(TWO_STEP_UZU_AccessData_CTRL_SR_reg, two_step_uzu_accessdata_ctrl_sr_reg.regValue);

	//color_sharp
	color_sharp_access_data_1_reg.regValue = IoReg_Read32(COLOR_SHARP_Access_Data_1_reg);
	color_sharp_access_data_1_reg.startx= 250;//read 250, 250 position
	color_sharp_access_data_1_reg.starty = 250;
	IoReg_Write32(COLOR_SHARP_Access_Data_1_reg, color_sharp_access_data_1_reg.regValue);

	color_sharp_access_data_0_reg.regValue = IoReg_Read32(COLOR_SHARP_Access_Data_0_reg);
	color_sharp_access_data_0_reg.read_en = 1;
	IoReg_Write32(COLOR_SHARP_Access_Data_0_reg, color_sharp_access_data_0_reg.regValue);
#endif
	//ICM
	color_icm_dm_icm_accessdata_posctrl_reg.regValue = IoReg_Read32(COLOR_ICM_DM_ICM_AccessData_PosCtrl_reg);
	color_icm_dm_icm_accessdata_posctrl_reg.accessdata_startx = 250;//read 250, 250 position
	color_icm_dm_icm_accessdata_posctrl_reg.accessdata_starty= 250;
	IoReg_Write32(COLOR_ICM_DM_ICM_AccessData_PosCtrl_reg, color_icm_dm_icm_accessdata_posctrl_reg.regValue);

	color_icm_dm_icm_accessdata_ctrl_reg.regValue = IoReg_Read32(COLOR_ICM_DM_ICM_AccessData_CTRL_reg);
	color_icm_dm_icm_accessdata_ctrl_reg.accessdata_read_en = 1;
	IoReg_Write32(COLOR_ICM_DM_ICM_AccessData_CTRL_reg, color_icm_dm_icm_accessdata_ctrl_reg.regValue);

	//Y2R
	yuv2rgb_accessdata_posctrl_reg.regValue = IoReg_Read32(YUV2RGB_AccessData_PosCtrl_reg);
	yuv2rgb_accessdata_posctrl_reg.startx = 250;//read 250, 250 position
	yuv2rgb_accessdata_posctrl_reg.starty = 250;
	IoReg_Write32(YUV2RGB_AccessData_PosCtrl_reg, yuv2rgb_accessdata_posctrl_reg.regValue);

	yuv2rgb_accessdata_ctrl_reg.regValue = IoReg_Read32(YUV2RGB_AccessData_CTRL_reg);
	yuv2rgb_accessdata_ctrl_reg.read_en = 1;
	IoReg_Write32(YUV2RGB_AccessData_CTRL_reg, yuv2rgb_accessdata_ctrl_reg.regValue);

	//HDR
	dm_hdr_access_data_ctrl1_reg.regValue = IoReg_Read32(DM_HDR_ACCESS_DATA_CTRL1_reg);
	dm_hdr_access_data_ctrl1_reg.accessdata_startx = 250;//read 250, 250 position
	dm_hdr_access_data_ctrl1_reg.accessdata_starty = 250;
	IoReg_Write32(DM_HDR_ACCESS_DATA_CTRL1_reg, dm_hdr_access_data_ctrl1_reg.regValue);

	dm_hdr_access_data_ctrl0_reg.regValue = IoReg_Read32(DM_HDR_ACCESS_DATA_CTRL0_reg);
	dm_hdr_access_data_ctrl0_reg.accessdata_rd_en = 1;
	dm_hdr_access_data_ctrl0_reg.access_data_sel = 2;
	IoReg_Write32(DM_HDR_ACCESS_DATA_CTRL0_reg, dm_hdr_access_data_ctrl0_reg.regValue);

	data_access_enable = TRUE;
	data_access_print_count = 5;//around 100 ms
	up(&DATA_ACCESS_DEBUG_Semaphore);
}
#endif

void output_data_access_data(void)
{
#ifndef UT_flag
	h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_RBUS h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg;
	h3ddma_hsd_i3ddma_readdata_data_y1_uzd_RBUS h3ddma_hsd_i3ddma_readdata_data_y1_uzd_reg;
	h3ddma_hsd_i3ddma_readdata_data_c1_uzd_RBUS h3ddma_hsd_i3ddma_readdata_data_c1_uzd_reg;

	mpegnr_ich1_accessdata_ctrl_pk_RBUS mpegnr_ich1_accessdata_ctrl_pk_reg;
	mpegnr_ich1_readdata_data_y1_pk_RBUS mpegnr_ich1_readdata_data_y1_pk_reg;
	mpegnr_ich1_readdata_data_c1_pk_RBUS mpegnr_ich1_readdata_data_c1_pk_reg;

	scaledown_accessdata_ctrl_uzd_RBUS  scaledown_accessdata_ctrl_uzd_reg;
	scaledown_readdata_data_y1_uzd_RBUS scaledown_readdata_data_y1_uzd_reg;
	scaledown_readdata_data_c1_uzd_RBUS scaledown_readdata_data_c1_uzd_reg;

	scaleup_accessdata_ctrl_uzu_RBUS scaleup_accessdata_ctrl_uzu_reg;
	scaleup_readdata_data_y1_uzu_RBUS scaleup_readdata_data_y1_uzu_reg;
	scaleup_readdata_data_c1_uzu_RBUS scaleup_readdata_data_c1_uzu_reg;
#if 0//non-existent in mac7p
	two_step_uzu_accessdata_ctrl_sr_RBUS two_step_uzu_accessdata_ctrl_sr_reg;
	two_step_uzu_readdata_data_y1_sr_RBUS two_step_uzu_readdata_data_y1_sr_reg;
	two_step_uzu_readdata_data_c1_sr_RBUS two_step_uzu_readdata_data_c1_sr_reg;

	color_sharp_access_data_0_RBUS color_sharp_access_data_0_reg;
	color_sharp_access_data_2_RBUS color_sharp_access_data_2_reg;
	color_sharp_access_data_4_RBUS color_sharp_access_data_4_reg;
#endif
	color_icm_dm_icm_accessdata_ctrl_RBUS color_icm_dm_icm_accessdata_ctrl_reg;
	color_icm_dm_icm_readdata_data_h1_RBUS color_icm_dm_icm_readdata_data_h1_reg;
	color_icm_dm_icm_readdata_data_s1_RBUS color_icm_dm_icm_readdata_data_s1_reg;
	color_icm_dm_icm_readdata_data_i1_RBUS color_icm_dm_icm_readdata_data_i1_reg;

	yuv2rgb_accessdata_ctrl_RBUS yuv2rgb_accessdata_ctrl_reg;
	yuv2rgb_readdata_data_y1_RBUS yuv2rgb_readdata_data_y1_reg;
	yuv2rgb_readdata_data_c1_RBUS yuv2rgb_readdata_data_c1_reg;

	dm_hdr_access_data_ctrl0_RBUS dm_hdr_access_data_ctrl0_reg;
	dm_hdr_access_data_status0_RBUS dm_hdr_access_data_status0_reg;
	dm_hdr_access_data_status4_RBUS dm_hdr_access_data_status4_reg;
	dm_hdr_access_data_status8_RBUS dm_hdr_access_data_status8_reg;

	VSC_INPUT_TYPE_T webos_src;

	if(data_access_enable)
	{
		down(&DATA_ACCESS_DEBUG_Semaphore);
		if(data_access_enable)
		{
			webos_src = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
			if(PPOVERLAY_Main_Display_Control_RSV_get_m_force_bg(IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg)) ||
				(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) || (webos_src == VSC_INPUTSRC_MAXN))
			{
				data_access_enable = FALSE;
				data_access_print_count = 0;
				up(&DATA_ACCESS_DEBUG_Semaphore);
				return;
			}
			if(data_access_print_count == 0)//count down
			{//print
				data_access_enable = FALSE;
				if((webos_src == VSC_INPUTSRC_HDMI) || (webos_src == VSC_INPUTSRC_ADC) || (webos_src == VSC_INPUTSRC_AVD))
				{
					//i3ddma
					h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_AccessData_CTRL_UZD_reg);
					if(h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.read_en)
					{
						h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.read_en = 0;
						IoReg_Write32(H3DDMA_HSD_I3DDMA_AccessData_CTRL_UZD_reg, h3ddma_hsd_i3ddma_accessdata_ctrl_uzd_reg.regValue);
						rtd_pr_vsc_info("i3ddma access data not ready \n");
					}
					else
					{//output i3ddma data
						h3ddma_hsd_i3ddma_readdata_data_y1_uzd_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_ReadData_DATA_Y1_UZD_reg);
						h3ddma_hsd_i3ddma_readdata_data_c1_uzd_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_ReadData_DATA_C1_UZD_reg);
						rtd_pr_vsc_info("i3ddma access data YUV(%d %d %d) \n", h3ddma_hsd_i3ddma_readdata_data_y1_uzd_reg.y00,
							h3ddma_hsd_i3ddma_readdata_data_c1_uzd_reg.u00, h3ddma_hsd_i3ddma_readdata_data_c1_uzd_reg.v00);
					}
				}

				//HDR
				dm_hdr_access_data_ctrl0_reg.regValue = IoReg_Read32(DM_HDR_ACCESS_DATA_CTRL0_reg);
				if(dm_hdr_access_data_ctrl0_reg.accessdata_rd_en)
				{
					dm_hdr_access_data_ctrl0_reg.accessdata_rd_en = 0;
					IoReg_Write32(DM_HDR_ACCESS_DATA_CTRL0_reg, dm_hdr_access_data_ctrl0_reg.regValue);
					rtd_pr_vsc_info("HDR access data not ready \n");
				}
				else
				{//output HDR data
					dm_hdr_access_data_status0_reg.regValue = IoReg_Read32(DM_HDR_ACCESS_DATA_STATUS0_reg);
					dm_hdr_access_data_status4_reg.regValue = IoReg_Read32(DM_HDR_ACCESS_DATA_STATUS4_reg);
					dm_hdr_access_data_status8_reg.regValue = IoReg_Read32(DM_HDR_ACCESS_DATA_STATUS8_reg);
					rtd_pr_vsc_info("HDR sel=2 access data RGB(%d %d %d) \n", dm_hdr_access_data_status0_reg.access_rdata_r00 & 0xFFF,
					dm_hdr_access_data_status4_reg.access_rdata_g00 & 0xFFF, dm_hdr_access_data_status8_reg.access_rdata_b00 & 0xFFF);
				}

				//peaking
				mpegnr_ich1_accessdata_ctrl_pk_reg.regValue = IoReg_Read32(MPEGNR_ICH1_AccessData_CTRL_PK_reg);
				if(mpegnr_ich1_accessdata_ctrl_pk_reg.read_en)
				{
					mpegnr_ich1_accessdata_ctrl_pk_reg.read_en = 0;
					IoReg_Write32(MPEGNR_ICH1_AccessData_CTRL_PK_reg, mpegnr_ich1_accessdata_ctrl_pk_reg.regValue);
					rtd_pr_vsc_info("peaking access data not ready \n");
				}
				else
				{//output peaking data
					mpegnr_ich1_readdata_data_y1_pk_reg.regValue = IoReg_Read32(MPEGNR_ICH1_ReadData_DATA_Y1_PK_reg);
	                mpegnr_ich1_readdata_data_c1_pk_reg.regValue = IoReg_Read32(MPEGNR_ICH1_ReadData_DATA_C1_PK_reg);
					rtd_pr_vsc_info("peaking access data YUV(%d %d %d) \n", mpegnr_ich1_readdata_data_y1_pk_reg.y00,
						mpegnr_ich1_readdata_data_c1_pk_reg.u00, mpegnr_ich1_readdata_data_c1_pk_reg.v00);
				}

				//uzd
				scaledown_accessdata_ctrl_uzd_reg.regValue = IoReg_Read32(SCALEDOWN_AccessData_CTRL_UZD_reg);
				if(scaledown_accessdata_ctrl_uzd_reg.read_en)
				{
					scaledown_accessdata_ctrl_uzd_reg.read_en = 0;
					IoReg_Write32(SCALEDOWN_AccessData_CTRL_UZD_reg, scaledown_accessdata_ctrl_uzd_reg.regValue);
					rtd_pr_vsc_info("uzd access data not ready \n");
				}
				else
				{//output uzd data
					scaledown_readdata_data_y1_uzd_reg.regValue = IoReg_Read32(SCALEDOWN_ReadData_DATA_Y1_UZD_reg);
					scaledown_readdata_data_c1_uzd_reg.regValue = IoReg_Read32(SCALEDOWN_ReadData_DATA_C1_UZD_reg);
					rtd_pr_vsc_info("uzd access data YUV(%d %d %d) \n", scaledown_readdata_data_y1_uzd_reg.y00,
						scaledown_readdata_data_c1_uzd_reg.u00, scaledown_readdata_data_c1_uzd_reg.v00);
				}

				//uzu
				scaleup_accessdata_ctrl_uzu_reg.regValue = IoReg_Read32(SCALEUP_AccessData_CTRL_UZU_reg);
				if(scaleup_accessdata_ctrl_uzu_reg.read_en)
				{
					scaleup_accessdata_ctrl_uzu_reg.read_en = 0;
					IoReg_Write32(SCALEUP_AccessData_CTRL_UZU_reg, scaleup_accessdata_ctrl_uzu_reg.regValue);
					rtd_pr_vsc_info("uzu access data not ready \n");
				}
				else
				{//output uzu data
					scaleup_readdata_data_y1_uzu_reg.regValue = IoReg_Read32(SCALEUP_ReadData_DATA_Y1_UZU_reg);
					scaleup_readdata_data_c1_uzu_reg.regValue = IoReg_Read32(SCALEUP_ReadData_DATA_C1_UZU_reg);

					rtd_pr_vsc_info("uzu access data YUV(%d %d %d) \n", scaleup_readdata_data_y1_uzu_reg.y00,
						scaleup_readdata_data_c1_uzu_reg.u00, scaleup_readdata_data_c1_uzu_reg.v00);
				}
#if 0//non-existent in mac7p
				//2step uzu
				two_step_uzu_accessdata_ctrl_sr_reg.regValue = IoReg_Read32(TWO_STEP_UZU_AccessData_CTRL_SR_reg);
				if(two_step_uzu_accessdata_ctrl_sr_reg.read_en)
				{
					two_step_uzu_accessdata_ctrl_sr_reg.read_en = 0;
					IoReg_Write32(TWO_STEP_UZU_AccessData_CTRL_SR_reg, two_step_uzu_accessdata_ctrl_sr_reg.regValue);
					rtd_pr_vsc_info("2step uzu access data not ready \n");
				}
				else
				{//output 2step uzu data
					two_step_uzu_readdata_data_y1_sr_reg.regValue = IoReg_Read32(TWO_STEP_UZU_ReadData_DATA_Y1_SR_reg);
					two_step_uzu_readdata_data_c1_sr_reg.regValue = IoReg_Read32(TWO_STEP_UZU_ReadData_DATA_C1_SR_reg);
					rtd_pr_vsc_info("2step uzu access data YUV(%d %d %d) \n", two_step_uzu_readdata_data_y1_sr_reg.y00,
					two_step_uzu_readdata_data_c1_sr_reg.u00, two_step_uzu_readdata_data_c1_sr_reg.v00);
				}

				//color_sharp
				color_sharp_access_data_0_reg.regValue = IoReg_Read32(COLOR_SHARP_Access_Data_0_reg);
				if(color_sharp_access_data_0_reg.read_en)
				{
					color_sharp_access_data_0_reg.read_en = 0;
					IoReg_Write32(COLOR_SHARP_Access_Data_0_reg, color_sharp_access_data_0_reg.regValue);
					rtd_pr_vsc_info("sharp access data not ready \n");
				}
				else
				{//output color_sharp data
					color_sharp_access_data_2_reg.regValue = IoReg_Read32(COLOR_SHARP_Access_Data_2_reg);
					color_sharp_access_data_4_reg.regValue = IoReg_Read32(COLOR_SHARP_Access_Data_4_reg);
					rtd_pr_vsc_info("sharp access data YUV(%d %d %d) \n", color_sharp_access_data_2_reg.y00,
					color_sharp_access_data_4_reg.u00, color_sharp_access_data_4_reg.v00);
				}
#endif
				//ICM
				color_icm_dm_icm_accessdata_ctrl_reg.regValue = IoReg_Read32(COLOR_ICM_DM_ICM_AccessData_CTRL_reg);
				if(color_icm_dm_icm_accessdata_ctrl_reg.accessdata_read_en)
				{
					color_icm_dm_icm_accessdata_ctrl_reg.accessdata_read_en = 0;
					IoReg_Write32(COLOR_ICM_DM_ICM_AccessData_CTRL_reg, color_icm_dm_icm_accessdata_ctrl_reg.regValue);
					rtd_pr_vsc_info("ICM access data not ready \n");
				}
				else
				{//output ICM data
					color_icm_dm_icm_readdata_data_h1_reg.regValue = IoReg_Read32(COLOR_ICM_DM_ICM_ReadData_DATA_H1_reg);
					color_icm_dm_icm_readdata_data_s1_reg.regValue = IoReg_Read32(COLOR_ICM_DM_ICM_ReadData_DATA_S1_reg);
					color_icm_dm_icm_readdata_data_i1_reg.regValue = IoReg_Read32(COLOR_ICM_DM_ICM_ReadData_DATA_I1_reg);
					rtd_pr_vsc_info("ICM access data HSI(%d %d %d) \n", color_icm_dm_icm_readdata_data_h1_reg.readdata_h00,
					color_icm_dm_icm_readdata_data_s1_reg.readdata_s00, color_icm_dm_icm_readdata_data_i1_reg.readdata_i00);
				}

				//Y2R
				yuv2rgb_accessdata_ctrl_reg.regValue = IoReg_Read32(YUV2RGB_AccessData_CTRL_reg);
				if(yuv2rgb_accessdata_ctrl_reg.read_en)
				{
					yuv2rgb_accessdata_ctrl_reg.read_en = 0;
					IoReg_Write32(YUV2RGB_AccessData_CTRL_reg, yuv2rgb_accessdata_ctrl_reg.regValue);
					rtd_pr_vsc_info("Y2R access data not ready \n");
				}
				else
				{//output Y2R data
					yuv2rgb_readdata_data_y1_reg.regValue = IoReg_Read32(YUV2RGB_ReadData_DATA_Y1_reg);
					yuv2rgb_readdata_data_c1_reg.regValue = IoReg_Read32(YUV2RGB_ReadData_DATA_C1_reg);
					rtd_pr_vsc_info("Y2R access data YUV(%d %d %d) \n", yuv2rgb_readdata_data_y1_reg.y00,
					yuv2rgb_readdata_data_c1_reg.u00, yuv2rgb_readdata_data_c1_reg.v00);
				}
			}
			else
			{
				data_access_print_count --;
			}
		}
		up(&DATA_ACCESS_DEBUG_Semaphore);
	}
#endif
}



#define SCALER_FRAMEDELAY_GAMEMODE_60 120  // 0.12 frame
#define SCALER_FRAMEDELAY_GAMEMODE_24 500  // 0.5 frame
#define PQ_HDMI_FRAMEDELAY_GAMEMODE 200    // 0.2 frame
#define PQ_VDEC_FRAMEDELAY_GAMEMODE 1000    // 1 frame
extern unsigned char Scaler_MEMC_GetAVSyncDelay(void);

unsigned int rtk_scaler_get_lowdelay_value(void)
{
	unsigned int u32_voVtotal = 0;
	unsigned int u32_voHtotal = 0;
	unsigned int u32_idomain_freq = 0;
	unsigned int u32_idomain_framePeriod = 0;
	unsigned int u32_idomain_frameDelay = 0;
	unsigned int u32_iv2dv_delay = 0;
	unsigned int u32_iv2pv_delay = 0;
	unsigned int u32_golden_vsync_delay = 0;
	unsigned int u32_disp_dvsta_delay = 0;
	unsigned int u32_sfg_line_delay = 1;
	unsigned int u32_dvtotal = 0;
	unsigned int u32_ddomain_freq = 0;
	unsigned int u32_ddomain_framePeriod = 0;
	unsigned int u32_ddomain_frameDelay = 0;
	unsigned int u32_final_frameDelay = 0;
	unsigned int u32_ddomainToidomain_frameDelay = 0;

    // i domain delay
	u32_voVtotal = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN);
	u32_voHtotal = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN);
	u32_idomain_freq = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
	if(u32_idomain_freq == 0){
		rtd_pr_vsc_notice("[%s][ERROR] u32_idomain_freq = %d \n", __FUNCTION__, u32_idomain_freq);
		return 0xFFFFFFFF;
	}
	if(u32_voHtotal){
		u32_iv2pv_delay = (VODMA_VODMA_PVS0_Gen_get_iv2pv_dly(IoReg_Read32(VODMA_VODMA_PVS0_Gen_reg)))/u32_voHtotal;
	}else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_voHtotal=0 \n");
		return 0xFFFFFFFF;
	}

	rtd_pr_vsc_notice("[lowdelay]u32_iv2pv_delay = %d (lines)\n", u32_iv2pv_delay);
	//Game mode calculate iv2dv phase error
	u32_iv2dv_delay = drv_GameMode_decided_iv2dv_delay_new_mode();
	//if compression enable, need to add margin. @Crixus 20170605
	if(dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY))
		u32_iv2dv_delay = drv_GameMode_iv2dv_delay_compress_margin(u32_iv2dv_delay);
	rtd_pr_vsc_notice("[lowdelay]u32_iv2dv_delay = %d (lines)\n", u32_iv2dv_delay);

	if(u32_voVtotal){
		u32_idomain_frameDelay = ((u32_iv2pv_delay+u32_iv2dv_delay)*1000)/u32_voVtotal;
	}else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_voVtotal=0 \n");
		return 0xFFFFFFFF;
	}

	//d domain delay
	u32_golden_vsync_delay = PPOVERLAY_MEMCDTG_CONTROL3_get_dtgm2goldenpostvs_line(IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg));
	u32_disp_dvsta_delay = PPOVERLAY_DV_DEN_Start_End_get_dv_den_sta(IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg));
	u32_dvtotal = PPOVERLAY_DV_total_get_dv_total(IoReg_Read32(PPOVERLAY_DV_total_reg))+1;
	u32_ddomain_freq =Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DTG_MASTER_V_FREQ);
	if(Get_DISPLAY_REFRESH_RATE() >= 120){
		u32_ddomain_freq = u32_ddomain_freq*2;
	}
	if(u32_dvtotal){
		u32_ddomain_frameDelay = ((u32_golden_vsync_delay+u32_disp_dvsta_delay+u32_sfg_line_delay)*1000)/u32_dvtotal;
	}

	if(u32_idomain_freq)
		u32_idomain_framePeriod = (10000000/u32_idomain_freq);	//ms * 1000000
	else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_idomain_framePeriod=0 \n");
		return 0xFFFFFFFF;
	}

	if(u32_ddomain_freq)
		u32_ddomain_framePeriod = 1000000/u32_ddomain_freq;
	else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_ddomain_freq=0 \n");
		return 0xFFFFFFFF;
	}

	if(u32_idomain_framePeriod && u32_dvtotal)
		u32_ddomainToidomain_frameDelay = (u32_ddomain_frameDelay *
		(u32_ddomain_framePeriod*u32_voVtotal))/ (u32_idomain_framePeriod*u32_dvtotal);

	u32_final_frameDelay = u32_idomain_frameDelay + u32_ddomainToidomain_frameDelay;

	rtd_pr_vsc_notice("[lowdelay] i=%d, d=%d , d2i=%d (0.001 frames)\n", u32_idomain_frameDelay,u32_ddomain_frameDelay, u32_ddomainToidomain_frameDelay);

	rtd_pr_vsc_notice("[lowdelay] final %d (0.001 frames)\n", u32_final_frameDelay);

	return u32_final_frameDelay; //unit : i domian delay framea * 1000
}

unsigned int rtk_scaler_calc_current_video_path_latency(void)
{
	unsigned char b_gamemode = 0;
	unsigned int u32_mdomainFrameBuf_delay = 0;
	unsigned int u32_scalerFrameBuf_delay = 0;
	unsigned int u32_pqFrameBuf_delay = 0;
	unsigned int u32_totalVideoPathFrame_delay = 0;
	unsigned int u32_scaler_delaytime = 0;
	unsigned int u32_pq_delaytime = 0;
	unsigned int u32_totalVideoPath_delaytime = 0;
	unsigned int u32_inputFramePeriod = 0;
	unsigned int u32_i3dmaFrameBuf_delay = 0;
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	//vodma_vodma_i2rnd_fifo_th_RBUS vodma_vodma_i2rnd_fifo_th_Reg;
	unsigned int u32_vfreq = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
	b_gamemode = drv_memory_get_game_mode_dynamic();
	//vodma_vodma_i2rnd_fifo_th_Reg.regValue = IoReg_Read32(VODMA_vodma_i2rnd_fifo_th_reg);
	mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	//i3ddma check buffer num
#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_VDEC)||(Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_JPEG)){
		u32_i3dmaFrameBuf_delay = 0;
	}else{
		if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY) == TRUE){
			//go through i3ddma
			if(VODMA_VODMA_V1_SEQ_3D_L1_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L1_reg)) ==
				VODMA_VODMA_V1_SEQ_3D_L2_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L2_reg))){
				//i3ddma single buffer
				u32_i3dmaFrameBuf_delay = 0;
			}else{
				u32_i3dmaFrameBuf_delay = 1000;
			}
		}else{
			u32_i3dmaFrameBuf_delay = 0;
		}
	}
#else
#if defined (CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT) || defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
if(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT))
	&& (get_force_hdmi_hdr_flow_enable(SLR_MAIN_DISPLAY) == FALSE))
#endif
{
	if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY) == TRUE){
		//go through i3ddma
		if(VODMA_VODMA_V1_SEQ_3D_L1_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L1_reg)) ==
			VODMA_VODMA_V1_SEQ_3D_L2_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L2_reg))){
			//i3ddma single buffer
			u32_i3dmaFrameBuf_delay = 0;
		}else{
			u32_i3dmaFrameBuf_delay = 1000;
		}
	}else{
		u32_i3dmaFrameBuf_delay = 0;
	}
}
#endif
	//mdomain buffer number
	if(MDOMAIN_DISP_Disp_main_enable_get_main_disp_en(IoReg_Read32(MDOMAIN_DISP_Disp_main_enable_reg))){
		//mdomain enable
		if(mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en){
			u32_mdomainFrameBuf_delay = (mdomain_disp_ddr_mainctrl_reg.main_cap2disp_distance)*1000;
		}else{
			if(mdomain_disp_ddr_mainctrl_reg.main_double_en){
				u32_mdomainFrameBuf_delay = 1000;
			}else{
				u32_mdomainFrameBuf_delay = 0;
			}
		}
	}else{
		//mdomain disable
		u32_mdomainFrameBuf_delay = 0;
	}
	if(b_gamemode){
		if(get_new_game_mode_condition()){
			//rtd_pr_vsc_notice("[calc_latency] game mode condition\n");

			if(((u32_vfreq > 235) && (u32_vfreq < 255)) ||
			   ((u32_vfreq > 295) && (u32_vfreq < 305)))
			{
#ifdef CONFIG_FORCE_RUN_I3DDMA
				//24/25/30hz
				if(u32_i3dmaFrameBuf_delay!=0){
					rtd_pr_vsc_notice("[WARN][%d] i3dma not single buffer.(%d)\n", __LINE__,u32_i3dmaFrameBuf_delay);
				}
#endif
				if(u32_mdomainFrameBuf_delay!=0){
					rtd_pr_vsc_notice("[WARN][%d] mdomain not single buffer.(%d)\n", __LINE__,u32_mdomainFrameBuf_delay);
				}else{
					u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_24;
				}
			}else if(((u32_vfreq > 475) && (u32_vfreq < 485)) ||
					 ((u32_vfreq > 495) && (u32_vfreq < 505)) ||
					 ((u32_vfreq > 595) && (u32_vfreq < 605)) ||
					 ((u32_vfreq > 995) && (u32_vfreq< 1005)) ||
					 ((u32_vfreq > 1195) && (u32_vfreq < 1205)))
			{
#ifdef CONFIG_FORCE_RUN_I3DDMA					//48/50/60hz
				if(u32_i3dmaFrameBuf_delay!=0){
					rtd_pr_vsc_notice("[WARN][%d] i3dma not single buffer.(%d)\n", __LINE__,u32_i3dmaFrameBuf_delay);
				}
#endif
				if(u32_mdomainFrameBuf_delay!=0){
					rtd_pr_vsc_notice("[WARN][%d] mdomain not single buffer.(%d)\n", __LINE__,u32_mdomainFrameBuf_delay);
				}else{
					u32_mdomainFrameBuf_delay = rtk_scaler_get_lowdelay_value();
					if(u32_mdomainFrameBuf_delay == 0xffffffff)
					{
						rtd_pr_vsc_err("[calc_latency]ERR!! rtk_scaler_get_lowdelay_value error.\n");
						//error handle
						return 0;
					}
				}
			}
/*
			// 120Hz VRR panel
			if((Get_DISPLAY_REFRESH_RATE() == 120) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) &&
				(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())&& ( Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DISP_LEN)== _DISP_LEN))
			{
				if(vbe_disp_get_VRR_device_max_framerate()> 1190){ // VRR 120hz
					u32_mdomainFrameBuf_delay = rtk_scaler_get_lowdelay_value();
					if(u32_mdomainFrameBuf_delay == 0xffffffff)
						u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_60;
				}else{	// VRR 60hz
					u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_24;
				}

			}
*/
		}
		else{
			if(u32_mdomainFrameBuf_delay == 0){
				// data fsync scaler delay
				u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_60;
			}
		}

	}
	else{	// non game mode
		//rtd_pr_vsc_notice("[calc_latency] non game mode condition\n");

		if(u32_mdomainFrameBuf_delay == 0){
			// data fsync scaler delay
			u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_60;
		}

	}

	// PQ delay
	if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE)){	 //interlace
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_VDEC)||(Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_JPEG))
			 u32_pqFrameBuf_delay = PQ_VDEC_FRAMEDELAY_GAMEMODE;
		else
			 u32_pqFrameBuf_delay = PQ_HDMI_FRAMEDELAY_GAMEMODE;
	}else{
		u32_pqFrameBuf_delay = 0;
	}

	u32_scalerFrameBuf_delay = u32_mdomainFrameBuf_delay + u32_i3dmaFrameBuf_delay;
	u32_totalVideoPathFrame_delay = u32_scalerFrameBuf_delay + u32_pqFrameBuf_delay;

	if(u32_vfreq){
		u32_inputFramePeriod = 100000/u32_vfreq;
	}else{
		rtd_pr_vsc_err("[calc_latency]ERR!! SLR_INPUT_V_FREQ cannot be zero.\n");
		return 0;
	}

	//rouding
	if(((u32_scalerFrameBuf_delay*u32_inputFramePeriod)%1000)>=500){
		u32_scaler_delaytime = (u32_scalerFrameBuf_delay*u32_inputFramePeriod)/1000+1;
	}else{
		u32_scaler_delaytime = (u32_scalerFrameBuf_delay*u32_inputFramePeriod)/1000;
	}
	//rouding
	if(((u32_pqFrameBuf_delay*u32_inputFramePeriod)%1000)>=500){
		u32_pq_delaytime = (u32_pqFrameBuf_delay*u32_inputFramePeriod)/1000+1;
	}else{
		u32_pq_delaytime = (u32_pqFrameBuf_delay*u32_inputFramePeriod)/1000;
	}
	//rtd_pr_vsc_notice("[calc_latency] delay	  : %d,%d,%d (0.1ms)\n", u32_i3dmaFrameBuf_delay, u32_mdomainFrameBuf_delay,u32_scalerFrameBuf_delay);
	//rtd_pr_vsc_notice("[calc_latency] iframePeriod: %d,%d (0.1ms)\n", u32_vfreq,u32_inputFramePeriod);
	//rtd_pr_vsc_notice("[calc_latency] scaler	  : %d (0.1ms)\n", u32_scaler_delaytime);
	//rtd_pr_vsc_notice("[calc_latency] pq		  : %d (0.1ms)\n", u32_pq_delaytime);
#ifndef CONFIG_MEMC_BYPASS
	//rtd_pr_vsc_notice("[calc_latency] memc		  : %d (0.1ms)\n", Scaler_MEMC_GetAVSyncDelay());
	u32_totalVideoPath_delaytime = u32_scaler_delaytime + u32_pq_delaytime + Scaler_MEMC_GetAVSyncDelay();
	rtd_pr_vsc_notice("[calc_latency] totalVideoDelayTime:%d (0.1ms)\n", u32_totalVideoPath_delaytime);
#else
	u32_totalVideoPath_delaytime = u32_scaler_delaytime + u32_pq_delaytime;
	rtd_pr_vsc_notice("[calc_latency] totalVideoDelayTime:%d (0.1ms)\n", u32_totalVideoPath_delaytime);
#endif
	return u32_totalVideoPath_delaytime;
}


unsigned int rtk_hal_vsc_scaler_check_video_delay(VIDEO_WID_T wid, unsigned int *current_video_delay)
{
	unsigned char forcebg_status = 1;
	unsigned char timinglock_status = 0;
	unsigned char fsync_en = (PPOVERLAY_Display_Timing_CTRL1_get_disp_fsync_en(IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg)));
	unsigned char fsync_ok_status = (PPOVERLAY_Display_Timing_CTRL1_get_disp_fsync_en(IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg)));
	unsigned char fll_status = (PPOVERLAY_Display_Timing_CTRL1_get_disp_fix_last_line(IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg)));

	forcebg_status = PPOVERLAY_Main_Display_Control_RSV_get_m_force_bg(IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg));
	timinglock_status = (fsync_en && fsync_ok_status) || fll_status;

	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
		*current_video_delay = 0;//no active return no delay
		return TRUE;
	}
	if((wid == VIDEO_WID_MIN)&&(forcebg_status == 0)&& timinglock_status){	//disable forcebg
		*current_video_delay = rtk_scaler_calc_current_video_path_latency();
	}
	return TRUE;
}
#ifndef UT_flag
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
// Dump VO frame CRC info to file
static int rtkscaler_dumpcrc_thread(void *arg)
{
	unsigned long magic, size, wr, rd;
	unsigned char *wrPtr, *rdPtr, *basePtr, *limitPtr;

	for (;;) {
		if (kthread_should_stop()) break;
		if (scalerfile_DumpCRC != 0 && scaler_DumpCRC_Config.enable) {
			SCALER_DUMP_BUFFER_HEADER *header;
			header = (SCALER_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
			magic = ntohl(header->magic) ;
			size  = ntohl(header->size) ;
			rd    = ntohl(header->rd) ;
			wr    = ntohl(header->wr) ;
			wrPtr = (unsigned char *)(scaler_g_pDumpCRC.Memory + wr - scaler_g_pDumpCRC.PhyAddr); /* make virtual address */
			rdPtr = (unsigned char *)(scaler_g_pDumpCRC.Memory + rd - scaler_g_pDumpCRC.PhyAddr); /* make virtual address */
			basePtr  = (unsigned char *)(scaler_g_pDumpCRC.Memory + sizeof(SCALER_DUMP_BUFFER_HEADER));
			size -= sizeof(SCALER_DUMP_BUFFER_HEADER);
			limitPtr = basePtr+ size;

                #if 0 // TEST
                    static unsigned long last_wr=0;
                    if(last_wr != wr){
                        rtd_pr_vsc_notice("[vo] Header %x, m=%x size=%x r(%x) w(%x)\n", (unsigned int)header, (unsigned int)magic, (unsigned int)size, (unsigned int)rd, (unsigned int)wr);
                        rtd_pr_vsc_notice("[vo] Ptr w(%x) r(%x) b(%x) (%x), offset=%x\n", (unsigned int)wrPtr, (unsigned int)rdPtr, (unsigned int)basePtr, (unsigned int)limitPtr, (unsigned int)f_offset_dumpcrc);
                        last_wr = wr;
                    }
                #endif

			if (wrPtr < rdPtr) {
				wrPtr = wrPtr + size;
			}

			if (wrPtr > rdPtr) {
				if (wrPtr > limitPtr) {
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, rdPtr, limitPtr -rdPtr) ;
					f_offset_dumpcrc += limitPtr -rdPtr ;
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, basePtr, wrPtr - limitPtr) ;
					f_offset_dumpcrc += wrPtr - limitPtr ;
				}
				else {
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, rdPtr, wrPtr - rdPtr) ;
					f_offset_dumpcrc += wrPtr - rdPtr ;
				}
				header->rd = htonl(wr) ;
                #if 0 // TEST
                         rtd_pr_vsc_notice("[vo] f_offset_dumpcrc=%x\n", (unsigned int)f_offset_dumpcrc);
                #endif
			}
		}

		msleep(100); /* sleep 10 ms */
	}

	/* rtd_pr_vsc_debug("rtkvdec_dumpes_thread break\n"); */
	rtd_pr_vsc_err("rtkscaler_dumpcrc_thread break\n");
	return 0;
}


static void rtkscaler_dump_init(void)
{
#ifndef CONFIG_ANDROID
	unsigned char default_file_name3[30] = "/tmp/video_dumpscalercrc.bin" ;
#else
	unsigned char default_file_name3[36] = "/data/data/video_dumpscalercrc.bin" ;
#endif

	scaler_DumpCRC_Config.enable = 0 ;
	scaler_DumpCRC_Config.mem_size = DUMP_ES_SIZE ;

#ifndef CONFIG_ANDROID
	memset((void *)scaler_DumpCRC_Config.file_name, '\0', FILE_NAME_SIZE );
	memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)default_file_name3, 21);
#else
	memset((void *)scaler_DumpCRC_Config.file_name, '\0', 27 + 1 );
	memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)default_file_name3, 27);
#endif

	scaler_g_pDumpCRC.Memory = scaler_g_pDumpCRC.PhyAddr = scaler_g_pDumpCRC.VirtAddr = 0 ;
	scaler_g_pDumpCRC_Send.Memory = scaler_g_pDumpCRC_Send.PhyAddr = scaler_g_pDumpCRC_Send.VirtAddr = 0 ;
}



int rtkscaler_dumpCRC_enable(const char *pattern, int length)
{
#ifdef CONFIG_RTK_KDRV_RPC
	//unsigned long return_value ;
#endif
	VO_DUMP_BUFFER_HEADER *header;
	unsigned long vir_addr = 0;

	if (length > FILE_NAME_SIZE - 1) {
		rtd_pr_vsc_warn("rtkscaler: file name is too long(<%d).\n", FILE_NAME_SIZE - 1);
		return 0;
	}
	else if (length > 0) {
		memset((void *)scaler_DumpCRC_Config.file_name, '\0', length+1);
		memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)pattern, length);
	}

	rtd_pr_vsc_notice("rtkscaler: dumpes_file_name(%s)\n", scaler_DumpCRC_Config.file_name);

	if (scaler_DumpCRC_Config.enable) {
		rtd_pr_vsc_notice("rtkscaler: es dump already enable!\n");
		return 0 ;
	}

	scalerfile_DumpCRC = file_open((char *)(scaler_DumpCRC_Config.file_name), O_TRUNC | O_RDWR | O_CREAT,0x755) ;
	if (scalerfile_DumpCRC == 0) {
		rtd_pr_vsc_err("[%s %d]open log file fail\n",__FUNCTION__,__LINE__);
		return -ENOMEM;
	}

	/* allocate debug memory */
	  #ifndef CONFIG_KDRIVER_USE_NEW_COMMON
	  //#FixMe, 20190912
	vir_addr = (unsigned long)dvr_malloc_uncached_specific(sizeof(VO_RPC_DEBUG_MEMORY)+256, GFP_DCU1, (void **)(&scaler_g_pDumpCRC_Send.Memory));
	  #endif
	if (!vir_addr) {
		rtd_pr_vsc_err("[%s %d]alloc debug memory fail\n",__FUNCTION__,__LINE__);
		return -ENOMEM;
	}
	scaler_g_pDumpCRC_Send.PhyAddr = (unsigned long)dvr_to_phys((void*)vir_addr);
	scaler_g_pDumpCRC_Send.VirtAddr = vir_addr ;
	rtd_pr_vsc_notice("Alloc DVOCRCME v(%lx) p(%lx) vn(%lx)\n", vir_addr, scaler_g_pDumpCRC_Send.PhyAddr, scaler_g_pDumpCRC_Send.Memory);

	if ((scalerfile_DumpCRC != 0) && (scaler_DumpCRC_Config.mem_size > 0)) {
		/* alocate dump memory */
		vir_addr = (unsigned long)dvr_malloc_uncached_specific(scaler_DumpCRC_Config.mem_size, GFP_DCU1, (void **)(&scaler_g_pDumpCRC.Memory));
		if (!vir_addr) {
			vir_addr = scaler_g_pDumpCRC_Send.VirtAddr ;
			dvr_free((void*)vir_addr);
			rtd_pr_vsc_err("[%s %d]alloc debug memory fail\n",__FUNCTION__,__LINE__);
			return -ENOMEM;
		}
		scaler_g_pDumpCRC.PhyAddr = (unsigned long)dvr_to_phys((void*)vir_addr);
		scaler_g_pDumpCRC.VirtAddr = vir_addr ;

		rtd_pr_vsc_notice("Alloc DUMPVOME v(%lx) p(%lx) vn(%lx)\n", vir_addr, scaler_g_pDumpCRC.PhyAddr, scaler_g_pDumpCRC.Memory);

		/* setup dump es ring buffer header */
		header = (VO_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
		header->magic = htonl(0xdeadcafe) ;
		header->size = htonl(scaler_DumpCRC_Config.mem_size) ;
		header->rd = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(VO_DUMP_BUFFER_HEADER)) ;
		header->wr = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(VO_DUMP_BUFFER_HEADER)) ;

		*(unsigned long *)scaler_g_pDumpCRC_Send.Memory = htonl(scaler_g_pDumpCRC.PhyAddr) ;

		rtd_pr_vsc_notice("[scaler] Header %lx, m=%x size=%x r(%x) w(%x)\n", (unsigned long)header, header->magic, header->size, header->rd, header->wr);
	}
	else {
		rtd_pr_vsc_notice("rtkscaler: no allocate debug dump ring buffer!\n");
		return 0 ;
	}

	rtkscaler_dumpcrc_tsk = kthread_create(rtkscaler_dumpcrc_thread, &data, "rtkscaler_dumpcrc_thread");
	if (IS_ERR(rtkscaler_dumpcrc_tsk)) {
		rtkscaler_dumpcrc_tsk = NULL;
		return -1 ;
	}
	wake_up_process(rtkscaler_dumpcrc_tsk);

	scaler_DumpCRC_Config.enable = 1 ;
#ifdef CONFIG_RTK_KDRV_RPC
	// FixMe, 20190920
	#if 0
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo, (unsigned long)scaler_g_pDumpCRC_Send.PhyAddr, _ENABLE, &return_value)){
            rtd_pr_vsc_err("rtkscaler: VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo fail %ld\n", return_value);
            rtkscaler_dumpCRC_disable();
            return -1;
       }
	#endif
#endif
	return 0 ;
}


void rtkscaler_dumpCRC_disable(void)
{
#ifdef CONFIG_RTK_KDRV_RPC
	//unsigned long return_value ;
#endif
	int ret = 0;
	unsigned long vir_addr ;
	SCALER_DUMP_BUFFER_HEADER *header;

	if (!scaler_DumpCRC_Config.enable) {
		rtd_pr_vsc_notice("rtkvo: es dump not enable!\n");
		return ;
	}

	scaler_DumpCRC_Config.enable = 0 ;
	/* setup debug dump ring buffer header */
	header = (SCALER_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
	header->magic = htonl(0xdeadcafe) ;
	header->size = htonl(16) ;
	header->rd = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(SCALER_DUMP_BUFFER_HEADER)) ;
	header->wr = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(SCALER_DUMP_BUFFER_HEADER)) ;
	*(unsigned long *)scaler_g_pDumpCRC_Send.Memory = htonl(scaler_g_pDumpCRC.PhyAddr) ;

#ifdef CONFIG_RTK_KDRV_RPC
	// FixMe, 20190920
	#if 0
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo, 0, 0, &return_value))
		rtd_pr_vsc_err("rtkscaler: VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo fail %ld\n", return_value);
	#endif
#endif

	ret = kthread_stop(rtkscaler_dumpcrc_tsk);
	if (!ret)
		rtd_pr_vsc_debug("rtkscaler dumpes thread stopped\n");

	f_offset_dumpcrc = 0 ;
	if (scaler_g_pDumpCRC.PhyAddr) {
		vir_addr = scaler_g_pDumpCRC.VirtAddr;
		dvr_free((void*)vir_addr);
		scaler_g_pDumpCRC.Memory = scaler_g_pDumpCRC.PhyAddr = scaler_g_pDumpCRC.VirtAddr = 0 ;
	}

	if (scaler_g_pDumpCRC_Send.PhyAddr) {
		vir_addr = scaler_g_pDumpCRC_Send.VirtAddr;
		dvr_free((void*)vir_addr);
		scaler_g_pDumpCRC_Send.Memory = scaler_g_pDumpCRC_Send.PhyAddr = scaler_g_pDumpCRC_Send.VirtAddr = 0 ;
	}

	if (scalerfile_DumpCRC)
		file_close(scalerfile_DumpCRC) ;
	scalerfile_DumpCRC = 0 ;
}
#endif
#endif
module_init(vsc_init_module) ;
module_exit(vsc_cleanup_module) ;
#endif
