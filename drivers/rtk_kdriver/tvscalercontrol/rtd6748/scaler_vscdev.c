//Kernel Header file
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <linux/delay.h>
#include <generated/autoconf.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/platform_device.h>
#include <linux/mtd/mtd.h>
#include <linux/uaccess.h>
#include <asm/cacheflush.h>
#include <asm/current.h>
#include <asm-generic/errno-base.h>
#include <rtk_kdriver/RPCDriver.h>
#include <linux/pageremap.h>
#include <linux/kthread.h>
#include <uapi/linux/const.h>
#include <linux/mm.h>
#include <linux/string.h>/*memset*/
#include <linux/wait.h>//For wake_up and wait
#include <linux/spinlock.h>
#include <linux/spinlock_types.h>/*For spinlock*/
#include <rbus/dma_vgip_reg.h>
#include <linux/poll.h>
#include <rtk_dc_mt.h>
#include <tvscalercontrol/vip/localcontrast.h>
#include <rbus/ldspi_reg.h>
#include <linux/hrtimer.h>
#include <linux/version.h>
#include <linux/completion.h>
#include <linux/export.h>
#include <linux/err.h>
#include <mach/platform.h>
#include "memc_isr/include/memc_lib.h"
#include <linux/suspend.h>

#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
#include <rtk_kdriver/rtk_pwm.h>
#endif
#if IS_ENABLED(CONFIG_RTK_KDRV_QOS_CONTROL)
#include <rtk_kdriver/rtk_qos_export.h>
#endif

#ifdef CONFIG_RTK_KDRV_VDEC
#include <rtk_kdriver/rtk_vdec_svp.h>
#endif

// FixMe
//#include "../rtk_gdma_export.h"
//#include "../rtk_osdcomp_driver.h"

//#ifndef CONFIG_KDRIVER_USE_NEW_COMMON
//#include <rtk_kdriver/gal/rtk_gdma_export_user.h>
//#endif
#include <tvscalercontrol/scaler/scalerlib.h>

//#include <tvscalercontrol/i3ddma/i3ddma.h>
//#include <tvscalercontrol/i3ddma/i3ddma_drv.h>

#include <rbus/sub_vgip_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/timer_reg.h>
#include <rbus/hsd_dither_reg.h>
#include <rbus/osdovl_reg.h>
#include <rbus/h3ddma_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/mdomain_cap_reg.h>
//#include <rbus/abl_reg.h>
#include <rbus/iedge_smooth_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/sub_vgip_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/ppoverlay_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/mdomain_cap_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/scaleup_reg.h>
#include <rbus/scaledown_reg.h>
//#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/misc_reg.h>
//#include <rbus/rbus_DesignSpec_MISC_GPIOReg.h>
#include <rbus/tvsb2_reg.h>
#include <rbus/sfg_reg.h>
#include <rbus/vdtop_reg.h>
#include <rbus/pst_i2rnd_reg.h>
#include <rbus/h3ddma_hsd_reg.h>
#include <rbus/sys_reg_reg.h>
#include <rbus/di_reg.h>
#include <rbus/vodma_reg.h>
//#include <rbus/dbus_wrapper_reg.h>
//#include <rbus/mc_dma_reg.h>
//#include <rbus/pqc_pqdc_reg.h>
//#include <rbus/lbmc_reg.h>
//#include <rbus/me_share_dma_reg.h>
//#include <rbus/mvinfo_dma_reg.h>
//#include <rbus/kme_dm_top0_reg.h>
//#include <rbus/kme_dm_top1_reg.h>
//#include <rbus/kme_dm_top2_reg.h>
#ifndef CONFIG_MEMC_NOTSUPPORT
#include "memc_reg_def.h"
#endif
#include <rbus/memc_mux_reg.h>
#include <rbus/h3ddma_hsd_reg.h>

#include <tvscalercontrol/io/ioregdrv.h>
#include <tvscalercontrol/scaler/source.h>
#include <tvscalercontrol/scalerdrv/scalerdrv.h>
#include <tvscalercontrol/scalerdrv/scalermemory.h>
#include <tvscalercontrol/scalerdrv/scalerclock.h>
#include <tvscalercontrol/scalerdrv/overscanTable.h>

#include <tvscalercontrol/pcbsource/pcbSource.h>
#include <tvscalercontrol/scalerdrv/scalerdisplay.h>
#include <tvscalercontrol/scalerdrv/syncproc.h>
#include <tvscalercontrol/scalerdrv/auto.h>
#include <tvscalercontrol/scalerdrv/mode.h>
#include <tvscalercontrol/scalerdrv/scalerip.h>
#include <tvscalercontrol/scalerdrv/framesync.h>
#include <tvscalercontrol/panel/panelapi.h>
#include <tvscalercontrol/adcsource/ypbpr.h>
#include <tvscalercontrol/adcsource/vga.h>
#include <tvscalercontrol/adcsource/adcctrl.h>
#include <tvscalercontrol/hdmirx/hdmifun.h>
#include <tvscalercontrol/vip/ultrazoom.h>
#include <tvscalercontrol/vip/di_ma.h>
#include <tvscalercontrol/vip/scalerColor.h>
#include <tvscalercontrol/vip/ST2094.h>
#include <rtk_kdriver/tvscalercontrol/hdmirx/hdmi_vfe.h>
#include <tvscalercontrol/scaler/scalercolorlib.h>
#include <tvscalercontrol/scalerdrv/adjust.h>
#include <tvscalercontrol/scalerdrv/scaler_2dcvt3d_ctrl.h>
#include <vo/rtk_vo.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle_lib.h>
#include <tvscalercontrol/scalerdrv/pipmp.h>
#include <tvscalercontrol/scalerdrv/power.h>
#include <tvscalercontrol/scalerdrv/inprocvideo.h>
#include <tvscalercontrol/scalerdrv/scaler_i2rnd.h>
#include <tvscalercontrol/scalerdrv/scaler_pst.h>
#include <tvscalercontrol/panel/panel_dlg.h>

#ifdef CONFIG_KDRIVER_USE_NEW_COMMON
	#include <VideoRPC_System.h>
#else
	#include <rpc/VideoRPC_System.h>
#endif
#include <vgip_isr/scalerAI.h>
#include <tvscalercontrol/vip/scalerColor_tv006.h>
#include <tvscalercontrol/i3ddma/i3ddma.h>
#include <tvscalercontrol/i3ddma/i3ddma_drv.h>
#include <tvscalercontrol/scaler_drv_verify/scaler_verify_common.h>

#include "scaler_vfedev.h"
#include "scaler_vscdev.h"
#include "scaler_vbedev.h"
#include "scaler_vtdev.h"
#include <tvscalercontrol/avd/avdctrl.h>
#include <rbus/vgip_reg.h>
#include "scaler_vpqmemcdev.h"
#include <linux/freezer.h>
#include "hdmirx/hdmiInternal.h"
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
#include <tvscalercontrol/scaler/scalervideo.h>
#include <tvscalercontrol/avd/avdctrl.h>
#include "scaler_vfedev.h"
static UINT8 read_buffer_first_flag = 0;
static UINT8 sub_read_buffer_first_flag = 0;

#endif

#if 1//(defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)||defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT))
#include <tvscalercontrol/scalerdrv/scaler_hdr_ctrl.h>
#endif

#ifdef CONFIG_RTK_KDRV_DV
#ifndef	CONFIG_DOLBY_IDK_1_6_1_1
#include "../dolbyvision_edr/dolbyvisionEDR_export.h"
#include "../dolbyvision_edr/dolby_flowCtrl.h"
#endif
#endif

#include <tvscalercontrol/vdc/video.h>
//#include <rbus/abl_reg.h>
#include <scaler/vipRPCCommon.h>	/* in common*/

#include <rtd_log/rtd_module_log.h>

#ifdef CONFIG_COMPAT
#include <linux/compat.h>
#define to_user_ptr(x)          compat_ptr((unsigned int)x)
#else
#define to_user_ptr(x)          ((void* __user)(x)) // convert 32 bit value to user pointer
#endif
unsigned char scaler_nn_force_run_idma(unsigned char display, VSC_INPUT_TYPE_T inputSrctype);
static DECLARE_COMPLETION(vsc_scaler_tsk_completion);
static DEFINE_SPINLOCK(orbit_timer_update_spinlock);/* This spinlock is for control wait_orbit_ready*/
unsigned char ScalerCheckOrbitFinish(void);

extern unsigned char update_dlg_Setting;
extern unsigned char vbe_disp_oled_orbit_enable;
extern enum PANEL_RES_TYPE get_panel_res(void);
extern void Scaler_wait_for_LCM_done(void);
//#define ENABLE_FORCE_PC_MODE 1
#ifdef CONFIG_RTK_KDRV_DV
extern bool check_hdmi_dolby_vision_rgb_and_full_hd(void);
extern bool check_hdmi_dolby_vision_FRT_one_drop_case(void);
#endif

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
  // VO frame CRC dump
  #ifdef CONFIG_KDRIVER_USE_NEW_COMMON
	#include <VideoRPC_System.h>
  #else
	#include <rpc/VideoRPC_System.h>
  #endif
  #include <linux/kthread.h>

  #include <tvscalercontrol/vdc/yc_separation_vpq.h>
#include <rtk_kdriver/rtk_qos_export.h>
#ifndef UT_flag
extern unsigned char data_access_enable;//data access
extern unsigned char sub_data_access_enable;//data access
extern struct semaphore DATA_ACCESS_DEBUG_Semaphore;//data access
extern struct semaphore SUB_DATA_ACCESS_DEBUG_Semaphore;/*For data access Semaphore*/
#endif // #ifndef UT_flag
extern void scaler_SendDispSize(StructSrcRect outregion);
extern HDMI_COLOR_SPACE_T drvif_Hdmi_GetRawColorSpace(void);
extern unsigned char drvif_Hdmi_GetFrlMode(void);
extern HDMI_bool drvif_Hdmi_SetClkPixelMode(unsigned char pixel_mode);
extern bool Scaler_AVD_GetHalVscConnect(unsigned char a_ucChannel);
extern HDMI_bool drvif_Hdmi_EnableBypassYUV420Engine(unsigned char enable);
extern void vsc_adaptivestream_save_region(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion);
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
extern int rtk_pwm_set_scaler_source( int h_total, int v_total, int ifold,unsigned char bEnableDB);
#endif
//unsigned char game_mode_tsk_pending = _low_power_tsk_no_pending; //new_game_mode_tsk
//unsigned char game_mode_unmute_tsk_pending = _low_power_tsk_no_pending;//game_mode_unmute_tsk
bool is_game_mode_set_line_buffer(void);
extern void MEMC_Lib_Freeze(unsigned char enable);
extern VIDEO_FW_CONTRL_MEMC_TYPE get_video_fw_memc_freeze_type(unsigned char display);
extern void set_video_fw_memc_freeze_type(unsigned char display,unsigned char value);

#ifndef UT_flag

#ifdef CONFIG_RTK_FEATURE_FOR_GKI
static struct file * file_open(const char *path, int flags, int rights)
{
    struct file* filp = NULL;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
    mm_segment_t oldfs;
    oldfs = get_fs();
    set_fs(KERNEL_DS);
#endif
    filp = filp_open(path, flags, rights);
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
    set_fs(oldfs);
#endif
    if(IS_ERR(filp)) {
        return NULL;
    }
    return filp;
}

static void file_close(struct file *file)
{
    filp_close(file, NULL);
}
#ifndef CONFIG_KDRIVER_USE_NEW_COMMON

static int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size)
{
#ifndef DISABLE_FILE_RW
    int ret;
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
    mm_segment_t oldfs;
    oldfs = get_fs();
    set_fs(KERNEL_DS);
#endif

#ifdef CONFIG_SUPPORT_SCALER_MODULE
    ret = kernel_write(file, data, size, &offset);
#else
    ret = vfs_write(file, data, size, &offset);
#endif

#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
    set_fs(oldfs);
#endif
    return ret;
#else
	return 0;
#endif
}
#endif
#else
static struct file * file_open(const char *path, int flags, int rights)
{
	return NULL;
}

static void file_close(struct file *file)
{
}
#ifndef CONFIG_KDRIVER_USE_NEW_COMMON
static int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size)
{
	return 0;
}
#endif
#endif
  static void rtkscaler_dump_init(void);
#endif // #ifndef UT_flag
#endif
enum{
	NOT_EQUAL = 0,
	ALL_EQUAL,
	ONLY_SHIFT_XY,
	ONLY_SHIFT_X,
	ONLY_SHIFT_Y,
};
static unsigned int vsc_task_status = 0;//record vsc task current status

#ifndef CONFIG_MEMC_NOTSUPPORT
static DEFINE_SPINLOCK(MAIN_BBD_STAGE_SPINLOCK);
static DEFINE_SPINLOCK(SUB_BBD_STAGE_SPINLOCK);
#endif

static unsigned char main_bbd_stage = BBD_FUNCTION_DONE;
static unsigned char sub_bbd_stage = BBD_FUNCTION_DONE;

static KADP_VSC_HDR_TYPE_T MAIN_VSC_HDRTYPE = KADP_VSC_HDR_MAXN;//KADP_VSC_HDR_MAXN is SDR //AP set the hdr type
void scaler_set_I2D_tracking_in_slow_mode(unsigned char bEnable);//True for fll use old flow

//#include <rtk_kdriver/rtk_platform.h>
void reset_any_srcrect(StructSrcRect *p_srcrect);
void trigger_mute_off(unsigned char display, unsigned char no_delay);
#ifndef UT_flag
//#define _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
static struct semaphore GameMode_SCALER_SYNC_Semaphore;//for game mode and scaler sync Semaphore
static struct semaphore VSC_Semaphore;
static struct semaphore DM_HDR_Semaphore;
static struct semaphore Force_Run_Idma_Semaphore;
static struct semaphore Low_Delay_Semaphore;
#endif // #ifndef UT_flag
static struct semaphore Double_buffer_Semaphore;
#ifndef UT_flag
static struct semaphore GameMode_Check_Semaphore;
static struct semaphore set_vsc_film_mode_semaphore;
extern struct semaphore VBE_LowDelay_Semaphore;

static DEFINE_SPINLOCK(muteoff_main_ctrl_flag_Spinlock);/* This spinlock is for DbgSclrFlgTkr.Main_Request_ForceBG_ctrl for */
#ifdef CONFIG_DUAL_CHANNEL
static DEFINE_SPINLOCK(muteoff_sub_ctrl_flag_Spinlock);/* This spinlock is for DbgSclrFlgTkr.Main_Request_ForceBG_ctrl for */
#endif
static struct mutex gamemode_fixlastline_mutex;

#ifdef CONFIG_HDR_SDR_SEAMLESS
void dynamic_change_hdr_setting(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format);
void dynamic_change_hdr_setting_hdmi_position(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type);
void dynamic_change_hdr_setting_hdmi_finish(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type);

unsigned char rtk_hal_vsc_SetRGB444Mode(bool bonoff);

static struct semaphore HDR_Setting_Semaphore;//this is for HDR V top setting Semaphore
#endif
static struct semaphore HDMI_4K120_MEMORY_PROTECTION_Semaphore;//For 4k120 se buffer protection

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
extern void reset_pst_sharemem_buffer(unsigned char display);//set pst sharememocry buffer data for chnage source
extern void set_pst_active_state(unsigned char display, unsigned short state);//set pst active state
#endif
#endif // #ifndef UT_flag


unsigned char vdo0_connect = FALSE;//means connect vo0 //add by will for live zoom
unsigned char vdo1_connect = FALSE;//means connect vo1 //add by will for live zoom

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
static struct semaphore Orbit_algo_Semaphore;
#endif
#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
static unsigned int cost_time;
#endif
#ifndef UT_flag
static struct semaphore SetMainOutPutRegion_Semaphore;/*For main set output region Semaphore*/
static struct semaphore Main_ResetMode_Semaphore;/*For main reset mode Semaphore*/

#ifdef CONFIG_DUAL_CHANNEL
static struct semaphore SetSubOutPutRegion_Semaphore;/*For sub set output region Semaphore*/
static struct semaphore Sub_ResetMode_Semaphore;/*For sub reset mode Semaphore*/
#endif
#endif // #ifndef UT_flag
extern DEBUG_SCALER_VSC_STRUCT DbgSclrFlgTkr; // debug scaler flag tracker
extern unsigned int rotatedisconnecten;
extern StructSrcRect Scaler_intputRegion_base_scalerTiming[MAX_DISP_CHANNEL_NUM];
extern void drvif_color_Set_DRV_SNR_Clock(SCALER_DISP_CHANNEL display, unsigned char En_flag);
extern void Scaler_AVD_SetHalVscConnect(unsigned char a_ucChannel,bool AvdVscConnect);
extern void drv_memory_Set_multibuffer_number_pre(UINT8 number);
extern void drv_memory_Set_multibuffer_flag(UINT8 enable);
extern void drv_memory_send_multibuffer_number_to_smoothtoogh(void);
extern void drv_memory_Set_multibuffer_number(UINT8 number);
extern unsigned char get_MEMC_bypass_status_refer_platform_model(void);


//int sub_window_type = 0;
//int subWin_LGowner = 0;
int ATV_forcei3ddma = 0;

//These are for mute on to wait memc already blck video
#define MAX_MEMC_DELAY_BUFFER 45//4.4 frame buffer
unsigned char sync_memc_ready = FALSE;//if TRUE. when mute on to wait memc buffer
void wait_memc_ready(void);

int main_InputRegion_0000 = 0;
#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
//unsigned char vsc_video_latency_pattern_enable = 0;
//KADP_VIDEO_RECT_T video_latency_pattern_size = {0, 0, 0, 0};
VSC_VIDEO_LATENCY_PATTERN_T hal_video_latency_pattern_info = {0, 0, {0, 0, 0 ,0}};//record hal info
unsigned char latency_pattern_change = FALSE;//record paramter is change or not
unsigned char latency_pattern_self_test = FALSE;//record paramter is change or not
static DEFINE_SPINLOCK(latency_pattern_spinlock);/*Spin lock no context switch. for control lenterncy info*/
spinlock_t* get_latency_pattern_spinlock(void)
{//this is for  latency_pattern control protection
	return &latency_pattern_spinlock;
}
#endif
#ifdef CONFIG_RTK_KDRV_DV
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
#include <dolby_adapter.h>
#else
extern volatile unsigned int g_picModeUpdateFlag;
#endif
#endif
  SCALER_DUMP_STRUCT scaler_DumpCRC_Config;
  #define SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX 30
  #define SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX 0
#ifndef UT_flag
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
  /* dump VO CRC info to file */
  SCALER_MALLOC_STRUCT scaler_g_pDumpCRC_Send ;
  SCALER_MALLOC_STRUCT scaler_g_pDumpCRC ;
  struct file *scalerfile_DumpCRC = 0 ;
  static struct task_struct *rtkscaler_dumpcrc_tsk;
  #ifndef CONFIG_KDRIVER_USE_NEW_COMMON
  static int data;
  static int rtkscaler_dumpcrc_thread(void *arg);
  #endif
  static unsigned long long f_offset_dumpcrc = 0 ;
  static int rtkscaler_dumpCRC_enable(const char *pattern, int length);
  static void rtkscaler_dumpCRC_disable(void);
#endif

//static unsigned char VSC_Device_Init_Done = FALSE;
//static unsigned char LivezoomMainRerunFlag = FALSE;
//unsigned char DataFramesynclivezoom = FALSE;
//static unsigned char check_only_xy_shift_same_region = FALSE;
//static unsigned char LivezoomOffKeepMainForceBG = FALSE;
//static unsigned char multiview_sub_interlace_flag = 0;//add HDMI sub channel field control @Crixus 20151203

//static unsigned short main_inputregion_x_pre = 0;
//static unsigned short main_inputregion_w_pre = 0;
//static unsigned short main_inputregion_x_ori_pre = 0;
//static unsigned short main_inputregion_w_ori_pre = 0;
//static unsigned char main_check_pre_flag = 0;

//static unsigned char DI_low_delay_flag = FALSE;

//static unsigned char g_ucCheckAVDandWebOSInfoCount = 0xff;

//unsigned char g_ucVSCCheckATVChanelChange;
//unsigned char g_ucVSCATVChanelChangeStart;
//unsigned char g_ucVSCATVSetWinBlankCount;
//unsigned char g_ucVDCDetectStage;

//#define CONFIG_FIXED_VD_27MHZ_960_TO_UZU 1
//#define CONFIG_MDOMAIN_COMPRESSION_ENBLE 1

#define VSC_PROFILE 0
#define _RGB2YUV_m11				0x00
#define _RGB2YUV_m12				0x01
#define _RGB2YUV_m13				0x02
#define _RGB2YUV_m21				0x03
#define _RGB2YUV_m22				0x04
#define _RGB2YUV_m23				0x05
#define _RGB2YUV_m31				0x06
#define _RGB2YUV_m32				0x07
#define _RGB2YUV_m33				0x08
#define _RGB2YUV_Yo_even			0x09
#define _RGB2YUV_Yo_odd			0x0a
#define _RGB2YUV_Y_gain				0x0b
#define _RGB2YUV_sel_RGB			0x0c
#define _RGB2YUV_set_Yin_offset		0x0d
#define _RGB2YUV_set_UV_out_offset	0x0e
#define _RGB2YUV_sel_UV_off			0x0f
#define _RGB2YUV_Matrix_bypass		0x10
#define _RGB2YUV_Enable_Y_gain		0x11
#endif // #ifndef UT_flag
#define REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD 	1920//960//1440


#define CHECK_AVD_WEBOS_INFO_TIMEOUT (30)

#define MSPG_AUTO_TEST
#define MSPG_AUTO_TEST_REGISTER SUB_VGIP_SUB_VCLK_CTRL_reg
#define MSPG_AUTO_TEST_START 0x00000001
#define MSPG_AUTO_TEST_SUCCESS 0x00000003
#define MSPG_AUTO_TEST_FAIL 0x00000007

#define FILM_DETECT_TO 30 // set film mode detect timeout to 600ms, for as avsync video latency

#define V_FREQ_THRESHOLD 985

//#define  _Mantis_74135
//#define  _Mantis_80057
//#define  _Mantis_72744
#define CONFIG_COMPRESSION_MODE_TEST
//#define WIN_DELAY_CALLBACK_PROFILE 1

int drivf_I3DDMA_3D_config(void);
#ifdef CONFIG_FORCE_RUN_I3DDMA
unsigned char drivf_i3ddma_config(unsigned char display, unsigned char src);
#endif
void drvif_I3DDMA_Init(void);
void I3DDMA_Parse_HDMI3D_pattern(void);
static void set_default_mcap_format(unsigned char display, VSC_INPUT_TYPE_T inputSrctype);//M Cap 444 or 422
//unsigned char Scaler_Set3DMode(unsigned char message, bool muteAudio);
unsigned char wait_atv_stable_for_bg(unsigned char display,char const* pfunc,unsigned int line);


#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
unsigned char rtk_hal_vsc_SetHdr10IdmaEnable(unsigned char bEnable);
#endif

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
static void update_arc_cmd_to_ring_buffer_sharemem(unsigned char display, KADP_VIDEO_RECT_T inregion, KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion,SCALER_VSC_INPUT_REGION_TYPE inputregion_type);
static DECLARE_WAIT_QUEUE_HEAD(ARC_CONTROL_WAIT_QUEUE);
static unsigned char main_arc_change_flag = FALSE;//main path arc change run scaler
static DEFINE_SPINLOCK(Main_ARC_Parm_Spinlock);/*Spin lock no context switch. This is for copy paramter*/
#ifdef CONFIG_DUAL_CHANNEL
static unsigned char sub_arc_change_flag = FALSE;//sub path arc change run scaler
static DEFINE_SPINLOCK(Sub_ARC_Parm_Spinlock);/*Spin lock no context switch. This is for copy paramter*/
#endif
#endif//#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
static DECLARE_WAIT_QUEUE_HEAD(HDMI_4K120_SE_WAIT_QUEUE);
static unsigned char hdmi_4k120_se_trigger_flag = FALSE;

KADP_VSC_ROTATE_T ap_main_rotate_type_parm;//for new input output. ap parameter from new hal //for main path
KADP_VIDEO_RECT_T ap_main_inregion_parm;//for new input output. main path ap parameter  from new hal
KADP_VIDEO_RECT_T ap_main_originalInput_parm;//for new input output. main path ap input resolution parameter from new hal
KADP_VIDEO_RECT_T ap_main_outregion_parm;//for new input output. main path ap input resolution parameter from new hal
static struct semaphore new_input_output_main_sem;//for main path new input out ap parameter semaphore
#ifdef CONFIG_DUAL_CHANNEL
KADP_VIDEO_RECT_T ap_sub_inregion_parm;//for new input output sub path ap parameter from new hal
KADP_VIDEO_RECT_T ap_sub_originalInput_parm;//for new input output. sub path ap input resolution parameter from new hal
KADP_VIDEO_RECT_T ap_sub_outregion_parm;//for new input output. sub path ap input resolution parameter from new hal
static struct semaphore new_input_output_sub_sem;//for sub path new input out ap parameter semaphore
#endif//#ifdef CONFIG_DUAL_CHANNEL

KADP_VIDEO_RECT_T air_mode_save_outregion_parm[MAX_DISP_CHANNEL_NUM];//for air mode save origin output.
unsigned char sub_hidden = FALSE;//for output = 0 sub hidden

#define VDC_DETECT_STAGE_FINAL 0xff
//static void apvr_request_run_main_path(void);//This api is for apvr need to run main path again
int sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
static int sub_mode_type = KADP_VSC_SUB_MODE_PIP;//PIP: Live zoom, magnifire //PBP: Multiview
unsigned char Scaler_CalWindowZoominForAVD(SCALER_DISP_CHANNEL display,VIDEO_RECT_T *inregion, VIDEO_RECT_T *outregion);
unsigned char Scaler_DispWindowZoominForAVD(SCALER_DISP_CHANNEL display, VIDEO_RECT_T inputwin, VIDEO_RECT_T outputwin, unsigned char changetomain);
extern unsigned char check_ott_dolby_update_run(void);
extern void Set_Reply_Zero_Timing_Flag(unsigned char src, unsigned char flag);
extern void modestate_set_display_timing(unsigned char dclk_is_max);
extern unsigned char modestate_decide_display_timing(void);
extern void memc_setting_displayDtiming_framerate(void);
extern unsigned char LiveZoom_MEMCClose_Flag;
extern unsigned char AspectRation_Zoom_MEMCClose_Flag;
extern struct semaphore* get_livezoom_memcclose_Semaphore(void);
extern void Scaler_AVD_EnableVD27MMode(VD_27M_OVERSAMPLING_MODE mode);
//===Test NN =================
#ifdef CONFIG_ENABLE_HDMI_NN
extern int h3ddma_get_NN_read_buffer(unsigned int *a_pulYAddr, unsigned int *a_pulCAddr, unsigned long long *uzd_timestamp, unsigned int *a_pulCropYAddr, unsigned int *a_pulCropCAddr, unsigned long long *crop_timestamp);
extern void h3ddma_get_NN_read_buffer_test(unsigned int *a_pulYAddr, unsigned int *a_pulCAddr);
extern void I3DDMA_ResetCap0(void);
extern void I3DDMA_ResetCap1(void);
extern int i3ddma_dump_data_to_file(void);
extern void h3ddma_nn_set_crop_size(unsigned int x, unsigned int y, unsigned int w, unsigned int h);
extern unsigned int scalerAI_get_AIPQ_mode_enable_flag(void);
extern unsigned int h3ddma_get_NN_start_buffer_addr(void);
extern void h3ddma_nn_set_sub_path_enable(unsigned char enable);

#endif
//====End of Test NN=========================

extern void vsc_adaptivestream_calc_outregion(unsigned char display);
extern void drvif_IESM_frontporch_set(unsigned char game_mode_flag);

unsigned char scaler_atv_force_run_idma(void);

static dev_t vsc_devno = 0;//vsc device number
#ifndef UT_flag
static struct cdev vsc_cdev;
#endif // #ifndef UT_flag
//Eric@0809
unsigned char VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
unsigned short virtual_x=0,virtual_y=0,virtual_w=0,virtual_h=0;
unsigned short true_wide=0,true_high=0;
unsigned short shape_wide=0,shape_high=0;

//Game mode cmd checking flow @Cixus 20161204
unsigned int game_mode_cmd_check = 0;
VIDEO_WID_T BLK_WID = 0;
static unsigned char game_mode_ignore_cmd_check = 0;

unsigned int smooth_toggle_game_mode_timeout_trigger_flag = 0;
unsigned int smooth_toggle_game_mode_check_cnt = 0;

extern unsigned int disp_smooth_variable_setting_flag;
KADP_SCALER_WIN_CALLBACK_DELAY_INFO g_scaler_win_delay_cb_info;
UINT8 g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 0;

unsigned int mdomain_input_fast_flag = 0;
#ifdef BRING_UP_I2RND
unsigned char i2rnd_brungup_setting_done = 0;
#endif
struct vsc_film_mode_parameter_t film_mode_parameter = {0,0,0};
unsigned int game_mode_cmd_pre = 0;
unsigned int st_game_mode_cmd_pre = 0;
extern unsigned int ori_voclk_ratio_num;
unsigned int idomain_vfreq_pre = 0;
extern SCALER_DATA_FS_ALGO_RESULT g_tDataFsAlgoResult;
unsigned char scaler_RGB444Mode_pre = 0;
unsigned char vsc_force_rerun_main_scaler = 0;
static unsigned char scaler_linebuffer_mode_finish = TRUE;//This is for scaler part all line buffer driver check or setting finish use to sync game mode
extern void Scaler_MEMC_Set_VpqLowDelayToMEMC_Flag(unsigned char u1_mode);
extern void vbe_disp_set_stop_memc_push_flag(unsigned char bOnOff);

#ifdef WIN_DELAY_CALLBACK_PROFILE
typedef struct _SCALER_WIN_CALLBACK_GLOBAL_PROFILE {//for scaler to check av sync
	UINT32 _90k_cnt;
	KADP_VIDEO_RECT_T  OutputRegion;
	UINT32 uzulcnt;
} _SCALER_WIN_CALLBACK_GLOBAL_PROFILE;

_SCALER_WIN_CALLBACK_GLOBAL_PROFILE gCallback_profile = {0};
#endif

unsigned char scaler_timing_mode_setting = 0;

//unsigned int main_opensourceID = _UNKNOWN_INPUT;
//#ifdef CONFIG_DUAL_CHANNEL
//unsigned int sub_opensourceID = _UNKNOWN_INPUT;
//#endif
//static unsigned char main_VO_smoothtoggle_need_presetting = FALSE;

static int flag_vsc_check_dolby_mode_change;

void set_vsc_check_dolby_mode_change_flag(void)
{
	flag_vsc_check_dolby_mode_change = true;
}


DECLARE_WAIT_QUEUE_HEAD(FORCEBG_WAIT_QUEUE);
DECLARE_WAIT_QUEUE_HEAD(DEBUGTSK_WAIT_QUEUE);//for runtime pm use wakeup tsk to pending

void update_vsc_task_status(unsigned char ctrl, unsigned int status)
{//ctrl: 1  set    0: clear
    if(ctrl)
    {
        vsc_task_status = vsc_task_status | status;
    }
    else
    {
        vsc_task_status = vsc_task_status & (~status);
    }
}


unsigned int get_vsc_task_running_status(void)
{
    return vsc_task_status;
}

void scaler_data_frame_sync_enable_gatting(unsigned char webos_src)
{
		//VDEC 2k1k use original flow, framesync with gatting
		if(((webos_src == VSC_INPUTSRC_VDEC)
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
			&& !((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > DATAFS_DISABLE_GATTING_WIDTH) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > DATAFS_DISABLE_GATTING_HEIGHT))
#endif
			//for KTASKWBS-17872, rotate case, game mode already done
			&& ((!drv_memory_get_low_delay_game_mode_dynamic()||(drv_memory_get_game_mode_flag() == drv_memory_get_low_delay_game_mode_dynamic()))
			|| (drv_memory_get_vdec_direct_low_latency_mode()==TRUE))) // vdec direct enable gating in scaler flow.
			||((webos_src == VSC_INPUTSRC_HDMI) && (!drv_memory_get_low_delay_game_mode_dynamic() || (drv_memory_get_low_delay_game_mode_dynamic() && is_game_mode_set_line_buffer()))) || (webos_src == VSC_INPUTSRC_JPEG))
		{
			//IoReg_SetBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
			//onms_onms1_status_RBUS onms_onms1_status_reg;
			if((webos_src == VSC_INPUTSRC_VDEC) && (Scaler_Get_Vo_Force_60_Framerate_State() == VO_ORIGINAL_24_FORCE_60)) {
				rtd_pr_vsc_emerg("Delay Gating for vo 24 to 60 flow!\n");
			}else{
        			unsigned int frame_delay = 0;
        			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 0)
        				frame_delay = (10000/Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ));
        			//Scaler_wait_for_frc2fs_hw_lock_done(SLR_MAIN_DISPLAY);
        			Scaler_wait_for_LCM_done();
        			scaler_set_full_gatting_rpc(true);
        			rtd_pr_vsc_notice("Enable gatting delay to input timing change\n");
        			//delay 1 frame
        			usleep_range(frame_delay * 1000, frame_delay * 1000);
			}
			framesync_clear_ibuffer_err_status();
			MODE_CLEAR_ONMS_FLAG();

			if(((webos_src == VSC_INPUTSRC_VDEC) || (webos_src == VSC_INPUTSRC_JPEG))//vo smooth toggle don't need onlinemeasure
				&& (_ENABLE == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
			{
				//Real Vo case
				drvif_mode_enableonlinemeasure(SLR_MAIN_DISPLAY);//Enable online measure
				drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_VO, TRUE, FALSE);
				rtd_pr_vsc_notice("Data FS enable ONMS!\n");
			}
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LB_MODE_GATTING_NOT_READY, 0);//disable line buffer mode gatting not ready mask
		}
}


//Below is used to check run scaler source already change or not
static struct semaphore vsc_src_verify_num_ctrl_sem;
static unsigned char source_connect_verify_num[MAX_DISP_CHANNEL_NUM] =
{//record vsc connect number. verify used. confirm vsc source connect numebt
	0,
#ifdef CONFIG_DUAL_CHANNEL
	0
#endif
};


void set_latency_pattern_info(VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern)
{
#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
	if(memcmp(&hal_video_latency_pattern_info, &set_video_latency_pattern, sizeof(VSC_VIDEO_LATENCY_PATTERN_T)))
	{//different parameter
		unsigned long flags;//for spin_lock_irqsave
		//Eric@20180626 vdec source no need enable dma vgip isr
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_VDEC){
			if(!((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120))))
			{
				dma_vgip_dma_vgip_ctrl_RBUS dma_vgip_chn1_ctrl_reg;
				dma_vgip_chn1_ctrl_reg.regValue = IoReg_Read32(DMA_VGIP_DMA_VGIP_CTRL_reg);
				if(!dma_vgip_chn1_ctrl_reg.dma_vact_start_ie)
				{
					dma_vgip_chn1_ctrl_reg.dma_vact_start_ie = 1;
					IoReg_Write32(DMA_VGIP_DMA_VGIP_CTRL_reg, dma_vgip_chn1_ctrl_reg.regValue);
				}
			}
		}
		spin_lock_irqsave(&latency_pattern_spinlock, flags);
		memcpy(&hal_video_latency_pattern_info, &set_video_latency_pattern, sizeof(VSC_VIDEO_LATENCY_PATTERN_T));
		latency_pattern_change = TRUE;
		spin_unlock_irqrestore(&latency_pattern_spinlock, flags);
	}
#endif
}

void set_latency_pattern_self_test(unsigned char b_On)
{
	latency_pattern_self_test = b_On;
}

void latency_pattern_self_test_run(void)
{
	static unsigned char latency_pattern_self_test_pre = 0;
	static unsigned char pattern_type = KADP_VSC_PATTERN_BLACK;
	VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern;

	if(latency_pattern_self_test_pre != latency_pattern_self_test){
		if(latency_pattern_self_test==0){
			set_video_latency_pattern.bOnOff = 0;
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_BLACK;
			set_video_latency_pattern.overlayWindow.x = 0;
			set_video_latency_pattern.overlayWindow.y = 0;
			set_video_latency_pattern.overlayWindow.w = 480;
			set_video_latency_pattern.overlayWindow.h = 480;
			set_latency_pattern_info(set_video_latency_pattern);
			pattern_type = set_video_latency_pattern.bPatternType;
		}
		latency_pattern_self_test_pre = latency_pattern_self_test;
	}

	if(latency_pattern_self_test){
		set_video_latency_pattern.bOnOff = 1;
		if(pattern_type == KADP_VSC_PATTERN_BLACK){
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_WHITE;
			rtd_pr_vsc_emerg( "videolatency white\n");
		}else{
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_BLACK;
			rtd_pr_vsc_emerg( "videolatency black\n");
		}
		set_video_latency_pattern.overlayWindow.x = 0;
		set_video_latency_pattern.overlayWindow.y = 0;
		set_video_latency_pattern.overlayWindow.w = 480;
		set_video_latency_pattern.overlayWindow.h = 480;
		set_latency_pattern_info(set_video_latency_pattern);
		pattern_type = set_video_latency_pattern.bPatternType;
		msleep(1000);
	}
}

static unsigned char cur_main_vsc_src_num = 0;//currently run scaler main path vsc source num
static unsigned char cur_sub_vsc_src_num = 0;//currently run scaler sub path vsc source num

void sync_pc_mode_info(void)
{//currently only decide yuv422 and enable pc mode or not
	pc_mode_sync_info* pc_mode_info = NULL;

	rtd_pr_vsc_debug("src=%x, color space=%x, get_vsc_run_pc_mode=%x\n", Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE), get_vsc_run_pc_mode());
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);
	if(pc_mode_info)
	{
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && get_vsc_run_pc_mode())
		{
			if((drvif_Hdmi_GetColorSpace() == COLOR_RGB) || (drvif_Hdmi_GetColorSpace() == COLOR_YUV444))
			{
				pc_mode_info->input444_pc_mode = 1;
				pc_mode_info->input422_pc_mode = 0;
			}
			else
			{
				pc_mode_info->input444_pc_mode = 0;
				pc_mode_info->input422_pc_mode = 1;
			}
		}
		else
		{
			pc_mode_info->input444_pc_mode = 0;
			pc_mode_info->input422_pc_mode = 0;
		}
	}

#ifdef ENABLE_FORCE_PC_MODE
	// Test PC mode
	rtd_pr_vsc_info("force input444_pc_mode = 1\n");
	pc_mode_info->input444_pc_mode = 1;
#endif
}

unsigned char pc_mode_run_422(void)
{
	pc_mode_sync_info* pc_mode_info = NULL;
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);
	if(pc_mode_info)
	{
		return pc_mode_info->input422_pc_mode;
	}
	return 0;
}

unsigned char pc_mode_run_444(void)
{
	pc_mode_sync_info* pc_mode_info = NULL;
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);


#ifdef ENABLE_FORCE_PC_MODE
	pc_mode_info->input444_pc_mode = 1;
	return 1;
#else
	if(pc_mode_info)
	{
		return pc_mode_info->input444_pc_mode;
	}
	return 0;
#endif
}

unsigned char get_source_connect_verify_num(unsigned char display)
{
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n get_source_connect_verify_num display(%d) error", display);
		return 0;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n get_source_connect_verify_num display(%d) error", display);
		return 0;
	}
#endif
		return source_connect_verify_num[display];
}

void increase_source_connect_verify_num(unsigned char display)
{
	#define max_source_verify_num 200
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n increase_source_connect_verify_num display(%d) error", display);
		return;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n increase_source_connect_verify_num display(%d) error", display);
		return;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(source_connect_verify_num[display] == max_source_verify_num)
		source_connect_verify_num[display] = 0;
	else
		source_connect_verify_num[display] =  source_connect_verify_num[display] + 1;
	up(&vsc_src_verify_num_ctrl_sem);
}

void set_current_scaler_source_num(unsigned char display)
{//set cur_vsc_src_num form get_source_connect_verify_num
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(display == SLR_MAIN_DISPLAY)
		cur_main_vsc_src_num = source_connect_verify_num[display];
	else
		cur_sub_vsc_src_num = source_connect_verify_num[display];
	up(&vsc_src_verify_num_ctrl_sem);

}

unsigned char compare_rerify_vsc_source_num_result(unsigned char display)
{//return TRUE: source not change.  return false: source change
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		rtd_pr_vsc_err("\r\n rerify_vsc_source_num_result display(%d) error", display);
		return TRUE;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		rtd_pr_vsc_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return TRUE;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(display == SLR_MAIN_DISPLAY)
	{
		if(cur_main_vsc_src_num == source_connect_verify_num[display])
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return TRUE;
		}
		else
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return FALSE;
		}
	}
	else
	{
		if(cur_sub_vsc_src_num == source_connect_verify_num[display])
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return TRUE;
		}
		else
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return FALSE;
		}
	}
}
//Above is used to check run scaler source already change or not


unsigned char rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * poutregion);

static SCALER_VSC_INPUT_REGION_TYPE hal_main_InputRegionType =  INPUT_BASE_ON_TIMING;
static StructSrcRect main_dispwin;//Temp record main output info
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
static StructSrcRect main_dlg_dispwin;
static unsigned char dlgOsdDisable = 0;
#endif
StructSrcRect main_input_size;
static StructSrcRect main_input_timing;
static StructSrcRect main_dispwin_pre = {0, 0, 0, 0};//Record previous main output info
static StructSrcRect main_input_size_pre = {0, 0, 0, 0};//Record previous main output info
static StructSrcRect main_input_timing_pre = {0, 0, 0, 0};//Record previous main input timing info
static StructSrcRect main_dispwin_for_only_xy = {0, 0, 0, 0};//Record previous main output info for apply_only_xy_shift

static KADP_VSC_INPUT_SRC_INFO_T DisplayModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T VencModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T MemoryModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T AveModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};

static DIRECT_VO_FRAME_ORIENTATION main_rotate_mode = DIRECT_VO_FRAME_ORIENTATION_DEFAULT; //this is the current rotate mode from webos
static DIRECT_VO_FRAME_ORIENTATION main_rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT; //this is the last rotate mode from webos

//static unsigned char OuputDisplayMode = FALSE;
//static unsigned char OutputVencMode = FALSE;
//static unsigned char OutputMemoryMode = FALSE;
//static unsigned char OutputAveMode = FALSE;
//static unsigned char RGB444Mode = TRUE;
//static unsigned char VscMuteStatus = FALSE;
unsigned char OutpuLocalDimmingPatMode = FALSE;
unsigned char LocalDimmingDemoCtrlMode = FALSE;
unsigned char LocalDimmingDemoCtrlType = 0;


//static unsigned char Main_AutoRunScaler = FALSE;//Mean when running scaler and set output again. let it auto run scaler. For ATV
//static char Main_Run_Scaler_flag = FALSE;//Mean that Scaler task to run main scaler
//static char Main_Output_Set_flag = FALSE;//Mean that set main setoutput region
//static char Main_force_frc_flag = FALSE;
//static char Main_force_frc_fs_flag = FALSE;
//static char Main_Scaler_Stop_flag = FALSE;//Mean that don't let task run main scaler. Because disconnet
//static char Main_ATV_Go_Smooth_Toggle_flag = FALSE;//Mean ATV current no mute, so can run smooth toggle
//static char Main_smooth_toggle_set_flag = FALSE;//Mean that Scaler task to run smooth toggle
//static char Main_ATV_PassThrought_output_flag = FALSE;//Mean ATV pass throught set output region. Let set winblank off work directly
//static char Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;//Mean that wait mute off to set Main_smooth_toggle_set_flag
//static char Main_Request_ForceBG_ctrl = FALSE;//Mean webos call set main winblank on/off
//static char Main_Reset_Mode_flag = FALSE;//Run Mode Reset mode
//static unsigned char Main_Reset_Mode_flag = FALSE;//Record during runing scaler. Can not mute off
#ifdef CONFIG_DUAL_CHANNEL
static SCALER_VSC_INPUT_REGION_TYPE hal_sub_InputRegionType;
static StructSrcRect sub_dispwin;//Temp record sub output info
static StructSrcRect sub_input_size;
static StructSrcRect sub_input_timing = {0, 0, 0, 0};
static StructSrcRect sub_dispwin_pre = {0, 0, 0, 0};//Record previour sub output info
static StructSrcRect sub_input_size_pre = {0, 0, 0, 0};//Record previour sub output info
#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
static StructSrcRect sub_input_timing_pre = {0, 0, 0, 0};//Record previour sub input timing info
#endif

static KADP_VSC_INPUT_SRC_INFO_T Sub_DisplayModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_VencModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_MemoryModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_AveModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };

//static unsigned char Sub_OuputDisplayMode = FALSE;
//static unsigned char Sub_OutputVencMode = FALSE;
//static unsigned char Sub_OutputMemoryMode = FALSE;
//static unsigned char Sub_OutputAveMode = FALSE;
//static char Sub_Run_Scaler_flag = FALSE;//Mean that Scaler task to run Sub scaler
//static char Sub_Output_Set_flag = FALSE;//Mean that set sub setoutput region
//static char Sub_Scaler_Stop_flag = FALSE;//Mean that don't let task run sub scaler. Because disconnet
//static unsigned char Sub_AutoRunScaler = FALSE;//Mean when running scaler and set output again. let it auto run scaler. For ATV
//static char Sub_ATV_Go_Smooth_Toggle_flag = FALSE;//Mean ATV current no mute, so can run smooth toggle
//static char Sub_Request_ForceBG_ctrl = FALSE;//Mean webos call set sub winblank on/off
//static char Sub_Reset_Mode_flag = FALSE;//Run SUB Reset mode

#endif

extern unsigned short Main_InputRegion_x;
extern unsigned short Main_InputRegion_y;
extern unsigned short Main_InputRegion_w;
extern unsigned short Main_InputRegion_h;
#ifdef CONFIG_DUAL_CHANNEL
extern unsigned short Sub_InputRegion_x;
extern unsigned short Sub_InputRegion_y;
extern unsigned short Sub_InputRegion_w;
extern unsigned short Sub_InputRegion_h;
#endif

extern StructSrcRect Scaler_intputRegion[MAX_DISP_CHANNEL_NUM];
extern StructSrcRect Scaler_intputTiming[MAX_DISP_CHANNEL_NUM];


//unsigned short Main_ATV_InputRegion_x_pre;
//unsigned short Main_ATV_InputRegion_y_pre;
//unsigned short Main_ATV_InputRegion_w_pre;
//unsigned short Main_ATV_InputRegion_h_pre;
#ifdef CONFIG_DUAL_CHANNEL
//unsigned short Sub_ATV_InputRegion_x_pre;
//unsigned short Sub_ATV_InputRegion_y_pre;
//unsigned short Sub_ATV_InputRegion_w_pre;
//unsigned short Sub_ATV_InputRegion_h_pre;
#endif


//unsigned short Main_ATV_OutputRegion_x_pre;
//unsigned short Main_ATV_OutputRegion_y_pre;
//unsigned short Main_ATV_OutputRegion_w_pre;
//unsigned short Main_ATV_OutputRegion_h_pre;
#ifdef CONFIG_DUAL_CHANNEL
//unsigned short Sub_ATV_OutputRegion_x_pre;
//unsigned short Sub_ATV_OutputRegion_y_pre;
//unsigned short Sub_ATV_OutputRegion_w_pre;
//unsigned short Sub_ATV_OutputRegion_h_pre;
#endif

//unsigned char main_winfreeze;


//unsigned char JPEG_Scaler_SM;
extern void ADC_set_detect_flag(unsigned char enable);
extern void VDC_set_detect_flag(unsigned char enable);
extern unsigned char VDC_get_detect_flag(void);
extern void HDMI_set_detect_flag(unsigned char enable);
extern struct semaphore* get_adc_adjustsemaphore(void);
extern struct semaphore *get_adc_detectsemaphore(void);
extern struct semaphore *get_vdc_detectsemaphore(void);
extern struct semaphore *get_hdmi_detectsemaphore(void);
extern struct semaphore *get_setsource_semaphore(void);
extern struct semaphore* get_scaler_fll_running_semaphore(void);
extern StructDisplayInfo * Get_ADC_Dispinfo(void);
extern StructDisplayInfo * Get_AVD_ScalerDispinfo(void);
extern ModeInformationType *Get_AVD_ScalerTiminginfo(void);
extern StructDisplayInfo * Get_VO_Dispinfo(unsigned char);
extern struct semaphore* get_vo_infosemaphore(void);
extern unsigned char get_vo_change_flag(unsigned char);
extern void set_vo_change_flag(unsigned char, unsigned char);
extern unsigned char ADC_Check_VSC_VFE_ConnectSrc_Match(unsigned int vsc_src);
extern unsigned char Check_DisplayFrame_isRightColorbar(void);
//void set_vsc_SetCircle_OutputRegion(VIDEO_RECT_T outregion, unsigned short W, unsigned short H, UINT32 num);
void wait_game_mode_frame_delay_done(void);
extern void UpdateDataFsAlgoRsult(void);

//unsigned int  sub_zoom_disp_hpos = 0;//For Scaler use
//unsigned int  sub_zoom_disp_vpos = 0;//For Scaler use
//unsigned int  sub_zoom_disp_hsize = 0;//For Scaler use
//unsigned int  sub_zoom_disp_vsize = 0;//For Scaler use
//static unsigned char sub_wind0000 = FALSE;
//static unsigned char main_wind0000 = FALSE;

//static unsigned char adaptive_stream;
//static unsigned char adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
//static unsigned char line_cnt_no_run_hdmi_check = 0;

//unsigned char hdmi_dolby_vision_flag = FALSE; //for dm function to adjust hdmi dolby vision detect result

struct semaphore Memc_Realcinema_Semaphore;/*For adaptive streaming info Semaphore*/
//char memc_realcinema_run_flag = FALSE;//Run memc mode
extern void memc_realcinema_framerate(void);

struct semaphore Iv2dv_Slow_Tuning_Semaphore;
//char run_iv2dv_slow_tuning_flag = FALSE;//Run iv2dv slow tuning flag
extern void drv_run_GameMode_iv2dv_slow_tuning(void);
static UINT8 enable_VSC_GameMode = _DISABLE;

struct semaphore VPQ_ld_running_Semaphore;/*For adaptive streaming info Semaphore*/

struct semaphore VPQ_DeXC_MEM_Semaphore;/*For Dexc MEM*/

//I2RND semaphore
struct semaphore I2RND_display_Semaphore;
struct semaphore I2RND_Semaphore;
#if 0
#ifdef CONFIG_I2RND_ENABLE
static unsigned char run_i2rnd_flag = 0;
#endif
#endif

//static unsigned char vpq_ld_first_boot = FALSE; //dc off/on condition, set at resume
extern unsigned char vpq_ld_running_flag;
extern unsigned char vpq_led_LDEnable;
//extern unsigned int ld_time_tick;
extern void drvif_HAL_VPQ_LED_LDEnable(unsigned char bCtrl);
extern unsigned char  fwif_color_get_black_detection_info_tv006(VIP_BlackDetectionInfo* BlackDetectionInfo);
extern unsigned char modestate_decide_display_timing(void);

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
//struct timer_list OrbitTimerList;
void Scaler_Orbit_Timer_Init(void);
#ifndef UT_flag
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
void OrbitTimer(struct timer_list *t);
#else
void OrbitTimer(void);
#endif
void Scaler_Orbit_Timer_Delete(void);

/* timer init*/
/* init_timer(&OrbitTimerList); */
/* OrbitTimerList.data = ((unsigned long) 0); */
/* OrbitTimerList.function = (void *)OrbitTimer; */
/* OrbitTimerList.expires = jiffies + ORBIT_TIME*HZ; */
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
DEFINE_TIMER(OrbitTimerList, (void *)OrbitTimer);
#else
DEFINE_TIMER(OrbitTimerList, (void *)OrbitTimer, 0, 0);
#endif
#endif // #ifndef UT_flag
static unsigned char g_ucTimerInitCount = 0;

#endif

#ifndef CONFIG_DOLBY_IDK_1_6_1_1
// For Dolby letter box DTG change
extern spinlock_t* dolby_letter_box_spinlock(void);
extern unsigned int dolby_proverlay_background_h_start_end;//For letter box use.Record h start and end
extern unsigned int dolby_proverlay_background_v_start_end;//For letter box use. Record V start and end
extern unsigned char letter_box_black_flag;//For letter box use. Need force BG black
extern unsigned char request_letter_dtg_change;//For letter box use. Requesttsk to run
#endif
//
#ifdef CONFIG_I2RND_ENABLE
unsigned char vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
unsigned char vsc_i2rnd_sub_output_mode = 0;
unsigned char vsc_i2rnd_sub_input_type = 0;
unsigned char vsc_i2rnd_sub_input_port = 0;
static unsigned char vsc_i2rnd_initial_done = _DISABLE;
unsigned char vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE; //for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
unsigned char vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_DISABLE;
extern SLR_VOINFO i2rnd_main_voinfo;
extern SLR_VOINFO i2rnd_sub_voinfo;
extern SLR_VOINFO i2rnd_empty_voinfo;
extern unsigned char vo_timing_change_for_adaptive;
//unsigned char i2r_main_pre_resourceIndex = 0;
//unsigned char i2r_sub_pre_resourceIndex = 0;
#ifdef CONFIG_PST_ENABLE
static unsigned char vsc_pst_initial_done = _DISABLE;
#endif
#endif

//k4lp new hal api - mute off callback. When mute off to callback api
unsigned char main_muteoff_cb_trigger = FALSE;
unsigned char sub_muteoff_cb_trigger = FALSE;
struct semaphore muteoff_cb_sem;
DEFINE_SPINLOCK(delay_info_cb_spinlock);

unsigned char delay_info_cb_trigger = FALSE;

static DECLARE_WAIT_QUEUE_HEAD(MUTEOFF_CB_WAIT_QUEUE);
static DECLARE_WAIT_QUEUE_HEAD(WIN_DELAY_CB_WAIT_QUEUE);


StructSrcRect get_main_dispwin(void)
{
	return main_dispwin;
}

StructSrcRect get_main_input_size(void)
{
	return main_input_size;
}

void set_shiftxy_main_inputpre(StructSrcRect input_size )
{
	main_input_size_pre=input_size;
}

void set_shiftxy_main_dispwinpre(StructSrcRect out_size )
{
	main_dispwin_for_only_xy=out_size;
}

#ifndef UT_flag
unsigned int vsc_poll(struct file *filp, struct poll_table_struct *wait){
/*
       poll_wait(filp, &mute_off_callback, wait);
       return POLLIN | POLLRDNORM;
*/
		return 0;
}
#endif // #ifndef UT_flag
spinlock_t* get_delay_info_cb_spin_lock(void)
{//this is for delay_info_cb_trigger flag protection
	return &delay_info_cb_spinlock;
}


void update_win_apply_delay_info_for_cb(unsigned char display, KADP_SCALER_WIN_CALLBACK_DELAY_INFO *p_scaler_win_delay_cb_info)
{
	if(display == SLR_MAIN_DISPLAY)
	{
		if(g_scalerForceUpdate_CB_by_InputOutput_Region_Flag){
			memcpy((void*) p_scaler_win_delay_cb_info, (void*) &g_scaler_win_delay_cb_info, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO));
			Scaler_Reset_ForceUpdate_Callback_Delay_Info();
		}else{
			Scaler_Fulfill_Callback_Delay_Info(p_scaler_win_delay_cb_info);
		}
		if(p_scaler_win_delay_cb_info->delayTime > 200)
			p_scaler_win_delay_cb_info->delayTime = 16;


#ifdef WIN_DELAY_CALLBACK_PROFILE
		if((p_scaler_win_delay_cb_info->OutputRegion.x == gCallback_profile.OutputRegion.x) &&
			(p_scaler_win_delay_cb_info->OutputRegion.y == gCallback_profile.OutputRegion.y) &&
			(p_scaler_win_delay_cb_info->OutputRegion.w == gCallback_profile.OutputRegion.w) &&
			(p_scaler_win_delay_cb_info->OutputRegion.h == gCallback_profile.OutputRegion.h))
		{
			unsigned int current_90K=0;

			current_90K = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);

			rtd_pr_vsc_err("[PROFILE_CALLBACK] c90k=%x. 90k=%x, diff=%d, (%d.%d.%d.%d)(line:%d) \n", current_90K, gCallback_profile._90k_cnt, (current_90K-gCallback_profile._90k_cnt)/90,
				gCallback_profile.OutputRegion.x, gCallback_profile.OutputRegion.y, gCallback_profile.OutputRegion.w, gCallback_profile.OutputRegion.h,
				gCallback_profile.uzulcnt);
		}else{
			rtd_pr_vsc_err("[PROFILE_CALLBACK] Cannot Match!! (%d.%d.%d.%d) / (%d.%d.%d.%d)\n",
				p_scaler_win_delay_cb_info->OutputRegion.x, p_scaler_win_delay_cb_info.->OutputRegion.y, p_scaler_win_delay_cb_info->OutputRegion.w, p_scaler_win_delay_cb_info->OutputRegion.h,
				gCallback_profile.OutputRegion.x, gCallback_profile.OutputRegion.y, gCallback_profile.OutputRegion.w, gCallback_profile.OutputRegion.h);
		}
#endif
	}
}


void wakeup_mute_off_callback(unsigned char display)
{//this is wake up to call webos callback function to notice mute off
#ifdef CONFIG_SCALER_ENABLE_V4L2
	extern void vsc_v4l2_muteoff_event_wakeup(unsigned char display);
	vsc_v4l2_muteoff_event_wakeup(display);//mute off event wake up
#endif
	if(display == SLR_MAIN_DISPLAY)
	{
		down(&muteoff_cb_sem);
		main_muteoff_cb_trigger = TRUE;
		up(&muteoff_cb_sem);
	}
	else
	{
		down(&muteoff_cb_sem);
		sub_muteoff_cb_trigger = TRUE;
		up(&muteoff_cb_sem);
	}
	wake_up(&MUTEOFF_CB_WAIT_QUEUE);
}

void wakeup_window_delay_info_callback(unsigned char display, unsigned char call_by_isr)
{//this is wake up to call webos callback function to notice mute off
#ifdef CONFIG_SCALER_ENABLE_V4L2
	extern void vsc_v4l2_win_apply_done_event_wakeup(unsigned char display);
	if(display == SLR_MAIN_DISPLAY)
	{
		vsc_v4l2_win_apply_done_event_wakeup(display);
	}
#endif
#if 0
	unsigned long flags;
	if(display == SLR_MAIN_DISPLAY)
	{
		//if call by isr, need use spin_lock/spin_unlock
		//if call by task, need use spin_lock_irqsave/spin_unlock_irqrestore
		if(call_by_isr){
			spin_lock(get_delay_info_cb_spin_lock());//lock delay_info_cb_trigger spinlock
			delay_info_cb_trigger = TRUE;
			spin_unlock(get_delay_info_cb_spin_lock());//unlock delay_info_cb_trigger spinlock
		}
		else{
			spin_lock_irqsave(get_delay_info_cb_spin_lock(), flags);//lock delay_info_cb_trigger spinlock
			delay_info_cb_trigger = TRUE;
			spin_unlock_irqrestore(get_delay_info_cb_spin_lock(), flags);//unlock delay_info_cb_trigger spinlock
		}
	}
	wake_up(&WIN_DELAY_CB_WAIT_QUEUE);
#endif
}
#ifndef UT_flag
struct semaphore* get_gamemode_check_semaphore(void)
{
	return &GameMode_Check_Semaphore;
}
#endif // #ifndef UT_flag

unsigned char force_i3ddma_enable = false;
unsigned char nn_force_i3ddma_enable = false;
void set_nn_force_i3ddma_enable(UINT8 enable)
{
	nn_force_i3ddma_enable = enable;
}

UINT8 get_nn_force_i3ddma_enable(void)
{
	return nn_force_i3ddma_enable;
}

void set_force_i3ddma_enable(UINT8 enable)
{
	if(enable == true){
		//clear nn force i3ddma flag
		set_nn_force_i3ddma_enable(false);
	}

	force_i3ddma_enable = enable;
}

UINT8 get_force_i3ddma_enable_impl(unsigned char display)
{
	if(display == SLR_MAIN_DISPLAY)
		return force_i3ddma_enable;
	else
		return 0;
}
unsigned char (*get_force_i3ddma_enable)(unsigned char) = get_force_i3ddma_enable_impl;

unsigned char get_vdec8Kflag(unsigned char display)
{
       SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

       if((display == SLR_MAIN_DISPLAY) &&(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC))
               return pVOInfo->is8K;
       else
               return 0;
}

void wait_memc_ready(void)
{
	unsigned int sleep_time = 0;
	unsigned int output_framerate = 0;

	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) &&  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO)
		&& Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO))
		output_framerate = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) * Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) / (10 * Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO));
	else
		output_framerate = 60;


	sleep_time = MAX_MEMC_DELAY_BUFFER * 100 / output_framerate;
	msleep(sleep_time);
	rtd_pr_vsc_notice("\r\n#### func:%s wait_time:%d framerate:(%d %d %d)####\r\n",__FUNCTION__, sleep_time, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ),  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO));
}


void wait_game_mode_finish(void)
{//if game mode switch. scaler need to wait finish
	unsigned char count = 100;//1000 ms
	down(&GameMode_SCALER_SYNC_Semaphore);
	while(count && DbgSclrFlgTkr.game_mode_dynamic_flag)
	{
		count--;
		msleep(0);//wait 10ms
	}
	up(&GameMode_SCALER_SYNC_Semaphore);
	if(count != 100)
	{
		rtd_pr_vsc_notice("\r\n## func:%s count:%d####\r\n",__FUNCTION__, count);
	}
}

KADP_VSC_SUB_MODE_T get_sub_mode(void)
{
//Get sub current mode
//PIP: Live zoom, magnifire
//PBP: Multiview
//default mode is pip
	return (KADP_VSC_SUB_MODE_T)sub_mode_type;
}

VSC_SUB_SHAPE_T get_shape_mode(void)
{

	return (VSC_SUB_SHAPE_T)sub_shape_type;
}

StructSrcRect Scaler_SubDispWindowGet(void)
{
	StructSrcRect subWindow;
	subWindow.srcx = DbgSclrFlgTkr.sub_zoom_disp_hpos;
	subWindow.srcy = DbgSclrFlgTkr.sub_zoom_disp_vpos;
	subWindow.src_wid = DbgSclrFlgTkr.sub_zoom_disp_hsize;
	subWindow.src_height = DbgSclrFlgTkr.sub_zoom_disp_vsize;
	return subWindow;
}

void Scaler_SubDispWindowSet(StructSrcRect subWindow)
{
	DbgSclrFlgTkr.sub_zoom_disp_hpos = subWindow.srcx;
	DbgSclrFlgTkr.sub_zoom_disp_vpos = subWindow.srcy;
	DbgSclrFlgTkr.sub_zoom_disp_hsize = subWindow.src_wid;
	DbgSclrFlgTkr.sub_zoom_disp_vsize = subWindow.src_height;
}

unsigned char get_sub_OutputVencMode(void)
{
	return DbgSclrFlgTkr.Sub_OutputVencMode;
}

unsigned char get_main_OutputVencMode(void)
{
	return DbgSclrFlgTkr.OutputVencMode;
}

void set_atv_go_smooth_toggle_flag(unsigned char display, unsigned char flag)
{
	if (display == SLR_MAIN_DISPLAY)
		DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = flag;
#ifdef CONFIG_DUAL_CHANNEL
	else
		DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag = flag;
#endif
}

void Set_vsc_input_src_info(unsigned char display,KADP_VSC_OUTPUT_MODE_T vsc_output_mode, KADP_VSC_INPUT_SRC_INFO_T source_info)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if (KADP_VSC_OUTPUT_DISPLAY_MODE  == vsc_output_mode) {
			DisplayModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_VENC_MODE  == vsc_output_mode) {
			VencModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_MEMORY_MODE  == vsc_output_mode) {
			MemoryModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_AVE_MODE  == vsc_output_mode) {
			AveModeInputInfo = source_info;
		}
	} else if (display == SLR_SUB_DISPLAY) {
		if (KADP_VSC_OUTPUT_DISPLAY_MODE  == vsc_output_mode) {
			Sub_DisplayModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_VENC_MODE  == vsc_output_mode) {
			Sub_VencModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_MEMORY_MODE  == vsc_output_mode) {
			Sub_MemoryModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_AVE_MODE  == vsc_output_mode) {
			Sub_AveModeInputInfo = source_info;
		}
	}
#else
	if (display == SLR_MAIN_DISPLAY) {
		if (KADP_VSC_OUTPUT_DISPLAY_MODE  == vsc_output_mode) {
			DisplayModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_VENC_MODE  == vsc_output_mode) {
			VencModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_MEMORY_MODE  == vsc_output_mode) {
			MemoryModeInputInfo = source_info;
		} else if (KADP_VSC_OUTPUT_AVE_MODE  == vsc_output_mode) {
			AveModeInputInfo = source_info;
		}
	}
#endif
    // if(source_info.type == KADP_VSC_INPUTSRC_DP)
    // {
    //     Set_Val_dp_input_source(display, (source_info.attr == KADP_VSC_DP_SRC_MINIDP) ? _SRC_MINI_DP :  _SRC_TYPEC);
    // }
}

void Set_Val_DisplayMode_info(unsigned char display, KADP_VSC_INPUT_SRC_INFO_T info)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY)
		DisplayModeInputInfo = info;
	else
		Sub_DisplayModeInputInfo = info;
#else
	if (display == SLR_MAIN_DISPLAY)
		DisplayModeInputInfo = info;
#endif
}

void SET_BBD_STAGE(unsigned char display, unsigned char stage)
{
#ifdef CONFIG_MEMC_NOTSUPPORT // for code size reduce, when MEMC_BYPASS
		return;
#else

	unsigned long flags = 0;//for spin_lock_irqsave
	if (display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&MAIN_BBD_STAGE_SPINLOCK, flags);
		if(stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
		{
			if(main_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				main_bbd_stage = BBD_FUNCTION_REQ_VGIP_DRIVER;
			}
		}
		else
		{
			main_bbd_stage = stage;
		}
		spin_unlock_irqrestore(&MAIN_BBD_STAGE_SPINLOCK, flags);
	}
	else
	{
		spin_lock_irqsave(&SUB_BBD_STAGE_SPINLOCK, flags);
		if(stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
		{
			if(sub_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				sub_bbd_stage = BBD_FUNCTION_REQ_VGIP_DRIVER;
			}
		}
		else
		{
			sub_bbd_stage = stage;
		}
		spin_unlock_irqrestore(&SUB_BBD_STAGE_SPINLOCK, flags);
	}
#endif
}

unsigned char GET_BBD_STAGE(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY)
	{
		return main_bbd_stage;
	}
	else
	{
		return sub_bbd_stage;
	}
}


void check_bdb_vgip_driver_request(unsigned char display)
{
	extern void set_bbd_vgip_driver(unsigned char display, StructDisplayInfo* VFEDispInfo);
	static unsigned short wait_vo1_timeout = 0;
	static unsigned short wait_vo2_timeout = 0;
	if (display == SLR_MAIN_DISPLAY)
	{
		if((main_bbd_stage != BBD_FUNCTION_DONE) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC))
		{
			if(main_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				wait_vo1_timeout = 300;//6 second
				SET_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_REQ_VGIP_DRIVER);
			}
			if(main_bbd_stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
			{
				if(get_vo_change_flag(0) || (wait_vo1_timeout == 0))
				{//main
					if(wait_vo1_timeout == 0)
					{
						SET_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_DONE);
						rtd_pr_vsc_err("\r### error func:%s main wait vo timeout ###\r\n", __FUNCTION__);
						return;
					}
					down(&VSC_Semaphore);
					drvif_mode_resetmode(display);
					Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FAILURECOUNT, 0);
					down(get_vo_infosemaphore());
					set_bbd_vgip_driver(display,  Get_VO_Dispinfo(0));
					up(get_vo_infosemaphore());
					up(&VSC_Semaphore);
					SET_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_DONE);
				}
				else
				{
					wait_vo1_timeout--;
				}
			}
		}
	}
	else if (display == SLR_SUB_DISPLAY)
	{
		if((sub_bbd_stage != BBD_FUNCTION_DONE) && (Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC))
		{
			if(sub_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				wait_vo2_timeout = 300;//6 second
				SET_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_REQ_VGIP_DRIVER);
			}
			if(sub_bbd_stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
			{
				if(get_vo_change_flag(1) || (wait_vo2_timeout == 0))
				{//sub
					if(wait_vo2_timeout == 0)
					{
						SET_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_DONE);
						rtd_pr_vsc_err("\r### error func:%s sub wait vo timeout ###\r\n", __FUNCTION__);
						return;
					}
					down(&VSC_Semaphore);
					drvif_mode_resetmode(display);
					Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_FAILURECOUNT, 0);
					down(get_vo_infosemaphore());
					set_bbd_vgip_driver(display,  Get_VO_Dispinfo(1));
					up(get_vo_infosemaphore());
					up(&VSC_Semaphore);
					SET_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_DONE);
				}
				else
				{
					wait_vo2_timeout--;
				}
			}
		}
	}

}

unsigned char rtk_rerun_scaler(SCALER_DISP_CHANNEL channel);

VSC_INPUT_TYPE_T Get_DisplayMode_Src(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN){
#ifdef CONFIG_I2RND_ENABLE
			if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				return (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type; //i2r sub re-run main case need to use sub src
			}
#endif
			return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
		}
		else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)VencModeInputInfo.type;
		else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  (VSC_INPUT_TYPE_T)MemoryModeInputInfo.type;
		else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)AveModeInputInfo.type;
		else{
#ifdef CONFIG_I2RND_ENABLE
			if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				return (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type; //i2r sub re-run main case need to use sub src
			}
#endif
			return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
		}
	} else {
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type;
		else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)Sub_VencModeInputInfo.type;
		else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  (VSC_INPUT_TYPE_T)Sub_MemoryModeInputInfo.type;
		else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return (VSC_INPUT_TYPE_T)Sub_AveModeInputInfo.type;
		else
			return (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type;
}
#else
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
	else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return (VSC_INPUT_TYPE_T)VencModeInputInfo.type;
	else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return  (VSC_INPUT_TYPE_T)MemoryModeInputInfo.type;
	else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return (VSC_INPUT_TYPE_T)AveModeInputInfo.type;
	else
		return (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
#endif
}

bool Get_HDMI_Port_is_withHDCP(void)
{
	unsigned char port_m = 0;
	unsigned char port_s = 0;
	unsigned char phy_port = 0 ;
	HDMI_HDCP_E type;
	int hdmi_select = 0;
	int error_cnt = 2;


	while(error_cnt){
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI){
			hdmi_select = 1;
			port_m =  DisplayModeInputInfo.resourceIndex;
			phy_port = drvif_Hdmi_GetCurrentPhysicalPort();
			type = newbase_hdcp_get_auth_mode(phy_port);
			rtd_pr_vsc_err("\r\nmain phy_port port = %d, virt=%d type=%d\n",phy_port, port_m, type);
			if(type == HDCP14 || type == HDCP22)
				return true;
		}
		if(Sub_DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI){
			hdmi_select = 1;
			port_s =  Sub_DisplayModeInputInfo.resourceIndex;
			phy_port = drvif_Hdmi_GetCurrentPhysicalPort();
			type = newbase_hdcp_get_auth_mode(phy_port);
			rtd_pr_vsc_err("\r\nsub phy_port port = %d, virt=%d type=%d\n",phy_port, port_s, type);
			if(type == HDCP14 || type == HDCP22)
				return true;
		}
		if(!hdmi_select){
			rtd_pr_vsc_err("\r\nHDMI not selected, but enter hdmi&i3ddma flow main=%d, sub=%d!!!\r\n, port_m, port_s");
			error_cnt --;
		}
        	usleep_range(5000, 8000);
	}
	return false;

}

unsigned char Get_DisplayMode_Port(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
#ifdef CONFIG_FORCE_RUN_I3DDMA
			if((DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_VDEC) && (DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_JPEG))
			{
				return 0;//Vo port is always 0 for all source go i3ddma
			}
#else
			if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
			{
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA))
				{
					return 0;//Vo port is always 0 for hdmi hdr case
				}
			}
#endif
			return DisplayModeInputInfo.resourceIndex;
		}
		else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return VencModeInputInfo.resourceIndex;
		else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  MemoryModeInputInfo.resourceIndex;
		else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return AveModeInputInfo.resourceIndex;
		else{
			return DisplayModeInputInfo.resourceIndex;
		}
	} else {
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_DisplayModeInputInfo.resourceIndex;
		else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_VencModeInputInfo.resourceIndex;
		else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  Sub_MemoryModeInputInfo.resourceIndex;
		else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_AveModeInputInfo.resourceIndex;
		else
			return Sub_DisplayModeInputInfo.resourceIndex;
}
#else
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if((DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_VDEC) && (DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_JPEG))
		{
			return 0;//Vo port is always 0 for all source go i3ddma
		}
#else
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
		{
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA))
			{
				return 0;//Vo port is always 0 for hdmi hdr case
			}
		}
#endif
		return DisplayModeInputInfo.resourceIndex;
	}
	else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return VencModeInputInfo.resourceIndex;
	else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return  MemoryModeInputInfo.resourceIndex;
	else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return AveModeInputInfo.resourceIndex;
	else
		return DisplayModeInputInfo.resourceIndex;
#endif
}

unsigned char get_output_set_flag(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	return ((display == SLR_MAIN_DISPLAY) ? DbgSclrFlgTkr.Main_Output_Set_flag : DbgSclrFlgTkr.Sub_Output_Set_flag);
#else
	return DbgSclrFlgTkr.Main_Output_Set_flag;
#endif
}

unsigned char get_scaler_stop_flag(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
#ifdef CONFIG_I2RND_ENABLE
	//i2r case, sub re-run main stage nned to check sub flag @Crixus 20180103
	if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE)
		&& ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
		display = SLR_SUB_DISPLAY;
	}
#endif
	return ((display == SLR_MAIN_DISPLAY) ? DbgSclrFlgTkr.Main_Scaler_Stop_flag : DbgSclrFlgTkr.Sub_Scaler_Stop_flag);
#else
	return DbgSclrFlgTkr.Main_Scaler_Stop_flag;
#endif
}

void reset_support_vo_force_v_top(void)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	if (vo_force_v_top)
		vo_force_v_top->vo_force_v_top_enable = 0;
}


void set_support_vo_force_v_top(bool enable, unsigned int func_flag)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	if (vo_force_v_top) {
		if (enable)
			vo_force_v_top->vo_force_v_top_enable |= func_flag;
		else
			vo_force_v_top->vo_force_v_top_enable &= ~func_flag;
	}
}

bool get_support_vo_force_v_top(unsigned int func_flag)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	return vo_force_v_top ? (vo_force_v_top->vo_force_v_top_enable) & func_flag : false;
}

void reset_ARC_cmd(unsigned char display)
{//clear arc command // for unstable use
	if(display == SLR_MAIN_DISPLAY)
	{
		down(&SetMainOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
		DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
		up(&SetMainOutPutRegion_Semaphore);
	}
}
void scaler_overscan_vertical_size(unsigned char display,unsigned int progressive,unsigned int source_height,unsigned int *height,unsigned int *v_start)
{
	*v_start =0;
	*height = 0;

	if((Get_DISPLAY_REFRESH_RATE() >= 120) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
		return;//vrr data frc case no need to do vo shift
	if (get_hdmi_4k_hfr_mode() != HDMI_NON_4K120) {
		return;//4k@120 data frc case no need to do vo shift
	}
	if ((get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1)&& (get_vsc_gamemode_datafrc_mode_flag() == 0)) {
		down(&SetMainOutPutRegion_Semaphore);
		if (DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_Output_Set_flag || (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
			if (((0 == progressive) && (main_dispwin.src_height <  _DISP_LEN)) ||
				((1 == progressive) && (main_dispwin.src_height <  _DISP_LEN))) {

			} else {
				if (hal_main_InputRegionType == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) {
					*height = (source_height *main_input_size.src_height * 100/main_input_timing.src_height + 50)/100;
					*v_start = (source_height *main_input_size.srcy * 100/main_input_timing.src_height + 50)/100;
				} else  if (hal_main_InputRegionType == INPUT_BASE_ON_DISP_WIN) {
					*height = (source_height *main_input_size.src_height * 100/_DISP_LEN+ 50)/100;
					*v_start = (source_height *main_input_size.srcy * 100/_DISP_LEN + 50)/100;
				} else {
					*height = main_input_size.src_height;
					*v_start =main_input_size.srcy;
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
}

void check_ARC_status(unsigned char display, KADP_VSC_INPUT_TYPE_T source)
{
	StructSrcRect outdispwin = {0, 0, _DISP_WID, _DISP_LEN};
	StructSrcRect indispwin = {0, 0, 0, 0};
	unsigned char isatv = FALSE;
	isatv = ((source ==KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) ? TRUE : FALSE;

	if(display == SLR_MAIN_DISPLAY)
	{
		down(&SetMainOutPutRegion_Semaphore);
		if((DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.rotate_run_scaler_flag || DbgSclrFlgTkr.rotate_muteoff_request_flag || (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
			&& !isatv)
		{
			DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
			DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
			DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
			DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
            vsc_force_rerun_main_scaler = FALSE;
            set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);

			Scaler_DispWindowSet(main_dispwin);


#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE

            set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode(SLR_MAIN_DISPLAY));
            set_rotate_mode(SLR_MAIN_DISPLAY, main_rotate_mode);

            if((display == SLR_MAIN_DISPLAY)
            	&&((get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)
            	||(get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270)))
            {
            	Set_rotate_function(SLR_MAIN_DISPLAY, TRUE);
            } else if ((display == SLR_MAIN_DISPLAY)
                && (get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
	            && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
            {
            	Set_rotate_function(SLR_MAIN_DISPLAY, TRUE);
            }
            else
            {
            	Set_rotate_function(SLR_MAIN_DISPLAY, FALSE);
            }
			//set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode());
#endif
			//Fixed ATV all direction zoom non-working issue. @Crixus 20160829
			if(!((source == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
				//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(display,main_input_size, main_input_timing, main_dispwin);
			}
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
			rtd_pr_vsc_notice("\r\n### func:%s apply ARC size (%d %d %d %d)#####\r\n",__FUNCTION__, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid,  main_input_size.src_height);

		}
		else
		{//no over scan and full panel size
//fill size condition
			StructSrcRect inputTiming ;
			reset_any_srcrect(&main_dispwin_for_only_xy);
            vsc_force_rerun_main_scaler = FALSE;
            indispwin.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
			if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
			{
				indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
				set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2);
			}
			else
			{
				indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
				set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
			}
			inputTiming = indispwin;
			set_input_for_crop(SLR_MAIN_DISPLAY, inputTiming);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, inputTiming);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
#if 0//this is for debug new flow
			set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)/2, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)/2);
			indispwin.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)/2;
			indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)/2;
#endif
			Scaler_DispWindowSet(outdispwin);
			if(!((source == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
				//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(SLR_MAIN_DISPLAY, indispwin, inputTiming,outdispwin);//for smooth toggle use
			}
			rtd_pr_vsc_notice("\r\n### func:%s apply full size w:%d h:%d#####\r\n",__FUNCTION__, indispwin.src_wid, indispwin.src_height);
		}

		if(get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) == ADAPTIVE_AIR_MODE)
		{
			vsc_adaptivestream_calc_outregion(SLR_MAIN_DISPLAY);
		}

		up(&SetMainOutPutRegion_Semaphore);
	}
}

unsigned char check_input_and_output_the_same(unsigned char display)
{//True: The same. False: The different
	unsigned char result = TRUE;
	if(display == SLR_MAIN_DISPLAY) {
		if((main_input_size_pre.srcx != main_input_size.srcx) || (main_input_size_pre.srcy != main_input_size.srcy) ||
			(main_input_size_pre.src_height != main_input_size.src_height) || (main_input_size_pre.src_wid != main_input_size.src_wid)) {
			result = FALSE;
			main_input_size_pre.srcx = main_input_size.srcx;
			main_input_size_pre.srcy = main_input_size.srcy;
			main_input_size_pre.src_height = main_input_size.src_height;
			main_input_size_pre.src_wid = main_input_size.src_wid;
		}
		#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if((main_input_timing_pre.srcx != main_input_timing.srcx) || (main_input_timing_pre.srcy != main_input_timing.srcy) ||
			(main_input_timing_pre.src_height != main_input_timing.src_height) || (main_input_timing_pre.src_wid != main_input_timing.src_wid)) {
			result = FALSE;
			main_input_timing_pre.srcx = main_input_timing.srcx;
			main_input_timing_pre.srcy = main_input_timing.srcy;
			main_input_timing_pre.src_height = main_input_timing.src_height;
			main_input_timing_pre.src_wid = main_input_timing.src_wid;
		}
		#endif
		if((main_dispwin_pre.srcx != main_dispwin.srcx) || (main_dispwin_pre.srcy != main_dispwin.srcy) ||
			(main_dispwin_pre.src_height != main_dispwin.src_height) || (main_dispwin_pre.src_wid != main_dispwin.src_wid)) {
			result = FALSE;
			main_dispwin_pre.srcx = main_dispwin.srcx;
			main_dispwin_pre.srcy = main_dispwin.srcy;
			main_dispwin_pre.src_height = main_dispwin.src_height;
			main_dispwin_pre.src_wid = main_dispwin.src_wid;
		}
	}

#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		if((sub_input_size_pre.srcx != sub_input_size.srcx) || (sub_input_size_pre.srcy != sub_input_size.srcy) ||
			(sub_input_size_pre.src_height != sub_input_size.src_height) || (sub_input_size_pre.src_wid != sub_input_size.src_wid)) {
			result = FALSE;
			sub_input_size_pre.srcx = sub_input_size.srcx;
			sub_input_size_pre.srcy = sub_input_size.srcy;
			sub_input_size_pre.src_height = sub_input_size.src_height;
			sub_input_size_pre.src_wid = sub_input_size.src_wid;
		}
		#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if((sub_input_timing_pre.srcx != sub_input_timing.srcx) || (sub_input_timing_pre.srcy != sub_input_timing.srcy) ||
			(sub_input_timing_pre.src_height != sub_input_timing.src_height) || (sub_input_timing_pre.src_wid != sub_input_timing.src_wid)) {
			result = FALSE;
			sub_input_timing_pre.srcx = sub_input_timing.srcx;
			sub_input_timing_pre.srcy = sub_input_timing.srcy;
			sub_input_timing_pre.src_height = sub_input_timing.src_height;
			sub_input_timing_pre.src_wid = sub_input_timing.src_wid;
		}
		#endif
		if((sub_dispwin_pre.srcx != sub_dispwin.srcx) || (sub_dispwin_pre.srcy != sub_dispwin.srcy) ||
			(sub_dispwin_pre.src_height != sub_dispwin.src_height) || (sub_dispwin_pre.src_wid != sub_dispwin.src_wid)) {
			result = FALSE;
			sub_dispwin_pre.srcx = sub_dispwin.srcx;
			sub_dispwin_pre.srcy = sub_dispwin.srcy;
			sub_dispwin_pre.src_height = sub_dispwin.src_height;
			sub_dispwin_pre.src_wid = sub_dispwin.src_wid;
		}
	}
#else
	result = FALSE;
#endif
	return result;
}

void source_disconnect_reset_input(unsigned char display)
{//for issue WOSQRTK-11401
	unsigned long flags = 0;//for spin_lock_irqsave
	if (display == SLR_MAIN_DISPLAY) {
		down(&new_input_output_main_sem);//lock semaphore
		spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
		//copy input region
		ap_main_inregion_parm.x = 0;
		ap_main_inregion_parm.y = 0;
		ap_main_inregion_parm.w = 0;
		ap_main_inregion_parm.h = 0;

		//copy original input region
		ap_main_originalInput_parm.x = 0;
		ap_main_originalInput_parm.y = 0;
		ap_main_originalInput_parm.w = 0;
		ap_main_originalInput_parm.h = 0;
		spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
		up(&new_input_output_main_sem);//lock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(display == SLR_SUB_DISPLAY)
	{
		down(&new_input_output_sub_sem);//lock semaphore
		spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
		//copy input region
		ap_sub_inregion_parm.x = 0;
		ap_sub_inregion_parm.y = 0;
		ap_sub_inregion_parm.w = 0;
		ap_sub_inregion_parm.h = 0;

		//copy original input region
		ap_sub_originalInput_parm.x = 0;
		ap_sub_originalInput_parm.y = 0;
		ap_sub_originalInput_parm.w = 0;
		ap_sub_originalInput_parm.h = 0;
		spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
		up(&new_input_output_sub_sem);//unlock semaphore
	}
#endif
}

void reset_any_srcrect(StructSrcRect *p_srcrect)
{
	if(p_srcrect) {
		p_srcrect->srcx = 0;
		p_srcrect->srcy = 0;
		p_srcrect->src_height = 0;
		p_srcrect->src_wid = 0;
	}
}

void set_source_info_forPQ(unsigned char display)
{
	//KADP_VSC_OUTPUT_MODE_T outputMode;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;

	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			//outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = DisplayModeInputInfo.type;
			inputPort = DisplayModeInputInfo.resourceIndex;
		}
		else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			//outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
		}
		else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			//outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = MemoryModeInputInfo.type;
			inputPort = MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return;
		}
		//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//No need
		if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
			if (FALSE == init_source_proc(SLR_MAIN_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort)) {
				rtd_pr_vsc_debug("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				return;
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			//outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			//outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			//outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return;
		}

		//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);//No need
		if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_SUB_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort) == FALSE) {
				rtd_pr_vsc_debug("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.sub_opensourceID = _UNKNOWN_INPUT;
				return;
			}
		}
	}
#endif
}

void Set_Val_cur_main_vsc_src_num(unsigned char val)
{
    cur_main_vsc_src_num = val;
}

void Set_Val_cur_sub_vsc_src_num(unsigned char val)
{
    cur_sub_vsc_src_num = val;
}

void Set_Val_source_connect_verify_num(unsigned char dispaly, unsigned char val)
{
    source_connect_verify_num[dispaly] = val;
}

unsigned judge_scaler_break_case_impl(unsigned char display)
{//Return True: break. False:No break
	unsigned char src;
	KADP_VSC_INPUT_TYPE_T webos_src;
	webos_src = (KADP_VSC_INPUT_TYPE_T)Get_DisplayMode_Src(display);
	src = Scaler_InputSrcGetType(display);
#ifdef CONFIG_SUPPORT_SRC_ADC
	if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_ADC))
	{
		if(check_verify_mode_enable())//adc verify mode
			return FALSE;
	}
#endif

    if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    {
        if((vbe_disp_get_VRR_timingMode_flag() != drvif_Hdmi_GetVRREnable()) && !get_scaler_qms_mode_flag() && vbe_get_panel_vrr_freesync_timing_is_valid())
        {
            rtd_pr_vsc_notice("\r HDMI VRR (%d %d) not match so break !!!####\r\n", vbe_disp_get_VRR_timingMode_flag(), drvif_Hdmi_GetVRREnable());
            return TRUE;
        }
	if((vbe_disp_get_freesync_mode_flag() != drvif_Hdmi_GetAMDFreeSyncEnable()) && !get_scaler_qms_mode_flag() && vbe_get_panel_vrr_freesync_timing_is_valid())
        {
            rtd_pr_vsc_notice("\r HDMI freesync (%d %d) not match so break !!!####\r\n", vbe_disp_get_freesync_mode_flag(), drvif_Hdmi_GetAMDFreeSyncEnable());
            return TRUE;
        }

        if(get_scaler_qms_mode_flag() != current_is_hdmi_qms_mode())
        {
                rtd_pr_vsc_notice("\r HDMI qms (%d %d) not match so break !!!####\r\n", get_scaler_qms_mode_flag(), current_is_hdmi_qms_mode());
                return TRUE;
        }


    }

#ifdef CONFIG_I2RND_ENABLE
	//Eric@20170817 do not break in dual vo sub rerun case
	if(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
	&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
	{
		if (get_scaler_stop_flag(display))
		{
			rtd_pr_vsc_notice("\r\n####channel:%d vsc already disconnect !!!####\r\n", display);
			return TRUE;
		}
		else if(!compare_rerify_vsc_source_num_result(display))
		{
			rtd_pr_vsc_notice("### judge_scaler_break_case source(%d) already change###\r\n", display);
			return TRUE;
		}

	}
#else
	if (get_scaler_stop_flag(display)) {
		rtd_pr_vsc_notice("\r\n####channel:%d vsc already disconnect !!!####\r\n", display);
		return TRUE;
	}
	else if(!compare_rerify_vsc_source_num_result(display))
	{
		rtd_pr_vsc_notice("### judge_scaler_break_case source(%d) already change###\r\n", display);
		return TRUE;
	}
	else if((webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
	{
		return FALSE;//ATV don't check online status
	}
#endif
	else if((display == SLR_MAIN_DISPLAY) &&
		(webos_src == KADP_VSC_INPUTSRC_HDMI) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120))
	)
	{
		if(drvif_mode_check_onlinemeasure_status(display) == FALSE) {
			rtd_pr_vsc_notice("\r\n####channel:%d online error status:%08x(1268) %08x(126C) %08x(1270)!!!####\r\n", display, IoReg_Read32(ONMS_onms1_status_reg), IoReg_Read32(ONMS_onms1_watchdog_en_reg), IoReg_Read32(ONMS_onms1_interrupt_en_reg));
			return TRUE;
		}

	}
#ifdef CONFIG_FORCE_RUN_I3DDMA
	else if((display == SLR_MAIN_DISPLAY) &&
		((webos_src == KADP_VSC_INPUTSRC_ADC) ||(webos_src == KADP_VSC_INPUTSRC_AVD) || (webos_src == KADP_VSC_INPUTSRC_HDMI))
	)
	{
		if((webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
		{
			return FALSE;//ATV don't check dma online status
		}
		else if(drvif_mode_check_dma_onlinemeasure_status() == FALSE) {
			rtd_pr_vsc_notice("\r\n####dma online error status:%08x!!!####\r\n", IoReg_Read32(ONMS_onms3_status_reg));
			return TRUE;
		}
		else if(webos_src == KADP_VSC_INPUTSRC_HDMI)
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
			if((get_ori_HDMI_HDR_mode() == HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() == HDR_DOLBY_HDMI))
			{//only dolby need to do this
				vsc_force_rerun_main_scaler = TRUE;
				rtd_pr_vsc_notice("\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
				return TRUE;
			}
            }

		if(get_vsc_gamemode_datafrc_mode_flag() != scaler_vsc_get_gamemode_go_datafrc_mode()){
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r\n gamemode_go_datafrc_mode_flag changed, force re-run scaler so break !!!####\r\n");
			vsc_force_rerun_main_scaler = TRUE;
			return TRUE;
		}

            if(vsc_force_rerun_main_scaler == TRUE){
				rtd_pr_vsc_notice("\r\nCondition changed, force re-run scaler so break !!!####\r\n");
				return TRUE;
			}
        }
	}
#endif
	else if(src == _SRC_VO) {
#ifdef CONFIG_I2RND_ENABLE
		//Eric@20170817 do not break in dual vo sub rerun case
		if(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
		&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
		{
			if(get_vo_change_flag(Get_DisplayMode_Port(display))) {
				rtd_pr_vsc_debug("\r\n####channel:%d vo already update !!!####\r\n", display);
				return TRUE;
			}
		}
#ifndef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
                rtd_pr_vsc_notice("\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
			    return TRUE;
            }
        }
#endif
	} else {
#ifdef CONFIG_I2RND_ENABLE
		if((display == SLR_SUB_DISPLAY) &&(webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
		{
			return FALSE;//ATV don't check dma online status
		}
#endif
		if(drvif_mode_check_onlinemeasure_status(display) == FALSE) {
			rtd_pr_vsc_notice("\r\n####channel:%d online error status:%08x!!!####\r\n", display, IoReg_Read32(ONMS_onms1_status_reg));
			return TRUE;
		}

		if(get_vsc_gamemode_datafrc_mode_flag() != scaler_vsc_get_gamemode_go_datafrc_mode()){
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r\n gamemode_go_datafrc_mode_flag changed, force re-run scaler so break !!!####\r\n");
			vsc_force_rerun_main_scaler = TRUE;
			return TRUE;
		}

#ifndef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
                rtd_pr_vsc_notice("\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
			    return TRUE;
            }
        }
#endif
	}
	return FALSE;
}
unsigned (*judge_scaler_break_case)(unsigned char display) = judge_scaler_break_case_impl;

void Scaler_Dolby_HDR_reset(void){
	//Reset DM control
	drvif_Dolby_HDR_disable_DM_LUT();//disable DM LUT @Crixus 20160313
}
void reset_hdr_mode_impl(unsigned char display)
{
	if(display == SLR_MAIN_DISPLAY)
	{
		hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	//Disable v top setting
		hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
		//top_ctl_reg.dolby_v_read_sel = 1;
		hdr_all_top_top_ctl_reg.dolby_mode = 0;
		hdr_all_top_top_ctl_reg.hdr1_in_sel = 0;//0: vo case  1: hdmi
		//hdr_all_top_top_ctl_reg.hdr_yuv444_en = 0;//reset yuv 444 enable
		IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue);//Disable dolby mode
		IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//Enable doublue buffer

		//reset HDR RGB swap
		drvif_color_set_HDR_RGB_swap(0);

#if IS_ENABLED(CONFIG_RTK_KDRV_QOS_CONTROL)
		//skip qos reset mode
		rtd_pr_vsc_debug("[QoS] %s:skip qos reset\n", __FUNCTION__);
		//rtk_qos_set_mode(RTK_QOS_NORMAL_MODE);
#endif
	}
	else
	{//sub case
	}

}
void (*reset_hdr_mode)(unsigned char display)=reset_hdr_mode_impl;

static void decide_qos_mode(void)
{
#if IS_ENABLED(CONFIG_RTK_KDRV_QOS_CONTROL)
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800) { // 4K
			if ((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SRC_FRAMERATE) >= 1195) &&
				(!get_vo_veComp_flag(SLR_MAIN_DISPLAY))) {
				rtk_qos_set_mode(RTK_QOS_DECODER_NON_COMPRESS);
			} else {
				rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
			}
#if 0 // Use same QoS for all 2K video now, add/change mode only if we find 2K60 or 2K120 needs different QoS setting
		} else if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) >= 490) { // 2K freq > 50, apply 4k qos
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
#endif
		} else {
			rtk_qos_set_mode(RTK_QOS_DECODER_2K_MODE);
		}
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800)
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
		else
			rtk_qos_set_mode(RTK_QOS_DECODER_2K_MODE);
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800)
			rtk_qos_set_mode(RTK_QOS_HDMI_4K_MODE);
		else
			rtk_qos_set_mode(RTK_QOS_HDMI_2K_MODE);
	}
	else
	{
		rtk_qos_set_mode(RTK_QOS_NORMAL_MODE);
	}
#endif
}

void qos_mode_switch(unsigned int is_bad_edit)
{
#if IS_ENABLED(CONFIG_RTK_KDRV_QOS_CONTROL)
	if (is_bad_edit) {
		rtk_qos_set_bad_edit(1);
		rtk_qos_set_mode(RTK_QOS_DECODER_BAD_EDIT_MODE);
	}
	else {
		rtk_qos_set_bad_edit(0);
		decide_qos_mode();
	}
#endif
}

#ifdef CONFIG_HDR_SDR_SEAMLESS
void dynamic_change_hdr_setting(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format)
{//This is for vgip isr setting //vdec source
	bool sdr_force_vtop = FALSE;
	unsigned char decide_final_hdr_enable;//decide final hdr enable or disable
	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	sdr_force_vtop = get_support_vo_force_v_top(support_sdr_max_rgb);
	decide_final_hdr_enable = (hdr_enable || sdr_force_vtop);

	IoReg_ClearBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT0);		//disable double buffer

	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
	if(hdr_enable || decide_final_hdr_enable)
	{
		hdr_all_top_top_ctl_reg.en_422to444_1 = 0;//hdr don't enable 422 to 444
	}
	else
	{
		if(color_format == I3DDMA_COLOR_YUV422)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 1;
		else if(color_format == I3DDMA_COLOR_YUV444)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 0;
	}
	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue); //Set vtop setting
	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//apply doublue buffer

	Scaler_hdr_setting_SEAMLESS(hdr_enable || decide_final_hdr_enable);

	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT0);			//enable double buffer
}

void dynamic_change_hdr_setting_hdmi_position(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type)
{//This is for vgip isr setting. hdr type is from PQ_HDR_TYPE

	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
	if(hdr_enable)
	{
		hdr_all_top_top_ctl_reg.en_422to444_1 = 0;//hdr don't enable 422 to 444
	}
	else
	{
		if(color_format == I3DDMA_COLOR_YUV422)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 1;
		else if(color_format == I3DDMA_COLOR_YUV444)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 0;
	}
	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue); //Set vtop setting
	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//apply doublue buffer

	Scaler_hdr_setting_SEAMLESS_hdmi_position(hdr_enable, hdr_type);

}

void dynamic_change_hdr_setting_hdmi_finish(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type)
{//This is for vgip isr setting. PQ_HDR_TYPE

	Scaler_hdr_setting_SEAMLESS_hdmi_finish(hdr_enable, hdr_type);
}


void reset_seamless_trigger_flag(void)
{//reset HDMI and vdec seamless trigger related flag. This is for run scaler
	extern unsigned char hdmi_position_seamless;//for hdr sdr seamless condition for vgip start
   	extern unsigned char hdmi_finish_seamless;//for hdr sdr seamless condition for vgip end
	unsigned long flags = 0;//for spin_lock_irqsave
    seamless_change_sync_info *seamless_info_sharememory = NULL;
    seamless_info_sharememory = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);
	if(seamless_info_sharememory)
	{
	    seamless_info_sharememory->hdmi_trigger_vo_change_flag = Scaler_ChangeUINT32Endian(0);
		seamless_info_sharememory->hdmi_not_ready = 0;
	}
    spin_lock_irqsave(get_i3ddma_change_spinlock(), flags);//lock i3ddma change spinlock
    set_i3ddma_change_format_flag(FALSE);
	hdmi_position_seamless = FALSE;
	hdmi_finish_seamless = FALSE;
    spin_unlock_irqrestore(get_i3ddma_change_spinlock(), flags);//unlock i3ddma change  spinlock
    spin_lock_irqsave(get_vdec_seamless_change_spinlock(), flags);//lock vdec semaless change spinlock
    set_vdec_seamless_change_flag(FALSE);
    spin_unlock_irqrestore(get_vdec_seamless_change_spinlock(), flags);//unlock vdec semaless change  spinlock
    set_hdr_semaless_active(FALSE);
}

#endif
#if 0
static void apvr_request_run_main_path(void)
{//This api is for apvr need to run main path again

	//reset i2rnd and pst write point when rerun scaler flow @Crixus 20180819
#ifdef CONFIG_I2RND_ENABLE
	//enable I2rnd
	if (Scaler_I2rnd_get_enable()) {
		Scaler_i2rnd_write_default_cmd_num();
		Scaler_I2rnd_set_read_cmd_num(0);
	}
#endif
#ifdef CONFIG_PST_ENABLE
	//enable pst
	if (Scaler_main_md_pst_get_enable()) {
		Scaler_pst_main_md_write_default_cmd_num();
		Scaler_pst_main_md_set_read_cmd_num(0);
	}
#endif

	if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)
	{
		mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
	}
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
	down(&SetMainOutPutRegion_Semaphore);
	DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Let main path run scaler again
	up(&SetMainOutPutRegion_Semaphore);
}
#endif
unsigned char get_vsc_mutestatus(void)
{
	return DbgSclrFlgTkr.VscMuteStatus;
}

unsigned int Scaler_Get_HDMI_VFREQ(unsigned int orig_v_freq)
{
	unsigned int v_freq = 0;
	if((orig_v_freq - (orig_v_freq/1000)*1000) > V_FREQ_THRESHOLD)
	{//XX.986~XX.999 -> (XX+1).000
		v_freq = orig_v_freq/100 + 1;
	}
	else
	{
		v_freq = orig_v_freq/100;
	}

	return v_freq;
}

unsigned int Scaler_Get_HDMI_HFREQ(unsigned int orig_h_freq)
{
	return orig_h_freq/100;
}

void Scaler_SET_VSCDispinfo_WithVFEHMDI(unsigned char display, vfe_hdmi_timing_info_t vfehdmitiminginfo)
{
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE, vfehdmitiminginfo.active.h);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE, vfehdmitiminginfo.active.y+vfehdmitiminginfo.y_offset);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_WID_PRE, vfehdmitiminginfo.active.w);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE, vfehdmitiminginfo.active.x+vfehdmitiminginfo.x_offset);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_HSYNC, vfehdmitiminginfo.hsync);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_VSYNC, vfehdmitiminginfo.vsync);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_CURR, vfehdmitiminginfo.mode_id);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_TABLE_INDEX, vfehdmitiminginfo.mode_table_index);

	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_POLARITY, vfehdmitiminginfo.polarity);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_FREQ, vfehdmitiminginfo.h_freq);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_FREQ, vfehdmitiminginfo.v_freq);
    Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_SRC_FRAMERATE, vfehdmitiminginfo.v_freq);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_LEN, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_LEN, vfehdmitiminginfo.v_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_COUNT, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_COUNT, vfehdmitiminginfo.v_total);
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);
	if((display == SLR_MAIN_DISPLAY) && (vfehdmitiminginfo.color_space==VFE_HDMI_COLOR_YUV422) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120)))
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, VFE_HDMI_COLOR_YUV444);//two pixel mode force vtop, so scaler is yuv 444
		Scaler_DispSetStatus(display, SLR_DISP_422, 0);
	}
	else
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, vfehdmitiminginfo.color_space);
		Scaler_DispSetStatus(display, SLR_DISP_422, (vfehdmitiminginfo.color_space==VFE_HDMI_COLOR_YUV422) ? 1 : 0);
	}
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_DEPTH, vfehdmitiminginfo.color_depth);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_IMETRY, vfehdmitiminginfo.color_imetry);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IVSYNCPULSECOUNT, vfehdmitiminginfo.IVSyncPulseCount);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_SYNC_HIGH_PERIOD, vfehdmitiminginfo.polarity);

	Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,  (!vfehdmitiminginfo.scan_type));
	//Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,FALSE);

    decide_hdmi_dp_framerate_for_timing_protect(display);

#if 0//frank@20141103 mark below code to reduce time
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_ADC_CLOCK));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_HSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_VSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_TABLE_INDEX));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_AFD));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_POLARITY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_SPACE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_DEPTH));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_IMETRY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE));
#endif
}

void Scaler_SET_VSCDispinfo_With_NEW_HDMI_TIMING_INFO(unsigned char display, HDMI_TIMING_T vfehdmitiminginfo)
{
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE, vfehdmitiminginfo.v_act_len);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE, vfehdmitiminginfo.v_act_sta);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_WID_PRE, vfehdmitiminginfo.h_act_len);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE, vfehdmitiminginfo.h_act_sta);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_HSYNC, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_VSYNC, vfehdmitiminginfo.v_total);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_CURR, vfehdmitiminginfo.mode_id);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_TABLE_INDEX, vfehdmitiminginfo.modetable_index);

	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_POLARITY, vfehdmitiminginfo.polarity);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_FREQ, Scaler_Get_HDMI_HFREQ(vfehdmitiminginfo.h_freq));
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_FREQ, Scaler_Get_HDMI_VFREQ(vfehdmitiminginfo.v_freq));
    Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_SRC_FRAMERATE, Scaler_Get_HDMI_VFREQ(vfehdmitiminginfo.v_freq));
    Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_LEN, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_LEN, vfehdmitiminginfo.v_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_COUNT, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_COUNT, vfehdmitiminginfo.v_total);
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);
	if((display == SLR_MAIN_DISPLAY) && (vfehdmitiminginfo.colorspace==(HDMI_COLOR_SPACE_T)VFE_HDMI_COLOR_YUV422) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120)))
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, VFE_HDMI_COLOR_YUV444);//two pixel mode force vtop, so scaler is yuv 444
		Scaler_DispSetStatus(display, SLR_DISP_422, 0);
	}
	else
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, vfehdmitiminginfo.colorspace);
		Scaler_DispSetStatus(display, SLR_DISP_422, (vfehdmitiminginfo.colorspace==(HDMI_COLOR_SPACE_T)VFE_HDMI_COLOR_YUV422) ? 1 : 0);
	}
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_DEPTH, vfehdmitiminginfo.colordepth);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_IMETRY, vfehdmitiminginfo.colorimetry);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IVSYNCPULSECOUNT, vfehdmitiminginfo.IVSyncPulseCount);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_SYNC_HIGH_PERIOD, vfehdmitiminginfo.polarity);

	Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,  vfehdmitiminginfo.is_interlace);
	//Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,FALSE);

    decide_hdmi_dp_framerate_for_timing_protect(display);

#if 0//frank@20141103 mark below code to reduce time
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_ADC_CLOCK));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_HSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_VSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_TABLE_INDEX));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_AFD));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_POLARITY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_SPACE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_DEPTH));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_IMETRY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE));
#endif
}

void Scaler_SET_VSCSubDispinfo_Withmain(void)
{
	//Scaler_DispSetInputInfo(SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE));

	Scaler_DispSetInputInfo(SLR_INPUT_HSYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC));
	Scaler_DispSetInputInfo(SLR_INPUT_VSYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC));

	Scaler_DispSetInputInfo(SLR_INPUT_MODE_CURR, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR));
	Scaler_DispSetInputInfo(SLR_INPUT_MODE_TABLE_INDEX, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX));

	//Scaler_DispSetInputInfo(SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfo(SLR_INPUT_POLARITY, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY));
	Scaler_DispSetInputInfo(SLR_INPUT_H_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ));
	Scaler_DispSetInputInfo(SLR_INPUT_V_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
    Scaler_DispSetInputInfo(SLR_INPUT_SRC_FRAMERATE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_SRC_FRAMERATE));
	Scaler_DispSetInputInfo(SLR_INPUT_H_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN));
	Scaler_DispSetInputInfo(SLR_INPUT_V_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN));
	Scaler_DispSetInputInfo(SLR_INPUT_H_COUNT, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT));
	Scaler_DispSetInputInfo(SLR_INPUT_V_COUNT, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT));
	//Scaler_DispSetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);

	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_SPACE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE));
	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_DEPTH, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH));
	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_IMETRY, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY));

	Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,FALSE);

#if 0//frank@20141103 mark below code to reduce time
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_ADC_CLOCK));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_HSYNC));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_VSYNC));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_TABLE_INDEX));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_AFD));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_POLARITY));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_FREQ));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_LEN));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_LEN));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_COUNT));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_COUNT));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_SPACE));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_DEPTH));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_IMETRY));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422));
	rtd_pr_vsc_debug("VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE));
#endif
}

void Scaler_SET_VSCDispinfo_WithVFEHMDIHDR( vfe_hdmi_timing_info_t vfehdmitiminginfo)
{
	//Scaler_DispSetInputInfo(SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE, vfehdmitiminginfo.active.h);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE, vfehdmitiminginfo.active.y+vfehdmitiminginfo.y_offset);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE, vfehdmitiminginfo.active.w);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE, vfehdmitiminginfo.active.x+vfehdmitiminginfo.x_offset);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC, vfehdmitiminginfo.hsync);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC, vfehdmitiminginfo.vsync);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR, vfehdmitiminginfo.mode_id);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX, vfehdmitiminginfo.mode_table_index);

	//Scaler_DispSetInputInfo(SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY, vfehdmitiminginfo.polarity);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ, vfehdmitiminginfo.h_freq);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ, vfehdmitiminginfo.v_freq);
    Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_SRC_FRAMERATE, vfehdmitiminginfo.v_freq);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN, vfehdmitiminginfo.v_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT, vfehdmitiminginfo.v_total);
	//Scaler_DispSetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE, vfehdmitiminginfo.color_space);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH, vfehdmitiminginfo.color_depth);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY, vfehdmitiminginfo.color_imetry);

	Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422, (vfehdmitiminginfo.color_space == VFE_HDMI_COLOR_YUV422) ? 1 : 0);
	Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE,  (!vfehdmitiminginfo.scan_type));
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE,FALSE);

    decide_hdmi_dp_framerate_for_timing_protect(SLR_MAIN_DISPLAY);

#if 0//frank@20141103 mark below code to reduce time
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_ADC_CLOCK));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_AFD));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	rtd_pr_vsc_notice("VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
#endif
}
#ifndef UT_flag
unsigned char VSC_Check_Signal_Lock(unsigned char display)
{
	VSC_INPUT_TYPE_T src_type;
	unsigned char port;
#ifndef CONFIG_DUAL_CHANNEL
	display = SLR_MAIN_DISPLAY;
	if(DisplayModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type = DisplayModeInputInfo.type;
		port = DisplayModeInputInfo.resourceIndex;
	} else if (VencModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type = VencModeInputInfo.type;
		port = VencModeInputInfo.resourceIndex;
	} else if (MemoryModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type =  MemoryModeInputInfo.type;
		port = MemoryModeInputInfo.resourceIndex;
	} else if (AveModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type = AveModeInputInfo.type;
		port = AveModeInputInfo.resourceIndex;
	} else {
		src_type = DisplayModeInputInfo.type;
		port = DisplayModeInputInfo.resourceIndex;
	}
#else
	if (display == SLR_MAIN_DISPLAY)
	{
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
			port = DisplayModeInputInfo.resourceIndex;
		} else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = (VSC_INPUT_TYPE_T)VencModeInputInfo.type;
			port = VencModeInputInfo.resourceIndex;
		} else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type =	(VSC_INPUT_TYPE_T)MemoryModeInputInfo.type;
			port = MemoryModeInputInfo.resourceIndex;
		} else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = (VSC_INPUT_TYPE_T)AveModeInputInfo.type;
			port = AveModeInputInfo.resourceIndex;
		} else {
			src_type = (VSC_INPUT_TYPE_T)DisplayModeInputInfo.type;
			port = DisplayModeInputInfo.resourceIndex;
		}
	}
	else
	{
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type;
			port = Sub_DisplayModeInputInfo.resourceIndex;
		} else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = (VSC_INPUT_TYPE_T)Sub_VencModeInputInfo.type;
			port = Sub_VencModeInputInfo.resourceIndex;
		} else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type =  (VSC_INPUT_TYPE_T)Sub_MemoryModeInputInfo.type;
			port = Sub_MemoryModeInputInfo.resourceIndex;
		} else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = (VSC_INPUT_TYPE_T)Sub_AveModeInputInfo.type;
			port = Sub_AveModeInputInfo.resourceIndex;
		} else {
			src_type = (VSC_INPUT_TYPE_T)Sub_DisplayModeInputInfo.type;
			port = Sub_DisplayModeInputInfo.resourceIndex;
		}
	}
#endif

	switch(src_type)
	{
		case KADP_VSC_INPUTSRC_ADC:
		case KADP_VSC_INPUTSRC_AVD:
		case KADP_VSC_INPUTSRC_HDMI:
			 if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && drvif_mode_check_onlinemeasure_status(display))
			 	return TRUE;
			 else
			 	return FALSE;

		case VSC_INPUTSRC_VDEC:
		case VSC_INPUTSRC_JPEG:
			if(get_vo_change_flag(port) == FALSE && Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}

		default:
			return FALSE;

	}
}
#endif // #ifndef UT_flag
unsigned char Scaler_CheckHDMI_4K60VRR(void)
{
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

	if ((srctype == VSC_INPUTSRC_HDMI)
			&& (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())
			&& (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID) >= 3840 && Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVHEIGHT) >= 2160 && Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVFREQ) <= 605)) {
		rtd_pr_vsc_emerg("[4k60VRR] Scaler_CheckHDMI_4K60VRR()=TRUE\n");
		return TRUE;
	} else {
		rtd_pr_vsc_emerg("[4k60VRR] Scaler_CheckHDMI_4K60VRR()=FALSE, srctype=%d\n", srctype);
		rtd_pr_vsc_emerg("[4k60VRR] vbe_disp_get_VRR_timingMode_flag()=%d, vbe_disp_get_freesync_mode_flag()=%d\n", vbe_disp_get_VRR_timingMode_flag(), vbe_disp_get_freesync_mode_flag());
		rtd_pr_vsc_emerg("[4k60VRR] SLR_MODE_IHWID=%d, SLR_MODE_IVHEIGHT=%d, SLR_MODE_IVFREQ=%d\n", Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID), Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVHEIGHT), Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVFREQ));
		return FALSE;
	}
}

unsigned char Scaler_get_data_framesync_impl(unsigned char display)
{
	unsigned int len_temp=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE);
	SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	if (Scaler_InputSrcGetType(display)==_SRC_VO) {
		if((pVOInfo == NULL) ||(pVOInfo->src_v_len ==0))
		{
			rtd_pr_vsc_emerg("Scaler_get_data_framesync get vo timinginfo error\n");

		} else {
			len_temp = pVOInfo->src_v_len;
		}
	}

#if 0
	if ((rtd_inl(0xb80277f0) & _BIT1) != 0)
	{
		pr_emerg("force data frc\n");
		return FALSE;
	}
#endif

#ifdef CONFIG_MDOMAIN_FORCE_FRC
	if (TRUE == modestate_get_mdomain_frc_flag(display))
	{
		pr_emerg("modestate_get_mdomain_frc_flag==TRUE, go data frc\n");
		return FALSE;
	}
#endif

	if (display == SLR_MAIN_DISPLAY) {
		if((get_panel_res() == PANEL_RES_FHD)||(get_panel_res() == PANEL_RES_HD))
		{
			rtd_pr_vsc_notice(" 2k panel,go frc\n");
			return FALSE;
		}
		else if((get_panel_res() == PANEL_RES_UHD)||(get_panel_res() == PANEL_RES_8K)){
#ifdef ENABLE_VR360_DATA_FS_FLOW
			if(get_vt_EnableFRCMode() == FALSE){
				//Enter VR360 Data Fs Mode
				INPUT_TIMING_INDEX index = get_current_pattern_index();
				if(index == VO_4K2K_60){
					rtd_pr_vsc_notice(" vr360 go data fs\n");
					return TRUE;
				}
			}
#endif

	//#ifdef CONFIG_MEMC_BYPASS
	//		if(get_MEMC_bypass_status_refer_platform_model() == TRUE){
	//			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) == PIXEL_MODE_2_PIXEL){
	//				rtd_pr_vsc_debug("[CONFIG_MEMC_BYPASS][2 pixel] go data FRC@%d\n", __LINE__);
	//				return FALSE;
	//			}
	//		}
	//#endif
			if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {
				if ((srctype != VSC_INPUTSRC_VDEC) && (srctype != VSC_INPUTSRC_JPEG) && (Scaler_InputSrcGetType(display)!=_SRC_VO)) {
					rtd_pr_vsc_notice("==== External src GO data frc ====\n");
					return FALSE;
				}
				if (get_vsc_gamemode_datafrc_mode_flag() && !is_game_mode_set_line_buffer() && (srctype == VSC_INPUTSRC_HDMI)){
					rtd_pr_vsc_notice("==== hdmi 4k game mode go data frc ====\n");
					return FALSE;
				}
				if(get_hdmi_4k_hfr_mode() != HDMI_NON_4K120)
				{//hmdi 4k2k 120 application force go data frc
					rtd_pr_vsc_notice("==== hdmi 4k120hz go data frc ====\n");
					return FALSE;
				}
				if((Get_DISPLAY_REFRESH_RATE() >= 120) && (srctype == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
				{//hmdi vrr application force go data frc
					rtd_pr_vsc_notice("==== hdmi vrr/freesync go data frc ====\n");
					return FALSE;
				}
				if (Get_rotate_function(SLR_MAIN_DISPLAY) && (get_rotate_mode(SLR_MAIN_DISPLAY)!=(DIRECT_VO_FRAME_ORIENTATION)ROTATE_MODE_0)) {
					rtd_pr_vsc_notice("====rotate go data frc ====\n");
					return FALSE;
				}
#ifndef ENABLE_VBY1_TO_HDMI_4K2K_DATA_FS
				if (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI ||
				Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI ||
				Get_DISPLAY_PANEL_TYPE() == P_LVDS_TO_HDMI) {
					rtd_pr_vsc_notice("====converter hdmi board go data frc ====\n");
					if(Get_DISPLAY_PANEL_CUSTOM_INDEX() == VBY_ONE_PANEL_COMMERCIAL_4K2K_600M_1S_8L_DUPLICATE)
						rtd_pr_vsc_notice("==== business display converter board case go data fs====\n");
					else
						return FALSE;
				}
#endif
				if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
					len_temp = len_temp *2;
				}
#if 0
				if (vsc_get_adaptivestream_flag()) {
				if (Scaler_DispWindowGet().src_height < (_DISP_LEN)) {
				return FALSE;
				} else
				{
				return TRUE;
				}
				} else
#endif
				{
				//	if (scaler_vsc_get_adaptive_pst_lowdelay_mode()) {
				//		rtd_pr_vsc_notice("====pst lowdelay mode go data frc====\n");
				//		return FALSE;
				//	}
					if (Scaler_DispWindowGet().src_height <  _DISP_LEN) {// && Scaler_DispWindowGet().src_height <  len_temp) {
						rtd_pr_vsc_notice("====display len<source go data frc====\n");
						return FALSE;
					}
					else if (get_vsc_run_adaptive_stream(display) && (pVOInfo->progressive== 0)) {
						rtd_pr_vsc_notice("  adaptive interlace go data frc====\n");
						return FALSE;
					}
					else if (scaler_vsc_get_gamemode_force_framerate_lowdelay_mode()){
						rtd_pr_vsc_notice("  game mode force framerate go data frc====\n");
						return FALSE;
					}
					else {
						rtd_pr_vsc_notice("====display len>=source or full size go data fs====\n");
						return TRUE;
					}
				}
			}
			else {
				if(get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) && pVOInfo->is2KCP) {
					rtd_pr_vsc_notice("====cp 2k timing run data frc====\n");
				}
				return FALSE;
			}
		}else{
			return FALSE;
			}
		}
		else{
			return FALSE;
		}
}
unsigned char (*Scaler_get_data_framesync)(unsigned char display) = Scaler_get_data_framesync_impl;

// only support tv006
//extern unsigned char vsc_get_main_win_apply_done_event_subscribe(void);
extern VOID Set_Info_from_Scaler(MEMC_INFO_FROM_SCALER *info_from_scaler);
extern VOID Scaler_Set_Info_from_Scaler(MEMC_INFO_FROM_SCALER *info_from_scaler);

void scaler_config_video_latency_info_for_memc(KADP_VSC_INPUT_TYPE_T inputSrctype)
{
	MEMC_INFO_FROM_SCALER scaler_latency_info = {0};

	// memc input framerate
	if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 235) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) < 245))
		scaler_latency_info.in_frame_rate = 24;
	else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 245) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) < 255))
		scaler_latency_info.in_frame_rate = 25;
	else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 295) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) < 305))
		scaler_latency_info.in_frame_rate = 30;
	else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 495) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) < 505))
		scaler_latency_info.in_frame_rate = 50;
	else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 595) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) <= 605))
		scaler_latency_info.in_frame_rate = 60;
	else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) >= 994) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) <= 1005))
		scaler_latency_info.in_frame_rate = 100;
	else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) >= 1191) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) <= 1206))
		scaler_latency_info.in_frame_rate = 120;
	else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) > 2390) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ) < 2410))
		scaler_latency_info.in_frame_rate = 240;
	else{
		scaler_latency_info.in_frame_rate = 60;
	}

	// memc output framerate
	modestate_decide_dtg_m_mode();

	if(Get_DISPLAY_REFRESH_RATE() >= 120){
        if(scaler_latency_info.in_frame_rate == 240)
        {
            scaler_latency_info.out_frame_rate = Scaler_DispGetInputInfo(SLR_INPUT_DTG_MASTER_V_FREQ);
        }
        else
        {
            scaler_latency_info.out_frame_rate = Scaler_DispGetInputInfo(SLR_INPUT_DTG_MASTER_V_FREQ)*2;
        }
	}else{
		scaler_latency_info.out_frame_rate = Scaler_DispGetInputInfo(SLR_INPUT_DTG_MASTER_V_FREQ);
	}

#ifdef CONFIG_MEMC_NOTSUPPORT
	scaler_latency_info.game_mode_flag = 0;
	scaler_latency_info.adaptive_stream_flag = 0;
	scaler_latency_info.hdmi_flag = 0;
	scaler_latency_info.vdec_flag = 0;
#else
	// memc game mode
	scaler_latency_info.game_mode_flag = (drv_memory_get_low_delay_game_mode_dynamic()||drv_memory_get_vdec_direct_low_latency_mode());

	// memc adaptive stream
	scaler_latency_info.adaptive_stream_flag = vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY);

	// memc youtube flag
	// only support tv006
	//scaler_latency_info.YT_callback_flag = vsc_get_main_win_apply_done_event_subscribe();

	// memc hdmi flag
	scaler_latency_info.hdmi_flag = (inputSrctype == KADP_VSC_INPUTSRC_HDMI)?1:0;

	// memc vdec flag
	scaler_latency_info.vdec_flag = (inputSrctype == KADP_VSC_INPUTSRC_VDEC)?1:0;
#endif

#ifndef CONFIG_MEMC_NOTSUPPORT
	//set latency info for memc
	Scaler_Set_Info_from_Scaler(&scaler_latency_info);
	//Set_Info_from_Scaler(&scaler_latency_info);
#endif

	rtd_pr_vsc_notice("[calc_latency]scaler_config_video_latency_info_for_memc:\n");
	rtd_pr_vsc_notice("[calc_latency]memc.in_frame_rate: %d\n", scaler_latency_info.in_frame_rate);
	rtd_pr_vsc_notice("[calc_latency]memc.out_frame_rate: %d\n", scaler_latency_info.out_frame_rate);
	rtd_pr_vsc_notice("[calc_latency]memc.game_mode_flag: %d\n", scaler_latency_info.game_mode_flag);
	rtd_pr_vsc_notice("[calc_latency]memc.adaptive_stream_flag: %d\n", scaler_latency_info.adaptive_stream_flag);
	rtd_pr_vsc_notice("[calc_latency]memc.YT_callback_flag: %d\n", scaler_latency_info.YT_callback_flag);
	rtd_pr_vsc_notice("[calc_latency]memc.hdmi_flag: %d\n", scaler_latency_info.hdmi_flag);
	rtd_pr_vsc_notice("[calc_latency]memc.vdec_flag: %d\n", scaler_latency_info.vdec_flag);

}

unsigned char get_displayinfo_proc_impl(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)//This is for driver base implement open source
{
#ifdef CONFIG_SUPPORT_SRC_ADC
	unsigned int *p_sourceID = NULL;
#endif
//	SLR_VOINFO* pVOInfo;
	extern unsigned int get_current_driver_pattern(DRIVER_LIST_INFO info);
	SLR_VOINFO* pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
#ifdef CONFIG_SUPPORT_SRC_ADC
	if(display == SLR_SUB_DISPLAY) {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#endif
#ifdef CONFIG_FORCE_RUN_I3DDMA
	if(
		((inputSrctype != VSC_INPUTSRC_VDEC) && (inputSrctype != VSC_INPUTSRC_JPEG) && (display == SLR_MAIN_DISPLAY) && (get_hdmi_4k_hfr_mode()== HDMI_NON_4K120) &&
		((get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
			|| get_force_i3ddma_enable(SLR_MAIN_DISPLAY))) /*&& inputSrctype == KADP_VSC_INPUTSRC_HDMI*/
#ifdef CONFIG_I2RND_ENABLE
			|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
	)
	{

//		fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);
		fw_scaler_set_vgip(display, VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);
		if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
		{//Set sub vgip
			fw_scaler_set_vgip(SLR_SUB_DISPLAY, VGIP_SRC_VODMA2, VGIP_MODE_DIGITAL);
		}

		if(get_force_i3ddma_enable(display) &&
			((inputSrctype != VSC_INPUTSRC_HDMI) || (get_HDMI_HDR_mode() == HDR_MODE_DISABLE))
		)
		{
			//drvif_mode_enable_dma_onlinemeasure();
		}

		if(display == SLR_MAIN_DISPLAY)
		{
			if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			{//decide hdmi2.1 2 pixel or 1 pixel mode for scaler
				if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
				{//enable hdmi two pixel mode
					drvif_Hdmi_SetClkPixelMode(1);
				}
				else
				{//disable hdmi two pixel mode
					drvif_Hdmi_SetClkPixelMode(0);
				}
			}
		}
	}
	else if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
#else
	if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
#endif
	{
#ifdef CONFIG_SUPPORT_SRC_ADC
		if(ADC_Check_VSC_VFE_ConnectSrc_Match(*p_sourceID) == FALSE)
		{
			return FALSE;
		}
		down(get_adc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_ADC_Dispinfo());//now for test, only for ypp timing info
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_adc_detectsemaphore());
			rtd_pr_vsc_err("#####[%s(%d)] adc vsc_timinginfo_check no signal error\n",__func__,__LINE__);
			return FALSE;
		}
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 2000)//mean 4095 no support
		{
			up(get_adc_detectsemaphore());
			rtd_pr_vsc_err("#####[%s(%d)] adc vsc_timinginfo_check no support error\n",__func__,__LINE__);
			return FALSE;
		}
		ADC_set_detect_flag(FALSE);
		up(get_adc_detectsemaphore());

		// Scart RGB
		if(get_ADC_Input_Source() == _SRC_SCART_RGB)
		{
//			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), VGIP_SRC_ATV, VGIP_MODE_ANALOG);
			fw_scaler_set_vgip(display, VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		}
		// YPP and VGA
		else
		{
//			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), VGIP_SRC_ADC, VGIP_MODE_ANALOG);
			fw_scaler_set_vgip(display, VGIP_SRC_ADC, VGIP_MODE_ANALOG);
//			fw_scaler_set_sample(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _ENABLE);
			fw_scaler_set_sample(display, _ENABLE);
		}

		rtd_pr_vsc_notice("#####[%s(%d)] call ADC_VSC_Setting\n",__func__,__LINE__);
		ADC_VSC_Setting(get_ADC_Input_Source());
		fw_scaler_adc_nolock_wdg_ctrl(display, FALSE);//Disable adc_nolock_wdg
		drvif_mode_enableonlinemeasure(display);//Enable online measure
#ifdef CONFIG_SUPPORT_SRC_VGA
		if(get_ADC_Input_Source() == _SRC_VGA){
			if(drvif_mode_online_result_check(Get_ADC_Dispinfo()) == false){
				reset_adc_timing_ready();
				ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
				return FALSE;
			}
		}
#endif
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
	}
	else if(inputSrctype == VSC_INPUTSRC_AVD)
	{
		down(get_vdc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_AVD_ScalerDispinfo());
		if(vsc_timinginfo_check() == FALSE)
		{
			rtd_pr_vsc_notice("######[%s(%d)] vsc_timinginfo_check fail\n", __func__, __LINE__);
			up(get_vdc_detectsemaphore());
			return FALSE;
		}
		//VDC_set_detect_flag(FALSE);//Will temp add. Need to check.
		up(get_vdc_detectsemaphore());
//		fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		fw_scaler_set_vgip(display, VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		drvif_mode_enableonlinemeasure(display);//Enable online measure
	}
	else if(inputSrctype == VSC_INPUTSRC_HDMI)
	{
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
		HDMI_TIMING_T vfehdmitiminginfo;
		down(get_hdmi_detectsemaphore());
		if(0 == drvif_Hdmi_GetRawTimingInfo(&vfehdmitiminginfo))
		{
			up(get_hdmi_detectsemaphore());
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_With_NEW_HDMI_TIMING_INFO(display, vfehdmitiminginfo);
#else
		vfe_hdmi_timing_info_t vfehdmitiminginfo;
		down(get_hdmi_detectsemaphore());
		if(0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, display))
		{
			up(get_hdmi_detectsemaphore());
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_WithVFEHMDI(display, vfehdmitiminginfo);
#endif

		if(get_field_alternative_3d_mode_enable() == TRUE)
		{
			//USER:Lewislee DATE:2015/09/29
			//PIP no 3D
			if(SLR_SUB_DISPLAY == display)
			{
				up(get_hdmi_detectsemaphore());
				return FALSE;
			}
			else// if(SLR_MAIN_DISPLAY == display)
			{
				if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
				{
					up(get_hdmi_detectsemaphore());
					return FALSE;
				}
			}

//				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE, TRUE);
			Scaler_DispSetStatus(display, SLR_DISP_INTERLACE, TRUE);
		}
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_hdmi_detectsemaphore());
			return FALSE;
		}

		HDMI_set_detect_flag(FALSE);
		if(display == SLR_MAIN_DISPLAY)
		{
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			{//enable hdmi two pixel mode
				drvif_Hdmi_SetClkPixelMode(1);
			}
			else
			{//disable hdmi two pixel mode
				drvif_Hdmi_SetClkPixelMode(0);
			}
		}
		up(get_hdmi_detectsemaphore());
		if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && drvif_scaler3d_decide_HDMI_framePacking_auto_status(display))
		{
			modestate_HDMI_3D_format_auto_detection(display);

			//USER:Lewislee DATE:2015/09/29
			//PIP no 3D
			if(SLR_SUB_DISPLAY == display)
			{
				if(SLR_3DMODE_3D_AUTO == Scaler_Get3DMode(SLR_SUB_DISPLAY))
				{
					if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE) >= HDMI3D_2D_ONLY)
					{
						//bypass
					}
					else
					{
//							up(get_hdmi_detectsemaphore());
						return FALSE;
					}
				}
			}
			else// if(SLR_MAIN_DISPLAY == display)
			{
				if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
				{
					if(SLR_3DMODE_3D_AUTO == Scaler_Get3DMode(SLR_MAIN_DISPLAY))
					{
						if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE) >= HDMI3D_2D_ONLY)
						{
							//bypass
						}
						else
						{
//								up(get_hdmi_detectsemaphore());
							return FALSE;
						}
					}
				}
			}
		}
		//HDMI HFR force Vtop or real HDR case, need configure Vtop settings before enabling onms
		if(get_support_vo_force_v_top(support_sdr_max_rgb) || (get_HDMI_HDR_mode() == HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() == HDR_HDR10_HDMI))
			hdmi_vtop_hfr_control();//for two pixel mode setting
		fw_scaler_set_vgip(display, ((display == SLR_MAIN_DISPLAY) && (get_support_vo_force_v_top(support_sdr_max_rgb)) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120)))? VGIP_SRC_VODMA1 : VGIP_SRC_TMDS, VGIP_MODE_ANALOG);
		drvif_mode_enableonlinemeasure(display);//Enable online measure
		save_online_enable_time(display);//save online enable time
	}
	else if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG)) {

		if (Scaler_Get_CurVoInfo_VoVideoPlane(display) == VO_VIDEO_PLANE_V2)
			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_VODMA2, VGIP_MODE_ANALOG);
		else
			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);
	} else {
		return FALSE;
	}

#ifdef SPEEDUP_NEW_SCALER_FLOW
	if(((inputSrctype == VSC_INPUTSRC_ADC) || (inputSrctype == VSC_INPUTSRC_HDMI) || (inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG) ||
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
		(inputSrctype == VSC_INPUTSRC_AVD)
#else
		((inputSrctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV))
#endif
		)

	//sub re-run main case, no need to check main arc @Crixus 20180112
#ifdef CONFIG_I2RND_ENABLE
	&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
#endif
	)
	{
		if(display == SLR_MAIN_DISPLAY)
		{//active state mean already run scaler
			check_ARC_status(display, (KADP_VSC_INPUT_TYPE_T)inputSrctype);
		}
	}
#endif

	//calc sub airplay output region
    if((display == SLR_SUB_DISPLAY) && (vsc_get_adaptivestream_flag(SLR_SUB_DISPLAY) == ADAPTIVE_AIR_MODE))
    {
    	vsc_adaptivestream_calc_outregion(SLR_SUB_DISPLAY);
    }

#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((((inputSrctype == VSC_INPUTSRC_VDEC)||(inputSrctype == VSC_INPUTSRC_JPEG) ||(get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		|| get_force_i3ddma_enable(display))&&(SLR_MAIN_DISPLAY == display))
#ifdef CONFIG_I2RND_ENABLE
		||((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
		)
#else
	if(((inputSrctype == VSC_INPUTSRC_VDEC)||(inputSrctype == VSC_INPUTSRC_JPEG) ||(get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		)&&(SLR_MAIN_DISPLAY == display))
#endif
	{
		//unsigned char smooth_toggle_mode=SLR_DISPLAY_DEFAULT;
		unsigned char plane=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
		if (Scaler_get_data_framesync(display)) {
			Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, TRUE);
		} else {
			Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		}

	        if ((get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) && (inputSrctype == VSC_INPUTSRC_VDEC))
			scaler_SendDispSize(Scaler_DispWindowGet());

		rtd_pr_vsc_emerg( "data FS/FRC@%d\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC));
		plane = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
		if (inputSrctype == VSC_INPUTSRC_VDEC) {
			if (get_vo_open_smooth_toggle_enable(display) && (!Get_vo_smoothtoggle_timingchange_flag(display))
				&&((get_rotate_mode(SLR_MAIN_DISPLAY)==get_ori_rotate_mode(SLR_MAIN_DISPLAY))|| (get_ori_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				/*&& (display == SLR_MAIN_DISPLAY)*/) {
					Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			} else if (Get_vo_smoothtoggle_timingchange_flag(display)) {
				set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
				//vo_force_data_mode_set_enable(smooth_toggle_mode, display);
			} else if(get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY)){
				Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			}
		}

	#if 1
		if(get_3D_mode_enable() == TRUE)
		{
			if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF )
			{
				Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE, SLR_3D_SIDE_BY_SIDE_HALF);
				Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_3D_SBS);
			}
			else if(get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM)
			{
				Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE, SLR_3D_TOP_AND_BOTTOM);
				Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_3D_TB);
			}
			else if(get_vo_3d_mode() == VO_3D_FRAME_PACKING)
			{
				Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE, SLR_3D_FRAME_PACKING);
				Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_3D_FP);
			}
		}
		else
		{
			Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE,SLR_3D_2D_ONLY);
			Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_2D);
		}
	#endif
	}
	else if(SLR_SUB_DISPLAY == display)
	{
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		if (inputSrctype == VSC_INPUTSRC_VDEC) {
			unsigned char plane=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
			if (get_vo_open_smooth_toggle_enable(display) && (!Get_vo_smoothtoggle_timingchange_flag(display))
				&&((get_rotate_mode(SLR_MAIN_DISPLAY)==get_ori_rotate_mode(SLR_MAIN_DISPLAY))|| (get_ori_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				/*&& (display == SLR_MAIN_DISPLAY)*/) {
					Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			} else if (Get_vo_smoothtoggle_timingchange_flag(display)) {
				set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
				//vo_force_data_mode_set_enable(smooth_toggle_mode, display);
			} else if(get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY)){
				Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			}
		}
	}
	else
	{
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		//vo_force_data_mode_set_enable(SLR_DISPLAY_DATA_FRC, display);
	}

	if(get_hdmi_4k_hfr_mode() != HDMI_NON_4K120)
	{//hmdi 4k2k 120 application force go data frc
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
	}
    else if((Get_DISPLAY_REFRESH_RATE() >= 120) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
    {
        //hmdi 4k2k 120 vrr/freesync go data frc
        Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
    }

		//Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);//temp to go data frc. sync is not ready



#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG) || (get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		|| get_force_i3ddma_enable(display)
#ifdef CONFIG_I2RND_ENABLE
		|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
		)
#else
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG) || (get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		)
#endif
	{
		Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, FALSE);

	}
	else
	{
		if (Get_PANEL_VFLIP_ENABLE())
			Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, TRUE);
		else
			Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, FALSE);
	}

	set_default_mcap_format(display, inputSrctype);//Set default m cap 422 or 444

	#ifdef HDMI_NO_PQDC_TEST
		set_vsc_run_pc_mode(TRUE);
		rtd_pr_vsc_emerg(" HDMI_NO_PQDC_TEST  set_vsc_run_pc_mode(TRUE);\n");
	#endif

	if ((get_sub_OutputVencMode() && (display == SLR_SUB_DISPLAY)) || (get_main_OutputVencMode() && (display == SLR_MAIN_DISPLAY))) {
		rtd_pr_vsc_debug("\r\n######DbgSclrFlgTkr.OutputVencMode force to 422capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	} else if((get_vsc_run_pc_mode() == TRUE) && ((inputSrctype == VSC_INPUTSRC_ADC) || (inputSrctype == VSC_INPUTSRC_HDMI) || (inputSrctype == VSC_INPUTSRC_JPEG))) {
		rtd_pr_vsc_debug("\r\n######get_vsc_run_pc_mode() is true force to 444capture######\r\n");
		if(display == SLR_SUB_DISPLAY)
			Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);//sub only run 422 format
		else
			Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
	}

	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
		rtd_pr_vsc_debug("\r\n######framesync is true force to 422capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#else
		rtd_pr_vsc_debug("\r\n######framesync is true force to 444capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#endif
	} else if(get_3D_overscan_enable()) {
		rtd_pr_vsc_debug("\r\n######get_3D_overscan_enable is true force to 444capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	}
	if((display == SLR_MAIN_DISPLAY) && pc_mode_run_444() && (inputSrctype == VSC_INPUTSRC_HDMI))
	{
		rtd_pr_vsc_debug("\r\n######RGB444 PC mode force to 444capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
	}
	if((display == SLR_MAIN_DISPLAY) && Get_rotate_function(SLR_MAIN_DISPLAY))
	{
        	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######rotate mode force to 422capture######\r\n");
        	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	}
#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(display == SLR_MAIN_DISPLAY)
		Scaler_DispSetStatus(display, SLR_DISP_INTERLACE, FALSE);//force to set no interlace
#endif

	if (Get_tv006_wb_pattern() == 0)
		IoReg_ClearBits(SCALEUP_D_UZU_Globle_Ctrl_reg, _BIT0|_BIT1);//clear uzu pattern gen
	// FixMe
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),SLR_DISP_10BIT,FALSE);//let all source go 10bit mode
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (get_vo_vp9_flag(Get_DisplayMode_Port(display)))) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);//VP9 case use 8 bits setting @ Crixus 20160407
#ifdef CONFIG_I2RND_ENABLE
	}else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
#endif
	} else if (display == SLR_MAIN_DISPLAY) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, TRUE);//let all source go 10bit mode
	} else if(display == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, TRUE);// sub go 10 bit
	}

	if (display == SLR_MAIN_DISPLAY)
	{
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		if (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
			Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
#endif
		if(Get_Factory_SelfDiagnosis_Mode() == TRUE)
			Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
	}

	//Eric@20181016 check direct vdec low latency mode
	if((inputSrctype == VSC_INPUTSRC_VDEC)&&(SLR_MAIN_DISPLAY == display) && get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) && (pVOInfo->lowdelay == _ENABLE)){
		if(get_vo_camera_flow_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))){
			drv_memory_set_vdec_direct_low_latency_mode(_DISABLE);
			rtd_pr_vsc_emerg("[vo low delay][%s]disable vdec direct low delay mode at camera flow\n", __FUNCTION__);
		}else{
			drv_memory_set_vdec_direct_low_latency_mode(_ENABLE);
			rtd_pr_vsc_emerg("[vo low delay][%s]enable vdec direct low delay mode\n", __FUNCTION__);
		}
	}
	else{
		drv_memory_set_vdec_direct_low_latency_mode(_DISABLE);
		rtd_pr_vsc_emerg("[vo low delay][%s]Disable vdec direct low delay mode\n", __FUNCTION__);
				rtd_pr_vsc_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
		vpq_memc_set_lowDelayMode(_DISABLE);	//reset MEMC low delay mode
	}

	if((inputSrctype == VSC_INPUTSRC_VDEC)&&(SLR_MAIN_DISPLAY == display) && !get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY))
		drvif_Hdmi_OutputDisable(1); //willychou fixed KTASKWBS-9866

#ifdef CONFIG_COMPRESSION_MODE_TEST
	if(SLR_SUB_DISPLAY == display)
	{
		if(get_sub_OutputVencMode())
		{
			dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, FALSE);//disable compress
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, FALSE);// disable compress sub go 8 bit
		}
		else
		{
#if 0
				if(get_hdmi_4k_hfr_mode() == HDMI_NON_4K120)
				{
					if(get_hdmi_vrr_4k60_mode()){
						dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, TRUE);//enable compress
						dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, COMPRESSION_FRAME_MODE);
						dvrif_memory_set_compression_bits(SLR_SUB_DISPLAY, COMPRESSION_12_BITS);//444 go 12 bits
						Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, FALSE);
					}
					else{
						//sub pqdc setting conflict with main 2step uzu,so go 422 8 bit
						dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, FALSE);//disable compress
						Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, FALSE);// disable compress sub go 8 bit
						Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, TRUE);
					}
				}else{
					dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, TRUE);//enable compress
					dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, COMPRESSION_FRAME_MODE);
					dvrif_memory_set_compression_bits(SLR_SUB_DISPLAY, COMPRESSION_12_BITS);//444 go 12 bits
					Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, FALSE);
				}
#else
				//If run sub path only, sub pqdc setting conflict with main 2step uzu,so go 422 8 bit
				//dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, TRUE);//disable compress
				//Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, FALSE);// disable compress sub go 8 bit
				//Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, TRUE);

				//enable compress for all sub source
				//if((get_hdmi_4k_hfr_mode() == HDMI_NON_4K120) && !(get_hdmi_vrr_4k60_mode()) && (Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC)) {
					dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, TRUE);
					dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, COMPRESSION_FRAME_MODE);
					dvrif_memory_set_compression_bits(SLR_SUB_DISPLAY, COMPRESSION_12_BITS);
					Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, FALSE);
				//}
#endif

		}
	}
	//self-dianosis need disable compression, rzhen@2016-09-01
	else if ((SLR_MAIN_DISPLAY == display)
		/*&&(drv_memory_get_game_mode() == _DISABLE)*/ //keep compression in game mode @Crixus 20170527
		&&(Get_Factory_SelfDiagnosis_Mode() == FALSE)
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		&&(FALSE == Get_rotate_function(SLR_MAIN_DISPLAY))
#endif
		)
	{
		#ifdef ENABLE_DE_CONTOUR_I2R // TEST -- de-contour test
            if(rtd_inl(VGIP_VGIP_VBISLI_reg) & _BIT20){
                // IDMA source chroma is 422 (encfmt = 2, 3)
                Scaler_DispSetStatus(display, SLR_DISP_422CAP, VODMA_VODMA_V1CHROMA_FMT_get_encfmt(rtd_inl(VODMA_VODMA_V1CHROMA_FMT_reg)) < 4? TRUE: FALSE);

                rtd_pr_vsc_emerg("[COMP] IDMA source 10bit/emcf=%d/%d\n", VODMA_VODMA_V1_DCFG_get_seq_data_width(rtd_inl(VODMA_VODMA_V1_DCFG_reg)),
                    VODMA_VODMA_V1CHROMA_FMT_get_encfmt(rtd_inl(VODMA_VODMA_V1CHROMA_FMT_reg)));

                dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);
        	   dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_NONE_MODE);
            }else
#endif
            {
		//Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);//compress force 422. need to check

		#ifdef HDMI_NO_PQDC_TEST
			rtd_pr_vsc_emerg(" HDMI_NO_PQDC_TEST  dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);\n");
			dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);
		#else
			dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, TRUE);
		#endif

		//for better performance under 2k and non-vrr set bigger comp ratio
		if((get_HD_FHD_platform_model() == FALSE) &&	//HD or FHD panel use 12/16bit compression
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) < 1920) &&
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) < 1080) &&
			!(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())) {
			if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) && (!get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY))) {
	            if(get_vsc_run_pc_mode())
					 dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_20_BITS);//K5X M-domain + DI = 51M, so only can use 16bit for PQC //444 go 20 bit for K4 PQC @Crixus 20170718
	            else
	                dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_18_BITS); //not pc mode
				//rtd_pr_vsc_emerg("[crixus]M-domain Compression RGB444 20bits Enable!!\n");
			}
			else{
				if(inputSrctype == VSC_INPUTSRC_VDEC){
					dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_10_BITS);//VDEC go 10 bits @crixus 20170724
				}
				else{
					dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_18_BITS);//422 go 12 bits
				}
				//rtd_pr_vsc_emerg("[crixus]M-domain Compression Enable!!\n");
			}
		} else {
			if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) && (!get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY))) {
	            if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
	                dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_12_BITS); //4k120 hdmi2.0 yuv420 go compress 12 bits
	            else if(get_vsc_run_pc_mode())
					 dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_16_BITS);//K5X M-domain + DI = 51M, so only can use 16bit for PQC //444 go 20 bit for K4 PQC @Crixus 20170718
		    else
	                dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_12_BITS); //not pc mode
				//rtd_pr_vsc_emerg("[crixus]M-domain Compression RGB444 20bits Enable!!\n");
			}
			else{
				if(inputSrctype == VSC_INPUTSRC_VDEC){
					dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_10_BITS);//VDEC go 10 bits @crixus 20170724
				}
				else{
					dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_12_BITS);//422 go 12 bits
				}
				//rtd_pr_vsc_emerg("[crixus]M-domain Compression Enable!!\n");
			}
		}
		//vflip need to use line mode @Crixus 20171102
		//Eric@20181016 direct vdec low latency mode use compression line mode
		//VRR need to use line mode @ Eric 20181107
		if (Get_PANEL_VFLIP_ENABLE() || drv_memory_get_vdec_direct_low_latency_mode()|| ((vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)))
			dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);
		else
			dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);
	}
		//rtd_pr_vsc_emerg("[crixus]M-domain Compression Enable!!\n");
	}
	else
	{
		dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);

		//rtd_pr_vsc_emerg("[crixus]M-domain Compression Disable!!\n");
	}

	if(inputSrctype == VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_emerg( "###Finally fsync:%d 422:%d comp(%d %d) disp(%d) hfr:%d vrr:%d freesync:%d qms:%d ###\r\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC), Scaler_DispGetStatus(display, SLR_DISP_422CAP), dvrif_memory_compression_get_enable(display), dvrif_memory_get_compression_bits(display), display, get_hdmi_4k_hfr_mode(), vbe_disp_get_VRR_timingMode_flag(), vbe_disp_get_freesync_mode_flag(), get_scaler_qms_mode_flag());
	}
	else
	{
		rtd_pr_vsc_emerg( "###Finally fsync:%d 422:%d comp(%d %d) disp(%d)###\r\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC), Scaler_DispGetStatus(display, SLR_DISP_422CAP), dvrif_memory_compression_get_enable(display), dvrif_memory_get_compression_bits(display), display);
	}
	//re-run sclar flow, reset game mode status.
	if(SLR_MAIN_DISPLAY ==display){
		drv_memory_set_game_mode(_DISABLE);
		Scaler_set_MEMC_gamemode_lowdelay(0);
		vpq_memc_set_lowDelayMode(_DISABLE);
		Scaler_MEMC_Set_VpqLowDelayToMEMC_Flag(0);
        DbgSclrFlgTkr.game_mode_rerun_scaler_flag = FALSE;
		game_mode_ignore_cmd_check = _ENABLE;//run scaler case, do not check game mode cmd to reduce the mute time.
		smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;//reset smooth_toggle_game_mode_timeout_trigger_flag
		game_mode_cmd_pre = game_mode_cmd_check;//update game_mode_cmd_pre
		st_game_mode_cmd_pre = smooth_toggle_game_mode_check_cnt;//update st_game_mode_cmd_pre flag
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);//reset game mode fbg mask
		rtd_pr_new_game_mode_emerg("reset game mode status when run scaler flow!!\n");

        drv_set_vrr_mode_dynamic(_DISABLE);
		drv_set_vrr_low_delay_mode_dynamic(_DISABLE);
		drv_set_freesync_mode_dynamic(_DISABLE);
    }

	//limit mode setting
	drv_memory_set_limit_boundary_mode(display, _ENABLE);

	if((SLR_MAIN_DISPLAY == display) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || get_hdmi_vrr_4k60_mode()))
	{//copy from main for sub m domain
		dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY));
		dvrif_memory_set_compression_bits(SLR_SUB_DISPLAY, dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));
		dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, dvrif_memory_get_compression_mode(SLR_MAIN_DISPLAY));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_VFLIP3, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_VFLIP3));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_FRAMESYNC, 0);
		drv_memory_set_limit_boundary_mode(SLR_SUB_DISPLAY, _ENABLE);
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_V_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	}

#ifdef CONFIG_I2RND_ENABLE
	if(Scaler_I2rnd_get_display() == I2RND_MAIN_S0_TABLE)
#endif
	drvif_memory_compression_rpc(display);

#endif
	return TRUE;
}
unsigned char (*get_displayinfo_proc)(unsigned char, VSC_INPUT_TYPE_T) = get_displayinfo_proc_impl;

void close_livezoom_doublebuffer(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS mdomain_disp_ddr_mainsubctrl_Reg;
	ppoverlay_double_buffer_ctrl_RBUS ppoverlay_double_buffer_ctrl_Reg;
	scaleup_dm_uzu_db_ctrl_RBUS scaleup_dm_uzu_db_ctrl_Reg;
	scaleup_ds_uzu_db_ctrl_RBUS scaleup_ds_uzu_db_ctrl_Reg;
	unsigned long flags = 0;//for spin_lock_irqsave

	//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);
	mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 0;
	mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 0;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

	down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
	//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Enable dtg double buffer register
	spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
	ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
	ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
	ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 0;
	IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
	spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
	up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
	//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
	scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
	scaleup_ds_uzu_db_ctrl_Reg.db_en = 0;
	IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);

	//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
	scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
	scaleup_dm_uzu_db_ctrl_Reg.db_en = 0;
	IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);

}

unsigned char init_source_proc_impl(unsigned char display, VSC_INPUT_TYPE_T sourcetype, unsigned char sourceport)
{
	unsigned short vfesource;
	unsigned int *p_sourceID = NULL;

	int i= 0, size;
	//unsigned int srcid = MainOpenSourceID;
	StructSourceInput *srcinput_pt = NULL;
	//rtd_pr_vsc_debug("%s.%d\n", __FUNCTION__, __LINE__);


	if(get_zoom_reset_double_state(display) == _ENABLE){
		set_zoom_reset_double_state(_DISABLE,display);
 	}

#ifdef CONFIG_DUAL_CHANNEL
		if (display == SLR_MAIN_DISPLAY) {
			p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
		} else {
			p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
		}
#else
		if (display == SLR_MAIN_DISPLAY) {
			p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
		} else {
			return FALSE;
		}

#endif

	switch(sourcetype)
	{
		case KADP_VSC_INPUTSRC_AVD:
		{
			down(get_setsource_semaphore());
			vfesource = get_AVD_Input_Source();
			up(get_setsource_semaphore());
			switch (vfesource) {
			case _SRC_TV://atv
			{
				if(sourceport == 0) {
					*p_sourceID = _TV_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _TV_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _TV_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc AVD ATV port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				if (display == SLR_MAIN_DISPLAY) {
					DbgSclrFlgTkr.Main_AutoRunScaler = TRUE;
				}
#ifdef CONFIG_DUAL_CHANNEL
				else {
					DbgSclrFlgTkr.Sub_AutoRunScaler = TRUE;
				}
#endif
				break;
			}
			case _SRC_CVBS://cvbs
			{
				if(sourceport == 0) {
					*p_sourceID = _AV_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _AV_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _AV_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc AVD CVBS port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}

				break;
			}
			case _SRC_SCART://SCART
			{
				if(sourceport == 0) {
					*p_sourceID = _SCART_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _SCART_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _SCART_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc AVD SCART RGB port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}

			default:
				rtd_pr_vsc_debug("init_source_proc AVD VFE not connect!!!!!!!!!!!!!!!1\n");
				return FALSE;
			}
			break;
		}
		case KADP_VSC_INPUTSRC_ADC:
		{
			down(get_setsource_semaphore());
			vfesource = get_ADC_Input_Source();
			up(get_setsource_semaphore());
			switch (vfesource) {
			case _SRC_YPBPR://ypp
			{
				if (sourceport == 0) {
					*p_sourceID = _YPBPR_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _YPBPR_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _YPBPR_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc ADC YPP port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}

				break;
			}
			case _SRC_VGA://VGA
			{
				if (sourceport == 0) {
					*p_sourceID = _VGA_INPUT1;
				} else if(sourceport == 1) {
					*p_sourceID = _VGA_INPUT2;
				} else if(sourceport == 2) {
					*p_sourceID = _VGA_INPUT3;
				} else {
					rtd_pr_vsc_info("init_source_proc ADC VGA port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}
			case _SRC_SCART_RGB://SCARTRGB
			{
				if (sourceport == 0) {
					*p_sourceID = _SCART_RGB_INPUT1;
				} else if(sourceport == 1) {
					*p_sourceID = _SCART_RGB_INPUT2;
				} else if(sourceport == 2) {
					*p_sourceID = _SCART_RGB_INPUT3;
				} else {
					rtd_pr_vsc_debug("init_source_proc ADC SCART_RGB port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}
			default:
				rtd_pr_vsc_debug("init_source_proc ADC VFE not connect!!!!!!!!!!!!!!!1\n");
				return FALSE;
			}
			break;
		}
		case KADP_VSC_INPUTSRC_HDMI:
		{

			if (sourceport == 0) {
				*p_sourceID = _HDMI_INPUT1;
			} else if(sourceport == 1) {
				*p_sourceID = _HDMI_INPUT2;
			} else if(sourceport == 2) {
				*p_sourceID = _HDMI_INPUT3;
			} else if(sourceport == 3) {
				*p_sourceID = _HDMI_INPUT4;
			} else {
				rtd_pr_vsc_debug("init_source_proc HDMI port%d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
				return FALSE;
			}
			break;
		}

		case VSC_INPUTSRC_VDEC:
		{
            *p_sourceID = _VO_INPUT1;
			break;
		}
		case VSC_INPUTSRC_JPEG:
		{
            *p_sourceID = _VO_INPUT1;
			break;
		}
		default:
		{
			return FALSE;
			break ;
		}
	}
	if(display == SLR_MAIN_DISPLAY)
	{
		if((get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1) && (get_hdmi_4k_hfr_mode() != HDMI_3K120))
		{
#ifdef CONFIG_FORCE_RUN_I3DDMA

#else
			if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
				)
#endif
			{
				  *p_sourceID = _VO_INPUT1;
			}
		}
	}


#ifdef CONFIG_I2RND_ENABLE
	//i2r case, sub will force to use port 1, need to use TV1. @Crixus 20171208
	if((display == SLR_SUB_DISPLAY) && (sourcetype == VSC_INPUTSRC_AVD) && (vfesource == _SRC_TV)){
		*p_sourceID = _TV_INPUT1;
	}
#endif

	size = PcbSource_GetTableSize();
	srcinput_pt = Scaler_InputSrc(0);

	for(i = 0; i < size; i++)
	{
		if(srcinput_pt->src_index == *p_sourceID) break;
		srcinput_pt++;
	}
	if(i == size)
	{
		rtd_pr_vsc_err("\r\n###### source not found#######\r\n");
		return FALSE;
	}
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_INPUT_SRC, i);
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_DATA_ARRAY_IDX, i);//For m_screenModeCurrInfo table
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_OSD_INPUT_SRC, i);
	Scaler_SetUserInputSrc((SCALER_DISP_CHANNEL)display, i);

	if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0) && (display == SLR_MAIN_DISPLAY))
	{
		Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)SLR_SUB_DISPLAY, SLR_INPUT_INPUT_SRC, i);
		Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)SLR_SUB_DISPLAY, SLR_INPUT_DATA_ARRAY_IDX, i);//For m_screenModeCurrInfo table
		Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)SLR_SUB_DISPLAY, SLR_INPUT_OSD_INPUT_SRC, i);
		Scaler_SetUserInputSrc((SCALER_DISP_CHANNEL)SLR_SUB_DISPLAY, i);
	}
	return TRUE;

}
unsigned char (*init_source_proc)(unsigned char display, VSC_INPUT_TYPE_T sourcetype, unsigned char sourceport) = init_source_proc_impl;

static void set_default_mcap_format(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)
{//Set M Cap 444 or 422
#ifndef CONFIG_DUAL_CHANNEL
	display = SLR_MAIN_DISPLAY;
#endif
	switch(inputSrctype) {
	case KADP_VSC_INPUTSRC_ADC:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

	case KADP_VSC_INPUTSRC_HDMI:
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#else
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#endif
	break;

	case KADP_VSC_INPUTSRC_AVD:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

	case VSC_INPUTSRC_VDEC:
	case VSC_INPUTSRC_JPEG:
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#else
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#endif

	break;

	default:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;
	}
}

static unsigned char modestate_set_vgip(StructDisplayInfo* info)
{

	unsigned char result = TRUE;
    //extern unsigned int vpq_project_id;
#if 0
	// restore original signa's info
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
	IoReg_WriteByte0(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_DELAY_reg : VGIP_VGIP_CHN1_DELAY_reg, Scaler_DispGetInputInfo(SLR_INPUT_IPV_DLY_PRE));
#else
	IoReg_WriteByte0(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_DELAY_reg : */VGIP_VGIP_CHN1_DELAY_reg, Scaler_DispGetInputInfo(SLR_INPUT_IPV_DLY_PRE));
#endif
#endif

#ifdef CONFIG_ENABLE_3D_SETTING
	modestate_decide3D_for_vdc();
#endif

	//If source is FR, handle display ratio at movie or caption
	if(!fw_scaler_cal_vgip_capture(info->display))
		return FALSE;
#if 0
    if (0){//(vpq_project_id == 0x00010000) {
        stDISPLAY_OVERSCAN_DATA scan_data={0};
        stVGIP_ADJUSTMENT_INFO adj_data={0};
        scan_data.HStart = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA);
        scan_data.HWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID);
        scan_data.VStart = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA);
        scan_data.VHeight = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN);
        Mode_scaler_overscan(&scan_data,0);
        Mode_scaler_VGIP_Adjustment(&adj_data,0);

        Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_STA,scan_data.HStart+adj_data.h_start);
        Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_WID,scan_data.HWidth+adj_data.h_width);
        Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_STA,scan_data.VStart+adj_data.v_start);
        Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_LEN,scan_data.VHeight+adj_data.v_length);
    }
#endif
	if ((Get_sub_from_DI_mux_path()) && (info->display== SLR_SUB_DISPLAY)) {
		//tmp code
		return result;
	}

	/* setup capture window */
	fw_scaler_set_vgip_capture(info->display);

	// Attention: This bit may be set as enable again in memory_3ddma_control()
	fw_scaler_set_vgip_3d_mode(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _DISABLE);

#if 1
	//USER:Lewis DTAE:2015/09/29
	//PIP no 3D
	if(SLR_MAIN_DISPLAY == info->display)
	{
		if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
		{
			fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
		else// if(((FALSE == DbgSclrFlgTkr.Sub_OuputDisplayMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputVencMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputMemoryMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputAveMode)))
		{
			if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
				if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING)
					fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
				else
					fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
			}
#ifdef ENABLE_SG_3D_SUPPORT_ALL_SOURCE_3D_MODE // [SG] HDMI FP video in M-domain frame sequence 3D output mode
			else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
				&& (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING) && (drvif_scaler3d_decide_3d_SG_Disable_IDMA(SLR_3D_FRAME_PACKING) == TRUE))
				fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
#endif // [SG] MVC 3D data FRC path (M-domain data FRC sequence 3D output)
			else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && modestate_get_vo3d_in_framePacking_FRC_mode())
				fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
			else
				fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
	}
	else// if(SLR_SUB_DISPLAY == info->display)
	{
		fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
	}
#else //#if 1
	if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
		if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING)
			fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
		else
			fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
#ifdef ENABLE_SG_3D_SUPPORT_ALL_SOURCE_3D_MODE // [SG] HDMI FP video in M-domain frame sequence 3D output mode
	else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
		&& (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING) && (drvif_scaler3d_decide_3d_SG_Disable_IDMA(SLR_3D_FRAME_PACKING) == TRUE))
		fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
#endif // [SG] MVC 3D data FRC path (M-domain data FRC sequence 3D output)
	else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && modestate_get_vo3d_in_framePacking_FRC_mode())
		fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
	else
		fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
#endif //#if 1

	return result;
}
#if 0
// move to fw_scalerip_set_di
static void modestate_check_prtnr(void)
{
	di_im_di_rtnr_new_control_RBUS rtnr_new_Ctrl;
	rtnr_new_Ctrl.regValue = IoReg_Read32(DI_IM_DI_RTNR_NEW_CONTROL_reg);
	if(Scaler_DispGetInputInfo(SLR_INPUT_DI_WID)>1920){
		rtnr_new_Ctrl.prtnr_4k2k = 0x1;		//4K2K support
	}else{
		rtnr_new_Ctrl.prtnr_4k2k = 0x0;
	}
	IoReg_Write32(DI_IM_DI_RTNR_NEW_CONTROL_reg, rtnr_new_Ctrl.regValue);
}
#endif
void modestate_decide_rtnr(void)
{
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
        {
                Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
		return;
        }
#endif

	//SLR_VOINFO* pVOInfo;

#ifdef HDMI_NO_PQDC_TEST
	return;
#endif
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	//Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
	//return;
#endif

#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
		return;
	}
#endif

	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		if(get_hdmi_4k_hfr_mode()== HDMI_4K120_2_1)
		{
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
			return;
		}
	}


	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		//RGB444 & 4k2k disable RTNR @Crixus 20160902
		if((get_vsc_run_pc_mode()) &&
            ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)))
        {
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
			rtd_pr_vsc_emerg("[crixus]RGB444 disable RTNR\n");
			return;
		}
	}

	/* in Main channel, RTNR is controlled by AP , AP controlled table priority is higher than others*/
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY){
		Scaler_color_decide_RTNR_H_Rotate(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));	// h flip en decide
	}
	if ((Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) && (get_current_driver_pattern(DRIVER_RTNR_PATTERN) == DI_RTNR_OFF)) {
		if(Scaler_color_access_RTNR_H_Rotate_Flag(0, 0) == 0){
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
			rtd_pr_vsc_info("Decide RTNR, RTNR OFF by AP table\n");
		} else {
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			rtd_pr_vsc_info("Decide RTNR, RTNR ON by rotate \n");
		}
    } else if (drv_memory_get_vdec_direct_low_latency_mode() && !((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))) {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "[KK] Decide RTNR, RTNR OFF by vdec low delay\n");
    } else {
	    Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
		rtd_pr_vsc_info("Decide RTNR, RTNR ON by AP table \n");
	}

	return;
#if 0
	/* in Main channel, RTNR is controlled by AP , AP controlled table priority is higher than others*/
	if ((Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) && (get_current_driver_pattern(DRIVER_RTNR_PATTERN) == DI_RTNR_OFF)) {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_pr_vsc_info("Decide RTNR, RTNR OFF by AP table\n");
	} else {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
		rtd_pr_vsc_emerg( "Decide RTNR, RTNR ON by AP table\n");
	}

	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) {
	       modestate_check_prtnr();
	}
	return;
#endif
#if 0
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		//RGB444 & 4k2k disable RTNR @Crixus 20160902
		if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) &&
            ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)))
        {
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
			//rtd_pr_vsc_emerg("[crixus]RGB444 disable RTNR\n");
			return;
		}
	}
	//20151124 roger, sub don't open RTNR
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) {
	       modestate_check_prtnr();
	}

	pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

	// frank@0207 disable DI/RTNR to reduce bandwidth usage
	if (Scaler_InputSrcGetMainChType() == _SRC_VO)
	{
//		if((Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) > 1080))		//4k2k
//			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
//		else
		#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
		if(vbe_disp_get_adaptivestream_fs_mode()==1){
			if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>3000) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>495)){
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
			}else{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			}
			return;
			#if 0
			if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>3000)
			{
				if ((Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)==1 || Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<500) ||get_vsc_run_adaptive_stream()) 	//	FRAMESYNC mode
					Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
				else
					Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
				return;
			}
			else
			{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);//Vo always enable RTNR
				return;
			}
			#endif
		} else if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>1920)
		#else
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>1920)
		#endif
		{
#if 0
			if ((Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)==1 || Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<500) ||get_vsc_run_adaptive_stream())		//  FRAMESYNC mode
			{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			}else{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			}
#endif
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			return;
		}
		else
		{
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);//Vo always enable RTNR
			return;
		}
	}

	// force enable DI/NR when need enable HSD & VSD in the same time
	if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
		if((Scaler_DispGetInputInfo(SLR_INPUT_DISP_WID) < Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID))
			&& (Scaler_Disp3dGetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE) == SLR_3D_SIDE_BY_SIDE_HALF))
		{
			rtd_pr_vsc_debug("[3D] Force Enable RTNR in SBS 3D, Width In/Out[%d/%d]\n", Scaler_DispGetInputInfo(SLR_INPUT_DISP_WID), Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID));
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			return;
		}
	}

#ifdef ENABLE_DRIVER_I3DDMA
	if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == TRUE){
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
#endif

	// [SG] disable RTNR in 4k2k 3D mode
	if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
		&& (Scaler_InputSrcGetMainChType() == _SRC_VO) && (Scaler_Get3DMode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) != SLR_3DMODE_2D)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) >= 3840))
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_pr_vsc_debug("[RTNR] disable in 4k2k 3D mode\n");
		return;
	}

	//Elsie 20130314, force it to enter RTNR if source is CVBS.
	if(Scaler_InputSrcGetMainChType() == _SRC_CVBS)
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR,TRUE);
		rtd_pr_vsc_debug("[CVBS] RTNR ON\n");
		return;
	}
#ifdef CONFIG_RTNR_4K2K
	// [#0048022] 4k1k/4k2k video ratio mode 4:3 will cause RTNR fail
	if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)
			&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){	// 4k1k/4k2k
		drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		//frank@20130604 add below patch code for mantis#40619 solve DI readstart bits not enough problem
		if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID)-Scaler_DispGetInputInfo(SLR_INPUT_CAP_WID)) < 960)
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
		else
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
#endif

	// disable DI/RTNR in VO source HD video 3D mode due to no enough memory space
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (drvif_scaelr3d_decide_is_3D_display_mode() == TRUE)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 720))
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	} // Disable RTNR in MVC 3D
	else if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (pVOInfo->mode_3d == VO_3D_FRAME_PACKING) && (!pVOInfo->force2d))
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_pr_vsc_debug("[VO][3D] NR OFF\n");
		return;
	}


	// JPEG doesn't enter RTNR
	if ((Scaler_InputSrcGetMainChType()==_SRC_VO) && (Scaler_VOFromJPEG(Scaler_Get_CurVoInfo_plane()) == 1)) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, FALSE);
		return;
	}

	#if 0	//20150817 roger mark, merlin do not have double DVS condition
	if (/*Scaler_PipGetInfo(SLR_PIP_ENABLE) && */modestate_decide_double_dvs_enable()) { //avoid memory allocate is not enough
		// Only main display can enter GIBI and RTNR should be closed
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
	#endif
#ifdef CONFIG_DUAL_CHANNEL
	// Sub doesn't enter RTNR.
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
#endif

	// [#0048022] 4k1k/4k2k video ratio mode 4:3 will cause RTNR fail

	if((Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) > 2160)|| (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 4096)){//3   		//input frame paking case avoid scaler memory not enough
		//rika20151120 updated
		//let w=4096 goes rtnr, too
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_pr_vsc_debug("[4k2k] RTNR OFF in 4k2k\n");
		return;
	}

	if (Scaler_InputSrcGetMainChType() != _SRC_VGA) {
		if ( ((Scaler_InputSrcGetMainChFrom()==_SRC_FROM_TMDS) && (!drvif_IsHDMI())) ||
			((Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE) == 0) && (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)) ) // DVI don't enter RTNR
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, FALSE);
		else
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, TRUE);
	} else { // VGA don't enter RTNR
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, FALSE);
	}
	//vflip rtnr check again
#ifdef CONFIG_DUAL_CHANNEL
	// if main needs RTNR but sub allocates DI, we have to release sub.
	if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR)) {
			if (Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP) || Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR)) {
				/*Scaler_ForceBg(SLR_SUB_DISPLAY, SLR_FORCE_BG_SYSTEM, TRUE);*/
				fw_scalerip_disable_ip(SLR_SUB_DISPLAY);
				//frank@0528 Sove QCBUG10151 push below to set sub channel i,m,d domain to avoid sub set display but DI disable by main channel
				//flow_message_push(_MODE_MSG_SUB_SET_VGIP_AFTER_FOUND_MODE_SIGNAL);
				//flow_message_clearallType(_MODE_MSG_SUB_SETUP_BEFORE_SHOW_SIGNAL);
				//mark by frank@0528 flow_message_push(_MODE_MSG_SUB_SETUP_AFTER_FOUND_MODE_SIGNAL);
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
			}
	}
#endif
#endif
}

static void modestate_decide_DI(void)
{
	//unsigned char source = fwif_vip_source_check(3, 0);
	UINT32 picWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE);
	//unsigned char display_mode = Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);
	UINT32 timingMode;
	// Elsie 20131106: playback always does not use RTNR 10-bit mode.
	// 20131210 sync from Mac2
	unsigned int modeByAP_table;
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY)
	{
		//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		/*warning: sub could not set main di 10bit or 8bit flag*/
		//fw_scalerip_set_DI_chroma_10bits(FALSE);
#ifdef CONFIG_I2RND_ENABLE
	}else if((Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
		rtd_pr_vsc_emerg("[%s]I2rnd go 8bits!!!!!!\n", __FUNCTION__);
#endif
	}
	else if (get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) && (Scaler_InputSrcGetMainChType() == _SRC_VO) ){
		//if <1080, di10bit , >1080 di 8bit
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);

		if(Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080){
			fw_scalerip_set_DI_chroma_10bits(TRUE);
			rtd_pr_vsc_notice("_rk adaptive >2k1k force 8bit\n");

		}
		else{
			fw_scalerip_set_DI_chroma_10bits(TRUE);
			rtd_pr_vsc_notice("_rk adaptive 2k1k force 10bit\n");
		}
	} else if (Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() && get_3D_overscan_enable() &&
		((Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_SIDE_BY_SIDE_HALF) || (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_TOP_AND_BOTTOM) || (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING))) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(FALSE);
	}
	else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) && (Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()) == SOURCE_VIDEO)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 3000) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) >= 480)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE) && (Get_DISPLAY_PANEL_OLED_TYPE() == TRUE))
	{ // [OLED panel] data FRC force in 8bit capture mode
		Scaler_DispSetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL) , SLR_DISP_10BIT, FALSE);
	} else if ((Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080) && (Scaler_InputSrcGetMainChType() == _SRC_VO)) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
	}
#ifdef ENABLE_DE_CONTOUR_I2R // TEST -- de-contour
    else if(rtd_inl(VGIP_VGIP_VBISLI_reg) & _BIT20){
        // IDMA source pixel width is 8 bit (0: 8bit, 1: 10bit)
        unsigned char bIdma10bitMode = VODMA_VODMA_V1_DCFG_get_seq_data_width(rtd_inl(VODMA_VODMA_V1_DCFG_reg));
        Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, bIdma10bitMode);
	  fw_scalerip_set_DI_chroma_10bits(bIdma10bitMode);
    }
#endif

	else {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
	}

	//VP9 case use 8 bits setting @Crixus 20160407	2192
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (get_vo_vp9_flag(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY))))) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(FALSE);
	}

	if(Get_Factory_SelfDiagnosis_Mode() == TRUE)
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);


	rtd_pr_vsc_debug("[VSC] src/vdec/wid/freq, fs/10/olde=%d/%d/%d/%d, %d/%d/%d\n",
		Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()),
		Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ), Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC),
		Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT), Get_DISPLAY_PANEL_OLED_TYPE());


#if 1//def REDUCE_DIBW_ENABLE
//	UINT32 picWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE);

	// [XF112HAICNRTK1-88] linmc@20120712, reduce di bandwidth to resolve flicker picture screen happened
	//if (setManualReduceDIBW != NULL)
	//	setManualReduceDIBW();
	//else
	{
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
		//USER:LewisLee DATE:2012/12/20
		//fix VDC 27MHz mode, picture abnormal
		if(VD_27M_OFF != fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
		{
			picWidth = picWidth>>1;
		}
#endif //#ifdef CONFIG_ENABLE_VD_27MHZ_MODE

		// for playback source memory/bandwidth issue (24bit DI only for SD video--480i/576i)
		timingMode =  Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);

		//Elsie 20131210: Enable BTR mode when source is 1080i. 20140211: Always disable BTR when source is playback.
		if((Scaler_InputSrcGetMainChType() != _SRC_VO) && (timingMode == _MODE_1080I25 || timingMode==_MODE_1080I30))
		{
			drv_memory_set_ip_Btr_mode(_ENABLE);
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		}
		else if (picWidth > REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD)
		{
			drv_memory_set_ip_Btr_mode(_DISABLE);
			if(Scaler_InputSrcGetMainChType() == _SRC_VO){
				if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){		// 4k2k
					drv_memory_set_ip_DMA420_mode(SLR_DMA_400_mode);
				} else {
					drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
				}
			}
	                //frank@0904 add below code to avoid DI memory trash
			else if(Get_PANEL_VFLIP_ENABLE()){
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			}
			else if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)
			&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);				/*WOSQRTK-2096*/
			}
			else
			{
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
			}
			rtd_pr_vsc_debug("[DI] DI BTR/420[%d/%d], width=%d!\n", drv_memory_get_ip_Btr_mode(), drv_memory_get_ip_DMA420_mode(), picWidth);
		}
		else{
		#if 0
			if(Scaler_InputSrcGetMainChType() == _SRC_VO) {
				drv_memory_set_ip_Btr_mode(_DISABLE);
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			} else {
		#endif
				drv_memory_set_ip_Btr_mode(_ENABLE);
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		//	}
		}
	}
#else

#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
	//USER:LewisLee DATE:2012/12/20
	//fix VDC 27MHz mode, picture abnormal
	if(VD_27M_OFF != fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
	{
		picWidth = picWidth>>1;
	}
#endif //#ifdef CONFIG_ENABLE_VD_27MHZ_MODE


	if (picWidth > REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD){
		if((Scaler_InputSrcGetMainChType() == _SRC_HDMI)&&((_MODE_1080I25 == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR))||(_MODE_1080I30 == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR))) )
		{
			drv_memory_set_ip_Btr_mode(_ENABLE);//for 1080i video book Di 1 #chapter_10
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		}
		else
		{
			drv_memory_set_ip_Btr_mode(_DISABLE);
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
  #if 0 // [IDMA] IDMA 3D reduce bandwidth issue (Sensio 3D mode)
			if((Scaler_InputSrcGetMainChType() == _SRC_VO) && modestate_I3DDMA_get_In3dMode() && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) >= REDUCE_DI_BW_VFREQ_THRESHOLD))
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			else
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);

			rtd_pr_vsc_debug("[DBG] V_Freq=%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
  #endif
		}
		rtd_pr_vsc_debug("[DI] DI BTR/420[%d/%d], width=%d!!\n", drv_memory_get_ip_Btr_mode(), drv_memory_get_ip_DMA420_mode(), picWidth);
	}
	else{
		drv_memory_set_ip_Btr_mode(_ENABLE);
		drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
	}
#endif

#ifdef CONFIG_DUAL_CHANNEL
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
#if 0//frank@1008 simple the PIP flow
		// main need DI, just return
		if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_THRIP) ||		// use DI's IP
			Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE) ||	// interlace source
			Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_RTNR))	{		// RTNR (because RTNR and DI uses the same IP)
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP,FALSE);
				return;
		}

		// main don't need DI, if sub need, sub get it!
		if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, TRUE);
		return;
#else
		//add HDMI sub channel field control @Crixus 20151203
		if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
			DbgSclrFlgTkr.multiview_sub_interlace_flag = TRUE;
		else
			DbgSclrFlgTkr.multiview_sub_interlace_flag = FALSE;

		//sub always don't go DI
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
		return;
#endif
	}
#endif

	// now handle main display
	//if(Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE)) {
	if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
#ifdef CONFIG_DUAL_CHANNEL
		if (Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP) || Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR)) {
			/*Scaler_ForceBg(SLR_SUB_DISPLAY, SLR_FORCE_BG_SYSTEM, TRUE);*/
			fw_scalerip_disable_ip(SLR_SUB_DISPLAY);
			//frank@0528 Sove QCBUG10151 push below to set sub channel i,m,d domain to avoid sub set display but DI disable by main channel
			/*flow_message_push(_MODE_MSG_SUB_SET_VGIP_AFTER_FOUND_MODE_SIGNAL);
			flow_message_clearallType(_MODE_MSG_SUB_SETUP_BEFORE_SHOW_SIGNAL);*/
			//mark by frank@0528 flow_message_push(_MODE_MSG_SUB_SETUP_AFTER_FOUND_MODE_SIGNAL);
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		}
#endif
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, TRUE);
	}
	else
	{
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, FALSE);
	}

	/* in Main channel, DI is controlled by AP , AP controlled table priority is higher than others*/
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) {
		modeByAP_table = get_current_driver_pattern(DRIVER_RTNR_PATTERN);
		if (modeByAP_table == DI_RTNR_422) {
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		} else if (modeByAP_table == DI_RTNR_420) {
			drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
		} else if (modeByAP_table == DI_RTNR_400) {
			if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == 0)
				drv_memory_set_ip_DMA420_mode(SLR_DMA_400_mode);
			else
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		} else {
			//rtd_pr_vsc_info("Decide DI by AP, NO RTNR, table value = %d\n", modeByAP_table);
		}
		rtd_pr_vsc_info("Decide DI, AP Val=%d, isInterlace=%d,\n", modeByAP_table, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
	}

}

static void modestate_decide_nr_path(void)
{
	/* select bypass, NR or VUZD */
	if(Scaler_DispGetScaleStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_SCALE_V_DOWN)){  // go vuzd path
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_VUZD_MODE);
	}else{
		if (Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL))   //sub channal no NR path
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_BYPASS_MODE);
		else
		{
			if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {//WOSQRTK-6131 Patch
				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_FRAMESYNC_MODE);
			} else {
				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_BYPASS_MODE);
			}
		}
	}
}
#if 0
static void modestate_setup_vgip_even_odd_toggle(void)
{
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
	unsigned short channel = Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL);
#endif

	//CSW+ 0970710 Sub Channel(480i or 576i or 1080i50 or 1080i60) interlace mode by video compensation
	if(Scaler_InputSrcGetMainChType() == _SRC_YPBPR || Scaler_InputSrcGetMainChType() == _SRC_VGA) {
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP))	//video comp
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			else										//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18);			//odd signal inverted enable
		}
#endif
	}
	else if((Scaler_InputSrcGetMainChType() == _SRC_TV) || (Scaler_InputSrcGetMainChType() == _SRC_CVBS) || (Scaler_InputSrcGetMainChType() == _SRC_SV)){
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP))	//video comp
			{
				if ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_AVD) && (!get_sub_OutputVencMode()))
				{
					// AVD display in sub channel.
					IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x0);			//odd signal inverted disable
				}
				else
				{
					// APVR recording by sub channel
					IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18);			//odd signal inverted enable
				}
			}
			else
			{
				//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			}
		}
#endif
	}
	else if(Scaler_InputSrcGetMainChType() == _SRC_HDMI){
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
		{
			IoReg_Mask32(VGIP_VGIP_CHN1_CTRL_reg, ~(_BIT16|_BIT18), (_BIT16|_BIT18));
		}
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		//add HDMI sub channel field control @Crixus 20151203
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!DbgSclrFlgTkr.multiview_sub_interlace_flag){//(!Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE)){//!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP)){	//video comp
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			}
			else{										//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18); 		//odd signal inverted enable
			}
		}
#endif
	}
}
#endif

static void modestate_EnableVGIPInt(unsigned char a_bEnable)
{
	// I-domain VGIP Int Ctl
	vgip_int_ctl_RBUS tVGIPIntCtl;

	tVGIPIntCtl.regValue = IoReg_Read32(VGIP_INT_CTL_reg);// Read value

	if (TRUE == a_bEnable){
		tVGIPIntCtl.vgip_int_ie = 1; // Enable VGIP Interrupt
	}else{
		tVGIPIntCtl.vgip_int_ie = 0; // Disable VGIP interrupt
	}

	IoReg_Write32(VGIP_INT_CTL_reg, tVGIPIntCtl.regValue); // Update value
}

#ifdef CONFIG_SCALER_BRING_UP
static void modestate_EnableDispInt(unsigned char a_bEnable)
{
	// Display I Domain Interrupt Enable Ctrl
	vgip_int_ctl_RBUS tVGIPIntCtl;

	tVGIPIntCtl.regValue = IoReg_Read32(VGIP_INT_CTL_reg); // Read value

	if (a_bEnable){
		tVGIPIntCtl.dispi_int_ie = 1; // Enable Disp Interrupt
	}else{
		tVGIPIntCtl.dispi_int_ie = 0; // Disable Disp interrupt
	}

	IoReg_Write32(VGIP_INT_CTL_reg, tVGIPIntCtl.regValue); // Update value
}
#endif

#ifdef CONFIG_SDNR_CROP
static void modestate_set_SDNR(unsigned char channel)
{
	VIDEO_RECT_T  outregion;
	outregion.x = Scaler_DispGetInputInfo(SLR_INPUT_SDNRH_ACT_STA);
	outregion.y = Scaler_DispGetInputInfo(SLR_INPUT_SDNRV_ACT_STA);
	outregion.w = Scaler_DispGetInputInfo(SLR_INPUT_SDNRH_ACT_WID);
	outregion.h = Scaler_DispGetInputInfo(SLR_INPUT_SDNRV_ACT_LEN);

	if (channel == SLR_MAIN_DISPLAY)
	{
		scaledown_ich1_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
		scaledown_ich1_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
		//scaledown_ich1_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
		scaledown_ich1_uzd_ctrl0_RBUS 	ich1_uzd_Ctrl0_REG;

		ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg);
		ich1_sdnr_cutout_range_hor_reg.hor_front= outregion.x;
		ich1_sdnr_cutout_range_hor_reg.hor_width= outregion.w; // chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front= outregion.y;
		ich1_sdnr_cutout_range_ver0_reg.ver_height= outregion.h;	// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);

		//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg);
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top=0;	// inregion.y;
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot=0;	// inregion.y;
		//IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);

#if 0
		rtd_pr_vsc_emerg( "******************reg_hor_front = %d \n", outregion.x);
		rtd_pr_vsc_emerg( "******************reg_ver_front = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_top = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_bot = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_hor_back = %d \n", outregion.x+outregion.w);
		rtd_pr_vsc_emerg( "******************reg_ver_back = %d \n", outregion.y+outregion.h);
#endif
		ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_Ctrl0_reg);
		ich1_uzd_Ctrl0_REG.cutout_en = 1;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_Ctrl0_reg, ich1_uzd_Ctrl0_REG.regValue);
	}
	else
	{
		scaledown_ich2_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
		scaledown_ich2_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
		//scaledown_ich2_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
		scaledown_ich2_uzd_ctrl0_RBUS scaledown_ich2_uzd_ctrl0_reg;

		ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg);
		ich1_sdnr_cutout_range_hor_reg.hor_front= outregion.x;
		ich1_sdnr_cutout_range_hor_reg.hor_width= outregion.w; // chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front= outregion.y;
		ich1_sdnr_cutout_range_ver0_reg.ver_height= outregion.h;	// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);

		//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg);
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top=0;	// inregion.y;
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot=0;	// inregion.y;
		//IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);
#if 0
		rtd_pr_vsc_emerg( "******************reg_hor_front = %d \n", outregion.x);
		rtd_pr_vsc_emerg( "******************reg_ver_front = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_top = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_ver_mid_bot = %d \n", outregion.y);
		rtd_pr_vsc_emerg( "******************reg_hor_back = %d \n", outregion.x+outregion.w);
		rtd_pr_vsc_emerg( "******************reg_ver_back = %d \n", outregion.y+outregion.h);
#endif
		scaledown_ich2_uzd_ctrl0_reg.regValue = IoReg_Read32(SCALEDOWN_ICH2_UZD_Ctrl0_reg);
		scaledown_ich2_uzd_ctrl0_reg.cutout_en = 1;
		IoReg_Write32(SCALEDOWN_ICH2_UZD_Ctrl0_reg, scaledown_ich2_uzd_ctrl0_reg.regValue);
	}
}

#endif

void modestate_setup_idomain(StructDisplayInfo* info)
{
        unsigned char display = (unsigned char)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY);

	idomain_vfreq_pre = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

	modestate_decide_pixel_mode();

	modestate_decide_dtg_m_mode();

	modestate_decide_fractional_framesync();

	//  decide which channel to use DI
	modestate_decide_DI();
	// Calculate main or sub display width and display height and set it to info
	// remember main's display width/height may change later if display ratio is
	// pointer to pointer
	fw_scalerdisplay_get_display_size(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	/* Decide RTNR flag */
	modestate_decide_rtnr();


#ifdef CONFIG_SDNR_CROP
	//for HSD enable

	//Scaler_AdjustPathAndInfo();/*Will add. decide Uzd path*/
	Scaler_AdjustPathAndInfo_HW_SNR();	// Include patch for SNR issue
	// Calculate Overscan

        if( display >= MAX_DISP_CHANNEL_NUM )
          display = 0;

	fw_scaler_cal_sdnr_capture(display);
	modestate_set_SDNR(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif

	// Calculate the output size of scale down
	fw_scaler_cal_scale_down_size();

	/*Decide NR buffer mode,move from fw_scaler_cal_scale_down_size to support new NR path limit*/
	modestate_decide_nr_path();
	// Set in the scale up&down
	drvif_color_ultrazoom_config_scaling_down(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));

	if((Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL) == SLR_MAIN_DISPLAY) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)) && (Scaler_DispGetScaleStatus(SLR_MAIN_DISPLAY, SLR_SCALE_V_DOWN) == FALSE))
	{
		fw_scaler_set_sample(SLR_SUB_DISPLAY, _ENABLE);
		drvif_color_Set_DRV_SNR_Clock(SLR_SUB_DISPLAY, 1);//enable sub clock

		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_DI_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DI_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_DI_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DI_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_SDNRH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_SDNRH_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_SDNRH_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_SDNRH_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_SDNRV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_SDNRV_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_SDNRV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_SDNRV_ACT_LEN));

		modestate_set_SDNR(SLR_SUB_DISPLAY);
	}

#if 0//remove in k4lp
	//DI game mode checking & setting in scaler flow @Crixus 20161217
	if(fw_scalerip_get_di_gamemode() == _ENABLE){
		fw_scalerip_set_di_gamemode_setting(_ENABLE);
		//rtd_pr_vsc_emerg("[Game Mode]Enter DI game mode\n");
	}
	else{
		fw_scalerip_set_di_gamemode_setting(_DISABLE);
		//rtd_pr_vsc_emerg("[Game Mode]Exit DI game mode\n");
	}
#endif

	if(((get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)) && get_ori_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)) {
		rtd_pr_vsc_emerg("[rotate] no run vgip&di\n");
		/*no need run vgip to di for livezoom main*/
	} else  {
		// Disable VGIP Interrupt and let DI can be enabled.
		if(get_sub_OutputVencMode() == TRUE)
			IoReg_ClearBits(VGIP_VGIP_CHN1_CTRL_reg, _BIT24|_BIT25);
		else
			modestate_EnableVGIPInt(FALSE);

#if IS_ENABLED(CONFIG_RTK_AI_DRV)
		fw_scalerip_reset_NN();
#endif

		//DI control setting
		down(get_DI_semaphore());
		fw_scalerip_set_di();
		up(get_DI_semaphore());

		//De-XCXL
		fw_scalerip_set_deXC_XL();

		// set i-edge smooth
		fw_scalerip_set_IEGSM();

		// set SPNR & decontour input size
		fw_scalerip_set_SPNR_size();

		// Enable VGIP Interrupt
		if(get_sub_OutputVencMode() == TRUE)
			IoReg_SetBits(VGIP_VGIP_CHN1_CTRL_reg, _BIT24|_BIT25);
		else
			modestate_EnableVGIPInt(TRUE);
	}

#ifdef CONFIG_VGA_AUTO_MA_ENABLE
	// enable AutoMA in VGA source

	if ( Scaler_InputSrcGetType(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_VGA ) {
		drvif_scaler_vactive_end_irq(_ENABLE, info->display); // enable automa ISR
		drvif_scaler_vactive_sta_irq(_ENABLE, info->display); // enable automa ISR
	}
#endif
#if 0/*Framesync also need to enable VGIP ISR*/
    if((_FALSE == Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) /*&& (_ENABLE == drvif_memory_sw_buffer_swap_Enable((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))*/)
#endif
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY){

		#ifdef CONFIG_SUPPORT_DOLBY_VSIF
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) {
			extern void reset_pre_dolby_hdmi_vsif_mode (void);

			reset_pre_dolby_hdmi_vsif_mode();
			drvif_Hdmi_set_infoframe_thread_stop(_TRUE);
		}
		#endif

		if(get_scaler_qms_mode_flag())
		{//qms enable
			//drvif_scaler_dma_vgip_sta_irq_ctrl(1);// qms already enable at i3ddma config
		}
		drvif_scaler_vactive_end_irq(_ENABLE, SLR_MAIN_DISPLAY);
		drvif_scaler_vactive_sta_irq(_ENABLE, SLR_MAIN_DISPLAY);
	} else {
#ifdef  CONFIG_I2RND_ENABLE
#else
		drvif_scaler_vactive_end_irq(_ENABLE, SLR_SUB_DISPLAY);
		drvif_scaler_vactive_sta_irq(_ENABLE, SLR_SUB_DISPLAY);
#endif
	}

#if 1
	if(get_3D_mode_enable() == TRUE && get_vo_3d_mode() == VO_3D_FRAME_PACKING && Scaler_InputSrcGetType(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_VO)
	{
		drvif_scaler_vactive_end_irq(_DISABLE, SLR_MAIN_DISPLAY);
		drvif_scaler_vactive_sta_irq(_DISABLE, SLR_MAIN_DISPLAY);
	}
#endif

	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			twopixel_2_oneline_ctrl(1);//control two pixel mode
		else
			twopixel_2_oneline_ctrl(0);//control two pixel mode
	}

	#ifndef CONFIG_FORCE_RUN_I3DDMA	//not define
	//CSW+ 0970710 Sub Channel(480i or 576i or 1080i50 or 1080i60) interlace mode by video compensation
	//modestate_setup_vgip_even_odd_toggle();
	#endif
}

static void modestate_set_imd_domain(StructDisplayInfo* info)
{
	//rtd_pr_vsc_debug("\n Setup State: display:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
	modestate_setup_idomain(info);

	force_enable_datapath_clock();//Force enable Xcdi_clock 0xb8022284 bit3
#ifdef CONFIG_DUAL_CHANNEL
	//when change PIP type to speed up sub channel setting
	/*modestate_set_sub_domain(msg);*/
#endif

}

static unsigned char modestate_set_framesync_impl(StructDisplayInfo* info)
{
//	unsigned char result=0;
//	SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());;
#ifdef CONFIG_DCLK_CHECK
	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC))
	{
		if (Scaler_OpenVOGating())
		{
		//if((GET_HDMI_3DTYPE() == HDMI3D_FRAMESEQUENCE) &&  Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()
		//&& (((Scaler_InputSrcGetMainChType() == _SRC_VO) && (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_NON_ACTIVE)) || (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_VO_GO)))

			check_dclk2_is_underflow();
		}
		else
		{
			check_dclk_is_underflow();
		}

	}
#endif
// move to vbe_disp_set_dtgM2uzu_lowdelay_mode(1)
//	if(info->display == SLR_MAIN_DISPLAY)
//		update_dtgm2uzu_delay();//update master to uzu dtg delay; //need to set before 0xb802850c bi30


	//frank@1011 FRC with frame sync timing so must do calculation IVS2DVS
	fw_scalerdisplay_handler(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	// Set in the scale up&down
	drvif_color_ultrazoom_config_scaling_up(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));

	if(info->display == SLR_MAIN_DISPLAY)
		vbe_disp_set_dtgM2uzu_lowdelay_mode(1);

	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
	//	if(Scaler_InputSrcGetMainChType() != _SRC_VO){
		dvrif_memory_setting_for_data_fs();
#ifdef CONFIG_SUPPORT_SRC_ADC
		if(Scaler_InputSrcGetMainChType() == _SRC_VGA) {	// weihao 960308
			fw_scaler_update_mode_para(); //update mode parameters after adjust IVS2DVSDelay
		}
#endif // #ifdef CONFIG_SUPPORT_SRC_ADC

		// set display FIFO for Frame sync
		drvif_memory_set_fs_display_fifo();

		//data fs need to disable compression clock @Crixus 20171227
		dvrif_memory_comp_setting(FALSE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN), dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));
#if 0 //gamemode fix later
#ifdef CONFIG_FORCE_RUN_I3DDMA
				if(drv_memory_get_game_mode()){
					if(drvif_i3ddma_triplebuf_flag())
						drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
					else
						drv_I3ddmaVodma_SingleBuffer_GameMode(_ENABLE);
					}
				else{

					drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
				}

				/*qiangzhou:all i3ddma source go vodma timing sync i3ddma,all i3ddma source should setting iv2pv delay*/
				if(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_ADC)
					|| (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
					||((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)	&& (get_AVD_Input_Source() != _SRC_TV)))
#ifdef CONFIG_ALL_SOURCE_DATA_FS
					//don't care 3 buffer case
					/*&&(!drvif_i3ddma_triplebuf_flag())*/){
#else
					&&(!drvif_i3ddma_triplebuf_flag())){
#endif
					drv_I3ddmaVodma_GameMode_iv2pv_delay(TRUE);
				} else {
					drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
				}
#endif
#endif

#if 0

		if(Scaler_OpenVOGating()){
/*
			if(Get_PANEL_TYPE_IS_MILLET3_4K2K_SERIES() ==1){
				//move framesync_gating to disp on
			}else if(Get_DISPLAY_PANEL_TYPE() == P_VBY1_4K2K){
				scaler_dtg_reconfig();
				drvif_framesync_gatting_do();
			}
			else
*/
			{
				scaler_dtg_reconfig();
				drvif_framesync_gatting_do();
				/*WaitFor_EN_STOP_MAIN_Done();*/
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting(_ENABLE);
				/*WaitFor_EN_STOP_MAIN_Done();*/
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
			}
		}else{
			rtd_pr_vsc_debug(KERN_INFO "\r\n[%s][line:%d] Error! Data FS without open gating!!\r\n", __FUNCTION__, __LINE__);
#if 0
				drvif_scaler_set_display_mode_frc2fsync_by_hw(_TRUE);
				result = drvif_framesync_do();

			if(Scaler_InputSrcGetMainChType()==_SRC_VO && (result != 0)){
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting_do();
				msleep(50);
				drvif_framesync_gatting(_ENABLE);
				result = 0;
			}else if(Scaler_InputSrcGetMainChType()==_SRC_VO){//frank@0920 open VO gating function to solve mantis#5011
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting(_ENABLE);
			}

			if (result != 0) {// frame sync fail
#if 0
				drvif_scaler_set_display_mode(DISPLAY_MODE_FRC);
				if(Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT) > 0) {
					//drvif_mode_resetmode();
					//Scaler_ForceBg((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_FORCE_BG_SYSTEM, TRUE);
					drvif_mode_disablechannelproc(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
					drvif_mode_disablevgip(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
					#if 0
					if(Scaler_InputSrcGetMainChType()==_SRC_VO) { // hsliao 20090311, VO source requests VO info again
						CVoRequestVoInfo(Scaler_Get_CurVoInfo_plane());
					}
					#endif
					Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH); // hsliao 20090311, from active state or search state to search state

#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH
					if(_FALSE == modestate_send_ypbpr_and_av_same_path_init_msg())
						flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT : _FL2FL_MAIN_STATE_PERIODIC_EVENT);
#else //#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH
					flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT : _FL2FL_MAIN_STATE_PERIODIC_EVENT);
#endif //#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH

					Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,0);
				} else {
					flow_message_push(_FL2FL_MAIN_SET_FRAMESYNC_SIGNAL);
					Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT)+1);
				}
#endif
				// while frame sync fail, must return fail
				// then try again, if frame sync still fail, goto search-state to re-detect signal.
				return FALSE;
			}else{
#ifdef CONFIG_FS_HS_BIAS
				if(drvif_framesync_hs_bias() == FALSE)
					return FALSE;
#endif
				// for gatting debug
				/*if(Scaler_InputSrcGetMainChType()==_SRC_VO){
					drvif_framesync_gatting(_ENABLE);
				}*/

			//	fw_dvi_framesync_setting();

			}
#endif
		}
#endif
#if 0
		if((GET_HDMI_3DTYPE() == HDMI3D_FRAMESEQUENCE) &&  Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()
		&& (((Scaler_InputSrcGetMainChType() == _SRC_VO) && (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_NON_ACTIVE)) || (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_VO_GO)))
		{
			memory_3ddma_control();
			drvif_3ddma_DVTotal_Set(2);
		}
#endif

		//Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,0);
		if(Get_DISPLAY_PANEL_TYPE() != P_VBY1_4K2K){
			if(!(Scaler_InputSrcGetMainChType() == _SRC_TV && Scaler_GetTvBlueScreen() == FALSE))	// weihao 960308
				fw_scaler_enable_fs_wdg(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), TRUE);
			else
				fw_scaler_enable_fs_wdg(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), FALSE);
		}
#if 0
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			&&(!drvif_i3ddma_triplebuf_flag())
			&&(get_HDMI_HDR_mode() != HDR_DOLBY_HDMI)
			//&&(pVOInfo->src_v_len>2000)
			){
			drv_I3ddmaVodma_GameMode_iv2pv_delay(TRUE);
		} else {
			drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
		}
#endif
		//drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
	} else {
#if 0 //frank@0903 mark redundent code
		if(Scaler_InputSrcGetMainChType() == _SRC_VGA) {	// weihao 960308
			fw_scaler_update_mode_para(); //update mode status after set capture window
		}
#endif

		//Set M-domain setting
		dvrif_memory_handler(info->display);
#if 0
		//USER:LewisLee DATE:2012/06/21
		//for SW buffer swap, need some IVS2DVS delay
		//to prevent DVS swap buffer too close IVS
		if(SLR_MAIN_DISPLAY == Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY))
		{
			if(TRUE == framesync_get_enterlastline_at_frc_mode_flg())
			{
				//it have set ivs2dvs Value
			}
			else// if(FALSE == framesync_get_enterlastline_at_frc_mode_flg())
			{
				//frank@0617 mark below code to speed up,below code will setting by memory_set_input_format
#if 0

				drvif_set_frc_ivs2dvsdelay_line(_FRC_MODE_IVS2DVS_LINE_1, _FRC_MODE_IVS2DVS_LINE_2, 0);
				drvif_set_frc_ivs2dvsdelay_pixel(_FRC_MODE_IVS2DVS_PIXEL_1, _FRC_MODE_IVS2DVS_PIXEL_2, 0);
#endif
			}
		}
//#else //#if 1
		if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
			drvif_clear_ivs2dvsdelay();

		modestate_set_FRC_fix_last_line();
#endif //#if 1
	}

//USER : LewusLee DATE:2012/11/30
//move position
#if 0
//USER : LewusLee DATE:2012/08/30
//for novatek Tcon IC, too easy to enter burn in mode
//sw we need to set FRC -> Framesync moer smooth
	framesync_adjust_dvtotal_at_framesync_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif

 	return TRUE;

}
unsigned char (*modestate_set_framesync)(StructDisplayInfo* info) = modestate_set_framesync_impl;


void state_update_disp_info(void)	// updated by hsliao 20090515
{
	SCALER_DISPINFO_PKG info_pkg;
	unsigned char i;
	int ret;
	unsigned int ulIPKGItemCount = 0;
	unsigned int *pulTemp;
	for ( i=0 ; i<MAX_DISP_CHANNEL_NUM ; ++i )
	{
		info_pkg.disp_info[i].input_src = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_INPUT_SRC);
		info_pkg.disp_info[i].state = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_STATE);
		info_pkg.disp_info[i].disp_status = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_STATUS);
		info_pkg.disp_info[i].display = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISPLAY);
		info_pkg.disp_info[i].MEM_ACT_WID = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_WID);
		info_pkg.disp_info[i].MEM_ACT_LEN = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_LEN);
		info_pkg.disp_info[i].MEM_ACT_HSTA = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_HSTA);
		info_pkg.disp_info[i].MEM_ACT_VSTA = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_VSTA);
		info_pkg.disp_info[i].ucMode_Curr = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MODE_CURR);
		info_pkg.disp_info[i].DispWid = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_WID);
		info_pkg.disp_info[i].DispLen = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_LEN);
		info_pkg.disp_info[i].IVFreq = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_V_FREQ);
		info_pkg.disp_info[i].CapWid = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_CAP_WID);
		info_pkg.disp_info[i].CapLen = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_CAP_LEN);
		info_pkg.disp_info[i].IphActWid_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_WID_PRE);
		info_pkg.disp_info[i].IpvActLen_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_LEN_PRE);


		info_pkg.disp_info[i].IpvActSTA_H = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_STA);
		info_pkg.disp_info[i].IpvActSTA_V = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_STA);
		info_pkg.disp_info[i].IphActWid_H = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_WID);
		info_pkg.disp_info[i].IpvActLen_V = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_LEN);
		info_pkg.disp_info[i].Iph_STA_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_STA_PRE);
		info_pkg.disp_info[i].Ipv_STA_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_STA_PRE);

		info_pkg.disp_info[i].src_h_total = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_H_LEN);
		info_pkg.disp_info[i].src_v_total = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_V_LEN);
		info_pkg.disp_info[i].scaler_source_type = Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)i);
		if (i==0) {
			if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) != VSC_INPUTSRC_MAXN)
				info_pkg.disp_info[i].input_2_pixel_mode = 0;//mean sub connect source
			else
				info_pkg.disp_info[i].input_2_pixel_mode = get_hdmi_4k_hfr_mode();
		} else {
			info_pkg.disp_info[i].input_2_pixel_mode = 0;
		}
		switch(Get_DisplayMode_Src(i))
		{//get adn set ui real src input
			case KADP_VSC_INPUTSRC_AVD:
				info_pkg.disp_info[i].ui_select_src = get_AVD_Input_Source();
			break;

			case KADP_VSC_INPUTSRC_ADC:
				info_pkg.disp_info[i].ui_select_src = get_ADC_Input_Source();
			break;

			case KADP_VSC_INPUTSRC_HDMI:
				info_pkg.disp_info[i].ui_select_src = _SRC_HDMI;
			break;

			case VSC_INPUTSRC_VDEC:
			case VSC_INPUTSRC_JPEG:
				info_pkg.disp_info[i].ui_select_src = _SRC_VO;
			break;

			default:
				info_pkg.disp_info[i].ui_select_src = _SRC_MAX;
			break;
		}
	}

	pulTemp = (unsigned int *)(&info_pkg);

	ulIPKGItemCount = sizeof(SCALER_DISPINFO_PKG) / sizeof(unsigned int);

	// change endian
	for (i = 0; i < ulIPKGItemCount; i++)
		pulTemp[i] = htonl(pulTemp[i]);

	//frank@0801 compare Disp_info is the same of video firmware,when the result is the same then return to speed up the code
	if (memcmp((unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_SETDISPINFO), pulTemp, sizeof(SCALER_DISPINFO_PKG)) == 0) //compare equal or not
		return;
	// copy from RPC share memory
	memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_SETDISPINFO), pulTemp, sizeof(SCALER_DISPINFO_PKG));

	if ((ret = Scaler_SendRPC(SCALERIOC_SETDISPINFO,0,0)) < 0)
	{
		rtd_pr_vsc_debug("ret = %d, set disp_info to driver fail !!!\n", ret );
		return;
	}

}

static struct vsc_film_mode_parameter_t vsc_film_mode_parameter = {0, 0, 60};

int vsc_get_film_mode_enable(void)
{
	return vsc_film_mode_parameter.enable;
}

int vsc_get_film_mode_type(void)
{
	return vsc_film_mode_parameter.type;
}

/*
int vsc_get_film_mode_type(void)
{
	return vsc_film_mode_parameter.type;
}
*/

struct vsc_film_mode_parameter_t vsc_set_film_mode_param(int film_mode_enable, int film_mode_type, int v_freq)
{
	struct vsc_film_mode_parameter_t cur_film_mode_parameter = {vsc_film_mode_parameter.enable, vsc_film_mode_parameter.type, vsc_film_mode_parameter.v_freq};

	if(!((film_mode_type == VO_FILM_TYPE_NONE) && (vsc_film_mode_parameter.type == 0))){
		rtd_pr_vsc_notice("[FILM] vsc_set_film_mode_param=%d/%d/%d\n", film_mode_enable, film_mode_type, v_freq);
		down(&set_vsc_film_mode_semaphore);
		//if new film type is NONE and current is 0, no need to run type change
		vsc_film_mode_parameter.enable = film_mode_enable;
		vsc_film_mode_parameter.type = film_mode_type;
		vsc_film_mode_parameter.v_freq = v_freq;
		up(&set_vsc_film_mode_semaphore);
	}

	return cur_film_mode_parameter;
}
unsigned int memc_me_clock_set_off = 0;
#ifndef UT_flag
extern void drivf_scaler_change_film_mode_type(int enable, int type, int v_freq);
// FixMe, 20190925
//extern void Scaler_MEMC_Set_EnableToBypass_Flag(unsigned char u1_enable);
static int film_mode_change_task_flag = FALSE;
struct task_struct *p_film_mode_change_task = NULL;
static int film_mode_change_task(void *data)
{
	struct vsc_film_mode_parameter_t cur_film_mode_parameter;
	unsigned int memc_me_clock = 0;
	while (1) {
		//Eric@20180913 check memc_me_clock_off status
		memc_me_clock = (IoReg_Read32(SYS_REG_SYS_CLKEN3_reg) & _BIT30) >> 30;
		if (Scaler_get_memc_me_clock_off() && memc_me_clock && !memc_me_clock_set_off &&
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) &&
			(Get_DISPLAY_REFRESH_RATE() < 120)
			/* && !modestate_get_fll_running_flag()*/	//Eric@20180926 do not check but break fll task.
			)
		{
			memc_me_clock_set_off = 1;
			rtd_pr_vsc_info("[FILM][%s] memc_me_clock_off = %d, memc_me_clock = %d, set ME clock off!!!\n", __func__,Scaler_get_memc_me_clock_off(),memc_me_clock);
			// FixMe, 20190925
			//Scaler_MEMC_Set_EnableToBypass_Flag(1);
			Scaler_MEMC_MEMC_CLK_OnOff(0, 1, 0);
			memc_me_clock = (IoReg_Read32(SYS_REG_SYS_CLKEN3_reg) & _BIT30) >> 30;
			rtd_pr_vsc_info("[FILM][%s] memc_me_clock_off = %d, memc_me_clock = %d, set ME clock off done!!!\n", __func__,Scaler_get_memc_me_clock_off(),memc_me_clock);
		}
		if((memc_me_clock == 0) && (memc_me_clock_set_off == 1))
			memc_me_clock_set_off = 0;

		if (vsc_get_film_mode_enable() &&
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			/* && !modestate_get_fll_running_flag()*/	//Eric@20180926 do not check but break fll task.
			)
		{
			rtd_pr_vsc_info("FILM_MODE %s, start\n", __func__);
			cur_film_mode_parameter = vsc_set_film_mode_param(0, 0, 0);
			film_mode_parameter = cur_film_mode_parameter;
			drivf_scaler_change_film_mode_type(1, cur_film_mode_parameter.type, cur_film_mode_parameter.v_freq);
			rtd_pr_vsc_info("FILM_MODE %s, end\n", __func__);
		}
		//Eric@20180926 do not check but break fll task.
		/* else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && modestate_get_fll_running_flag()){
			if(Scaler_get_film_mode_change_type() != 2){
			    rtd_pr_vsc_info("FILM_MODE FLL Running...\n");
			    Scaler_set_film_mode_change_type(2);
			}
		}*/
		else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
			if(Scaler_get_film_mode_change_type() != 3){
			    rtd_pr_vsc_info("FILM_MODE scaler state(%d) not in ACTIVE!!\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE));
			    Scaler_set_film_mode_change_type(3);
			}
		}else if(Scaler_get_film_mode_change_type()){
			rtd_pr_vsc_info("FILM_MODE running state[%d] reset\n", Scaler_get_film_mode_change_type());
			Scaler_set_film_mode_change_type(0);
		}

		if (freezing(current)) {
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}

		msleep(10);
	}
	rtd_pr_vsc_debug("\n%s exit\n", __func__);
	do_exit(0);
	return 0;
}



struct vsc_film_mode_parameter_t get_film_mode_parameter(void){
	return film_mode_parameter;
}


static void create_film_mode_change_task(void)
{
	if (film_mode_change_task_flag == FALSE) {
		p_film_mode_change_task = kthread_run(film_mode_change_task, NULL, "init film_mode_change_task");

		if (IS_ERR(p_film_mode_change_task)) {
			rtd_pr_vsc_err("create film mode change task failed\n");
		} else {
			rtd_pr_vsc_notice("create film mode change task OK\n");
			film_mode_change_task_flag = TRUE;
		}
	}
}


static void delete_film_mode_change_task(void)
{
	int ret;
	if (film_mode_change_task_flag == TRUE) {
		if(p_film_mode_change_task){
			ret = kthread_stop(p_film_mode_change_task);
			if (!ret) {
				p_film_mode_change_task = NULL;
				film_mode_change_task_flag = FALSE;
			}
		}
	}
}

static bool hdmi_4k120_se_task_flag = FALSE;
static struct task_struct *p_hdmi_4k120_se_tsk = NULL;
extern unsigned int i3ddma_cap_isr_cnt;
extern void scaler_hdmi_4k120_UV_interleave(void);
int i3ddma_dump_cap0cap2_to_file(unsigned int bufferindex);

void hdmi_4k120_se_wakeup(void)
{
	hdmi_4k120_se_trigger_flag = TRUE;
	wake_up(&HDMI_4K120_SE_WAIT_QUEUE);
}

static int hdmi_4k120_se_task(void *p)//This task run se proc
{
	static unsigned int vgip_isr_cnt_pre = 0;

	rtd_pr_vsc_debug("hdmi_4k120_se_task()\n");

	current->flags &= ~PF_NOFREEZE;

	while (1)
	{
		wait_event_freezable(HDMI_4K120_SE_WAIT_QUEUE, hdmi_4k120_se_trigger_flag);
        down(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		if(hdmi_4k120_se_trigger_flag)
		{
			hdmi_4k120_se_trigger_flag = FALSE;

			if((i3ddma_cap_isr_cnt != vgip_isr_cnt_pre))
			{
				vgip_isr_cnt_pre = i3ddma_cap_isr_cnt;

				if(get_i3ddma_4k120_flag() == TRUE)
				{
					//rtd_pr_vsc_emerg("se_task:i3ddma_cap_isr_cnt=%d\n",i3ddma_cap_isr_cnt);
					//scaler_hdmi_4k120_UV_interleave();
				}
			}
		}

		//dump 4k120 data
		#if 0
		if(get_i3ddma_4k120_flag() == TRUE)
		{
			if(IoReg_Read32(ABL_Reserved_reg)& _BIT20)
			{
				IoReg_ClearBits(ABL_Reserved_reg, _BIT20);
				i3ddma_dump_cap0cap2_to_file(0);
			}
		}
		#endif
        up(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		// to prevent STR/Snapshot fail
		if (freezing(current))
		{
			try_to_freeze();
		}

		if (kthread_should_stop()){
			rtd_pr_vsc_debug("hdmi_4k120_se_task stop!!\n");
			break;
		}



	}

    rtd_pr_vsc_debug("\r\n####hdmi_4k120_se_task: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_hdmi_4k120_se_task(void)
{
	int err;
	if (hdmi_4k120_se_task_flag == FALSE) {
		p_hdmi_4k120_se_tsk = kthread_create(hdmi_4k120_se_task, NULL, "hdmi_4k120_se_task");

		if (p_hdmi_4k120_se_tsk) {
			wake_up_process(p_hdmi_4k120_se_tsk);
			hdmi_4k120_se_task_flag = TRUE;
		} else {
			err = PTR_ERR(p_hdmi_4k120_se_tsk);
			rtd_pr_vsc_debug("Unable to start create_hdmi_4k120_se_task (err_id = %d)./n", err);
		}
	}
}


static void delete_hdmi_4k120_se_task(void)
{
	int ret;
	if (hdmi_4k120_se_task_flag && p_hdmi_4k120_se_tsk) {
		ret = kthread_stop(p_hdmi_4k120_se_tsk);
		if (!ret) {
			p_hdmi_4k120_se_tsk = NULL;
			hdmi_4k120_se_task_flag = FALSE;
			rtd_pr_vsc_debug("hdmi_4k120_se_task thread stopped\n");
		}
	}
}
#endif // #ifndef UT_flag

unsigned char Scaler_get_vdec_2k120hz(void){
	if(!get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) &&
		(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE) == 1920) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE) == 1080) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SRC_FRAMERATE) >= 1195))
		return 1;
	else
		return 0;
}

unsigned int scaler_get_idomain_vfreq_pre(void)
{
	return idomain_vfreq_pre;
}

extern void i2rnd_debug(void);
extern void drv_memory_display_set_input_fast(void);
extern void drvif_color_rtnr_progressive_check(unsigned char interlace_flag, unsigned char channel);
extern void scalerVIP_Write_s1_RGB2YUV(unsigned long arg);
extern void i2rnd_s1_default_memory_tag(void);

extern int Scaler_MEMC_DTV_ME_CLK_OnOff(unsigned char enable, unsigned char bMute);
extern int vbe_dtg_memec_bypass_switch(void);
extern void vbe_dtg_memec_bypass_switch_set(int mode);
extern unsigned int vbe_get_HDMI_dynamic_film_mode_flag(void);
// FixMe, 20190925
//extern void MEMC_Lib_set_INPUT_COLOR_SPACE_Mode(unsigned char u1_mode);

static unsigned int record_Setup_IMD_timer_counter = 0;// record TIMER_SCPU_CLK90K_LO_reg after Setup_IMD
unsigned int MEMC_error_status_print_flag = 0;
bool vcom_flag = false;

void scaler_vsc_set_gamemode_force_framerate_lowdelay_mode(UINT8 bOnOff);
static DECLARE_WAIT_QUEUE_HEAD(dolby_apply_wq);
static bool dolby_apply_done = false;
int wait_ott_dolby_apply(void *data)
{
#ifdef CONFIG_RTK_KDRV_DV
    unsigned char cnt = 100;
#ifdef  CONFIG_DOLBY_IDK_1_6_1_1
    while (dolby_adapter_get_g_picModeUpdateFlag() && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
    while (g_picModeUpdateFlag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#endif
    {

        if (cnt == 0) {
            /* force set Normal_TEST() */
            rtd_pr_vsc_info("[%s:%d][Dolby] force trigger Normal_TEST()", __func__, __LINE__);
            #ifdef  CONFIG_DOLBY_IDK_1_6_1_1
            dolby_adapter_set_g_picModeUpdateFlag(0xFFFFFFFF);
            #else
            g_picModeUpdateFlag = 0xFFFFFFFF;
            #endif
            break;
        }
        cnt--;
        usleep_range(1000, 1100);
    }

    if (cnt == 0) {
        cnt = 100;
#ifdef  CONFIG_DOLBY_IDK_1_6_1_1
        while (dolby_adapter_get_g_picModeUpdateFlag()
                && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
        while (g_picModeUpdateFlag
                && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#endif
        {
            usleep_range(1000, 1100);
            cnt--;
        }
        usleep_range(40000, 40000);
    }

    dolby_apply_done = true;
    wake_up(&dolby_apply_wq);
#endif
    return 0;
}

extern unsigned int DI_SW_Detection_90k;
void Set_DI_SW_Detection_in_IMD(unsigned char display)
{
	extern unsigned char DI_SW_Reset_INIT_Flag;
	int timeout_cnt = 500;
	unsigned int t0, t1, t2;
	_RPC_system_setting_info *RPC_vipSysInfo = NULL;

	RPC_vipSysInfo = (_RPC_system_setting_info *)Scaler_GetShareMemVirAddr(SCALERIOC_VIP_RPC_system_info_structure);

	if(display == SLR_MAIN_DISPLAY) {
		t0 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
		if((DI_IM_DI_CONTROL_get_ip_enable(IoReg_Read32(DI_IM_DI_CONTROL_reg)) ==1 ) &&
			(DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 0) &&
			(VGIP_Data_Path_Select_get_xcdi_clk_en(IoReg_Read32(VGIP_Data_Path_Select_reg)) == 1)) {

			IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1
			rtd_pr_vsc_info("DI_Enable, DI reset En, t0=%d, DI_SW_Reset_INIT_Flag=%d,\n", t0, DI_SW_Reset_INIT_Flag);

			if ((DI_SW_Reset_INIT_Flag == 1) &&
			((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD))
			&& (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ==1) /*&& (get_platform() == PLATFORM_KXLP)*/)	 {
				timeout_cnt = 500;
				while ((DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 1) && (timeout_cnt>0)) {
					usleep_range(100, 200);
					timeout_cnt--;
				}

				t1 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
				if (timeout_cnt<=0) {
					IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
					rtd_pr_vsc_emerg( "DI_Enable, DI reset En timeout, t0=%d,t1=%d, timeout_cnt=%d,\n", t0, t1, timeout_cnt);
				}
				usleep_range(42000, 43000);

				t2 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
				IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1

				rtd_pr_vsc_info("DI_Enable, DI reset Enter 2, t0=%d,t1=%d, t2=%d, timeout_cnt=%d,\n", t0, t1,t2,  timeout_cnt);
			} else if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ==1) {
				timeout_cnt = 25;
				while ((DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 1) && (timeout_cnt>0)) {
					usleep_range(1000, 1100);
					timeout_cnt--;
				}
				t1 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
				if (timeout_cnt<=0) {
					IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
					rtd_pr_vsc_emerg( "DI_Enable, DI reset 2-2 En timeout, t0=%d,t1=%d, timeout_cnt=%d,\n", t0, t1, timeout_cnt);
					usleep_range(25000, 26000);	// one frame in 50hz
					t2 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
					IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1

					rtd_pr_vsc_info("DI_Enable, DI reset Enter 2-2, t0=%d,t1=%d, t2=%d, timeout_cnt=%d,\n", t0, t1,t2,  timeout_cnt);
				}
			}

		}else{
			IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
			t1 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
			if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_THRIP) || Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_RTNR)) {
				rtd_pr_vsc_emerg( "DI_Enable, DI should be reset,ip_en=%d, sw_detect_en=%d,xcdi_clk=%d,DISP_THRIP=%d,DISP_RTNR=%d,t0=%d,\n",
					DI_IM_DI_CONTROL_get_ip_enable(IoReg_Read32(DI_IM_DI_CONTROL_reg)),
					DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)),
					VGIP_Data_Path_Select_get_xcdi_clk_en(IoReg_Read32(VGIP_Data_Path_Select_reg)),
					Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_THRIP), Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_RTNR), t0);

					usleep_range(42000, 43000);

					t2 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
					IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1

					rtd_pr_vsc_info("DI_Enable, DI should be reset, t0=%d,t1=%d, t2=%d, timeout_cnt=%d,\n", t0, t1,t2,  timeout_cnt);
			} else {
				rtd_pr_vsc_info("DI_Enable, DI reset Disable, t0=%d,\n", t0);
			}
		}
		DI_SW_Reset_INIT_Flag = 0;
		DI_SW_Detection_90k = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);

		if (RPC_vipSysInfo != NULL)
			RPC_vipSysInfo->PQ_IP_Enable_Monitor_2.DI_RTNR_SW_Detection_90k = Scaler_ChangeUINT32Endian(DI_SW_Detection_90k);

		rtd_pr_vsc_info("DI_Enable, DI reset DI_SW_Detection_in_VPQ_TSK_Stable_CNT=%d,\n", DI_SW_Detection_90k);
	}
}

unsigned char Setup_IMD_impl(StructDisplayInfo* info)
{
	extern void reset_hdmi_error_hanler_ctrl(void);
	extern void two_pixel_mode_edge_smooth_update(void);//two pixel mode edge smooth setting force update
       extern void check_delay_set_nnsr(void);
	extern void clear_delay_set_nnsr_flag(void);
#ifndef CONFIG_SDNR_CROP
	scaledown_ich1_uzd_RBUS 	ich1_uzd_Ctrl0_REG;
	ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_CTRL0_VADDR);
	ich1_uzd_Ctrl0_REG.cutout_en = 0;
	IoReg_Write32(SCALEDOWN_ICH1_UZD_CTRL0_VADDR, ich1_uzd_Ctrl0_REG.regValue);
#endif
	//unsigned char srcType_2d;
	unsigned char display;
#ifdef CONFIG_SUPPORT_SRC_ADC
	unsigned char phase_result = 0;
#ifndef ADC_UP_DOWN_CLAMP
	int count;
#endif
#endif
//	mdomain_cap_cap_ddr_fifostatus_RBUS cap_ddr_fifostatus_reg;
//	unsigned char game_mode_wait_frame = 0;
//	unsigned int plane=0;
	VSC_INPUT_TYPE_T webos_src;
	seamless_change_sync_info *seamless_info = NULL;
	unsigned char hdrtype = HDR_DM_MODE_NONE;
	unsigned int src_type = 0;
    unsigned int *setup_di_done_flag = NULL;

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	ROTATE_MODE_LIST rotatemode;
#endif

	display = info->display;

	if(Get_DisplayMode_Src(display) == VSC_INPUTSRC_HDMI)
	{
		reset_hdmi_error_hanler_ctrl();//reset
	}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if ((display == SLR_MAIN_DISPLAY) && (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY)))
	{
		rotatemode = (ROTATE_MODE_LIST)get_rotate_mode(SLR_MAIN_DISPLAY);
		rtd_pr_vsc_emerg("rotatemode=%d\n",rotatemode);
		Scaler_HDMI_Rotate(TRUE, rotatemode, 0);
	}
#endif


#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif

	Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT, 0);
#if(VSC_PROFILE == 1)
	unsigned int before_time = 0;
	unsigned int after_time = 0;
	before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif
	set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, FALSE);//disable hdmi av mute mask
    update_vsc_task_status(1, VSC_I_DOMAIN);

	if(display == SLR_MAIN_DISPLAY)
	{
		set_mdomain_driver_status(false);//m domain driver not ready
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DTV_CHANNEL_CHANGE_HDR_SEAMLESS, 0);//diable DTV switch seamless mask
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DOLBY, 0); /* disable dolby not ready and dolby crc error mask */
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
        dlg_callback_handler(E_DLG_DISABLE_DLG_MASK);
#endif
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		set_dolby_vsif_change(0);
#endif
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))
		{
			scaler_linebuffer_mode_finish = FALSE;//need to set TRUE when after gatting check during scaler
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LB_MODE_GATTING_NOT_READY, 1);//enable line buffer mode gatting not ready mask
		}
		else
		{
			scaler_linebuffer_mode_finish = TRUE;
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LB_MODE_GATTING_NOT_READY, 0);//disable line buffer mode gatting not ready mask
			drv_memory_Main_Disp_Enable(FALSE);//move here early avoid noise
		}
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
        if(TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
        {
            scaler_set_I2D_tracking_in_slow_mode(1);//disable speedup locking flow
        }
        else
#endif
        {
            scaler_set_I2D_tracking_in_slow_mode(0);//keep speedup locking flow
        }
		if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1))
			two_pixel_mode_ctrl(1);
		else
			two_pixel_mode_ctrl(0);
		if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
		{
			set_scaler_run_hdmi_hfr_mode(get_hdmi_4k_hfr_mode());
		}
		else if(get_hdmi_vrr_4k60_mode())
		{
			set_scaler_run_4k60_vrr_two_path(true);
		}

    }
        clear_delay_set_nnsr_flag();
	set_di_wait_frame_num(0);//reset DI wait number
#ifdef ENABLE_AV1_AUTOSWITCH2SV1
		StructSourceInput *srcinput_pt = Scaler_InputSrc(Scaler_DispGetInputInfo(SLR_INPUT_INPUT_SRC));
		srcinput_pt->srcAutoSwitchAVSV_DB = 10;
#endif

		//Scaler_Set_Dynamic_Display_HV_total_Value((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

#ifdef ENABLE_DRIVER_I3DDMA
		// [I3DDMA] VO source I3DDMA enable/disable control
		modestate_I3DDMA_update_VO_3D_enable();
		//srcType_2d = modestate_I3DDMA_get_In3dMode() ? drvif_I3DDMA_Get_Input_Info_Vaule(I3DDMA_INFO_INPUT_SRC_TYPE):
#else
		//srcType_2d = Scaler_InputSrcGetType(display);
#endif
		webos_src = Get_DisplayMode_Src(display);

		if(judge_scaler_break_case(display)) {
			rtd_pr_vsc_notice("####channel:%d scaler need to break 1!!!####\r\n", display);
			return FALSE;
		}

		 {
			if(display == SLR_MAIN_DISPLAY)
			{
			//	if(!(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)){
			//		reset_hdr_mode(SLR_MAIN_DISPLAY);//disable dolby mode
			//	}
					decide_qos_mode();//for kernel team to decide BW mode

#ifdef CONFIG_I2RND_ENABLE
					//get the sub hdr type from shared memory @Crixus 20180117
					if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
						seamless_info = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SUB_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);
					else
#endif
						seamless_info = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);
					down(&HDR_Setting_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
					//get the sub src type for hdr info @Crixus 20180117
					if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
						src_type = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
					else
#endif
						src_type = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
					if(src_type == VSC_INPUTSRC_VDEC)
					{
						if(get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER)
						/*20170908, pinyen add dolby hdr case*/
						{
							hdrtype = HDR_DM_DOLBY;
#ifdef CONFIG_RTK_KDRV_DV
#ifdef  CONFIG_DOLBY_IDK_1_6_1_1
                            dolby_adapter_set_g_picModeUpdateFlag(1);
#else
                            g_picModeUpdateFlag = 1;
#endif
#endif
						}
						else if(seamless_info)
						{
						    if(Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type) == HDR_DM_MODE_NONE)
							{//cp case and webos call dm connect and vo don't know har type. Currently this is youtube case
								if(get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) && (get_OTT_HDR_mode() == HDR_HDR10_VDEC))
								{
									if(MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HLG)
										hdrtype = HDR_DM_HLG;//according tha AP type
									else
										hdrtype = HDR_DM_HDR10;//according tha AP type
								}
								else if (get_support_vo_force_v_top(support_sdr_max_rgb))
								{
									hdrtype = HDR_DM_SDR_MAX_RGB;
								}
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_HDR10)
							{
								hdrtype = HDR_DM_HDR10;
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_HLG)
							{
								hdrtype = HDR_DM_HLG;
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_TECHNICOLOR)
							{
								hdrtype = HDR_DM_TECHNICOLOR;
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_ST2094)
							{
								//hdrtype = HDR_DM_ST2094;
								if (drvif_Get_ST2094_EFuse_Status() == 0)
									hdrtype = HDR_DM_ST2094;
								else
									hdrtype = HDR_DM_HDR10;
							}
							else if (get_support_vo_force_v_top(support_sdr_max_rgb))
							{
								hdrtype = HDR_DM_SDR_MAX_RGB;
							}
						}
					}
					else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
					{
#ifdef CONFIG_RTK_KDRV_DV
						if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
						/*20170908, pinyen add dolby hdr case*/
						{
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
							dolby_adapter_set_g_picModeUpdateFlag(3);
#else
                            g_picModeUpdateFlag = 3;//force update 3 times
#endif
							hdrtype = HDR_DM_DOLBY;
						}
						else
#endif
                        if(get_HDMI_HDR_mode() == HDR_HDR10_HDMI)
						{
							if (MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HLG)	/*HLG case from LG*/
								hdrtype = HDR_DM_HLG;
							else if(MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HDR10_PLUS) {
								//hdrtype = HDR_DM_ST2094;
								if (drvif_Get_ST2094_EFuse_Status() == 0)
									hdrtype = HDR_DM_ST2094;
								else
									hdrtype = HDR_DM_HDR10;

							} else
								hdrtype = HDR_DM_HDR10;
						}
						else if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0))
						{
							hdrtype = HDR_DM_MODE_NONE;//hdmi2.0 4k2k120 mode can not do hdr
						}
						else if (get_support_vo_force_v_top(support_sdr_max_rgb))
						{
							hdrtype = HDR_DM_SDR_MAX_RGB;
						}
						else if ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120))
						{//if two pixel mode sdr also need to go vtop
							hdrtype = HDR_DM_SDR_MAX_RGB;
						}
					}
					else if(get_support_vo_force_v_top(support_sdr_max_rgb))
					{
						hdrtype = HDR_DM_SDR_MAX_RGB;

					}
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
					down(get_dolby_vision_dm_path_sem());
#endif
					Scaler_color_set_HDR_Type(hdrtype);
					scaler_vtop_dolby_mode_setting(hdrtype);
					if(Scaler_color_Get_HDR_AutoRun())
						Scaler_color_HDRIP_AutoRun(hdrtype);
					scaler_hdr_mode_setting(SLR_MAIN_DISPLAY, hdrtype);
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
					up(get_dolby_vision_dm_path_sem());
#endif
					Scaler_SetDataFormatHandler();

					down(&SetMainOutPutRegion_Semaphore);
					if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag)
						set_hdr_semaless_active(TRUE);
					up(&SetMainOutPutRegion_Semaphore);
					up(&HDR_Setting_Semaphore);
					rtd_pr_vsc_info("[%s][%d] hdrtype=%d \n", __FUNCTION__, __LINE__,hdrtype);

                    if((src_type == VSC_INPUTSRC_VDEC)
						&& (get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER)
						&& (hdrtype == HDR_DM_DOLBY)) {
#ifdef CONFIG_RTK_KDRV_DV
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
						dolby_adapter_set_g_picModeUpdateFlag(2);
#else
                        g_picModeUpdateFlag = 2;
#endif
#endif
						dolby_apply_done = false;
						kthread_run(wait_ott_dolby_apply, NULL, "wait_ott_dolby_apply");
					}

			} else {	/* for sub*/
				src_type = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
				Scaler_SetDataFormatHandler();
				if(src_type == VSC_INPUTSRC_VDEC)
				{
					hdrtype = HDR_DM_MODE_NONE;
					scaler_hdr_mode_setting(SLR_SUB_DISPLAY, hdrtype);
				}
			}
#ifdef CONFIG_SUPPORT_SRC_ADC
			if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR) && (auto_phase_flow_bypass() == FALSE)){// Start YPbPr auto phase
				//rtd_pr_vsc_notice("%s(line: %d)####display=%d(0:main, 1:sub)####\r\n", __func__, __LINE__, display);
			#if 1 //enable auto phase flow, rzhen@2016-08-15
				rtd_pr_vsc_info("start drvif_ypbpr_auto_phasedo_start\n");
				phase_result = drvif_ypbpr_auto_phasedo_start(SLR_MAIN_DISPLAY);
				//rtd_pr_vsc_notice("drvif_ypbpr_auto_phasedo_start  result = %x\n", phase_result);
				if(phase_result != ERROR_SUCCEED){//Phase start setting fail
					rtd_pr_vsc_info("###########drvif_ypbpr_auto_phasedo_start fail#############\r\n");
					return FALSE;
				}else{
					rtd_pr_vsc_info("###########drvif_ypbpr_auto_phasedo_start success#############\r\n");
				}
			#else
				SyncProc_SetMinDiff(display);
			#endif
				drvif_scaler_check_vgip_data_dclk(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL));
			} else
#endif
			{
				if ((Get_sub_from_DI_mux_path()) && (display == SLR_SUB_DISPLAY)) {
					//tmp code
				}
				else
				{
					fw_scaler_set_sample(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _ENABLE);
					drvif_scaler_check_vgip_data_dclk(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL));
				}
				if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR))
					rtd_pr_vsc_notice("\r\n####YPP no need to run autophase again####\r\n");
			}

			if ( ( Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_TV ||
			      Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_CVBS ||
			      Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_SV ) &&
				( Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422) == TRUE ) )
			{
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
				IoReg_Mask32(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_MISC_reg : VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _BIT0);
#else
				IoReg_Mask32(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)?SUB_VGIP_VGIP_CHN2_MISC_reg:*/VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _BIT0);
#endif
			}
			else
			{
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
				IoReg_Mask32(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_MISC_reg : VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _ZERO);
#else
				IoReg_Mask32(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)?SUB_VGIP_VGIP_CHN2_MISC_reg:*/VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _ZERO);
#endif
			}

			Scaler_SetDataFormatHandler();

			// we have to remember the original iv2dvs delay and other parameters
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
			Scaler_DispSetInputInfo(SLR_INPUT_IPV_DLY_PRE,Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? IoReg_ReadByte0(SUB_VGIP_VGIP_CHN2_DELAY_reg) : IoReg_ReadByte0(VGIP_VGIP_CHN1_DELAY_reg));
#else
			Scaler_DispSetInputInfo(SLR_INPUT_IPV_DLY_PRE,/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? IoReg_ReadByte0(SUB_VGIP_VGIP_CHN2_DELAY_reg) : */IoReg_ReadByte0(VGIP_VGIP_CHN1_DELAY_reg));
#endif
#if(VSC_PROFILE == 1)
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_pr_vsc_debug("Setup_IMD initial time=%d ms", (after_time-before_time));
			before_time = after_time;
#endif
		}
		if(!modestate_set_vgip(info)){//set VGIP fail for vo source return detect state
			//flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT: _FL2FL_MAIN_STATE_PERIODIC_EVENT);
			return FALSE;
		}
		//Merlin6 new flow : calculate iv2pv delay before setting i-domain, make VO timing stable when setting d-domain.
		//cal iv2pv delay
		#if 0
		if(_ENABLE == Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)){
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				rtd_pr_vsc_emerg(" data fs go vbe_disp_decide_frc2fsync_using_I2D!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
				Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(FALSE);
				Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(TRUE);
			}else{
				rtd_pr_vsc_emerg(" data fs go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
				Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
				Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
			}
		}else{
			rtd_pr_vsc_emerg(" data frc go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
			Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
			Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
		}
		#else
		if((Get_VO_Tracking_D_PANEL_TYPE()) &&
			//for KTASKWBS-19867, miracast mute due to memc forcebg, so it cannot run reset vodma
			!((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (DbgSclrFlgTkr.Sub_OuputDisplayMode==TRUE)) &&
			(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && get_force_i3ddma_enable(SLR_MAIN_DISPLAY) &&
#ifdef CONFIG_RTK_KDRV_DV
			   !check_hdmi_dolby_vision_rgb_and_full_hd() &&
			   !check_hdmi_dolby_vision_FRT_one_drop_case() &&
#endif
			/* (drv_memory_get_game_mode_dynamic() == FALSE || !scaler_vsc_get_gamemode_go_datafs_mode()) && */
			!(get_new_game_mode_small_window_condition() && (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1)) &&    //small window
                          (get_hdmi_4k_hfr_mode() == HDMI_NON_4K120) && !(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag() || get_scaler_qms_mode_flag())) ||
			(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) ||
			(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)))
		{
			rtd_pr_vsc_emerg(" Scaler_Set_FreeRun_To_FrameSync_By_Reset_VODMA!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
			Scaler_Set_FreeRun_To_FrameSync_By_Reset_VODMA(TRUE);
			Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(FALSE);
			Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
		}else{
			if(_ENABLE == Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)){
				if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
					rtd_pr_vsc_emerg(" data fs go vbe_disp_decide_frc2fsync_using_I2D!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
					Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(FALSE);
					Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(TRUE);
				}else{
					rtd_pr_vsc_emerg(" data fs go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
					Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
					Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
				}
			}else{
				rtd_pr_vsc_emerg(" data frc go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
				Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
				Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
			}
		}
		#endif
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			&&(!is_game_mode_keep_buffer_mode())
			&&(!drvif_i3ddma_triplebuf_by_timing_protect_panel())
			//&&(get_HDMI_HDR_mode() != HDR_DOLBY_HDMI)
			&&(false == is_hdmi_dolby_vision_sink_led())
			&&(display == SLR_MAIN_DISPLAY)
			){
			if(/*((webos_tooloption.eModelModuleType == module_LGD) && (webos_tooloption.eBackLight == direct ) && (webos_tooloption.eLEDBarType == local_dim_block_32))
				||*/ (Scaler_Get_FreeRun_To_FrameSync_By_Reset_VODMA() && vbe_get_HDMI_run_timing_framesync_condition())){
				drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
			}else{
				drv_I3ddmaVodma_GameMode_iv2pv_delay(TRUE);
			}
		} else if (display == SLR_MAIN_DISPLAY) {
			drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
		}

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set VGIP time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif

#ifdef CONFIG_I2RND_ENABLE
		//check s0 still run idomain stage before refine vo1 clock, vgip hporch and DI h_blk size @Crixus 20180119
		if((display == SLR_MAIN_DISPLAY) && !((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
			if((get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S1_REFINE_VO1) && (webos_src == VSC_INPUTSRC_VDEC)){
				Scaler_I2rnd_wait_timing_enable();
			}
			set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_START);
			rtd_pr_vsc_emerg("[I2RND]I2RND_S0_IDOMAIN_STAGE_START!!\n");
		}
#endif
		//IF HFR case, need bypass MEMC earlier, to avoid MEMC garbage
		if(((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || force_enable_two_step_uzu() || get_hdmi_vrr_4k60_mode())){
			vbe_disp_set_stop_memc_push_flag(TRUE);
			//set MEMC mux disable
			Scaler_MEMC_Bypass_On(1);
			//MEMC bypass
			Scaler_MEMC_MEMC_CLK_OnOff(0, 0, 1);
	//		vbe_dtg_memec_bypass_switch_set(0);
			rtd_pr_vsc_notice("HDMI_4K120 or force2stepuzu bypass MEMC!!\n");
		}else{
			vbe_disp_set_stop_memc_push_flag(FALSE);
		}

		modestate_set_imd_domain(info);

		//memc timing stable log print
		MEMC_error_status_print_flag = 1;

#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC){
			//VDEC 2k1k use original flow, framesync with gatting
			if((_ENABLE == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) > DATAFS_DISABLE_GATTING_WIDTH) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) > DATAFS_DISABLE_GATTING_HEIGHT)){
				g_tDataFsAlgoResult.ulEnableVCrop = 1;
				g_tDataFsAlgoResult.ulUpdateReg = 1;
				rtd_pr_vsc_emerg("Send RPC to recalculate vo vstart htotal\n");
				UpdateDataFsAlgoRsult();
				//scaler_update_vo_vstat_htotal(TRUE,TRUE);
			}
		}
#endif
        if(judge_scaler_break_case(display))
        {
            rtd_pr_vsc_notice("####channel:%d scaler need to break before dtg_pre_idomain!!!####\r\n", display);
            return FALSE;
        }

	//Merlin6 new flow : DataFS increase VO clock new flow
	if((display == SLR_MAIN_DISPLAY)&&(_ENABLE == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))){
		g_tDataFsAlgoResult.ulDispWin = SLR_MAIN_DISPLAY;
		rtd_pr_vsc_emerg("Send RPC to increase VO clock for DataFS\n");
		UpdateDataFsAlgoRsult();
	}
		//scaler timing change stable flag
		vbe_set_disp_timing_change_status(FALSE);
		scaler_disp_dtg_pre_i_domain_setting(display);

		//set memc in/out framerate after memc handle done, if set this function after force bg,
		//it may happen memc buffer index jump back. (ex: 60hz->24hz, unmute, set in/out framerate)
		// move in front of frc2fsync timing change, prevent from phase table error
		//Scaler_MEMC_SetInOutFrameRate();

		if(idomain_vfreq_pre != Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)){
			rtd_pr_vsc_emerg("input vfreq has changed, force return to re-run scaler!!!\n");
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			return FALSE;
		}

#ifdef CONFIG_I2RND_ENABLE
		//check s0 still run idomain stage before refine vo1 clock, vgip hporch and DI h_blk size @Crixus 20180119
		if((display == SLR_MAIN_DISPLAY) && !((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
			set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_DONE);
			rtd_pr_vsc_emerg("[I2RND]I2RND_S0_IDOMAIN_STAGE_DONE!!\n");
		}
#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set imd time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif

		//modestate_arbitration_setup();

		//rtd_pr_vsc_emerg("Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_GameMode) = %d\n", Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_GameMode));


#ifdef CONFIG_WSS_ENABLE
		check_wss(_TRUE,0); // move here by linmc, need to wait wss stable
#endif
		//IoReg_SetBits(/*Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL) ? SYNCPROCESSOR_SP_MS2STUS_VADDR : */ONMS_onms1_status_reg, (_BIT14|_BIT15|_BIT8|_BIT9));//clear online ms error flag
		if(judge_scaler_break_case(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_pr_vsc_debug("\r\n####channel:%d scaler need to break 2!!!####\r\n", display);
			return FALSE;
		}

//move her to let semaless work early
		if(display == SLR_MAIN_DISPLAY)
		{
			if(webos_src == VSC_INPUTSRC_HDMI)
			{
#ifdef CONFIG_HDR_SDR_SEAMLESS
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				i3ddma_cap1_interrupt_ctrl(TRUE);//enable i3ddma cap1 interrupt
#endif
#endif
			}
		}

		//scaler timing change stable flag
		vbe_set_disp_timing_change_status(TRUE);

		if(display == SLR_MAIN_DISPLAY)
		{
			if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1))
			{
				two_pixel_mode_edge_smooth_update();//force update
			}
		}

        update_vsc_task_status(0, VSC_I_DOMAIN);//clear i domain statsu
        update_vsc_task_status(1, VSC_M_DOMAIN);//set M domain statsu
		if (((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode()) || ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode())) {
#ifdef CONFIG_I2RND_ENABLE
 			if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){//capture progressive video data
 				rtd_pr_vsc_emerg("[frank] apvr step3!\n");
				Scaler_i2rnd_send_apvr_info();
				mdomain_handler_i2rnd_mcap_apvr();

				vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_I2RND_DONE;
				drvif_scaler_vactive_end_irq(_ENABLE, SLR_SUB_DISPLAY);
				drvif_scaler_vactive_sta_irq(_ENABLE, SLR_SUB_DISPLAY);
				VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
				DbgSclrFlgTkr.OutputVencMode = FALSE;
				Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
				i2rnd_send_table_idx(I2RND_MAIN_S0_TABLE);
				rtd_pr_vsc_emerg("[frank] apvr step4!\n");
				//go to timing frame sync mode -s- Eric@0809
				rtd_pr_vsc_emerg( "[OUTPUT_VENC_MODE] go to data frc & timing framesync!\n");
				VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
                modestate_set_fll_running_flag(_DISABLE);
                fwif_color_safe_od_enable(0);
				drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
				fwif_color_safe_od_enable(1);
				//go to timing frame sync mode -e-
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);
				//scaler_update_struct_info(SLR_SUB_DISPLAY);
				scaler_update_struct_info(SLR_MAIN_DISPLAY);
				return TRUE;
			}else if((display == SLR_SUB_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){//sub path capture
				rtd_pr_vsc_emerg("[frank] apvr step1!\n");
				mdomain_handler_onlycap_i2run();
			}
			else
#endif
				mdomain_handler_onlycap();
		}
#ifdef CONFIG_I2RND_ENABLE
		else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)){
			mdomain_handler_i2rnd_mcap_sdisp();
			i2rnd_group3_s1_to_s0_register_sync();
			Pipmp_SetPipCtrl();
			//Eric@0916 check s0 mdomain_in1cap_enable bit
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
			IoReg_SetBits(MDOMAIN_CAP_Cap_In1_enable_reg, _BIT0);
			if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
				//Eric@0917 check s0 rtnr progressive i2r_fix_me
				drvif_color_rtnr_progressive_check(!i2rnd_main_voinfo.progressive,SLR_MAIN_DISPLAY);
				//Eric@0917 set s0 di size i2r_fix_me
				i2rnd_di_size_toggle();
			}
			Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
			//Eric@20171221 Trigger run s1 vip matrix table
			scalerVIP_Write_s1_RGB2YUV(1);
			//Eric@20171214 toggle di to make di change size setting
			i2rnd_di_size_toggle();
			#if 0
			//reset to free run first
			drivf_scaler_reset_freerun();
			modestate_set_fll_running_flag(_DISABLE);

			//Eric@20170919 set disp timing to framesync
			fwif_color_safe_od_enable(0);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			fwif_color_safe_od_enable(1);
			rtd_pr_vsc_emerg("[I2RND] I2rnd default timing fs\n");
			#endif
			vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_DONE;
			rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@ Stage go I2RND_DUALVO_STAGE_RERUN_MAIN_DONE @@@@@@@@@@\n");
			return TRUE;

		}
		else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
			mdomain_handler_i2rnd_mcap_sdisp();
			i2rnd_group3_s1_to_s0_register_sync();
			Pipmp_SetPipCtrl();
			//Eric@0916 check s0 mdomain_in1cap_enable bit
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
			IoReg_SetBits(MDOMAIN_CAP_Cap_In1_enable_reg, _BIT0);
			if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
				//Eric@0917 check s0 rtnr progressive
				drvif_color_rtnr_progressive_check(!i2rnd_main_voinfo.progressive,SLR_MAIN_DISPLAY);
				//Eric@0917 set s0 di size
				i2rnd_di_size_toggle();
			}
			Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
			//Eric@20171221 Trigger run s1 vip matrix table
			scalerVIP_Write_s1_RGB2YUV(1);
			//Eric@20171214 toggle di to make di change size setting
			i2rnd_di_size_toggle();
			//reset to free run first
			drivf_scaler_reset_freerun();
			modestate_set_fll_running_flag(_DISABLE);

			//Eric@20170919 set disp timing to framesync
            fwif_color_safe_od_enable(0);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			fwif_color_safe_od_enable(1);
			rtd_pr_vsc_emerg("[I2RND] I2rnd default timing fs\n");

			vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_I2RND_DONE;
			rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@ I2RND_STAGE_MAIN_I2RND_DONE @@@@@@@@@@\n");
			return TRUE;
		}
#endif
		else {

			if (!modestate_set_framesync(info))  // if fs fail, keep in fs state
			{
				return FALSE;
			}
		}
#if 0//remove in k4lp
		//run scaler IM-domain flow to sync timing info after running smooth toggle@Crixus 20160919
		if((DbgSclrFlgTkr.game_mode_dynamic_flag == TRUE)&&(display == SLR_MAIN_DISPLAY))
		{
			rtd_pr_vsc_notice("[GameMode][break for not setting d domain timing]Main re run scaler flow!!\n");
			//When enter or exit game mode, need to wait buffer write done @Crixus 20161005
			if(drv_memory_get_game_mode() == _ENABLE)
				game_mode_wait_frame = 1;//triple-buffer => single buffer, need to wait least 1 frame done.
			else
				game_mode_wait_frame = 3;//single-buffer => triple buffer, need to wait least 3 frame done.

			//Update the M-domain last done @Crixus 20161013
			drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, game_mode_wait_frame, FALSE);
			state_update_disp_info();//send scaler info to smoothtoggle ,for issue KTASKWBS-6453
			return TRUE;
		}
#endif
#ifdef CONFIG_I2RND_ENABLE
		//update s1 memory tag info before send memory in fo video fw @Crixus 20171223
		if(display == SLR_MAIN_DISPLAY)
			i2rnd_s1_default_memory_tag();
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
		//enable I2rnd_b05
         if (Scaler_I2rnd_b05_get_enable()) {
		 //	 Scaler_i2rnd_b05_buffer_copy();
             Scaler_I2rnd_b05_handler();
         }


#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set Mdomain time=%d ms",(after_time-before_time));
		before_time = after_time;
#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD online measure enable time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif
        update_vsc_task_status(0, VSC_M_DOMAIN);//clear M domain statsu
		update_vsc_task_status(1, VSC_D_DOMAIN);//clear M domain statsu

		if (((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode())
			|| ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode())
			) {
			/*not open disp*/
			//in VENC mode, apvr need to enable d-domain den start irq @Crixus 20161014
			drvif_scaler_ddomain_switch_irq(_ENABLE);
			if ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode())
				drvif_scaler_sub_mdomain_switch_irq(_ENABLE);
		} else {
			Scaler_disp_setting(display);
		}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	//rtd_setbits(TVSB2_TV_SB2_DCU1_ARB_CR1_reg,_BIT2|_BIT3);
	//if(DisplayModeInputInfo.type == VSC_INPUTSRC_VDEC || VencModeInputInfo.type ==VSC_INPUTSRC_VDEC || MemoryModeInputInfo.type ==VSC_INPUTSRC_VDEC)
			//if((rotatemode == ROTATE_MODE_90) || (rotatemode == ROTATE_MODE_180) || (rotatemode == ROTATE_MODE_270))
			if ((display == SLR_MAIN_DISPLAY) && (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY)))
				scaler_Rotate_VI_init_send_rpc();
#endif

		if(judge_scaler_break_case(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_pr_vsc_debug("\r\n####channel:%d scaler need to break 3!!!####\r\n", display);
			return FALSE;
		}

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_pr_vsc_debug("Setup_IMD set display time=%d ms",(after_time-before_time));
		before_time = after_time;
#endif
	//Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT, 0);
	if (display == SLR_MAIN_DISPLAY)
		check_delay_set_nnsr();
//#ifndef CONFIG_MEMC_BYPASS
	if(get_MEMC_bypass_status_refer_platform_model() == FALSE){
	if(Get_MEMC_Enable_Dynamic() == 1)
	{
		//run MEMC setting
		Scaler_MEMC_Handler();
	}

	// FixMe, 20190925
	//MEMC_Lib_set_INPUT_COLOR_SPACE_Mode(pc_mode_run_422());//I3DDMA_COLOR_SPACE_T

	if(0){//k-task8503 patch avoid set memc clk onoff(1) will mute main path
//	if(display == SLR_MAIN_DISPLAY){//k-task8503 patch avoid set memc clk onoff(1) will mute main path
		if(vbe_get_HDMI_dynamic_film_mode_flag()!= 1){
			if (vbe_dtg_memec_bypass_switch()) {
				rtd_pr_vsc_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_GGG][%d,%x]\n", ((rtd_inl(PPOVERLAY_MEMC_MUX_CTRL_reg)>>13)&0x1), rtd_inl(MEMC_MUX_MEMC_MUX_FUNC_CTRL_reg));
				//Scaler_MEMC_Bypass_CLK(0);
				//Scaler_MEMC_Bypass_CLK_OnOff(0);
		#if 1
				Scaler_MEMC_DTV_ME_CLK_OnOff(0, 1);
		#endif
			} else {
				rtd_pr_vsc_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_HHH][%d,%x]\n", ((rtd_inl(PPOVERLAY_MEMC_MUX_CTRL_reg)>>13)&0x1), rtd_inl(MEMC_MUX_MEMC_MUX_FUNC_CTRL_reg));
				//Scaler_MEMC_Bypass_CLK(1);
				//Scaler_MEMC_Bypass_CLK_OnOff(1);
		#if 1
				Scaler_MEMC_DTV_ME_CLK_OnOff(1, 1);
		#endif
			}
		}
	}
	}
	else {
//#else
		rtd_pr_vsc_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_III]\n");
		//Scaler_MEMC_Bypass_CLK(0);
		//Scaler_MEMC_Bypass_CLK_OnOff(0);
		vbe_dtg_memec_bypass_switch_set(1);
		#if 1
			Scaler_MEMC_DTV_ME_CLK_OnOff(0, 1);
		#endif
	}
//#endif
	if(display == SLR_MAIN_DISPLAY)
	{
		check_di_buffer_mode();//Check DI buffer mode right or not. If wrong, recover it.
		Set_DI_SW_Detection_in_IMD(display);
	}

	if(vcom_flag){
		Scaler_color_Set_PQ_ByPass_Lv(8);	/* Spec flow for VCOM pattern*/
		IoReg_ClearBits(DM_dm_submodule_enable_reg, DM_dm_submodule_enable_b01_02_enable_mask);
		IoReg_Mask32(DM_Input_Format_reg,~DM_Input_Format_dm_in_sel_mask,DM_Input_Format_dm_in_sel(3));
		IoReg_SetBits(DM_HDR_Double_Buffer_CTRL_reg, DM_HDR_Double_Buffer_CTRL_dm_db_apply_mask);
		drvif_color_set_PQ_Module(PQ_ByPass_I_RGB2YUV,1);
		drvif_color_set_PQ_Module(PQ_ByPass_D_YUV2RGB,1);
	}

	setup_di_done_flag = (unsigned int *)Scaler_GetShareMemVirAddr(SCALERIOC_SETUP_DI_DONE);
	if(setup_di_done_flag)
    {
        *setup_di_done_flag = Scaler_ChangeUINT32Endian(1);
    }

	zoom_update_scaler_info_from_vo_smooth_toggle(display,1);//running scaler need to clear smoothtoggle info
    if(((Get_DISPLAY_PANEL_OLED_TYPE() == TRUE) || (vbe_disp_get_orbit())) && (SLR_MAIN_DISPLAY== display) )
    {
        smooth_toggle_state_info_rpc(SLR_MAIN_DISPLAY);
        vo_smoothtoggle_memory_alloc(SLR_MAIN_DISPLAY);
    }

	if(Scaler_InputSrcGetType(display) == _SRC_VO)
	{
		MODE_CLEAR_ONMS_FLAG();
		if(!Get_vo_smoothtoggle_timingchange_flag(display))  //vo smooth toggle don't need onlinemeasure
		{
			if(!((display == SLR_MAIN_DISPLAY) && (_ENABLE == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))) {	//data fs mode move to after gatting enable
				if((webos_src == VSC_INPUTSRC_VDEC) || (webos_src == VSC_INPUTSRC_JPEG)){
					//Real Vo case
					drvif_mode_enableonlinemeasure(display);//Enable online measure
					drvif_mode_onlinemeasure_setting(display, _SRC_VO, TRUE, FALSE);
				}
			}
		}

		if (get_scaler_stop_flag(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_pr_vsc_debug("\r\n####channel:%d vsc already disconnet !!!####\r\n", display);
			return FALSE;
		} else if(get_vo_change_flag(Get_DisplayMode_Port(display))){
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_pr_vsc_debug("\r\n####channel:%d vo change!!!####\r\n", display);
			return FALSE;
		}
		down(get_vo_infosemaphore()); /* lock VO Semaphore */
#ifdef CONFIG_HDR_SDR_SEAMLESS
		if(display == SLR_MAIN_DISPLAY)
		{
			down(&HDR_Setting_Semaphore);
			if(!get_vo_change_flag(0)) {//main
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
			}
			up(&HDR_Setting_Semaphore);
		}
		else
		{
			if(!get_vo_change_flag(1))//sub
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
#else
		if(display == SLR_MAIN_DISPLAY)
		{
			if(!get_vo_change_flag(0))//main
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
		else
		{
			if(!get_vo_change_flag(1))//sub
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
#endif
		up(get_vo_infosemaphore()); /* Release VO Semaphore */
		state_update_disp_info();//Update the active state
		if(((Get_vo_smoothtoggle_timingchange_flag(display)) && (get_vo_smoothtoggle_state(display) == SLR_SMOOTH_TOGGLE_INIT) && (Scaler_DispGetInputInfo(SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)))
		{
			smooth_toggle_preset_info(display);
			rtd_pr_vsc_notice("enter SLR_SMOOTH_TOGGLE_ACTIVE state\n");
		}
	}
	else
	{
		if(judge_scaler_break_case(display) == FALSE)
		{
			if (get_scaler_stop_flag(display)) {
				rtd_pr_vsc_debug("\r\n####channel:%d vsc already disconnet !!!####\r\n", display);
				return FALSE;
			}

			if(Scaler_InputSrcGetType(display) == _SRC_TV) {
				if (display == SLR_MAIN_DISPLAY) {
#ifndef SPEEDUP_NEW_SCALER_FLOW
					down(&SetMainOutPutRegion_Semaphore);
					if(DbgSclrFlgTkr.Main_Output_Set_flag == TRUE) {
						up(&SetMainOutPutRegion_Semaphore);
						rtd_pr_vsc_debug("\r\n####Main Output change can not active!!!####\r\n");
						return FALSE;
					}
					up(&SetMainOutPutRegion_Semaphore);
#endif

				} else {
					down(&SetSubOutPutRegion_Semaphore);
					if(DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) {
						up(&SetSubOutPutRegion_Semaphore);
						rtd_pr_vsc_debug("\r\n####Sub Output change can not active!!!####\r\n");
						return FALSE;
					}
					up(&SetSubOutPutRegion_Semaphore);
				}
			}
			Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
			state_update_disp_info();//Update the active state
		}
		else
		{
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_pr_vsc_debug("####Online measure status error!!!####\r\n");
			return FALSE;
		}
	}
	MEMC_error_status_print_flag = 0;

#ifdef CONFIG_SUPPORT_SRC_ADC
	//rtd_pr_vsc_notice("%s(line: %d)####display=%d(0:main, 1:sub)####\r\n", __func__, __LINE__, display);
	if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR) && (auto_phase_flow_bypass() == FALSE)){

		//rtd_pr_vsc_info("YPbPr auto phase---wait\n");
		drvif_ypbpr_auto_phasedo_WaitFinish(SLR_MAIN_DISPLAY);
		rtd_pr_vsc_info("YPbPr auto phase---done\n");
		SyncProc_SetMinDiff(display);

		if(judge_scaler_break_case(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_pr_vsc_info("####after auto phase need to break!!!####\r\n");
			return FALSE;
		}
	}

#ifdef ADC_UP_DOWN_CLAMP
	if(webos_src == VSC_INPUTSRC_ADC){
		SyncProc_Check_UpDn_Stable(display);
	}
#else
	if(webos_src == VSC_INPUTSRC_ADC)
	{
		 abl_abl_status_RBUS abl_status_reg;
		 abl_abl_mgn_b_RBUS abl_mgn_b_reg;
		 abl_abl_mgn_rg_RBUS abl_mgn_rg_reg;
		 count = 50;
		 while(count > 0)	/* wait abl status ready */
		 {
			abl_status_reg.regValue = IoReg_Read32(ABL_ABL_STATUS_reg);
			if(abl_status_reg.abl_red_equal & abl_status_reg.abl_grn_equal & abl_status_reg.abl_blu_equal)
			{
				if(judge_scaler_break_case(display)){
					if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
						drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
					}
					return FALSE;
				}
				abl_mgn_rg_reg.regValue = IoReg_Read32(ABL_ABL_MGN_RG_reg);
				abl_mgn_rg_reg.abl_l_mgn_red = YPBPR_ABL_UV_LARGE_MARGIN;
				IoReg_Write32(ABL_ABL_MGN_RG_reg, abl_mgn_rg_reg.regValue);

				abl_mgn_b_reg.regValue = IoReg_Read32(ABL_ABL_MGN_B_reg);
				abl_mgn_b_reg.abl_l_mgn_blu = YPBPR_ABL_UV_LARGE_MARGIN;
				IoReg_Write32(ABL_ABL_MGN_B_reg, abl_mgn_b_reg.regValue);
				break;
			}
			else
			{
				count--;
				if((count%10) == 0) {
					if(judge_scaler_break_case(display)){
						if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
							drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
						}
						return FALSE;
					}
				}
				if(count == 0)
				{
					abl_mgn_rg_reg.regValue = IoReg_Read32(ABL_ABL_MGN_RG_reg);
					abl_mgn_rg_reg.abl_l_mgn_red = YPBPR_ABL_UV_LARGE_MARGIN;
					IoReg_Write32(ABL_ABL_MGN_RG_reg, abl_mgn_rg_reg.regValue);

					abl_mgn_b_reg.regValue = IoReg_Read32(ABL_ABL_MGN_B_reg);
					abl_mgn_b_reg.abl_l_mgn_blu = YPBPR_ABL_UV_LARGE_MARGIN;
					IoReg_Write32(ABL_ABL_MGN_B_reg, abl_mgn_b_reg.regValue);

					rtd_pr_vsc_info("ABLStatus_Reg Count Time out!\n");
				}
				usleep_range(5000, 5000);
			}
		 }
		//rtd_pr_vsc_debug("%s(%d)-%s:  ABLStatus_Reg Count Time =%d !\n", __FILE__,__LINE__,__FUNCTION__, count);
	}
#endif
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC

#ifndef CONFIG_SCALER_BRING_UP
	if(webos_src == VSC_INPUTSRC_HDMI)
	{
		unsigned char check_framerate_result = TRUE;
		if(_FALSE == drvif_Hdmi_CheckStableBeforeDisplay())
			return FALSE;

		if(display == SLR_MAIN_DISPLAY)
		{
			if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120))
			{
				if(!check_online_result(SLR_MAIN_DISPLAY, _MAIN_VGIP_PATH))
					check_framerate_result = FALSE;
			}
			else
			{
				if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
				{
					if(!check_online_result(SLR_MAIN_DISPLAY, _DAM_VGIP_PATH))
						check_framerate_result = FALSE;
				}
				else
				{
					if(!check_online_result(SLR_MAIN_DISPLAY, _MAIN_VGIP_PATH))
						check_framerate_result = FALSE;
				}
			}
		}
		else
		{
			if(!check_online_result(SLR_SUB_DISPLAY, _SUB_VGIP_PATH))
				check_framerate_result = FALSE;
		}
		if(check_framerate_result == FALSE)
		{
			reset_hdmi_timing_ready();
			down(get_hdmi_detectsemaphore());
			if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
				vfe_hdmi_drv_handle_on_line_measure_error(0);
			}
			up(get_hdmi_detectsemaphore());
			return FALSE;
		}
	}
#endif

	if((display == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
		scaler_data_frame_sync_enable_gatting(webos_src);
             if((webos_src == VSC_INPUTSRC_VDEC) && (Scaler_Get_Vo_Force_60_Framerate_State() == VO_ORIGINAL_24_FORCE_60)) {

             } else {
                 scaler_linebuffer_mode_finish = TRUE;
             }
	}

	if (display == SLR_MAIN_DISPLAY){
		//add main double buffer apply @Crixus 20160126
		imd_smooth_main_double_buffer_all_apply();
		if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE){
			//Update the M-domain last done @Crixus 20161013
			if ((TRUE == Get_rotate_function(SLR_MAIN_DISPLAY)) && (get_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				drv_memory_wait_mdom_vi_last_write_done(SLR_MAIN_DISPLAY, 3);//triple buf for rotate
			else
				drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, 1, FALSE);

			//if input fast case, it need to wait capture done, then set FRC style.
			if(mdomain_input_fast_flag){
				drv_memory_display_set_input_fast();
				mdomain_input_fast_flag = 0;
			}
		}
		set_mdomain_driver_status(TRUE);//m domain driver ready
	} else {
		//add sub double buffer apply @Crixus 20160126
		imd_smooth_sub_double_buffer_all_apply();
#ifdef CONFIG_I2RND_ENABLE
		if(!(Scaler_I2rnd_get_timing_enable()) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE))
#else
		if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)
#endif
        {
			if (!get_sub_OutputVencMode()) {//sub m domain iterrupt open so don't need wait lastwrite @qing_liu --s4ap
				//Update the M-domain last done @Crixus 20161013
				drv_memory_wait_cap_last_write_done(SLR_SUB_DISPLAY, 1, FALSE);
			}
		}
	}

	if(judge_scaler_break_case(display)) {
		if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
			drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
		}
		rtd_pr_vsc_debug("\r\n####channel:%d scaler need to break 4!!!####\r\n", display);
		return FALSE;
	}
	wait_DI_ready();//wait DI ready

	if(judge_scaler_break_case(display)) {
		if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
			drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
		}
		rtd_pr_vsc_debug("\r\n####channel:%d scaler need to break 5!!!####\r\n", display);
		return FALSE;
	}

	record_Setup_IMD_timer_counter = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);//record current 90k counter
#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif
#ifdef CONFIG_RTK_8KCODEC_INTERFACE
        if (display == SLR_MAIN_DISPLAY)
        {
            unsigned short len = 0;
            unsigned short wid = 0;

            if(webos_src != VSC_INPUTSRC_VDEC)
            {
                len = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE);
                wid = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_WID_PRE);
                if(Scaler_DispGetStatus(display, SLR_DISP_INTERLACE) == 1)
                {
                    len = len * 2;
                }
            }
            else
            {
                SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

                len = pVOInfo->src_v_len;
                if(pVOInfo->progressive == 0)
                {
                    len = len * 2;
                }

                wid = pVOInfo->src_h_wid;
            }

            send_srnn_real_size_to_slave(wid, len);
        }
#endif
        update_vsc_task_status(0, VSC_D_DOMAIN);//clear M domain statsu

	return TRUE;
}
unsigned char (*Setup_IMD)(StructDisplayInfo* info) = Setup_IMD_impl;

void drvif_vodma_di_freeze(unsigned char bFreeze)
{
	int ret;
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_SET_VODMADI_FREEZE_ENABLE,bFreeze,1))){
		rtd_pr_vsc_emerg("[dc2h]ret=%d, SCALERIOC_SET_VODMADI_FREEZE_ENABLE RPC fail !!!\n", ret);
	}
}

void drvif_mdomain_freeze(unsigned char bFreeze)
{
	int ret;
	Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_SET_MDOMAIN_FREEZE_ENABLE,bFreeze,1))){
		pr_emerg("[mdomain]ret=%d, SCALERIOC_SET_MDOMAIN_FREEZE_ENABLE RPC fail !!!\n", ret);
	}
}

void Scaler_SetFreeze_impl(unsigned char channel, unsigned char mode)
{
#ifdef CONFIG_FORCE_RUN_I3DDMA
	VSC_INPUT_TYPE_T srctype;
	srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

	if (SLR_MAIN_DISPLAY == channel) {
		if((channel == SLR_MAIN_DISPLAY) && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) {
			pr_info("MEMC_freeze, freeze ATV\n");
			MEMC_Lib_Freeze(1);
		} else if((srctype != VSC_INPUTSRC_VDEC)&&(srctype != VSC_INPUTSRC_JPEG)&&(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)==FALSE)){
			/*livezoom on k4lp,for smoothtgogle,could not m domain freeze, so progressive hdmi do freeze at i3ddma capture*/
			drvif_I3DDMA_freeze(mode);

		} else {
			if((vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)) &&
					(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) && (!(Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()) == SOURCE_DIRECTVO))){
				rtd_pr_vsc_debug(KERN_EMERG, TAG_NAME_VSC, "DTV channel change memc freeze[%d][%s %d]\n", mode,__FUNCTION__, __LINE__);
				drvif_mdomain_freeze(mode);
			} else {
				if(mode == TRUE) {
					if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
						drvif_vodma_di_freeze(0);/*di freeze on*/
					else
						drvif_vodma_di_freeze(1);/*vo freeze on*/
				} else {
					if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
						drvif_vodma_di_freeze(2);/*di freeze off*/
					else
						drvif_vodma_di_freeze(3);/*vo freeze off*/
				}
			}
		}
	}
#else
	if (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)channel, SLR_INPUT_FRAMESYNC))
	{
	#if 0
		if(Scaler_DispGetStatus((SCALER_DISP_CHANNEL)channel, SLR_DISP_THRIP)
			|| Scaler_DispGetStatus((SCALER_DISP_CHANNEL)channel, SLR_DISP_RTNR))
		{
			//drvif_color_di_freeze(mode);
			if(mode == TRUE)
			{
				rtd_pr_vsc_debug(KERN_EMERG, TAG_NAME_VSC, "di freeze on[%s %d]\n", __FUNCTION__, __LINE__);
				drvif_vodma_di_freeze(0);/*di freeze on*/
			}
			else
			{
				rtd_pr_vsc_debug(KERN_EMERG, TAG_NAME_VSC, "di freeze off[%s %d]\n", __FUNCTION__, __LINE__);
				drvif_vodma_di_freeze(2);/*di freeze off*/
			}
		}
		else
	#endif
		{
			if(((srctype == VSC_INPUTSRC_VDEC)||(srctype == VSC_INPUTSRC_JPEG) ||(get_line_alternative_3d_mode_enable() == TRUE)
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
#endif
			)&&(SLR_MAIN_DISPLAY == channel))
			{
				if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) &&
					(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) && (!(Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()) == SOURCE_DIRECTVO))){
					rtd_pr_vsc_debug(KERN_EMERG, TAG_NAME_VSC, "dtv channel change mdomain freeze[%d][%s %d]\n", mode,__FUNCTION__, __LINE__);
					drvif_mdomain_freeze(mode);
				}else{
					if(mode == TRUE)
					{
						rtd_pr_vsc_debug(KERN_EMERG, TAG_NAME_VSC, "vo freeze on[%s %d]\n", __FUNCTION__, __LINE__);
						drvif_vodma_di_freeze(1);/*vo freeze on*/
					}
					else
					{
						rtd_pr_vsc_debug(KERN_EMERG, TAG_NAME_VSC, "vo freeze off[%s %d]\n", __FUNCTION__, __LINE__);
						drvif_vodma_di_freeze(3);/*vo freeze off*/
					}
				}
			}
		}
	}
	else
	{
		rtd_pr_vsc_debug("drvif_scalerdisplay_set_freeze\n");
		drvif_scalerdisplay_set_freeze(channel, mode);
	}
#endif
}
void (*Scaler_SetFreeze)(unsigned char channel, unsigned char mode) = Scaler_SetFreeze_impl;

extern void magnifier_color_ultrazoom_config_scaling_up(unsigned char display);
//extern void imd_smooth_enable_sub_double_buffer(unsigned char bEnable);


unsigned short Scaler_CalAVD27MWidth(SCALER_DISP_CHANNEL display,unsigned short a_usInput)
{
	unsigned short usRet = a_usInput;

	//rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	//rtd_pr_vsc_debug("outregion.w=%d,display=%d,  outputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", outregion->w,display,Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);

	//if (outregion->w >= AVD_DI_5A_WIDTH )
	if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode(display))
	{
		if (display == SLR_MAIN_DISPLAY)
		{
			usRet = a_usInput * AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH * 2;
		}
#ifdef CONFIG_DUAL_CHANNEL
		else
		{

		// Sub can use DI
		#ifdef CONFIG_I2RND_ENABLE
			usRet = a_usInput * AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH * 2;
		#else
			// By pass DI
			usRet = a_usInput * 2;
		#endif
		}
#endif
	}
	else if(VD_27M_HSD1440_DI3A== fw_video_get_27mhz_mode(display))
	{
		usRet = a_usInput * 2;
	}

	return usRet;

}


unsigned char Scaler_CalWindowZoominForAVD(SCALER_DISP_CHANNEL display,VIDEO_RECT_T *inregion, VIDEO_RECT_T *outregion)
{
	VIDEO_RECT_T tmpinregion;

#if 1
	if (display == SLR_MAIN_DISPLAY)
	{
		tmpinregion.x = Main_InputRegion_x;
		tmpinregion.y = Main_InputRegion_y;
		tmpinregion.w = Main_InputRegion_w;
		tmpinregion.h = Main_InputRegion_h;

		rtd_pr_vsc_debug("Main path inputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY)
	{
		tmpinregion.x = Sub_InputRegion_x;
		tmpinregion.y = Sub_InputRegion_y / 2;  // ByPass DI
		tmpinregion.w = Sub_InputRegion_w;
		tmpinregion.h = Sub_InputRegion_h / 2;  // ByPass ID

		rtd_pr_vsc_debug("Sub path inputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);
	}
#endif

#endif


	rtd_pr_vsc_debug("outregion.w=%d,display=%d,  outputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", outregion->w,display,Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);

	if (outregion->w >= AVD_DI_5A_WIDTH )
	{
		if (display == SLR_MAIN_DISPLAY)
		{
			inregion->x = tmpinregion.x*2*AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH ;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w*2*AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH ;
			inregion->h = tmpinregion.h;

			#ifdef CONFIG_FIXED_VD_27MHZ_960_TO_UZU
				inregion->x = 0;
				inregion->w = 960;
			#endif
		}
#ifdef CONFIG_DUAL_CHANNEL
		else
		{
			inregion->x = tmpinregion.x*2;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w*2;
			inregion->h = tmpinregion.h;
		}
#endif
	}
	else
	{
		if (outregion->w > tmpinregion.w)
		{
			inregion->x = tmpinregion.x;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w;
			inregion->h = tmpinregion.h;
		}
		else
		{
			inregion->x = (tmpinregion.x *2*outregion->w)/AVD_27M_VGIP_WIDTH;
			inregion->y = tmpinregion.y;
			inregion->w = (tmpinregion.w *2*outregion->w)/AVD_27M_VGIP_WIDTH;
			inregion->h = tmpinregion.h;

			rtd_pr_vsc_debug("inregion.w=%d, outregion.w=%d\n", inregion->w, outregion->w);
		}
	}

	#if 1
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("rtk_run_scaler 1 inregion x=%d, y=%d, w=%d, h=%d\n", inregion->x, inregion->y, inregion->w, inregion->h);
	rtd_pr_vsc_debug("rtk_run_scaler 1 outregion x=%d, y=%d, w=%d, h=%d\n", outregion->x, outregion->y, outregion->w, outregion->h);
	rtd_pr_vsc_debug("**** Scaler_DispWindowZoominForAVD()\n");
	#endif

	#if 0
	rtd_pr_vsc_emerg( "display=%d\n", display);
	rtd_pr_vsc_emerg( "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_emerg( "rtk_run_scaler 1 inregion x=%d, y=%d, w=%d, h=%d\n", inregion->x, inregion->y, inregion->w, inregion->h);
	rtd_pr_vsc_emerg( "rtk_run_scaler 1 outregion x=%d, y=%d, w=%d, h=%d\n", outregion->x, outregion->y, outregion->w, outregion->h);
	rtd_pr_vsc_emerg( "**** Scaler_DispWindowZoominForAVD()\n");
	#endif

	return TRUE;
}

extern void avdmdsmooth_color_ultrazoom_config_scaling_up(unsigned char display);
unsigned char Scaler_DispWindowZoominForAVD(SCALER_DISP_CHANNEL display, VIDEO_RECT_T inputwin, VIDEO_RECT_T outputwin, unsigned char changetomain)
{
	unsigned short usAfterDILen = 0;
	unsigned short usAfterDIWid = 0;
	unsigned short mDomainCapLen = 0;
	unsigned short mDomainCapWid = 0;
	unsigned short x_offset = 0;
	unsigned short w_offset = 0;
	unsigned int ulMemActLen;
	unsigned int ulMemActSta;

	mdomain_disp_ddr_mainsubctrl_RBUS mdomain_disp_ddr_mainsubctrl_Reg;
	ppoverlay_double_buffer_ctrl_RBUS ppoverlay_double_buffer_ctrl_Reg;
	scaleup_dm_uzu_db_ctrl_RBUS scaleup_dm_uzu_db_ctrl_Reg;
	scaleup_ds_uzu_db_ctrl_RBUS scaleup_ds_uzu_db_ctrl_Reg;


	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if (((outputwin.x + outputwin.w) > _DISP_WID) || ((outputwin.y + outputwin.h) > _DISP_LEN)) {
		rtd_pr_vsc_debug("Zoom in fail, for out size out of panel range\n");
		return FALSE;
	}

	if (display == SLR_SUB_DISPLAY) {
		sub_dispwin.srcx = outputwin.x;
		sub_dispwin.srcy = outputwin.y;
		sub_dispwin.src_height = outputwin.h;
		sub_dispwin.src_wid = outputwin.w;
		Scaler_SubDispWindowSet(sub_dispwin);
	} else {
		main_dispwin.srcx = outputwin.x;
		main_dispwin.srcy = outputwin.y;
		main_dispwin.src_height = outputwin.h;
		main_dispwin.src_wid = outputwin.w;

		Scaler_DispWindowSet(main_dispwin);
	}

	if (display == SLR_MAIN_DISPLAY)
	{
		/*livezoom & magnifier DI Len Wid is the same*/
		if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			usAfterDILen =	(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN) << 1);
		} else {
			//usAfterDILen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN);
			usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);
		}

		rtd_pr_vsc_debug("main path usAfterDILen=%d\n", usAfterDILen);
	}
	else
	{
		usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);

		rtd_pr_vsc_debug("sub path usAfterDILen=%d\n", usAfterDILen);
	}

	if ((display == SLR_SUB_DISPLAY) && (changetomain == TRUE))
	{
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID);
	} else {
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_WID);
	}

	usAfterDIWid = mDomainCapWid;

	rtd_pr_vsc_debug("mDomainCapLen=%d, mDomainCapWid=%d\n", mDomainCapLen, mDomainCapWid);

	rtd_pr_vsc_debug("inputwin.y=%d,  SLR_INPUT_IPV_ACT_STA=%d, SLR_INPUT_IPV_ACT_STA_PRE=%d, usAfterDILen=%d\n", inputwin.y, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA), Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE), usAfterDILen);

#if 1
		if (inputwin.w > mDomainCapWid)
		{
			if (SLR_MAIN_DISPLAY == display)
			{
				inputwin.x = inputwin.x * mDomainCapWid / AVD_DI_5A_WIDTH ;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_DI_5A_WIDTH ;
			}
			else
			{
				inputwin.x = inputwin.x * mDomainCapWid / AVD_27M_VGIP_WIDTH ;;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_27M_VGIP_WIDTH ;

			}

		}
		else if (mDomainCapWid > AVD_NORMAL_WIDTH && mDomainCapWid < AVD_DI_5A_WIDTH)
		{
			inputwin.x = inputwin.x * mDomainCapWid / AVD_NORMAL_WIDTH;
			inputwin.w = inputwin.w * mDomainCapWid / AVD_NORMAL_WIDTH;
		}

		/*
		if (inputwin.h >= mDomainCapLen)
		{
			inputwin.h = mDomainCapLen;
			inputwin.y = 0;
		}
		*/
#endif

	ulMemActLen =  inputwin.h * mDomainCapLen / usAfterDILen;
	ulMemActSta = inputwin.y * mDomainCapLen / usAfterDILen;

	//rtd_pr_vsc_info("ulMemActLen = %d\n", ulMemActLen);

	if (ulMemActLen > mDomainCapLen)
	{
		ulMemActLen = mDomainCapLen;
		ulMemActSta = 0;
	}
	//rtd_pr_vsc_info("2 ulMemActLen = %d\n", ulMemActLen);


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, ulMemActLen);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, ulMemActSta);


#if 0
	if (display == SLR_MAIN_DISPLAY)
	{
		if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
			//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y - 2*(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE))) / usAfterDILen);
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, inputwin.y * inputwin.h / usAfterDILen);
		} else {
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y - (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE))) / usAfterDILen);
		}
	}
	else
	{
#if 0
		if (inputwin.w > mDomainCapWid)
		{
			if (SLR_MAIN_DISPLAY == display)
			{
				inputwin.x = 0;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_DI_5A_WIDTH ;
			}
			else
			{
				inputwin.x = 0;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_27M_VGIP_WIDTH ;

			}

		}

		if (inputwin.h >= mDomainCapLen)
		{
			inputwin.h = mDomainCapLen;
			inputwin.y = 0;
		}
#endif
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, inputwin.y * inputwin.h / usAfterDILen);
	}

#endif

	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_LEN=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN));
	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_VSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA));

	rtd_pr_vsc_debug("mDomainCapWid = %d,inputwin.w=%d,usAfterDIWid=%d\n",mDomainCapWid,inputwin.w,usAfterDIWid);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, mDomainCapWid * inputwin.w / usAfterDIWid);
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, mDomainCapWid * (inputwin.x - (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE))) / usAfterDIWid);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, inputwin.x);

	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_pr_vsc_debug("SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, drvif_memory_get_data_align(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID), 2));
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, drvif_memory_get_data_align(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA), 2));

	rtd_pr_vsc_debug("align 2 SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_pr_vsc_debug("align 2 SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));

	if ((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA)  + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID)) > mDomainCapWid) {
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - 4));
	}

	DbgSclrFlgTkr.main_inputregion_x_ori_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
	DbgSclrFlgTkr.main_inputregion_w_ori_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);

	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_x_ori_pre=%d\n", DbgSclrFlgTkr.main_inputregion_x_ori_pre);
	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_w_ori_pre=%d\n", DbgSclrFlgTkr.main_inputregion_w_ori_pre);
	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_x_pre=%d\n", DbgSclrFlgTkr.main_inputregion_x_pre);
	rtd_pr_vsc_debug("DbgSclrFlgTkr.main_inputregion_w_pre=%d\n", DbgSclrFlgTkr.main_inputregion_w_pre);

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < DbgSclrFlgTkr.main_inputregion_w_pre)
		w_offset = DbgSclrFlgTkr.main_inputregion_w_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
	else
		w_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - DbgSclrFlgTkr.main_inputregion_w_pre;

	//add AVD offset modification flow for ISF @Crixus 20151220
	if(w_offset <= 4){//in the ISF control, there is only 2 pixels shift
		if(DbgSclrFlgTkr.main_inputregion_w_pre == 0){
			DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
			DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
		}
		else{
			if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) > DbgSclrFlgTkr.main_inputregion_x_pre) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < DbgSclrFlgTkr.main_inputregion_w_pre)){
				x_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) - DbgSclrFlgTkr.main_inputregion_x_pre;
				w_offset = DbgSclrFlgTkr.main_inputregion_w_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
				if(w_offset > x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) + (w_offset - x_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
				else if(w_offset < x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - (x_offset-w_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
			}
			else if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) < DbgSclrFlgTkr.main_inputregion_x_pre) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) > DbgSclrFlgTkr.main_inputregion_w_pre)){
				x_offset = DbgSclrFlgTkr.main_inputregion_x_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
				w_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - DbgSclrFlgTkr.main_inputregion_w_pre;
				if(w_offset > x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - (w_offset - x_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
				else if(w_offset < x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) + (x_offset-w_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}

			}
			else{
				if((DbgSclrFlgTkr.main_check_pre_flag == 1) && (DbgSclrFlgTkr.main_inputregion_x_ori_pre == Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA)) && (DbgSclrFlgTkr.main_inputregion_w_ori_pre == Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID))){
					//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, DbgSclrFlgTkr.main_inputregion_x_pre);
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, DbgSclrFlgTkr.main_inputregion_w_pre);
					DbgSclrFlgTkr.main_check_pre_flag = 0;
				}
			}
				DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
				DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
		}
	}
	else{
		DbgSclrFlgTkr.main_check_pre_flag = 0;
		DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
		DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
	}

	rtd_pr_vsc_debug("final SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_pr_vsc_debug("final SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_WID, outputwin.w);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_LEN, outputwin.h);

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID)){
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, TRUE);
	}else{
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, FALSE);
	}

	rtd_pr_vsc_debug("SLR_SCALE_H_UP=%d\n", Scaler_DispGetScaleStatus(display, SLR_SCALE_H_UP));


	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN))
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, TRUE);
	else
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, FALSE);

	rtd_pr_vsc_debug("SLR_SCALE_V_UP=%d\n", Scaler_DispGetScaleStatus(display, SLR_SCALE_V_UP));

	if (display == SLR_SUB_DISPLAY) {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 1;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
	} else {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT1);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT1);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 1;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);

	}
	//imd_smooth_enable_sub_double_buffer(TRUE);

	/*IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);//Enable double buffer register*/
	/*WaitFor_DEN_START();*/
	/*WaitFor_DEN_STOP_Done_SUB();*/
	/*sub m domain display*/
	if (display == SLR_SUB_DISPLAY) {
		memory_set_sub_displaywindow_change(changetomain);
	} else {
		memory_set_main_displaywindow_change();
	}
	/*sub uzu*/
	avdmdsmooth_color_ultrazoom_config_scaling_up(display);

	if (display == SLR_SUB_DISPLAY) {
		PipmpSetSubDisplayWindow(
			outputwin.x, outputwin.x + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID) - 1,
			outputwin.y, outputwin.y + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN) - 1,
			0);

		PipmpSetSubActiveWindow(
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_WID)  - 1,
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_LEN) - 1);

	} else {
		ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
		ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;

		// Main Active H pos
		main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
		main_active_h_start_end_reg.mh_act_sta = outputwin.x & 0x0fff;
		main_active_h_start_end_reg.mh_act_end = (outputwin.x + outputwin.w) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);

		// Main Active V pos
		main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
		main_active_v_start_end_reg.mv_act_sta = outputwin.y & 0x0fff;
		main_active_v_start_end_reg.mv_act_end = (outputwin.y + outputwin.h) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);

	}

	if (display == SLR_SUB_DISPLAY) {
		unsigned int uzulinecntA =0;
		unsigned int uzulinecntB =0;

		unsigned int timeoutcount = 0x3ffff;
		ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
		ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//load M domain double buffer
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_apply = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);
#if 0
		IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT4);//load D domaindouble buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_set = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
#endif
		//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT0);//load uzu double buffer
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_apply = 1;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);

		dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);

		do {
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntA = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntB = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			if((uzulinecntA == uzulinecntB)&&((uzulinecntA < (dv_den_start_end_reg.dv_den_sta)) || (uzulinecntA > (dv_den_start_end_reg.dv_den_end)))) {
				//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
				ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
				ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
				IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
				break;
			}
			timeoutcount--;
		} while(timeoutcount);

		if(timeoutcount == 0){
			//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
			ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
			rtd_pr_vsc_debug("[SUB DEN]timeout error!!!\n");
		}
#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT4) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT16) || (IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
#endif
	} else {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//load M domain double buffer
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_apply = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT4);//load D domaindouble buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_set = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT0);//load uzu double buffer
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_apply = 1;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT0) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT0) || (IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT2);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
#endif
	}

	return TRUE;
}


void Scaler_SetDisplaySingleBufferMode(SCALER_DISP_CHANNEL channel, unsigned char mode)
{
	if (channel == SLR_MAIN_DISPLAY) {
		mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl_reg;
		ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
		if (mode) {
			ddr_mainctrl_reg.main_v_flip_3buf_en = 0;
			ddr_mainctrl_reg.main_double_en = 0;
			ddr_mainctrl_reg.main_single_buffer_select = 2;
		} else {
			ddr_mainctrl_reg.main_v_flip_3buf_en = 1;
			ddr_mainctrl_reg.main_double_en = 1;
		}
		IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, ddr_mainctrl_reg.regValue);
	} else if (channel == SLR_SUB_DISPLAY) {
		mdomain_disp_ddr_subctrl_RBUS ddr_subctrl_reg;
		ddr_subctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_SubCtrl_reg);
		if (mode) {
			ddr_subctrl_reg.sub_v_flip_3buf_en = 0;
			ddr_subctrl_reg.sub_double_en = 0;
			ddr_subctrl_reg.sub_single_buffer_select = 2;
		} else {
			ddr_subctrl_reg.sub_v_flip_3buf_en = 1;
			ddr_subctrl_reg.sub_double_en = 1;
		}
		IoReg_Write32(MDOMAIN_DISP_DDR_SubCtrl_reg, ddr_subctrl_reg.regValue);
	}
	drvif_memory_set_dbuffer_write();
}

static unsigned char Hdmi_GameMode = FALSE;

unsigned char Get_HDMI_SingleBuffer_GameMode(void)
{
	//only support 50hz/60hz hdmi timing go data frc
	//if(((Scaler_InputSrcGetMainChType() == _SRC_HDMI) || (Scaler_InputSrcGetMainChType() == _SRC_DVI)) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE))
	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)
	{
		/*magellan and sirius ic m cap and m disp not the same, but merlin the same*/
		if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 490) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 510)) || ((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 590) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 610)))
		{
			return Hdmi_GameMode;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}
}

extern unsigned int Get_fine_tune_dclk_forGameMode(void);
#define IV2DVLINE_GAPSPACE 2
void FineTune_iv2dvline_GameMode(void)
{

	unsigned int htotal = Get_DISP_HORIZONTAL_TOTAL();
	unsigned int vtotal = Get_DISP_VERTICAL_TOTAL();
	unsigned int Dclock = Get_fine_tune_dclk_forGameMode();
	unsigned int dispDFRate =  (10*Dclock/(htotal*vtotal));
	unsigned int iputFRate = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

	unsigned int dispLen = Scaler_DispGetInputInfo(SLR_INPUT_DISP_LEN);
	unsigned int inputSta = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA);
	unsigned int inputLen = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN);

	mdomain_disp_ddr_mainprevstart_RBUS ddr_mainprevstart_Reg;
	ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
	ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
	unsigned int preread = 0;
	unsigned int dv_sta = 0;
	unsigned int mv_sta = 0;
	int iv2dvlinesta = 0;
	unsigned int iv2dvlinefreq = 0;

	if(Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
		inputLen = inputLen*2;

	rtd_pr_vsc_debug("[Game_mode]input frame rate = %d;output frame rate = %d\n",(unsigned int)iputFRate, (unsigned int)dispDFRate);
	rtd_pr_vsc_debug("[Game_mode]inputSta = %d;inputLen = %d;dispLen = %d\n",(unsigned int)inputSta, (unsigned int)inputLen, (unsigned int)dispLen);

	if ((0 == iputFRate) || (0 == inputLen))
		return;

	ddr_mainprevstart_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainPreVStart_reg);
	preread = ddr_mainprevstart_Reg.main_pre_rd_v_start;
	rtd_pr_vsc_debug("[Game_mode]preread = %d\n",preread);


	dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);
	dv_sta = dv_den_start_end_reg.dv_den_sta;


	main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
	mv_sta = main_active_v_start_end_reg.mv_act_sta;

	rtd_pr_vsc_debug("[Game_mode]dv_sta = %d;mv_sta = %d\n",dv_sta,mv_sta);

	iv2dvlinesta = (inputSta*(dispLen*dispDFRate)/(inputLen*iputFRate)) + IV2DVLINE_GAPSPACE + preread - (dv_sta+mv_sta);

	if(iv2dvlinesta < 0)
		iv2dvlinesta = 0;
	rtd_pr_vsc_debug("[Game_mode]iv2dvline for reason sta diff = %d\n", iv2dvlinesta);

	if(iputFRate<dispDFRate)
		iv2dvlinefreq = (inputLen - inputLen*iputFRate/dispDFRate);

	rtd_pr_vsc_debug("[Game_mode]iv2dvline for reason freq diff = %d\n", iv2dvlinefreq);
	drvif_set_frc_ivs2dvsdelay_line((iv2dvlinesta+iv2dvlinefreq),(iv2dvlinesta+iv2dvlinefreq), 0);
}


static unsigned char vscFilmMode = FALSE;

unsigned char Get_vscFilmMode(void)
{
	return vscFilmMode;
}

void filmmode_videofw_config(unsigned int filmmode, unsigned int buf4addr)//filmmode:0 disable filmmode;filmmode:0 enable filmmode
{
	FILM_MODE_IOCTL_PARAM param = {filmmode, buf4addr};
	unsigned int *pulTemp = NULL;
	unsigned int ulCount = 0, i = 0;
	int ret;

	pulTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_VIDEO_FILMMODE_ENABLE);
	ulCount = sizeof(FILM_MODE_IOCTL_PARAM) / sizeof(unsigned int);
	// copy to RPC share memory
	memcpy(pulTemp, &param, sizeof(FILM_MODE_IOCTL_PARAM));

	for (i = 0; i < ulCount; i++)
		pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);

	if (0 != (ret = Scaler_SendRPC(SCALERIOC_VIDEO_FILMMODE_ENABLE, 0, 0)))
	{
		rtd_pr_vsc_debug("ret=%d, Deinit SCALERIOC_VIDEO_FILMMODE_ENABLE fail !!!\n", ret);
	}
}

extern unsigned int FilmModeCachaddr;
extern unsigned int FilmModePhyadddr;

unsigned char rtk_vsc_setFilmMode(bool value)
{
//remove by ben, due to mag2 remove fs_5_4 hw
#ifdef CONFIG_5_4_FS
#if 0
	vscFilmMode = value;
	if(value == TRUE)
	{
		HAL_VBE_DISP_SetFrameRate(TRUE,48);
	}
	else
	{
		HAL_VBE_DISP_SetFrameRate(FALSE,60);
		dvr_free((void *)FilmModeCachaddr);
		FilmModeCachaddr = NULL;
		FilmModePhyadddr = NULL;
		filmmode_videofw_config(FALSE,NULL);
	}
//#else
	if(value==TRUE)
	{
		ppoverlay_dh_total_last_line_length_RBUS ppoverlay_dh_total_last_line_length_Reg;
		ppoverlay_dh_total_last_line_length_Reg.regValue=IoReg_Read32(PPOVERLAY_DH_TOTAL_LAST_LINE_LENGTH_VADDR);

		ppoverlay_dv_total_RBUS ppoverlay_dv_total_Reg;
		ppoverlay_dv_total_Reg.regValue = IoReg_Read32(PPOVERLAY_DV_TOTAL_VADDR);

		ppoverlay_fs54_dh_RBUS ppoverlay_fs54_dh_Reg;
		ppoverlay_fs54_dh_Reg.fs54_dh_total = ppoverlay_dh_total_last_line_length_Reg.dh_total;
		ppoverlay_fs54_dh_Reg.fs54_dh_last_line = ppoverlay_dh_total_last_line_length_Reg.dh_total_last_line;
		IoReg_Write32(PPOVERLAY_FS54_DH_VADDR, ppoverlay_fs54_dh_Reg.regValue);

		ppoverlay_fs54_dv_RBUS ppoverlay_fs54_dv_Reg;
		ppoverlay_fs54_dv_Reg.fs54_dv_total = ppoverlay_dv_total_Reg.dv_total*5/4;
		IoReg_Write32(PPOVERLAY_FS54_DV_VADDR,ppoverlay_fs54_dv_Reg.regValue);

		fs54_ctrl_RBUS ppoverlay_fs54_ctrl_Reg;
		ppoverlay_fs54_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_FS54_CTRL_VADDR);
		ppoverlay_fs54_ctrl_Reg.fs54_dclk_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_dclk_slow_modify_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_pseudo_fsync_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_timing_en = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_vs_align = 3;
		ppoverlay_fs54_ctrl_Reg.fs54_force = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_main_sub_sel = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_frc_fastslow = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_db_load = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_en = 1;
		if((IoReg_Read32(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR)&_BIT2)>>2)
		{
			IoReg_ClearBits(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR, _BIT2);
			IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
			IoReg_SetBits(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR, _BIT2);
		}
		else
		{
			IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
		}
	}
	else
	{
		fs54_ctrl_RBUS ppoverlay_fs54_ctrl_Reg;
		ppoverlay_fs54_ctrl_Reg.regValue = 0;
		IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
	}
#else
	if(value == TRUE)
		drvif_framesync_5_4();
	else
		drvif_framesync_5_4_release();
#endif
#endif
	return TRUE;

}

void scaler_sub_sync_main_timing_info(void)
{
	unsigned short IPH_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE);
	unsigned short IPV_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE);
	unsigned short IPH_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE);
	unsigned short IPV_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE);

	Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);

	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE, IPH_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE, IPV_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE, IPH_ACT_WID);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE, IPV_ACT_LEN);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA, IPH_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA, IPV_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID, IPH_ACT_WID);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN, IPV_ACT_LEN);

}

void scaler_set_sub_vgip(unsigned char src, unsigned char mode)
{
	sub_vgip_vgip_chn2_ctrl_RBUS vgip_chn2_ctrl_reg;
	sub_vgip_vgip_chn2_act_hsta_width_RBUS vgip_chn2_act_hsta_width_reg;
	sub_vgip_vgip_chn2_act_vsta_length_RBUS vgip_chn2_act_vsta_length_reg;
	sub_vgip_vgip_chn2_delay_RBUS sub_vgip_vgip_chn2_delay_reg;

	// Disable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_clk_en = 0;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	// determine the input source
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_sel = src;
	vgip_chn2_ctrl_reg.ch2_digital_mode = mode;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	//sub vgip size sync from main
	vgip_chn2_act_hsta_width_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg);
	vgip_chn2_act_hsta_width_reg.ch2_ih_act_sta = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE);
	if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) < 720)
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_wid = 720;
	else
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_wid = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg, vgip_chn2_act_hsta_width_reg.regValue);

	vgip_chn2_act_vsta_length_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg);
	vgip_chn2_act_vsta_length_reg.ch2_iv_act_sta = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE);

	if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) < 288 ) && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))//SE do scaling up to 720x288 interlace
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = 288;
	else if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) < 576 ) && !Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))//SE do scaling up to 720x288 profrassive
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = 576;
	else
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg, vgip_chn2_act_vsta_length_reg.regValue);

	sub_vgip_vgip_chn2_delay_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_DELAY_reg);
	sub_vgip_vgip_chn2_delay_reg.ch2_ihs_dly = 0;//reset 0
	sub_vgip_vgip_chn2_delay_reg.ch2_ivs_dly = 0;//reset 0
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_DELAY_reg, sub_vgip_vgip_chn2_delay_reg.regValue);

	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_field_det_en = _DISABLE;		//bit16
	vgip_chn2_ctrl_reg.ch2_field_sync_edge = _ENABLE;	//bit17
	vgip_chn2_ctrl_reg.ch2_field_inv = _ENABLE;		//bit18
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	// enable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_clk_en = 1;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

}

void scaler_run_sub_capture_tve(SIZE outsize)
{
	unsigned char src;
	unsigned char mode;
	SIZE insize;
	unsigned char nMode = 0;
	src = VGIP_SRC_VODMA1;

	scaler_set_sub_vgip(src, VGIP_MODE_ANALOG);

	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, false);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_FSYNC_VUZD, 0x2);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_COMP, false);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, true);

	mode = Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);
	if ((mode !=  _MODE_480I) && (mode !=  _MODE_480P) && (mode !=  _MODE_576I) && (mode !=  _MODE_576P))
		nMode = 1;
	drvif_color_set422to444(SLR_SUB_DISPLAY, false);
	fwif_color_colorspacergb2yuvtransfer(SLR_SUB_DISPLAY, _SRC_VO, nMode, 1, 0);

	insize.nWidth = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
	insize.nLength = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);

	if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))
	{

		outsize.nLength /=2;
		rtd_pr_vsc_debug("[scart out]enter DI, nLength = %d\n",outsize.nLength);
	}
	Scaler_DispSetScaleStatus(SLR_SUB_DISPLAY, SLR_SCALE_H_DOWN, (insize.nWidth > outsize.nWidth)?true:false);
	Scaler_DispSetScaleStatus(SLR_SUB_DISPLAY, SLR_SCALE_V_DOWN, (insize.nLength > outsize.nLength)?true:false);
#ifndef UT_flag
	drvif_color_ultrazoom_set_scale_down(SLR_SUB_DISPLAY, &insize, &outsize, 0);
#endif // #ifndef UT_flag
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_WID,outsize.nWidth);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_LEN,outsize.nLength);
	mdomain_handler_onlycap();
}

#if 0	//remove tve
void scaler_vodmatosub_prog(TVE_VIDEO_MODE_SEL tve_mode, UINT8 tve_vflip_en)
{

	SIZE tve_outsize;

	if (tve_mode == TVE_NTSC) {
		tve_outsize.nWidth = 720;
		tve_outsize.nLength = 480;
	}
	else if (tve_mode == TVE_PAL_I) {
		tve_outsize.nWidth = 720;
		tve_outsize.nLength = 576;
	} else {
			rtd_pr_vsc_debug("wrong params	tve_mode=%d\n",(int)tve_mode);
			return ;
	   }

	scaler_sub_sync_main_timing_info();

	scaler_run_sub_capture_tve(tve_outsize);
	//Not to do initial in based driver - LGE Project @ Crixus 20141110
	//drvif_module_tve_init();
	drvif_module_tve_set_mode(tve_mode);
	drvif_module_tve_video_memory_setting(tve_vflip_en);
	drvif_module_tve_change_memory_setting(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE),tve_vflip_en);

	scaler_scart_out_isr_set_enable(TRUE);
	//rtd_pr_vsc_debug("[scart out]fScartOut_isr_Enable = %x\n",fScartOut_isr_Enable);

	//VODMA clock fine tune
	#if 0
	if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 720) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) <= 576)){
		fScartOut_VO_clock_check = TRUE;
		//SE scaling up
		if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) < 720) || (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) < 576))
			fScartOut_VO_scaling_enable = TRUE;
		else
			fScartOut_VO_scaling_enable = FALSE;
	}else{
		fScartOut_VO_clock_check = FALSE;
	}
	#endif
	scaler_set_tve_vflip_enable(tve_vflip_en);

	 //bVodma2I3Dma = true;
#if 0//M-disp debug using
	//M-domain Disp verify
	IoReg_ClearBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg,_BIT1); //clear double buffer
	IoReg_ClearBits(MDOMAIN_DISP_DDR_MainCtrl_reg,MDOMAIN_DISP_DDR_MainCtrl_main_double_en_mask); //use single buffer. [9:8] = 0 use buffer 0,
									   // [9:8] = 1 use buffer 1
	i3ddmaCapAddr = IoReg_Read32(I3DDMA_CAP_L1_START_VADDR); //capture Buf L1
	//UINT32 i3ddmaCapAddr = IoReg_Read32(I3DDMA_CAP_L2_START_VADDR); //capture Buf L2
	rtd_pr_vsc_debug("##### i3ddmaCapAddr : %x ##### \n", i3ddmaCapAddr);  //capture Buf L
	IoReg_Write32(MDOMAIN_DISP_DDR_MainAddr_reg, i3ddmaCapAddr); //M-Disp Buffer0 use capture Buf
#endif
}
#endif

static unsigned char VscInitdone_Flag = FALSE;
static unsigned char VscOpendone_Flag = FALSE;
#ifdef CONFIG_DUAL_CHANNEL
static unsigned char Sub_VscOpendone_Flag = FALSE;
#endif
static struct semaphore vsc_initial_ctrl_semaphore;//for call  rtk_hal_vsc_initialize use


unsigned char rtk_hal_vsc_initialize(void)
{
	if(VscInitdone_Flag == FALSE)
 	{
 		down(&vsc_initial_ctrl_semaphore);
		if(VscInitdone_Flag == FALSE)
 		{
			rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
			VscInitdone_Flag = TRUE;
#ifndef UT_flag
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
			Scaler_Orbit_Timer_Init();
#endif
#endif // #ifndef UT_flag
			panel_parameter_send_info(); //send panel info
			reset_support_vo_force_v_top();
#ifdef	CONFIG_SUPPORT_SDR_MAX_RGB
			set_support_vo_force_v_top(true, support_sdr_max_rgb);
#else
			set_support_vo_force_v_top(false, support_sdr_max_rgb);
#endif

#ifdef CONFIG_I2RND_ENABLE
				//Eric@20170904 I2rnd & pst init
				drvif_scaler_i2rnd_initial();
				drvif_scaler_pst_initial(_MAIN_MD);
				drvif_scaler_pst_initial(_SUB_MD);
				vsc_i2rnd_initial_done = _ENABLE;
#ifdef CONFIG_PST_ENABLE
				vsc_pst_initial_done = _ENABLE;
#endif
				//set_i2rnd_s0_pst_check_stage(MAIN_PST_TOP_CTRL_STAGE_DISABLE);
				//set_i2rnd_s1_pst_check_stage(SUB_PST_TOP_CTRL_STAGE_DISABLE);
#endif

#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			drvif_scaler_pst_initial(_MAIN_VO_IMD);
			drvif_scaler_pst_initial(_SUB_VO_IMD);
#endif
#endif

#ifdef CONFIG_SCALER_BRING_UP
			modestate_EnableDispInt(TRUE);
#endif
			if(FALSE==Scaler_StructInit(PcbSource_GetTable(), PcbSource_GetTableSize(), PcbSource_GetTableSize()-3 /*OSD*/, 4 /*ypp*/))
			{
				rtd_pr_vsc_err("function=%s Scaler_StructInit fail\n", __FUNCTION__);
			}
		}
		up(&vsc_initial_ctrl_semaphore);
	}
	return TRUE;
}

unsigned char rtk_hal_vsc_uninitialize(void)
{
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
#ifdef CONFIG_DUAL_CHANNEL
	if ((VscOpendone_Flag == TRUE) || (Sub_VscOpendone_Flag == TRUE)) {
#else
	if (VscOpendone_Flag == TRUE) {
#endif
		rtd_pr_vsc_debug("VSC main and sub not all closed,so can not uninitialize!\n");
		return TRUE;
	} else {
		return TRUE;


#ifdef CONFIG_I2RND_ENABLE
		//I2rnd & pst uninitial
		drvif_scaler_i2rnd_uninitial();
		drvif_scaler_pst_uninitial(_MAIN_MD);
		drvif_scaler_pst_uninitial(_SUB_MD);
		vsc_i2rnd_initial_done = _DISABLE;
#ifdef CONFIG_PST_ENABLE
		vsc_pst_initial_done = _DISABLE;
#endif
#endif

/*

		if (VscInitdone_Flag == TRUE) {
			Scaler_StructUninit();
			VscInitdone_Flag = FALSE;
			return TRUE;
		} else {
			rtd_pr_vsc_debug("VSC not init\n");
			return TRUE;
		}
*/
	}
}

unsigned char rtk_hal_vsc_open(VIDEO_WID_T wid)
{
#ifdef CONFIG_DUAL_CHANNEL
	if ((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX)) {
		rtd_pr_vsc_info("wid id is not right\n");
		return FALSE;
	}
#else
	if (wid !=VIDEO_WID_0) {
		rtd_pr_vsc_info("wid id is not right\n");
		return FALSE;
	}
#endif

	if (VscInitdone_Flag == FALSE) {
		rtd_pr_vsc_info("VSC is not init, can not be opened\n");
	} else {
		if (wid ==VIDEO_WID_0) {
			if(VscOpendone_Flag == FALSE)	{
				rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				VscOpendone_Flag = TRUE;
			} else {
				rtd_pr_vsc_info("Main vsc open have done, not need open again\n");
			}
		}
#ifdef CONFIG_DUAL_CHANNEL
		if (wid ==VIDEO_WID_1) {
			if(Sub_VscOpendone_Flag == FALSE)	{
				rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				Sub_VscOpendone_Flag = TRUE;
			} else {
				rtd_pr_vsc_info("Sub vsc open have done,not need open again\n");
			}
		}
#endif
	}
	return TRUE;
}

unsigned char rtk_hal_vsc_close(VIDEO_WID_T wid)
{
#ifdef CONFIG_DUAL_CHANNEL
	if ((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX)) {
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#else
	if (wid != VIDEO_WID_0) {
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		if (DbgSclrFlgTkr.OuputDisplayMode || DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode ||
		    DbgSclrFlgTkr.OutputAveMode) {
			rtd_pr_vsc_info("Main vsc have source not disconnect, so can not close!\n");
		} else {
			if(VscOpendone_Flag == TRUE) {
				rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				//drvif_mode_resetmode(SLR_MAIN_DISPLAY);
				down(&Main_ResetMode_Semaphore);
				rtd_pr_vsc_info("\r\n####func:%s request reset mode####\r\n", __FUNCTION__);
				DbgSclrFlgTkr.Main_Reset_Mode_flag = TRUE;
				up(&Main_ResetMode_Semaphore);
				VscOpendone_Flag = FALSE;
		 	} else {
		 		rtd_pr_vsc_info("Main vsc not opened\n");
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		if (DbgSclrFlgTkr.Sub_OuputDisplayMode || DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode ||
		    DbgSclrFlgTkr.Sub_OutputAveMode) {
			rtd_pr_vsc_info("Sub vsc have source not disconnect, so can not close!\n");
		} else {
			if(Sub_VscOpendone_Flag == TRUE) {
				rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				//drvif_mode_resetmode(SLR_SUB_DISPLAY);
				down(&Sub_ResetMode_Semaphore);
				DbgSclrFlgTkr.Sub_Reset_Mode_flag = TRUE;
				up(&Sub_ResetMode_Semaphore);
				Sub_VscOpendone_Flag = FALSE;
		 	} else {
		 		rtd_pr_vsc_info("Sub vsc not opened\n");
			}
		}
	}
#endif
	return TRUE;
}

long Scaler_Send_VoDisconnect_VOMDA_impl(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port)
{
	long ret = 0;
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	unsigned char type_local;
	unsigned char port_local;
	rtd_pr_vsc_debug("[]###############%s\n", __FUNCTION__);

	if (type == KADP_VO_VSC_SRC_VDEC) {
		rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 0;
	} else if(type == KADP_VO_VSC_SRC_JPEG){
		rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 1;
	} else {
		rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 2;
	}
	if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Port(SLR_MAIN_DISPLAY) != Get_DisplayMode_Port(SLR_SUB_DISPLAY)) {
		type_local = 0x10 | type_local;
	}

	port_local = wid_port;
	rtd_pr_vsc_debug("\n\n[pool test][sendVo]wid:%d,port:%d,plane:%d\n",(wid_port&0xf0)>>4,wid_port&0xf,Scaler_DispGetInputInfoByDisp(((wid_port&0xf0)>>4), SLR_INPUT_VODMA_PLANE));
	rtd_pr_vsc_debug("[vo]%s type %d, port %d, m[%d/%d] s[%d/%d]\n", __FUNCTION__, type_local, port_local, Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Port(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY), Get_DisplayMode_Port(SLR_SUB_DISPLAY));
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	//set_vo_nosignal_flag((port_local & 0xf), 1);
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCDISCONNECT_TO_VODMA, type_local, port_local, &ret))
		rtd_pr_vsc_err("RPC fail!!\n");
#endif
    // reset decomp info for main VDEC
    if((type == KADP_VO_VSC_SRC_VDEC) && ((wid_port & 0xf) < 2) && (((wid_port&0xf0)>>4) == 0))
        set_vo_veComp_flag(wid_port & 0xf,0);
#endif

	return ret;
}
long (*Scaler_Send_VoDisconnect_VOMDA)(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port) = Scaler_Send_VoDisconnect_VOMDA_impl;

long Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port)
{
	long ret = 0;
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	unsigned char type_local;
	unsigned char port_local;
	rtd_pr_vsc_debug("[]###############%s\n", __FUNCTION__);

	if (type == KADP_VO_VSC_SRC_VDEC) {
		rtd_pr_vsc_debug("\r\n###func:%s line:%d VO_VSC_SRC_VDEC####\r\n", __FUNCTION__, __LINE__);
		type_local = 0;
	} else if(type == KADP_VO_VSC_SRC_JPEG){
		rtd_pr_vsc_debug("\r\n###func:%s line:%d VO_VSC_SRC_JPEG####\r\n", __FUNCTION__, __LINE__);
		type_local = 1;
	} else {
		rtd_pr_vsc_debug("\r\n###func:%s line:%d VO_VSC_SRC_HDMI####\r\n", __FUNCTION__, __LINE__);
		type_local = 2;
	}
	if ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Port(SLR_MAIN_DISPLAY) != Get_DisplayMode_Port(SLR_SUB_DISPLAY))){
		type_local = 0x10 | type_local;
	}

	port_local = wid_port;
	rtd_pr_vsc_debug("\n\n[pool test][sendVo]wid:%d,port:%d,plane:%d\n",(wid_port&0xf0)>>4,wid_port&0xf,Scaler_DispGetInputInfoByDisp(((wid_port&0xf0)>>4), SLR_INPUT_VODMA_PLANE));
	rtd_pr_vsc_debug("[vo]%s type %d, port %d, m[%d/%d] s[%d/%d]\n", __FUNCTION__, type_local, port_local, Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Port(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY), Get_DisplayMode_Port(SLR_SUB_DISPLAY));

	if((type == KADP_VO_VSC_SRC_VDEC) || (type == KADP_VO_VSC_SRC_JPEG)){
		set_vo_nosignal_flag((port_local & 0xf), 1);
		set_vo_EOS_flag((port_local & 0xf), 0);
		set_film_detect_done_flag((port_local & 0xf), 0);
       }
#if 0
	VIDEO_RPC_VOUT_VSCCONNECT_STRUCT *connect_parms;
	unsigned int vir_addr, vir_addr_noncache;
	unsigned int phy_addr;

	vir_addr = (unsigned int)dvr_malloc_uncached_specific(sizeof(VIDEO_RPC_VOUT_VSCCONNECT_STRUCT), GFP_DCU1_LIMIT, (void **)&vir_addr_noncache);
	phy_addr = (unsigned int)dvr_to_phys((void*)vir_addr);

	connect_parms = (VIDEO_RPC_VOUT_VSCCONNECT_STRUCT *)vir_addr_noncache;
	connect_parms->wid = port_local;
	connect_parms->vsc_source = type_local;
	connect_parms->vdo_port = connect_parms->wid;
	connect_parms->hdr_mode = port_local; //TODO

	connect_parms->wid = htonl(connect_parms->wid);
	connect_parms->vsc_source = htonl(connect_parms->vsc_source);
	connect_parms->vdo_port = htonl(connect_parms->vdo_port);
	connect_parms->hdr_mode = htonl(connect_parms->hdr_mode);

	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCINPUTTYPE_TO_VODMA,phy_addr, 0, &ret))
		rtd_pr_vsc_err("RPC fail!!\n");

        dvr_free((void *)vir_addr);
#else
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCINPUTTYPE_TO_VODMA, type_local, port_local, &ret))
		rtd_pr_vsc_err("RPC fail!!\n");
#endif
#endif


#endif


	return ret;
}

unsigned char vsc_force_disconnect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{//This API is patch for CI test not work. force disconnect current outputMode.
	unsigned int *p_sourceID = NULL;
	StructSrcRect SrcRect = {0, 0, 0, 0};
	unsigned char plane=0;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	} else if (wid == VIDEO_WID_0) {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	}
#else
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#endif


	rtd_pr_vsc_debug(KERN_WARNING "\r\n####function:%s wid:%d outputMode:%d####\r\n", __FUNCTION__, wid, outputMode);
	if (wid == VIDEO_WID_0) {
		//set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){//AP not mute on yet
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);//reset  vsc connect ready
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
				DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
				DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
				DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
				DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				is_DTV_flag_set(_DISABLE);
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetMainOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
				DbgSclrFlgTkr.main_winfreeze=0;
				DbgSclrFlgTkr.mainVscFreezeFlag=0;
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				drivf_scaler_reset_freerun();
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
#ifdef CONFIG_SUPPORT_SRC_ADC
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
#endif
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {

				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.OuputDisplayMode = FALSE; // Preset for vo
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					DisplayModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};// Preset for vo
					set_vo_change_flag(SLR_MAIN_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OuputDisplayMode = FALSE;
				DisplayModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;
				//close display panel

				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
#ifdef CONFIG_SUPPORT_SRC_ADC
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				}
#endif
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					//smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OutputVencMode = FALSE;
				VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE://Current same with VSC_OUTPUT_DISPLAY_MODE
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){//AP not mute on yet
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);//reset  vsc connect ready
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
				DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
				DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
				DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
				DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				is_DTV_flag_set(_DISABLE);
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetMainOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
				DbgSclrFlgTkr.main_winfreeze=0;
				DbgSclrFlgTkr.mainVscFreezeFlag=0;
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
#ifdef CONFIG_SUPPORT_SRC_ADC
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.OutputMemoryMode = FALSE;
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
					set_vo_change_flag(SLR_MAIN_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OutputMemoryMode = FALSE;
				MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				HAL_VBE_AVE_Disconnect();
				DbgSclrFlgTkr.OutputAveMode = FALSE;
				AveModeInputInfo =  (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				break;
			}
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid == VIDEO_WID_1) {
		//set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				down(get_forcebg_semaphore());
				scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//Auto mue before disconnect
				drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
				up(get_forcebg_semaphore());
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetSubOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

				drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type ==KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
#ifdef CONFIG_SUPPORT_SRC_ADC
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
#endif
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE; // Preset for vo
					plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};// Preset for vo
					set_vo_change_flag(SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
					//set_vo_change_flag((wid == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_SUB_DISPLAY, TRUE);
					//set_force_change_vo_flag((wid == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}

				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
				DbgSclrFlgTkr.sub_wind0000 = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				//add semaphore for sub disp @Crixus 20150901

				Scaler_SubDispWindowSet(SrcRect);
				Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				//close_livezoom_doublebuffer();
				//close display panel

				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
					rtd_pr_vsc_emerg("[vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
					rtd_pr_vsc_emerg("rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

					if(run_i2rnd_flag == 1){
						run_i2rnd_flag = 0;
						rtk_hal_vsc_i2rnd_enable(_DISABLE);
						//frank@I2run disable main VENC flag
						VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
						DbgSclrFlgTkr.OutputVencMode = FALSE;
						vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
						rtd_pr_vsc_emerg("[%s][frank]I2RND close\n", __FUNCTION__);
					}
#endif
#endif
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
#ifdef CONFIG_SUPPORT_SRC_ADC
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
					//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				}
				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();
				DbgSclrFlgTkr.Sub_OutputVencMode = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				Sub_VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
				up(&SetSubOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero


				drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL2,Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
#ifdef CONFIG_SUPPORT_SRC_ADC
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
#endif
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE; // Preset for vo
					plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Sub_MemoryModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};// Preset for vo
					set_vo_change_flag(SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
					//set_vo_change_flag((wid == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(SLR_SUB_DISPLAY, TRUE);
					//set_force_change_vo_flag((wid == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}

				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.sub_wind0000 = FALSE;
				DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				Scaler_SubDispWindowSet(SrcRect);
				Sub_MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;
				//close_livezoom_doublebuffer();
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{

				HAL_VBE_AVE_Disconnect();
				DbgSclrFlgTkr.Sub_OutputAveMode = FALSE;
				Sub_AveModeInputInfo =	(KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};

				break;
			}
			default:
				break;
		}
	}
#endif
	return TRUE;
}


unsigned char rtk_hal_vsc_Connect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#endif
	rtd_pr_vsc_info("vsc_connect wid:%d SrcInfo:%d;%d;%d,Mode:%d\n", wid, inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

	if (wid ==VIDEO_WID_0) {
		if (VscOpendone_Flag == FALSE) {
			rtd_pr_vsc_info("Main vsc not open,so can not connect!\n");
			return TRUE;
		}
		increase_source_connect_verify_num(SLR_MAIN_DISPLAY);//increase the main source num
		if(KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type)
		{
			if(SRC_CONNECT_DONE == get_AVD_Global_Status()){
				Scaler_AVD_SetHalVscConnect(SLR_MAIN_DISPLAY,TRUE);
				drvif_module_vpq_DmaAccessCtrl(ON);
				drvif_adc_power_control(ADC_POWER_ADC_DISABLE_VDC_ALIVE_CONTROL,__func__,__LINE__);
#ifdef CONFIG_SUPPORT_SRC_ADC
				if(get_AVD_Input_Source() == _SRC_CVBS){
					drvif_adc_ctl_rgb12_check(get_AVD_Input_Source());
				}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
				rtd_pr_vsc_info("########[%s(%d)] ##drvif_module_vpq_DmaAccessCtrl(ON)######", __FUNCTION__, __LINE__);
			}
		}
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				scaler_Setdualdecoder_notchange(0);
				if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
				{
					 if(rtk_hal_vsc_Getdualdecoder_run() && (inputSrcInfo.type == (KADP_VSC_INPUT_TYPE_T)VSC_INPUTSRC_VDEC)) {
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						rtd_pr_vsc_info("dual decoder case,connect just change port return\n");
						DisplayModeInputInfo = inputSrcInfo;
						set_current_scaler_source_num(SLR_MAIN_DISPLAY);
						return TRUE;
					}
					rtd_pr_vsc_info("DbgSclrFlgTkr.OuputDisplayMode is on, please disconnect output display mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					if((VencModeInputInfo.type == inputSrcInfo.type) && (VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_pr_vsc_info("because venc mode is on, and display mode input is not the same with venc mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					if((MemoryModeInputInfo.type == inputSrcInfo.type) && (MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_pr_vsc_info("because memory mode is on, and display mode input is not the same with memory mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					if((AveModeInputInfo.type == inputSrcInfo.type) && (AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_pr_vsc_info("because ave mode is on, and display mode input is not the same with ave mode\n");
						return TRUE;
					}

				}
				else
				{
					DisplayModeInputInfo = inputSrcInfo;
#ifdef CONFIG_I2RND_ENABLE
					down(&I2RND_Semaphore);
					//if timing disable or sub disconnect, need to set force cmd flag let update register @Crixus 20171124
					if(!(Scaler_I2rnd_get_timing_enable() && DbgSclrFlgTkr.Sub_OuputDisplayMode)){
						Scaler_I2rnd_set_force_cmd(_ENABLE);
						Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
					}
					if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC){
						set_i2rnd_vo1_refine_status_vir_addr(I2RND_S0_CONNECTED);
						set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_OFF);
						rtd_pr_vsc_emerg("[I2RND]main connect, I2RND_S0_CONNECTED!!\n");
					}
					up(&I2RND_Semaphore);
#endif
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
#ifdef CONFIG_I2RND_ENABLE
					//fixed main use port 0;
					DisplayModeInputInfo.resourceIndex = 0;
#else
					if((inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG))
						DisplayModeInputInfo.resourceIndex = 0;//add by will for live zoom
#endif
#endif
					DbgSclrFlgTkr.OuputDisplayMode = TRUE;
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
						rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					}
					else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
						rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
					}

					if(KADP_VSC_INPUTSRC_HDMI != inputSrcInfo.type)
					{
						if(SRC_CONNECT_DONE == get_HDMI_Global_Status())
							drvif_Hdmi_WatchDogApply(_DISABLE, HDMI_WD_VSC_COND);

						//drvif_Hdmi_OutputDisable(1); //willychou remove it for fixing KTASKWBS-9866 on 2018/11/28
					}
					else
					{
						drvif_Hdmi_OutputDisable(0);
#ifdef CONFIG_SUPPORT_FREESYNC
						//vbe_disp_set_freesync_mode_flag(1);
						//rtd_pr_vsc_info("\r\n########[FreeSync] set_freesync_mode_flag enable!!!######\r\n");
#endif
					}

				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, TRUE);
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.OutputVencMode==TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputVencMode = TRUE;
							VencModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and venc mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						VencModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.OutputVencMode = TRUE;
					}
				}

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.OutputMemoryMode==TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputMemoryMode = TRUE;
							MemoryModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and memory mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						MemoryModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.OutputMemoryMode = TRUE;
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						} else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
						}
					}
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, TRUE);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output ave mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputAveMode = TRUE;
							AveModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and AVE mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						DbgSclrFlgTkr.OutputAveMode = TRUE;
						AveModeInputInfo = inputSrcInfo;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		if (Sub_VscOpendone_Flag == FALSE) {
			rtd_pr_vsc_debug("Sub vsc not open,so can not connect!\n");
			return TRUE;
		}
		increase_source_connect_verify_num(SLR_SUB_DISPLAY);//increase the sub source num

		if(KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type)
		{
			if(SRC_CONNECT_DONE == get_AVD_Global_Status()){
				Scaler_AVD_SetHalVscConnect(SLR_SUB_DISPLAY,TRUE);
				drvif_module_vpq_DmaAccessCtrl(ON);
				rtd_pr_vsc_info("\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(ON)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OuputDisplayMode is on, please disconnect output display mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					if((Sub_VencModeInputInfo.type == inputSrcInfo.type) && (Sub_VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Sub_DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because venc mode is on, and display mode input is not the same with venc mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					if((Sub_MemoryModeInputInfo.type == inputSrcInfo.type) && (Sub_MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Sub_DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because memory mode is on, and display mode input is not the same with memory mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					if((Sub_AveModeInputInfo.type == inputSrcInfo.type) && (Sub_AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Sub_DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_pr_vsc_debug("because ave mode is on, and display mode input is not the same with ave mode\n");
						return TRUE;
					}

				}
				else
				{
					Sub_DisplayModeInputInfo = inputSrcInfo;

#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
#ifdef CONFIG_I2RND_ENABLE
					//fixed sub use port 1;
					Sub_DisplayModeInputInfo.resourceIndex = 1;
#else
					if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC /*|| (inputSrcInfo.type == VSC_INPUTSRC_JPEG)*/)
					{
						Sub_DisplayModeInputInfo.resourceIndex = 1;
					}
#endif
#endif
					DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;



#ifdef CONFIG_I2RND_ENABLE
						down(&I2RND_Semaphore);
						if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC){
							set_i2rnd_vo1_refine_status_vir_addr(I2RND_S1_REFINE_VO1);
							rtd_pr_vsc_emerg("[I2RND]sub connect, I2RND_S1_REFINE_VO1!!\n");
						}
						up(&I2RND_Semaphore);
#endif
#ifdef CONFIG_PST_ENABLE
						if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
							drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
						if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
							drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
						sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);

							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						}
						else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
						}


				}

				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputVencMode = TRUE;
							Sub_VencModeInputInfo = inputSrcInfo;
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
							rtd_pr_vsc_emerg("[vsc_connect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
							rtd_pr_vsc_emerg("rtk_hal_vsc_Connect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

							if((run_i2rnd_flag == 0) && (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)){
								run_i2rnd_flag = 1;
								rtk_hal_vsc_i2rnd_enable(_ENABLE);
								Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
								VSC_OUTPUT_VENC_MODE_FLAG = TRUE;
								//apvr trigger scaler flow in tsk @Crixus 20160824
								if((vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_DISABLE) || (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE))
									vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_TRIGGER_RUN_MAIN;
								rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
							}
#endif
#endif
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and venc mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						Sub_VencModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.Sub_OutputVencMode = TRUE;
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
						rtd_pr_vsc_emerg("[vsc_connect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
						rtd_pr_vsc_emerg("rtk_hal_vsc_Connect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

						if((run_i2rnd_flag == 0) && (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)){
							run_i2rnd_flag = 1;
							rtk_hal_vsc_i2rnd_enable(_ENABLE);
							Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
							VSC_OUTPUT_VENC_MODE_FLAG = TRUE;

							//apvr trigger scaler flow in tsk @Crixus 20160824
							if((vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_DISABLE) || (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE))
								vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_TRIGGER_RUN_MAIN;
							rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
						}
#endif
#endif
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputMemoryMode = TRUE;
							Sub_MemoryModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and memory mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{

						Sub_MemoryModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.Sub_OutputMemoryMode = TRUE;
						if ((/*(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) ||*/(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC))
							&& (Sub_DisplayModeInputInfo.type == DisplayModeInputInfo.type)
							&& (Sub_DisplayModeInputInfo.resourceIndex == DisplayModeInputInfo.resourceIndex)
							&& (DbgSclrFlgTkr.Sub_OuputDisplayMode == DbgSclrFlgTkr.OuputDisplayMode))
						{/*DTV and HDMI*/

							} else {
#ifdef CONFIG_PST_ENABLE
								if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
									drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
								if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
									drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
								sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
									rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);

									Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								}
								else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
									rtd_pr_vsc_debug("\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
									Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
								}
							}
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputAveMode is on, please disconnect output ave mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputAveMode = TRUE;
							Sub_AveModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_pr_vsc_debug("because display mode is on, and AVE mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						DbgSclrFlgTkr.Sub_OutputAveMode = TRUE;
						Sub_AveModeInputInfo = inputSrcInfo;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#endif
	return TRUE;
}

void rtk_i3ddma_disable(void)
{
	extern void h3ddma_set_capture_enable(unsigned char chanel,unsigned char enable);

#ifdef CONFIG_FORCE_RUN_I3DDMA
	h3ddma_interrupt_enable_RBUS	h3ddma_interrupt_enable_reg;
	unsigned int timeoutcount = 5;

	down(&Force_Run_Idma_Semaphore);
	if((get_force_i3ddma_enable(SLR_MAIN_DISPLAY)) || i3ddmaCtrl.cap_buffer[0].phyaddr || get_nn_force_i3ddma_enable() ||
		(H3DDMA_CAP0_CTI_DMA_WR_Ctrl_get_cap0_dma_enable(IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Ctrl_reg))) ||
		(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_get_cap1_dma_enable(IoReg_Read32(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_reg))) ||
		(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_get_cap2_dma_enable(IoReg_Read32(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_reg))) ||
		(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_get_cap3_dma_enable(IoReg_Read32(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_reg)))){
		if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
			Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);

		down(get_main_mdomain_ctrl_semaphore());//avoid race condition
		IoReg_ClearBits(MDOMAIN_CAP_Cap_In1_enable_reg, MDOMAIN_CAP_Cap_In1_enable_in1_cap_enable_mask);//clear m domain capture
		up(get_main_mdomain_ctrl_semaphore());//avoid race condition

		//set i3ddma read hw level
		IoReg_ClearBits(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_reg, H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_db_read_sel_mask|H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_db_en_mask);

		//disable cap1 interrupt
		h3ddma_interrupt_enable_reg.regValue = IoReg_Read32(H3DDMA_Interrupt_Enable_reg);
		h3ddma_interrupt_enable_reg.cap1_last_wr_ie = 0;
		IoReg_Write32(H3DDMA_Interrupt_Enable_reg,h3ddma_interrupt_enable_reg.regValue);

		h3ddma_set_capture_enable(0,0);
		h3ddma_set_capture_enable(1,0);
		h3ddma_set_capture_enable(2,0);
		h3ddma_set_capture_enable(3,0);
		set_force_i3ddma_enable(false);
		set_nn_force_i3ddma_enable(false);
		set_i3ddma_4k120_flag(0);

		I3DDMA_Setup3DDMA(&i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
		do {
			if((H3DDMA_CAP0_CTI_DMA_WR_Ctrl_get_cap0_dma_enable(IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Ctrl_reg)) == 0) && ((H3DDMA_CAP1_CTI_DMA_WR_Ctrl_get_cap1_dma_enable(IoReg_Read32(H3DDMA_CAP1_CTI_DMA_WR_Ctrl_reg))) == 0) &&
				(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_get_cap2_dma_enable(IoReg_Read32(H3DDMA_CAP2_CTI_DMA_WR_Ctrl_reg)) == 0) && (H3DDMA_CAP3_CTI_DMA_WR_Ctrl_get_cap3_dma_enable(IoReg_Read32(H3DDMA_CAP3_CTI_DMA_WR_Ctrl_reg)) == 0))
				break;

			msleep(10);
			timeoutcount--;
		}while(timeoutcount);
#if 0
		/* WOSQRTK-11529 */
		if(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_get_db_en(IoReg_Read32(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_reg)) == 0) {
			mdelay(1);
		} else {
			msleep(40); /*wait DMA write done */
		}
#endif
		down(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		up(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		drvif_I3DDMA_Disable_Vgip();
		drvif_I3DDMA_Disable_uzd();
		// [IDMA] allocate/release IDMA memory dynamic
		if(I3DDMA_Get3DAllocReleaseMemoryDynamic() == TRUE)
			I3DDMA_DolbyVision_HDMI_DeInit();

		#ifdef CONFIG_ENABLE_HDMI_NN
			h3ddma_free_nv12_mermory();
		#endif
	}
	I3DDMA_set_dither_bit(0);	/* set dither bit setting to default */
#if IS_ENABLED(CONFIG_RTK_KDRV_DC_MEMORY_TRASH_DETCTER)
	//h3mdda_set_dcmt(1);
#endif

up(&Force_Run_Idma_Semaphore);

#endif
}


struct semaphore* get_double_buffer_semaphore(void)
{
	return &Double_buffer_Semaphore;
}
extern void vo_free_photo_buffer(unsigned int ch);

extern int flag_vdo_disconnect;
unsigned char vdo_connect(unsigned char display, unsigned char vdec_port)
{
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	unsigned long ret = 0;
#endif
	if (display == VIDEO_WID_0)
	{
		if(vdo0_connect)
		{
			rtd_pr_vsc_notice("\r\n## main vdo_connect already connect ##\r\n");
			return TRUE;
		}
	}
	else
	{
		if(vdo1_connect)
		{
			rtd_pr_vsc_notice("\r\n## sub vdo_connect already connect ##\r\n");
			return TRUE;
		}
	}
	rtd_pr_vsc_info("vdo_connect wid:%d vdec_port:%d\n", display, vdec_port);


	if(display == VIDEO_WID_0)//add by will for live zoom
		vdo0_connect = TRUE; //vo 0 connect
	else
		vdo1_connect = TRUE; //vo 1 connect

	increase_source_connect_verify_num(display);//increase the vsc source verify num. for checking vsc connect again

#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDOCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
	{
		rtd_pr_vsc_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDOCONNECT_TO_VODMA RPC fail ####\r\n");
		return FALSE;
	}
#endif


#ifdef CONFIG_DUMP_REGISTER_WHEN_ONLY_DISCONNECT
		flag_vdo_disconnect = 0;

#endif

	return TRUE;

}

unsigned char vdo_disconnect(unsigned char display, unsigned char vdec_port)
{
	unsigned char result = TRUE;
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	unsigned long ret;
#endif

#ifdef CONFIG_DUMP_REGISTER_WHEN_ONLY_DISCONNECT
	flag_vdo_disconnect = 1;
#endif

	if (display == VIDEO_WID_0)
	{
		if(!vdo0_connect)
		{
			rtd_pr_vsc_notice("\r\n## main vdo_disconnect already disconnect ##\r\n");
			return TRUE;
		}
	}
	else
	{
		if(!vdo1_connect)
		{
			rtd_pr_vsc_notice("\r\n## sub vdo_disconnect already disconnect ##\r\n");
			return TRUE;
		}
	}
	if (rtk_hal_vsc_Getdualdecoder_run()) {
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
		if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
		{
			rtd_pr_vsc_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA RPC fail ####\r\n");
			result =  FALSE;
		}
#endif
		if (display == VIDEO_WID_0) {
			vdo0_connect = FALSE;
		} else {
			vdo1_connect = FALSE;
		}
		rtd_pr_vsc_info("dual decoder case,vdo_disconnect not change,return\n");
		return result;
	}
	set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
	mute_control(display, TRUE);/*Auto BG. Add by Will*/
	rtd_pr_vsc_info("vdo_disconnect wid:%d vdec_port:%d (0x%08x)\n", display, vdec_port, IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg));


	if (display == VIDEO_WID_0) {
		vdo0_connect = FALSE; //vo 0 disconnect
		down(&SetMainOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
		DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
		DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
		DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
		DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
		DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
		DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
		DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
		main_rotate_mode = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
		main_rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
		set_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
		set_ori_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
		is_DTV_flag_set(_DISABLE);
		DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
		zoom_clear_input_output_region_record((unsigned char)display);
		Scaler_InputRegionType_Set(display,INPUT_BASE_ON_TIMING);
		up(&SetMainOutPutRegion_Semaphore);
		source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero

		DbgSclrFlgTkr.main_winfreeze=0;
		drivf_scaler_reset_freerun();
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
        scaler_vsc_set_keep_vo_framerate_control(0);
        scaler_vsc_set_adaptive_pst_lowdelay_mode(0);
#endif
	}
	else
	{
		vdo1_connect = FALSE; //vo 1 disconnect
		down(&SetSubOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
		zoom_clear_input_output_region_record((unsigned char)display);
		Scaler_InputRegionType_Set(display,INPUT_BASE_ON_TIMING);
		up(&SetSubOutPutRegion_Semaphore);
		source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero
	}

	drvif_mode_onlinemeasure_setting(display, Scaler_InputSrcGetType(display), FALSE, FALSE);
    drvif_mode_disableonlinemeasure(display);//Diable online measure

	down(get_vo_infosemaphore());
	set_vo_change_flag((display == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
	set_force_change_vo_flag((display == VIDEO_WID_0) ? SLR_MAIN_DISPLAY : SLR_SUB_DISPLAY, TRUE);
	up(get_vo_infosemaphore());

	Check_smooth_toggle_update_flag(display);
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
	{
		rtd_pr_vsc_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA RPC fail ####\r\n");
		result =  FALSE;
	}
#endif
	smooth_toggle_disconnect(display,display);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
	state_update_disp_info();

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if ((display == VIDEO_WID_0) && (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY)))
	{
		down(&Main_ResetMode_Semaphore);
		rtd_pr_vsc_debug("\r\n####func:%s request reset mode####\r\n", __FUNCTION__);
		DbgSclrFlgTkr.Main_Reset_Mode_flag = TRUE;
		up(&Main_ResetMode_Semaphore);
	}
#endif


#ifdef Mer2_MEMORY_ALLOC
	if (display == VIDEO_WID_0)
	{
		Scaler_color_set_HDR_Type(0xff);	// reset hdr type
		drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(0, 0, 0, 1);
		drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(1, 0, 0, 1);
		drv_memory_MA_SNR_Disable(0);
		drv_memory_MA_SNR_Disable(1);
		/* for PQ IP Enable monitor*/
		// use vpq tsk to monitor, use lv control, buff control is not neccessary
		//Scaler_PQ_IP_Enable_Monitor_clear_Buff();
		Scaler_color_Set_PQ_ByPass_Lv(255);
	}
#endif

	if (display == VIDEO_WID_0) {
		DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
		DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
		down(&SetMainOutPutRegion_Semaphore);
		reset_any_srcrect(&main_dispwin_pre);
		reset_any_srcrect(&main_dispwin_for_only_xy);
		up(&SetMainOutPutRegion_Semaphore);
	} else {
		DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
		down(&SetSubOutPutRegion_Semaphore);
		reset_any_srcrect(&sub_dispwin_pre);
		up(&SetSubOutPutRegion_Semaphore);
	}


	rtd_pr_vsc_notice("[VSC] vdo_disconnect done (0x%08x)\n", IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg));
	return result;
}


unsigned char rtk_hal_vsc_Disconnect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{
	unsigned int *p_sourceID = NULL;
	StructSrcRect SrcRect = {0, 0, 0, 0};
	unsigned char plane=0;
#ifdef CONFIG_I2RND_ENABLE
	unsigned char i2rnd_port_main = 0;
	unsigned char i2rnd_port_sub = 0;
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
     if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
           //  rtd_pr_vsc_info("!!!!!!!!!!!!!!!!!!!!!!!!!!!b05_vsc_Disconnect!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
             rtk_hal_vsc_i2rnd_b05_enable(_DISABLE);
     }
#endif

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	} else if (wid == VIDEO_WID_0) {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	}
#else
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#endif
//Eric@20171013 set cmd table index before setting register
#ifdef CONFIG_I2RND_ENABLE
	if(Scaler_I2rnd_get_timing_enable()){
		if(wid == VIDEO_WID_0)
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
		else if (wid == VIDEO_WID_1)
			Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
	}
#endif
	rtd_pr_vsc_info("vsc_disconnect wid:%d SrcInfo:%d;%d;%d,Mode:%d\n", wid, inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

	if (wid ==VIDEO_WID_0) {

		if((KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type))
		{
			Scaler_AVD_SetHalVscConnect(SLR_MAIN_DISPLAY,FALSE);
			if((Scaler_AVD_GetHalVscConnect(SLR_SUB_DISPLAY) == FALSE) && module_vdc_check_vd_clock()){
				drvif_module_vpq_DmaAccessCtrl(OFF);
				rtd_pr_vsc_info("\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(OFF)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
				{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
					if(DisplayModeInputInfo.type == inputSrcInfo.type)
#else
					if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
#endif
					{
						if (rtk_hal_vsc_Getdualdecoder_run() && (inputSrcInfo.type == (KADP_VSC_INPUT_TYPE_T)VSC_INPUTSRC_VDEC)) {
							Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
							down(get_vo_infosemaphore());
							set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
							up(get_vo_infosemaphore());
                            reset_any_srcrect(&main_input_size);
							reset_any_srcrect(&main_dispwin);
							scaler_Setdualdecoder_notchange(1);
							rtd_pr_vsc_info("dual decoder case,disconnect not change,return, and clear pre input,output\n");
							return TRUE;
						}
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
						set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);
						down(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
						DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
						DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
						DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
						DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
						main_rotate_mode = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
						main_rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
						set_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
						set_ori_rotate_mode(SLR_MAIN_DISPLAY, DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
						is_DTV_flag_set(_DISABLE);
						zoom_clear_input_output_region_record(wid);
						Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
						up(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.main_winfreeze=0;
						DbgSclrFlgTkr.mainVscFreezeFlag=0;
						source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
						memc_me_clock_set_off = 0;	//reset me_clock_set_off flag
						//reset film parameter
						film_mode_parameter.enable = 0;
						film_mode_parameter.type= 0;
						film_mode_parameter.v_freq = 0;
						ori_voclk_ratio_num = 0;
                        			smooth_toggle_game_mode_check_cnt = 0;// reset default value
						st_game_mode_cmd_pre = 0;
						Scaler_set_dynamic_framerate_change_flag(_DISABLE);
						drv_memory_set_vdec_direct_low_latency_mode(_DISABLE);
						scaler_set_VRR_pwm_frequency_update_in_isr(FALSE);
						Scaler_set_MEMC_gamemode_lowdelay(0);
						set_video_fw_memc_freeze_type(SLR_MAIN_DISPLAY,VIDEO_FW_CONTRL_MEMC_NONE);
						Scaler_Set_FreeRun_To_FrameSync_By_Reset_VODMA(TRUE);
						Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(FALSE);
                        			scaler_RGB444Mode_pre = FALSE;
						vsc_force_rerun_main_scaler = FALSE;
						set_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY, FALSE);
						set_vsc_gamemode_datafrc_mode_flag(FALSE);
						drv_set_datafs_gatting_enable_done(FALSE);
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
                        //dlg_callback_handler(E_DLG_ENABLE_OSD);
                        dlg_callback_handler(E_DLG_DISABLE_DLG_MASK);
#endif

#ifdef CONFIG_SUPPORT_FREESYNC
						//vbe_disp_set_freesync_mode_flag(0);
						//rtd_pr_vsc_info("\r\n########[FreeSync] set_freesync_mode_flag disable!!!######\r\n");
#endif
						//if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
						//	vo_free_photo_buffer(0);
						//}
						drivf_scaler_reset_freerun();

						if((DbgSclrFlgTkr.OutputVencMode == FALSE) && (DbgSclrFlgTkr.OutputMemoryMode == FALSE) && (DbgSclrFlgTkr.OutputAveMode == FALSE))
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
                            smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);//wait smooth toggle finish need before rtk_i3ddma_disable
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
#ifdef CONFIG_SUPPORT_SRC_ADC
								rtd_pr_vsc_info("#####[%s(%d)] get_ADC_Global_Status=%d,get_ADC_Input_Source=%d\n", __func__, __LINE__, get_ADC_Global_Status(), get_ADC_Input_Source());
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									drvif_adc_power_control(ADC_POWER_YPP_ONLY_DETECT_CONTROL,__func__,__LINE__);
									drvif_adc_ctl_rgb12_check(get_ADC_Input_Source());
								}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
                                rtk_i3ddma_disable();
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
                                rtk_i3ddma_disable();
								//drvif_Hdmi_OutputDisable(1); // not HDMI source, disable HDMI output,willychou remove it for fixing KTASKWBS-9866 on 2018/11/28
								drvif_Hdmi_WatchDogApply(_DISABLE, HDMI_WD_VSC_COND);
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							}
#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								rtk_i3ddma_disable();
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							//	vo_overscan_disable(inputSrcInfo.type);
								Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
								if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
									rtk_i3ddma_disable();
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
								{
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								}
								else
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);


								down(get_vo_infosemaphore());
								DbgSclrFlgTkr.OuputDisplayMode = FALSE;
								plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
								DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
#ifdef CONFIG_I2RND_ENABLE
								set_vo_change_flag(i2rnd_port_main, FALSE);//Reset Vo change flag
								set_force_change_vo_flag(i2rnd_port_main, TRUE);
#else
								set_vo_change_flag(SLR_MAIN_DISPLAY, FALSE);//Reset Vo change flag
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
#endif
								rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
								up(get_vo_infosemaphore());
							}
							//smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
							scaler_vsc_set_gamemode_go_datafrc_mode(FALSE);

#ifdef Mer2_MEMORY_ALLOC
							Scaler_color_set_HDR_Type(0xff);	// reset hdr type
							drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(0, 0, 0, 1);
							drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(1, 0, 0, 1);
							drv_memory_MA_SNR_Disable(0);
							drv_memory_MA_SNR_Disable(1);
							/* for PQ IP Enable monitor*/
							// use vpq tsk to monitor, use lv control, buff control is not neccessary
							//Scaler_PQ_IP_Enable_Monitor_clear_Buff();
							Scaler_color_Set_PQ_ByPass_Lv(255);
#endif

						}
						//USER:Lewislee DATE:2015/10/2
						//when PIP off, need reset setting
						Scaler_Disp3dSetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE, SLR_3D_2D_ONLY);
						Scaler_Set3DMode_Attr(SLR_MAIN_DISPLAY, SLR_3DMODE_2D);
#ifdef CONFIG_I2RND_ENABLE
						//rtd_pr_vsc_emerg("[crixus][vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
						//rtd_pr_vsc_emerg("[crixus]rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);
						down(&I2RND_Semaphore);
						//clear i2rnd main voinfo i2r_fix_me
						i2rnd_main_voinfo = i2rnd_empty_voinfo;

						//Eric@20170809 disable i2rnd when VDEC src disconnected
						if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE)){
							//sub already disconnect
							Scaler_I2rnd_set_force_cmd(_DISABLE);
							Scaler_pst_buffer_initial(_MAIN_MD);
							rtd_pr_vsc_emerg("[%s][I2RND][main disconnect]I2RND initial\n", __FUNCTION__);
						}
						else{
							//sub still connect, keep 1:1 mode
							rtd_pr_vsc_emerg("[%s][I2RND][main disconnect]sub still connect, keep 1:1\n", __FUNCTION__);
						}
						if(get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S0_CONNECTED){
							set_i2rnd_vo1_refine_status_vir_addr(I2RND_VO1_REFINE_OFF);
							rtd_pr_vsc_emerg("[I2RND]main disconnect, I2RND_VO1_REFINE_OFF!!\n");
						}
						set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_OFF);
						rtd_pr_vsc_emerg("[I2RND]main disconnect, I2RND_S0_IDOMAIN_STAGE_OFF!!\n");
						up(&I2RND_Semaphore);
#endif

						DbgSclrFlgTkr.OuputDisplayMode = FALSE;
						DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
						//close display panel
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#ifdef CONFIG_SUPPORT_DOLBY_VSIF
						if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)//disconnect hdmi change the resource
							drvif_Hdmi_set_infoframe_thread_stop(_FALSE);
#endif //#ifdef CONFIG_SUPPORT_DOLBY_VSIF
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;display mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error display mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
#ifndef UT_flag
				if(get_vdec_securestatus()==TRUE){
#ifdef CONFIG_RTK_KDRV_VDEC
                    rtkvdec_svp_disable_protection(0, 0, TYPE_SVP_PROTECT_DISPLAY);
#endif
					set_vdec_securestatus(FALSE);
					set_dtv_securestatus(FALSE);
					// 0520 lsy
					set_vdec_securestatus_aipq(FALSE);
					set_dtv_securestatus_aipq(FALSE);
					// end 0520 lsy
				}
#endif // #ifndef UT_flag
				if(read_buffer_first_flag == 1){
					read_buffer_first_flag = 0;
					rtd_pr_vsc_debug("[self-dianosis]27M reset !!\n");
				}
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					if((VencModeInputInfo.type == inputSrcInfo.type) && (VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.OuputDisplayMode == FALSE)
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
								//smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							}
							smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);//wait smooth toggle finish
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						DbgSclrFlgTkr.OutputVencMode = FALSE;
						VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;venc mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error venc mode not open\n");
						return TRUE;
					}
				}

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE://Current same with VSC_OUTPUT_DISPLAY_MODE
			{
				if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					if((MemoryModeInputInfo.type == inputSrcInfo.type) && (MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
						down(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
						DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
						DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
						DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
						DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
						is_DTV_flag_set(_DISABLE);
						zoom_clear_input_output_region_record(wid);
						Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
						up(&SetMainOutPutRegion_Semaphore);
						source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
						DbgSclrFlgTkr.main_winfreeze=0;
						DbgSclrFlgTkr.mainVscFreezeFlag=0;
						if(DbgSclrFlgTkr.OuputDisplayMode==FALSE)
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							//	vo_overscan_disable(inputSrcInfo.type);
								Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								else
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

								down(get_vo_infosemaphore());
								DbgSclrFlgTkr.OutputMemoryMode = FALSE;
								plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
								MemoryModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
								set_vo_change_flag(SLR_MAIN_DISPLAY, FALSE);//Reset Vo change flag
								set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
								rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
								up(get_vo_infosemaphore());
							}
							smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						DbgSclrFlgTkr.OutputMemoryMode = FALSE;
						MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;memory mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error memory mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);

				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					if((AveModeInputInfo.type == inputSrcInfo.type) && (AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						HAL_VBE_AVE_Disconnect();
						DbgSclrFlgTkr.OutputAveMode = FALSE;
						AveModeInputInfo =  (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;ave mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else {
						rtd_pr_vsc_debug(" error ave mode not open\n");
						return TRUE;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		//set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);

		if((KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type))
		{
			Scaler_AVD_SetHalVscConnect(SLR_SUB_DISPLAY,FALSE);
			if((Scaler_AVD_GetHalVscConnect(SLR_MAIN_DISPLAY) == FALSE) && module_vdc_check_vd_clock()){
				drvif_module_vpq_DmaAccessCtrl(OFF);
				rtd_pr_vsc_info("\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(OFF)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
					if(Sub_DisplayModeInputInfo.type == inputSrcInfo.type)
#else
					if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
#endif
					{
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//Auto mue before disconnect
						drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
						up(get_forcebg_semaphore());
						if((DbgSclrFlgTkr.Sub_OutputVencMode == FALSE) && (DbgSclrFlgTkr.Sub_OutputMemoryMode == FALSE) && (DbgSclrFlgTkr.Sub_OutputAveMode == FALSE))
						{
							down(&SetSubOutPutRegion_Semaphore);
							DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
							DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
							zoom_clear_input_output_region_record(wid);
							Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
							up(&SetSubOutPutRegion_Semaphore);
							source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

#ifdef CONFIG_I2RND_ENABLE

							down(&I2RND_Semaphore);
							//clear i2rnd sub voinfo //i2r_fix_me
							i2rnd_sub_voinfo = i2rnd_empty_voinfo;
							vsc_i2rnd_dualvo_sub_stage= I2RND_DUALVO_STAGE_SUB_DISABLE;
							vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
							//Eric@20171213 disable pst flag
							Scaler_main_md_pst_set_enable(_DISABLE);
							Scaler_sub_md_pst_set_enable(_DISABLE);

							if(DbgSclrFlgTkr.OuputDisplayMode == FALSE){
								rtd_pr_vsc_emerg("[%s][I2RND]PIP disconnect sub src!\n", __FUNCTION__);
							}
							else{
								//main still connect
								Scaler_I2rnd_set_force_cmd(_ENABLE);
								Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
								//drivf_scaler_reset_freerun();
								//modestate_set_fll_running_flag(_ENABLE);
								rtd_pr_vsc_emerg("[%s][I2RND]PIP disconnect sub src, main still connect, set force cmd enable!\n", __FUNCTION__);
							}
							//disable dual vo mode flag
							if((inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC))
								Scaler_Send_VoDisconnect_VOMDA(VO_VSC_SRC_HDMI, 0xaa); //0xaa use for i2r sub window

							if(get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S1_REFINE_VO1){
								set_i2rnd_vo1_refine_status_vir_addr(I2RND_VO1_REFINE_OFF);
								rtd_pr_vsc_emerg("[I2RND]sub disconnect, I2RND_VO1_REFINE_OFF!!\n");
							}
							up(&I2RND_Semaphore);

#endif


							drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
#ifdef CONFIG_SUPPORT_SRC_ADC
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
#endif
							} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								down(get_vo_infosemaphore());
								DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
								plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
#ifdef CONFIG_I2RND_ENABLE
								set_vo_change_flag(i2rnd_port_sub, FALSE);//Reset Vo change flag
#else
								set_vo_change_flag(SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
#endif

#ifdef CONFIG_I2RND_ENABLE
								set_force_change_vo_flag(i2rnd_port_sub, TRUE);
#else
								set_force_change_vo_flag(SLR_SUB_DISPLAY, TRUE);
#endif


								rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
								up(get_vo_infosemaphore());
							//	vo_overscan_disable(inputSrcInfo.type);
								Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								else
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

								//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							}

							smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						set_vsc_run_adaptive_stream(SLR_SUB_DISPLAY, FALSE);
						DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
						DbgSclrFlgTkr.sub_wind0000 = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Scaler_SubDispWindowSet(SrcRect);

						Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
						//close_livezoom_doublebuffer();
						//close display panel

						//USER:Lewislee DATE:2015/10/2
						//when PIP off, need reset setting
						Scaler_Disp3dSetInfo(SLR_SUB_DISPLAY, SLR_DISP_3D_3DTYPE, SLR_3D_2D_ONLY);
						Scaler_Set3DMode_Attr(SLR_SUB_DISPLAY, SLR_3DMODE_2D);
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;display mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error display mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				/*qiangzhou:should clear setting for mutilvew(sub nosignal) and livezoom switch case */
				if (DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) {
					DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
				}
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);

				if(sub_read_buffer_first_flag == 1){
					Scaler_AVD_EnableVD27MMode(VD_27M_HSD960_DI5A);
					Scaler_AVD_SetDetectStage(0);//DETECT_STAGE_INIT
					sub_read_buffer_first_flag = 0;
					rtd_pr_vsc_debug("[self-dianosis]27M reset !!\n");
				}
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					if((Sub_VencModeInputInfo.type == inputSrcInfo.type) && (Sub_VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.Sub_OuputDisplayMode == FALSE)
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
							/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
							*/
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
							rtd_pr_vsc_emerg("[vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
							rtd_pr_vsc_emerg("rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

							if(run_i2rnd_flag == 1){
								run_i2rnd_flag = 0;
								//i2rnd_send_table_idx(I2RND_TABLE_OFF);
								rtk_hal_vsc_i2rnd_enable(_DISABLE);
								//frank@I2run disable main VENC flag
								VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
								DbgSclrFlgTkr.OutputVencMode = FALSE;
								vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
								vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
								//apvr_request_run_main_path();
								rtd_pr_vsc_emerg("[%s][frank]I2RND close\n", __FUNCTION__);
							}
#endif
#endif

							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
								//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							}
							smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}

						DbgSclrFlgTkr.Sub_OutputVencMode = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Sub_VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;venc mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug(" error venc mode not open\n");
						return TRUE;
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					if((Sub_MemoryModeInputInfo.type == inputSrcInfo.type) && (Sub_MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.Sub_OuputDisplayMode == FALSE)
						{
							down(&SetSubOutPutRegion_Semaphore);
							DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
							zoom_clear_input_output_region_record(wid);
							Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
							up(&SetSubOutPutRegion_Semaphore);
							source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

							drvif_mode_onlinemeasure_setting(_CHANNEL2,Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
#ifdef CONFIG_SUPPORT_SRC_ADC
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
#endif
							} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {

							//	vo_overscan_disable(inputSrcInfo.type);
								Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								else
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

								smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
								down(get_vo_infosemaphore());
								DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE;
								plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Sub_MemoryModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
								set_vo_change_flag(SLR_SUB_DISPLAY, FALSE);//Reset Vo change flag
								set_force_change_vo_flag(SLR_SUB_DISPLAY, TRUE);
								rtd_pr_vsc_debug("\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
								up(get_vo_infosemaphore());
							}

							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}

						DbgSclrFlgTkr.sub_wind0000 = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Scaler_SubDispWindowSet(SrcRect);

						DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE;
						Sub_MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;

						//close_livezoom_doublebuffer();
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;memory mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_pr_vsc_debug("error memory mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					if((Sub_AveModeInputInfo.type == inputSrcInfo.type) && (Sub_AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						HAL_VBE_AVE_Disconnect();
						DbgSclrFlgTkr.Sub_OutputAveMode = FALSE;
						Sub_AveModeInputInfo =	(KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
					}
					else
					{
						rtd_pr_vsc_debug("inputSrcInfo not match;ave mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else {
						rtd_pr_vsc_debug("error ave mode not open\n");
						return TRUE;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#endif
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
    vbe_set_panel_dlg_mode(PANEL_DLG_DEFAULT);
    //dlg_callback_handler(E_DLG_ENABLE_OSD);
#endif
	return TRUE;
}

unsigned char check_zoom_smooth_toggle_proc(void)
{//added by rika 20140904
	//int failflag=ZOOM_STATE_OK;
	//unsigned char resetflag=_DISABLE;
	return ZOOM_STATE_OK;//temp return by will.
#if 0
	if(zoom_smooth_toggle_get_finish() == ZOOM_STATE_NONE){
		rtd_pr_vsc_debug("_rk %s none\n",__FUNCTION__);
		///Scaler_DispSetInputInfo(SLR_INPUT_STATE,_MODE_STATE_ACTIVE);//For check timing
	}
	else if(zoom_smooth_toggle_get_finish() == ZOOM_STATE_WAIT_APPLY_OK){
		//zoom_smooth_toggle_set_finish(ZOOM_STATE_DONOW);
		rtd_pr_vsc_debug("_rk wait ok here\n-----\n");
		resetflag=_ENABLE;//reset size anyway  rika 20141112
		failflag=zoom_imd_smooth_toggle_proc(_ENABLE, _ENABLE, Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));//need review rika 20141224

		if(failflag==ZOOM_STATE_OK){
			rtd_pr_vsc_debug("_rk %s wait ok done. send active2 \n", __FUNCTION__);
			///Scaler_DispSetInputInfo(SLR_INPUT_STATE,_MODE_STATE_ACTIVE);//For check timing

		}
		//else fail
		// do not set active
	}
	return failflag;
#endif
}


#define AVD_480i_MAX_LENGTH 504   // WebOS adjust v_size max size (2*v_start + v_length)
unsigned char CheckAVDandWebOSInfo(unsigned char display)
{
	unsigned char ucRet = TRUE;

	// The current signal color std is supported, check the M-domain size and InputRegion
	if( (Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL)
		&& (0 == Scaler_AVD_IsSupportedColorSys()))  // 0: supported, -1: non-supported
	{
		unsigned short usAfterDILen = 0;
		unsigned short usInputRegion_h = 0, usInputRegion_y = 0;
		rtd_pr_vsc_notice("#####[%s(%d)]DbgSclrFlgTkr.Main_Output_Set_flag=%x, DbgSclrFlgTkr.Main_Scaler_Stop_flag=%x, DbgSclrFlgTkr.Main_Run_Scaler_flag=%x\n", __FUNCTION__, __LINE__, DbgSclrFlgTkr.Main_Output_Set_flag, DbgSclrFlgTkr.Main_Scaler_Stop_flag, DbgSclrFlgTkr.Main_Run_Scaler_flag);


		if (display == SLR_MAIN_DISPLAY && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			usAfterDILen =	(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN) << 1);
		} else {
			usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);
		}

		if(display == SLR_MAIN_DISPLAY)
		{
			usInputRegion_h = Main_InputRegion_h;
			usInputRegion_y = Main_InputRegion_y;
		}
		else
		{
			usInputRegion_h = Sub_InputRegion_h / 2;  // 480=>240, 576=>288 (InputRegion_h is full size)
			usInputRegion_y = Sub_InputRegion_y / 2;
		}

#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT){
			if(display == SLR_MAIN_DISPLAY)
			{
				usInputRegion_h = Scaler_intputRegion_base_scalerTiming[display].src_height;//Main_InputRegion_h;
				usInputRegion_y = Scaler_intputRegion_base_scalerTiming[display].srcy;//Main_InputRegion_y;
			}
			else
			{
				usInputRegion_h = Scaler_intputRegion_base_scalerTiming[display].src_height / 2;//Sub_InputRegion_h / 2;  // 480=>240, 576=>288 (InputRegion_h is full size)
				usInputRegion_y = Scaler_intputRegion_base_scalerTiming[display].srcy / 2;//Sub_InputRegion_y / 2;
			}
		}
#endif

		rtd_pr_vsc_debug("usInputRegion=%d,  usAfterDILen=%d\n", usInputRegion_h , usAfterDILen);

		if ((usInputRegion_h > usAfterDILen)
			|| ((usInputRegion_y*2 + usInputRegion_h) <= AVD_480i_MAX_LENGTH && usAfterDILen > 500)  //Throw DI (Current signal is 576i, but inputRegion is 480i)
			|| ((usInputRegion_y*2 + usInputRegion_h) <= (AVD_480i_MAX_LENGTH/2) && usAfterDILen > 250) ) // ByPass DI
		{
			rtd_pr_vsc_debug(" m-domain size wrong, return false\n");

			ucRet = FALSE;
		}
	}

	return ucRet;
}

void wait_DI_auto_freeze(void)
{
	if(((rtd_inl(VODMA_VODMA_V1_DCFG_reg) &VODMA_VODMA_V1_DCFG_vodma_go_mask)==0)
			&&((rtd_inl(VODMA_VODMA_V1INT_reg) &VODMA_VODMA_V1INT_vgip_en_mask) == 0))
		{

			int timeout = 50;
			while(((rtd_inl(DI_IM_DI_DEBUG_MODE_reg)&_BIT8)>>8==0)&&timeout--){
				rtd_pr_vsc_emerg("wait DI freeze\n");
				mdelay(1);
			}
			if(timeout == 0)
				rtd_pr_vsc_emerg("wait_DI_auto_freeze timeout\n");

		}
}


void reset_rotate_mode_impl(unsigned char display)
{
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if(display == SLR_MAIN_DISPLAY)
	{
			if (TRUE == Get_rotate_function(SLR_MAIN_DISPLAY))
			{
				extern unsigned int rotatedisconnecten;
				extern void scaler_mdom_stop(void);
				rotatedisconnecten = 1;
				scaler_Rotate_VI_init_send_rpc();
				rotatedisconnecten = 0;
				if(get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY))
					wait_DI_auto_freeze();
				scaler_mdom_stop();
				Set_rotate_function(SLR_MAIN_DISPLAY, FALSE);
			}
			rtd_pr_vsc_debug("function=%s, line=%d\n", __FUNCTION__, __LINE__);
			rtd_pr_vsc_debug("vflip=%d\n", 0);
	}else
		rtd_pr_vsc_emerg("reset_rotate_mode sub do nothing\n");


	if (!Get_PANEL_VFLIP_ENABLE())
	{
		scaler_send_rotate_vflip_rpc(FALSE);
	}
#endif
}
void (*reset_rotate_mode)(unsigned char display) = reset_rotate_mode_impl;

extern void drvif_scaler_enable_frc2fsync_HW_speedup_vtotal(UINT8 bEnable);
void scaler_timing_ctrl_reset(unsigned char display)
{//for run scaler need to do some timing ctrl reset. avoid timing can not lock
	if(display == SLR_MAIN_DISPLAY)
	{
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FAILURECOUNT) == 0)
		{
			unsigned int wait_timeoutcnt = 30;
			//roatte case, becasue rotate not call reset mode for freeze issue.
			modestate_set_fll_running_flag(FALSE);
			drivf_scaler_reset_freerun();//free run
			drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, Scaler_InputSrcGetFrom(SLR_MAIN_DISPLAY), FALSE, FALSE);//Disable online measure watchdog and interrupt
			drvif_mode_disableonlinemeasure(SLR_MAIN_DISPLAY);//Disable online measure
			IoReg_ClearBits(MDOMAIN_CAP_Cap_In1_enable_reg, _BIT0);//disable m domain capture
			IoReg_ClearBits(MDOMAIN_DISP_Disp_main_enable_reg, _BIT0);//disable m display capture
			IoReg_SetBits(MDOMAIN_CAP_cap_reg_doublbuffer_reg, _BIT2);//m cap db apply
			IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//m diaplay db apply

			//reset speedup_vtotal
			drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			drvif_scaler_enable_frc2fsync_HW_speedup_vtotal(FALSE);

			do{//wait gatting disable
				if(VODMA_VODMA_CLKGEN_get_en_fifo_full_gate(IoReg_Read32(VODMA_VODMA_CLKGEN_reg)) == 0)
					break;
				else
				{
					msleep(1); /* delay 10 ms*/
					wait_timeoutcnt--;
				}
			}while(wait_timeoutcnt);

			if((wait_timeoutcnt == 0) && VODMA_VODMA_CLKGEN_get_en_fifo_full_gate(IoReg_Read32(VODMA_VODMA_CLKGEN_reg)))
			{
				rtd_pr_vsc_err(" scaler_timing_ctrl_reset disable gatting timeout fail\n\n");
				IoReg_ClearBits(VODMA_VODMA_CLKGEN_reg, VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
			}

		}
	}
}
void vo_force_24_to_60_flow_control(unsigned char display,KADP_VSC_INPUT_TYPE_T inputType)
{
    if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_VDEC) && (Scaler_Get_Vo_Force_60_Framerate_State() == VO_ORIGINAL_24_FORCE_60)) {
    	rtd_pr_vsc_emerg("[24force60][state %d->2]when 60hz set_imd finished, trigger vo run real 24hz\n", Scaler_Get_Vo_Force_60_Framerate_State());
    	Scaler_Set_Vo_Force_60_Framerate_State(VO_60_CHANGE_ORIGINAL_24);
    }else {
    	rtd_pr_vsc_emerg("[24force60][state %d->0]no trigger vo run 24hz",Scaler_Get_Vo_Force_60_Framerate_State());
    	Scaler_Set_Vo_Force_60_Framerate_State(DEFAULT_KEEP_FRAMERATE);
    }
    if(Scaler_Get_Vo_Force_60_Framerate_State()==VO_60_CHANGE_ORIGINAL_24){
        unsigned char count=20;
        while((Scaler_Get_Vo_Force_60_Framerate_State()!=VO_SMT_24_FINISH)&& --count){
            msleep(0);
        }
    	rtd_pr_vsc_emerg("[24force60][state %d] count=%d",Scaler_Get_Vo_Force_60_Framerate_State(),count);
    }
    if((display == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
        if((inputType == KADP_VSC_INPUTSRC_VDEC) && (Scaler_Get_Vo_Force_60_Framerate_State() == VO_SMT_24_FINISH)) {
        	scaler_set_full_gatting_rpc(true);
        	rtd_pr_vsc_emerg("Enable Gating on state 4!\n");
        }
		else if((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) && (Get_DISPLAY_PANEL_CUSTOM_INDEX() == VBY_ONE_PANEL_COMMERCIAL_4K2K_600M_1S_8L_DUPLICATE)) {
			scaler_set_full_gatting_rpc(true);
        	rtd_pr_vsc_emerg("Enable Gating on state !\n");
		}
     scaler_linebuffer_mode_finish = TRUE;
    }
}
unsigned char rtk_run_scaler_impl(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType, KADP_VSC_OUTPUT_MODE_T outputMode)
{
#ifdef CONFIG_SUPPORT_SRC_ADC
	StructDisplayInfo  *p_timing = NULL;
#endif
	StructSrcRect winSrcRect = {0, 0, 0, 0};
	unsigned char hdmi_unstable_reset_timing = TRUE;//if TRUE, do reset timing info. If false, this is hdr change case
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
	extern void HAL_VBE_DISP_GetOutputFrameRate(UINT16* pframeRates);
//	UINT8 frameRates;
#endif
	unsigned char wait_to_after_avsync_do = 0;
	unsigned char new_voinfo_flag = 0;// to check vo overscan or not
	unsigned char game_mode_wait_timeout = 40;	//400ms
	//unsigned char port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
	switch(outputMode)
	{
		case KADP_VSC_OUTPUT_DISPLAY_MODE:
		case KADP_VSC_OUTPUT_MEMORY_MODE:
		{
#if(VSC_PROFILE == 1)
			unsigned int before_time = 0;
			unsigned int after_time = 0;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif
			down(&Force_Run_Idma_Semaphore);
#ifndef UT_flag
			if((display == SLR_MAIN_DISPLAY) && ((inputType == KADP_VSC_INPUTSRC_VDEC) || (inputType == KADP_VSC_INPUTSRC_JPEG))&& (outputMode == KADP_VSC_OUTPUT_DISPLAY_MODE) && (scalerAI_get_AIPQ_mode_enable_flag()))
			{
				scaler_nn_force_run_idma(display, (VSC_INPUT_TYPE_T)inputType);
			}
#endif // #ifndef UT_flag
			up(&Force_Run_Idma_Semaphore);

#ifdef CONFIG_FORCE_RUN_I3DDMA
			if ((get_force_i3ddma_enable(display) == false)
				&&((get_rotate_mode(SLR_MAIN_DISPLAY)==get_ori_rotate_mode(SLR_MAIN_DISPLAY) && main_rotate_mode == main_rotate_mode_pre)|| (get_ori_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
#ifdef CONFIG_I2RND_ENABLE
				//Eric@20170808 Dual vo i2rnd do not run reset mode when rerun main scaler path
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
				)
#else
			if (((get_rotate_mode(SLR_MAIN_DISPLAY)==get_ori_rotate_mode(SLR_MAIN_DISPLAY))|| (get_ori_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
#ifdef CONFIG_I2RND_ENABLE
				//Eric@20170808 Dual vo i2rnd do not run reset mode when rerun main scaler path
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
				)
#endif
			{
				drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
			} else {
				if((get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)) && (get_ori_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)) {
					//disable onms before re-run scaler
					if(display == SLR_MAIN_DISPLAY) {
						scaler_timing_ctrl_reset(display);
					}
					reset_rotate_mode(SLR_MAIN_DISPLAY);
				}
				if ((display == SLR_MAIN_DISPLAY)
#ifdef CONFIG_I2RND_ENABLE
					//Eric@20171019 Dual vo i2rnd do not change snr clock setting when rerun main scaler path
					&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
					&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
					&&(!((get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)) && (get_ori_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)))
				){
					//disable data path s1 clock for snr hw bug
					drvif_color_Set_DRV_SNR_Clock(display, _DISABLE);
				}

				set_zoom_reset_double_state(_DISABLE, display);//always disable double buffer
			}
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			down(&SetMainOutPutRegion_Semaphore);
			if((display == SLR_MAIN_DISPLAY)
				&&((get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)
				||(get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270)))
			{
				Set_rotate_function(SLR_MAIN_DISPLAY, TRUE);
			}else if ((display == SLR_MAIN_DISPLAY) && (get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
			        && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
            {
            	Set_rotate_function(SLR_MAIN_DISPLAY, TRUE);
            }else
            {
		        Set_rotate_function(SLR_MAIN_DISPLAY, FALSE);
	        }
			//set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode(SLR_MAIN_DISPLAY));
			up(&SetMainOutPutRegion_Semaphore);

			if(Get_PANEL_VFLIP_ENABLE()) {
				if((get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180) && (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == FALSE)) {
					rtd_pr_vsc_emerg("vflip progressive rotate 180, send vo vflip=false to vcpu\n");
					rtd_pr_vsc_debug("vflip=%d\n", FALSE);
					scaler_send_rotate_vflip_rpc(FALSE);
				} else {
					rtd_pr_vsc_debug("vflip=%d\n", TRUE);
					scaler_send_rotate_vflip_rpc(TRUE);
				}

			} else {
				if((get_rotate_mode(SLR_MAIN_DISPLAY) == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180) && (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == FALSE)) {
					rtd_pr_vsc_emerg("progressive rotate 180, send vo vflip=true to vcpu\n");
					rtd_pr_vsc_debug("vflip=%d\n", TRUE);
					scaler_send_rotate_vflip_rpc(TRUE);
				} else {
					rtd_pr_vsc_debug("vflip=%d\n", FALSE);
					scaler_send_rotate_vflip_rpc(FALSE);
				}

			}

			if((Get_rotate_function(SLR_MAIN_DISPLAY) == TRUE) || (get_rotate_mode(SLR_MAIN_DISPLAY)!=get_ori_rotate_mode(SLR_MAIN_DISPLAY)))
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ROTATE, TRUE);
#endif
            update_vsc_task_status(1, VSC_GET_INFO);
			if(get_displayinfo_proc(display, (VSC_INPUT_TYPE_T)inputType) == FALSE)
			{
				rtd_pr_vsc_notice("######get_displayinfo_proc fail fail fail!!!#######\n");
				if (display == SLR_MAIN_DISPLAY) {
					if(((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV))
#ifdef CONFIG_SUPPORT_SRC_ADC
						|| (inputType == KADP_VSC_INPUTSRC_ADC)
#endif
						|| (inputType == KADP_VSC_INPUTSRC_HDMI)){//adc hdmi av case
						if(compare_rerify_vsc_source_num_result(SLR_MAIN_DISPLAY))
							reset_ARC_cmd(SLR_MAIN_DISPLAY);//not change source case
					}
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre);
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre);
					up(&SetSubOutPutRegion_Semaphore);
				}
				if(inputType == KADP_VSC_INPUTSRC_ADC)
				{//Need to rerun scaler
#ifdef CONFIG_SUPPORT_SRC_ADC
					down(get_adc_detectsemaphore());
					reset_adc_timing_ready();
					p_timing = Get_ADC_Dispinfo();
					p_timing->IPH_ACT_WID_PRE = 0;
					p_timing->IPV_ACT_LEN_PRE = 0;
					p_timing->IVFreq = 0;
					p_timing->IHFreq = 0;
					p_timing->IHTotal = 0;
					p_timing->IVTotal = 0;
					p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
						Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						//YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
#endif
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{//Need to rerun scaler
					reset_hdmi_timing_ready();
					down(get_hdmi_detectsemaphore());
					if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
						vfe_hdmi_drv_handle_on_line_measure_error(0);
						Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						HDMI_set_detect_flag(TRUE);
					}
					up(get_hdmi_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_AVD)
				{//Need to rerun scaler
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {
						VDC_set_detect_flag(TRUE);
					}
					up(get_vdc_detectsemaphore());
					*/
					reset_avd_timing_ready();
					Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
				}
				if (display == SLR_MAIN_DISPLAY) {
					drivf_scaler_reset_freerun();
					if(DbgSclrFlgTkr.Main_AutoRunScaler) {
						rtd_pr_vsc_debug("######Need to run scale again#######\n");
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
					}
				} else {
					if(DbgSclrFlgTkr.Sub_AutoRunScaler) {
						rtd_pr_vsc_debug("######Need to run scale again#######\n");
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
					}
				}
                update_vsc_task_status(0, VSC_GET_INFO);
				return FALSE;
			}
			else
			{
				rtd_pr_vsc_info("######get_displayinfo_proc success!!!#######\n");
			}
            update_vsc_task_status(0, VSC_GET_INFO);

			//set scaler path info to memc for video latency result
			if(SLR_MAIN_DISPLAY == display){
				scaler_config_video_latency_info_for_memc(inputType);
				scaler_set_force_update_video_latency(TRUE);
			}

			if(Setup_IMD(Scaler_DispGetInfoPtr()) == FALSE)
			{
				//reset smoothtoggle state
				if(Get_vo_smoothtoggle_timingchange_flag(display)) {
					unsigned int plane = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(display);
					set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
	                           	smooth_toggle_state_info_rpc(display);
				}
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();//Update the search state
				if (display == SLR_MAIN_DISPLAY) {
					if((inputType == KADP_VSC_INPUTSRC_ADC) || (inputType == KADP_VSC_INPUTSRC_HDMI) || ((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV)))
					{//adc hdmi av case
						reset_ARC_cmd(SLR_MAIN_DISPLAY);
					}
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre);
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre);
					up(&SetSubOutPutRegion_Semaphore);
				}
				if(inputType == KADP_VSC_INPUTSRC_ADC)
				{
#ifdef CONFIG_SUPPORT_SRC_ADC
					if (display == SLR_MAIN_DISPLAY) {
						Reset_YPP_Auto_Phase_SmartFit_Setting();//Reset auto phase related setting
					}
					down(get_adc_detectsemaphore());
					reset_adc_timing_ready();
					p_timing = Get_ADC_Dispinfo();
					p_timing->IPH_ACT_WID_PRE = 0;
					p_timing->IPV_ACT_LEN_PRE = 0;
					p_timing->IVFreq = 0;
					p_timing->IHFreq = 0;
					p_timing->IHTotal = 0;
					p_timing->IVTotal = 0;
					p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
						Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						//YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{
					if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) && (display == SLR_MAIN_DISPLAY))
						twopixel_disable_sub_vgip_clock();////disable vgip clock for 4k120
					if((display == SLR_MAIN_DISPLAY) && (vsc_force_rerun_main_scaler == TRUE)){
						rtd_pr_vsc_notice("######run scaler again due to condition changed#######\n");
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
					}
					else{
						if (display == SLR_MAIN_DISPLAY)
						{
							set_hdr_semaless_active(FALSE);
							if(Scaler_InputSrcGetType(display) == _SRC_VO)
							{
								if(drvif_mode_check_dma_onlinemeasure_status())
									hdmi_unstable_reset_timing = FALSE;
							}
							else
							{
								if(drvif_mode_check_onlinemeasure_status(SLR_MAIN_DISPLAY))
									hdmi_unstable_reset_timing = FALSE;
							}
						}
						if(hdmi_unstable_reset_timing)
						{
							reset_hdmi_timing_ready();
						}
						drvif_Hdmi_set_infoframe_thread_stop(FALSE);
						down(get_hdmi_detectsemaphore());
						if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
							if(hdmi_unstable_reset_timing)
							{
								vfe_hdmi_drv_handle_on_line_measure_error(0);
							}
							Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
							HDMI_set_detect_flag(TRUE);
						}
						up(get_hdmi_detectsemaphore());
					}
				}
				else if(inputType == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {

						VDC_set_detect_flag(TRUE);
					}
					up(get_vdc_detectsemaphore());
					*/
					reset_avd_timing_ready();
					Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
				} else if(inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC){
					 //[WOSQRTK-7490]update to add Dolby OTT condition @Crixus 20160414
					if(get_vo_open_smooth_toggle_enable(display) || get_vsc_run_adaptive_stream(display) || ((get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER) && (display == SLR_MAIN_DISPLAY))) {//direct vo and VO change
						rtd_pr_vsc_notice("######run scale again vo change for direct vo#######\n");
						if(display == SLR_MAIN_DISPLAY)
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
						else
							DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
					}
					if (display == SLR_MAIN_DISPLAY)
						DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag
				}
				rtd_pr_vsc_notice("######Channel:%d src:%d Setup_IMD fail!!!#######\n", display, inputType);
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
                //dlg_callback_handler(E_DLG_ENABLE_OSD);
#endif
				if (display == SLR_MAIN_DISPLAY) {
					drivf_scaler_reset_freerun();
					if(DbgSclrFlgTkr.Main_AutoRunScaler) {
						rtd_pr_vsc_debug("######Need to run scale again#######\n");
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
					}
				} else {
					if(DbgSclrFlgTkr.Sub_AutoRunScaler) {
						rtd_pr_vsc_debug("######Need to run scale again#######\n");
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
					}
				}
				return FALSE;
			}
			else
			{
				if(display == SLR_MAIN_DISPLAY)
				{
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ROTATE, FALSE);//disable roate mask
					if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
						twopixel_disable_sub_vgip_clock();////disable vgip clock for 4k120
#ifdef CONFIG_I2RND_ENABLE
					if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_DONE))){
#ifdef CONFIG_MDOMAIN_RESERVED_MEMORY
						//Eric@20171206 send rpc to set i2rnd memory addr
						send_memory_mapping_for_adaptive_streaming();
#endif
						rtd_pr_vsc_emerg("[crixus]I2RND_STAGE_MAIN_I2RND_DONE return 2!!\n");
						return 1;
					}
#endif

				}
				else
				{
                    if(vbe_disp_oled_orbit_enable)
					{
#ifndef UT_flag
						ScalerForceUpdateOrbit(1);
#endif // #ifndef UT_flag
						rtd_pr_vsc_info("####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
					}

					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				}

				if(display == SLR_MAIN_DISPLAY){
					Share_Memory_Set_Scaler_Run_Flag(0);
					if(inputType == KADP_VSC_INPUTSRC_AVD){
						//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
						zoom_clear_input_output_region_record(display);
					}
				}

#ifdef CONFIG_SUPPORT_DOLBY_VSIF
				if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI && get_HDMI_HDR_mode() == HDR_DOLBY_HDMI) {
					drvif_Hdmi_SetDolbyVsifUpdateNoPktThreshold(1);
				}
#endif

				//imd_smooth_toggle_check_pre_double_buffer(display);

				rtd_pr_vsc_info("######Channel:%d src:%d Setup_IMD success!!!#######\n", display, inputType);
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
                //dlg_callback_handler(E_DLG_ENABLE_OSD);
                dlg_callback_handler(E_DLG_SET_PRINT_DLG_MESSAGE_CNT);
#endif
				//Need to check MEMC output BG again for first booting
				if(Scaler_MEMC_Get_First_Run_FBG_enable() || Scaler_MEMC_Get_instanboot_resume_Done() || Scaler_MEMC_Get_snashop_resume_Done()){
					Scaler_MEMC_Set_CheckMEMC_Outbg(TRUE);
				}
				//state_update_disp_info();//Update the active state
				if (display == SLR_MAIN_DISPLAY) {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre);
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre);
					up(&SetSubOutPutRegion_Semaphore);
				}
				if (Scaler_InputSrcGetType(display) != _SRC_VO)
				{

						if (Scaler_InputSrcGetType(display) == _SRC_TV)//ATV no need online interrupt
							drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, FALSE);
						else
						{
#ifdef CONFIG_SUPPORT_SRC_ADC
							if(inputType == KADP_VSC_INPUTSRC_ADC)
							{
								if(check_verify_mode_enable())//adc verify mode
									drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), FALSE, FALSE);
								else
									drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
							}
							else
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
								drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
						}

#ifdef CONFIG_SUPPORT_SRC_ADC
					if (Scaler_InputSrcGetType(display) == _SRC_YPBPR || Scaler_InputSrcGetType(display) == _SRC_VGA) {
						if(YPbPr_Small_Signal_precheck() == FALSE)
							fw_scaler_adc_nolock_wdg_ctrl(display, TRUE);
					}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
				}
				else
				{
#ifdef CONFIG_FORCE_RUN_I3DDMA
					if(display == SLR_MAIN_DISPLAY)
					{
						if(inputType == KADP_VSC_INPUTSRC_ADC)
						{
#ifdef CONFIG_SUPPORT_SRC_ADC
							if(check_verify_mode_enable())
								drvif_mode_dma_onlinemeasure_setting( FALSE, FALSE);//ADC verify mode
							else
								drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//ADC CASE
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
						}
						else if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV))
							drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//AV CASE
						else if(inputType == KADP_VSC_INPUTSRC_HDMI)
							drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//HDMI CASE
					}
#endif
                    //disable vo empty gating, due to vo crop will cause empty gating dead lock
					//if(inputType != KADP_VSC_INPUTSRC_JPEG)
						//enable_vodma_empty_gate(Scaler_Get_CurVoInfo_VoVideoPlane(display));//Enable vo gating
					//Scaler_SendDisplayReadyIrc(Scaler_Get_CurVoInfo_VoVideoPlane(display));/*Send display ready to video FW*/
				}

				if(inputType == KADP_VSC_INPUTSRC_AVD) //Let AVD detect enable
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
					rtd_pr_vsc_info("#####[%s(%d) Scaler_AVD_SetRunSearchState(false)\n",__func__,__LINE__);
					Scaler_AVD_SetRunSearchState(display, false);
				}
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
				if (display == SLR_MAIN_DISPLAY) {
					/*
					frameRates = Scaler_DispGetInputInfo(SLR_INPUT_DTG_MASTER_V_FREQ);
					//rtk_pwm_set_freq(0, frameRates, 2);
					rtk_pwm_set_scaler_source(frameRates, 2);
					rtd_pr_vsc_debug("########Set PWM framerate:%d##########\r\n", frameRates);
					*/
					//vbe_disp_pwm_frequency_update(TRUE);
				}
#endif
				if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
					Scaler_MEMC_SetInOutFrameRateByDisp(SLR_MAIN_DISPLAY);
                }
                        vo_force_24_to_60_flow_control(display, inputType);

				if(display == SLR_MAIN_DISPLAY) {
					if((DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
					{
						if (/*Scaler_InputSrcGetType(display) == _SRC_VO && */DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting)	{
							//This is for smooth togggle presetting
							//state_update_disp_info();//Update the active state
							DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
						#ifdef CONFIG_I2RND_ENABLE
							if (!((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)))
						#endif
								smooth_toggle_preset_info(display);
						}
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
						if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
							return FALSE;
#endif
						down(&SetMainOutPutRegion_Semaphore);
						if(!compare_rerify_vsc_source_num_result(display))
						{
							up(&SetMainOutPutRegion_Semaphore);
							rtd_pr_vsc_notice("### rtk_run_scaler main source already change line:%d###\r\n", __LINE__);
							return FALSE;
						}

						Scaler_DispWindowSet(main_dispwin);

						if(inputType == KADP_VSC_INPUTSRC_AVD)
						{
							if(get_AVD_Input_Source() != _SRC_TV)
							{//AV case
								new_voinfo_flag = 1;
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								winSrcRect = Scaler_DispWindowGet();
								//zoom_imd_smooth_toggle_config(VIDEO_WID_0, main_dispwin.srcx, main_dispwin.srcy, main_dispwin.src_wid, main_dispwin.src_height, ZOOM_DISP);
								zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change

#ifdef SPEEDUP_NEW_SCALER_FLOW
									set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
									avd_start_compensation();//compensation h v start
#endif
								}
						} else {
							if (inputType != KADP_VSC_INPUTSRC_VDEC) {
								new_voinfo_flag = 1;
								Check_smooth_toggle_update_flag(display);
								winSrcRect = Scaler_DispWindowGet();
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change
							} else {
								wait_to_after_avsync_do = 1;
							}
#ifdef SPEEDUP_NEW_SCALER_FLOW
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
#endif
						}
						DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
						DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						rtd_pr_vsc_notice("\r\n#### scaler to run smooth toggle 1 (%d %d %d %d)####\r\n", main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
						up(&SetMainOutPutRegion_Semaphore);
					}else if (DbgSclrFlgTkr.rotate_muteoff_request_flag && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
						rtd_pr_vsc_debug("request mute off run rotate-scaler\n");
						return FALSE;
					}
					if((DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
						if(Scaler_InputSrcGetType(display) == _SRC_VO ){
							if(get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY)) == FALSE) {
								if (DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting) {
									//This is for smooth togggle presetting
									//state_update_disp_info();//Update the active state
									DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
								#ifdef CONFIG_I2RND_ENABLE
									if (!((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)))
								#endif
										smooth_toggle_preset_info(display);
								}
							} else {
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								state_update_disp_info();
								DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag
								return FALSE;
							}

						}
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
						if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
							return FALSE;
#endif
						down(&SetMainOutPutRegion_Semaphore);
						if(!compare_rerify_vsc_source_num_result(display))
						{
							up(&SetMainOutPutRegion_Semaphore);
							rtd_pr_vsc_notice("### rtk_run_scaler main source already change line:%d###\r\n", __LINE__);
							return FALSE;
						}
						Scaler_DispWindowSet(main_dispwin);
						if(((get_rotate_mode(SLR_MAIN_DISPLAY)>=DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)&& (get_rotate_mode(SLR_MAIN_DISPLAY)<=DIRECT_VO_FRAME_ORIENTATION_FLIP_ROTATE_270))||((main_rotate_mode>=DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)&& (main_rotate_mode<=DIRECT_VO_FRAME_ORIENTATION_FLIP_ROTATE_270))){
							up(&SetMainOutPutRegion_Semaphore);
							return FALSE;
						}else{
							DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
							DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
							DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
							DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						}

						if(inputType == KADP_VSC_INPUTSRC_AVD)
						{
							if(get_AVD_Input_Source() != _SRC_TV)
							{//AV case
								new_voinfo_flag = 1;
								winSrcRect = Scaler_DispWindowGet();
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change

#ifdef SPEEDUP_NEW_SCALER_FLOW
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
								avd_start_compensation();//compensation h v start
#endif
							}
						} else {
							if (inputType != KADP_VSC_INPUTSRC_VDEC) {
								new_voinfo_flag = 1;
								Check_smooth_toggle_update_flag(display);
								winSrcRect = Scaler_DispWindowGet();
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change
							} else {
								wait_to_after_avsync_do = 1;
							}
#ifdef SPEEDUP_NEW_SCALER_FLOW
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
#endif
						}
						rtd_pr_vsc_notice("\r\n#### scaler to run smooth toggle 2 (%d %d %d %d)####\r\n", main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
						up(&SetMainOutPutRegion_Semaphore);
					} else if (DbgSclrFlgTkr.rotate_run_scaler_flag && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
						rtd_pr_vsc_debug("request just run rotate-scaler\n");
						return FALSE;
					}
					if(!get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_VDEC) && (is_DTV_flag_get())
						&& (display == SLR_MAIN_DISPLAY)
						&& (!(Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display,SLR_INPUT_IPV_ACT_LEN_PRE) > 2000) || (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display,SLR_INPUT_IPV_ACT_LEN_PRE) == 720))// 4k2k or 720p don't have ip change
						&& ((IoReg_Read32(VODMA_VODMA_V1_DCFG_reg) &VODMA_VODMA_V1_DCFG_vodma_go_mask) &&(IoReg_Read32(VODMA_VODMA_V1INT_reg) &VODMA_VODMA_V1INT_vgip_en_mask))// when vo FREEZE ,don't go this flow
						&& (!(IoReg_Read32(DI_IM_DI_DEBUG_MODE_reg) & DI_IM_DI_DEBUG_MODE_auto_freeze_mask))
#ifdef CONFIG_I2RND_ENABLE
						&& (Scaler_I2rnd_get_timing_enable() == _DISABLE)//i2run case need to	use pst flow. @Crixus 20170418
#endif
					){// if di freeze ,can't run this flow ,cause this flow need apply di double buffer
							/* K5lp No need the dummy smooth toggle. reduce time
							rtd_pr_vsc_emerg("run smooth toggle for DTV I/P exchange after scaler\n");
							run_smoothtoggle_for_ip_change(display);
							*/
					}
				}
#if 0//for sub smooth toggle test
#ifdef CONFIG_DUAL_CHANNEL
				else
				{
					down(&SetSubOutPutRegion_Semaphore);
					//if(DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE)
					{
						//Scaler_DispWindowSet(main_dispwin);
						Scaler_SubDispWindowSet(sub_dispwin);
						rtd_pr_vsc_notice("\r\n####send sub smooth toggle info!!!####\r\n");
						//sub always sends memory info to video after scaler
						smooth_toggle_preset_info(display);

						//DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
					}
					if(!compare_rerify_vsc_source_num_result(display))
					{
						up(&SetSubOutPutRegion_Semaphore);
						rtd_pr_vsc_notice("### rtk_run_scaler sub source already change line:%d###\r\n", __LINE__);
						return FALSE;
					}
					if((inputType != KADP_VSC_INPUTSRC_AVD) || (_SRC_TV != get_AVD_Input_Source()))
					{
						if(((DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) || (DbgSclrFlgTkr.Sub_Run_Scaler_flag == TRUE)) && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
						{
							if(decide_run_sub_smoothtoggle_case())
							{
								set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
								zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, hal_sub_InputRegionType, sub_input_size, sub_input_timing, sub_dispwin);
								DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
								DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
							}
							else
							{
								Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								state_update_disp_info();
								reset_any_srcrect(&sub_dispwin_pre);
								up(&SetSubOutPutRegion_Semaphore);
								rtd_pr_vsc_notice("####(%d) got new output. need to run scaler again ####\n", __LINE__);
								return FALSE;
							}
						}
					}
					up(&SetSubOutPutRegion_Semaphore);
				}
#endif
#endif
			}

#if(VSC_PROFILE == 1)
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_pr_vsc_debug("\nVSC VSC_CONNECT time=%d ms\n",(after_time-before_time));
#endif


#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
			if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV) && (display == SLR_MAIN_DISPLAY))
			{//current smooth toggle is at video fw, so need alwasy to call smooth_toggle_preset_info
				if (/*Scaler_InputSrcGetType(display) == _SRC_VO && */DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting && (display == SLR_MAIN_DISPLAY)){
				//This is for smooth togggle presetting
					DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
					smooth_toggle_preset_info(display);
				}
				return FALSE;//no need to do forcebg. we always to mute off at smooth toggle
			}
#endif



			if (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
				//Avoid online interrupt occur
//				if(Scaler_InputSrcGetType(display) == _SRC_TV) {
				//if((Scaler_InputSrcGetType(display) == _SRC_TV)||(Scaler_InputSrcGetType(display) == _SRC_CVBS)) {

#ifdef SPEEDUP_NEW_SCALER_FLOW
				if((inputType == KADP_VSC_INPUTSRC_AVD) && (_SRC_TV == get_AVD_Input_Source()))
#else
				if(inputType == KADP_VSC_INPUTSRC_AVD)//need to check
#endif
				{

#ifdef CONFIG_ENABLE_VD_27MHZ_MODE


#ifdef CONFIG_SDNR_CROP

#else
					//if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
					if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode(display))
					{
						VIDEO_RECT_T inregion_avd;
						VIDEO_RECT_T outregion_avd;
						rtk_hal_vsc_GetOutputRegion(display, &outregion_avd);
						Scaler_CalWindowZoominForAVD(display, &inregion_avd, &outregion_avd);

						rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
						Scaler_DispWindowZoominForAVD(display, inregion_avd, outregion_avd,FALSE);
						rtd_pr_vsc_debug("&&&& Scaler_DispWindowZoominForAVD()\n");
						//rtd_pr_vsc_emerg( "&&&& Scaler_DispWindowZoominForAVD()\n");
					}
#endif

#endif


					if (FALSE == CheckAVDandWebOSInfo(display))
					{
						rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
						rtd_pr_vsc_debug("CheckAVDandWebOSInfo() fail\n");

						if (0xff == DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount)
						{
							rtd_pr_vsc_debug("Set DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0\n");
							DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0;
						}

						DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount++;

						if(display == SLR_MAIN_DISPLAY)	{
							if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE && DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount < CHECK_AVD_WEBOS_INFO_TIMEOUT){
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
								return FALSE;
							}
							else
							{
								rtd_pr_vsc_debug("DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount timeout\n");
								DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
							}
						} else {
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE && DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount < CHECK_AVD_WEBOS_INFO_TIMEOUT){
									DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
									return FALSE;
							}
							else
							{
								rtd_pr_vsc_debug("DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount timeout\n");
								DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
							}
						}
					}
					else
					{
						rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
						rtd_pr_vsc_debug("CheckAVDandWebOSInfo ok, DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount=%d\n", DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount);
						DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
					}


					rtd_pr_vsc_debug("Cur VD stage=%x, SetWinBlank VD stage=%x\n", Scaler_AVD_GetDetectStage(), DbgSclrFlgTkr.g_ucVDCDetectStage);
					rtd_pr_vsc_debug("DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=%d\n", DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount);

					//rtd_pr_vsc_emerg( "Cur VD stage=%x, SetWinBlank VD stage=%x\n", Scaler_AVD_GetDetectStage(), DbgSclrFlgTkr.g_ucVDCDetectStage);
					//rtd_pr_vsc_emerg( "DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=%d\n", DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount);

					// The timing info is changed from SetOutputRegion to SetWinBlank, therefore avoid to clear ForceBg
					if ((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL)
						&& (DbgSclrFlgTkr.g_ucVDCDetectStage != VDC_DETECT_STAGE_FINAL)
						&& (get_AVD_Input_Source() == _SRC_TV)
						&& DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount  == 1)
					{
						rtd_pr_vsc_info("In ATV, The timing info is changed between SetWinBlank and Scaler unmute video, therefore avoid to clear ForceBg\n");

						if(display == SLR_MAIN_DISPLAY){
							if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
							return FALSE;
						} else {
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE)
								DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
							return FALSE;
						}
					}

					if(wait_atv_stable_for_bg(display,__func__,__LINE__) == FALSE)
					{
						if((get_AVD_Input_Source() != _SRC_TV) || (display == SLR_SUB_DISPLAY)) {//For KTASKWBS-5200
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						if(display == SLR_MAIN_DISPLAY)	{
							if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
								return FALSE;
							}
							if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
								&&(get_AVD_Input_Source() == _SRC_TV)
								&&((drvif_module_vdc_GetLockStatus() == 0)||(drvif_module_vdc_OutputStable()==FALSE)||(Scaler_AVD_GetDetectStage() != VDC_DETECT_STAGE_FINAL))
								&&(0 == drvif_video_status_reg(VDC_no_signal))){
								rtd_pr_vsc_info("######[%s(line:%d)]fast zapping, flicker garbage.#####\n",__FUNCTION__, __LINE__);
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
								return FALSE;
							}
						} else {
							if((DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && (DbgSclrFlgTkr.Sub_Output_Set_flag  || DbgSclrFlgTkr.Sub_Run_Scaler_flag)) {
								DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
								return FALSE;
							}
						}
					}

					if ((get_AVD_Input_Source() == _SRC_TV)
						&&(Scaler_AVD_GetVDPreMode() == _MODE_UNKNOWN)
						&&(1 == drvif_module_vdc_GetLockStatus())
						&&(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (display == SLR_MAIN_DISPLAY)){
						rtd_pr_vsc_info("######[%s(line:%d)]fast zapping, flicker garbage.#####\n",__FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE; // Set output again, switch channel
						return FALSE;
					}
				}
#ifdef SPEEDUP_NEW_SCALER_FLOW
				else if((inputType == KADP_VSC_INPUTSRC_AVD) && (_SRC_TV != get_AVD_Input_Source()))
				{//av condition
					if(wait_atv_stable_for_bg(display,__func__,__LINE__) == FALSE)
					{
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
							reset_avd_timing_ready();
							Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/

					}

				}
#endif
				else if(inputType == KADP_VSC_INPUTSRC_VDEC)
				{
					int port = Get_DisplayMode_Port(display);
					int vo_timeout = 30;
                                	int filmDetect_timeout = FILM_DETECT_TO;
					unsigned int input_len_tmp = 0;
					unsigned int vo_len_tmp = 0;
					if(display == SLR_MAIN_DISPLAY) {
						if(Scaler_DispGetInputInfoByDisp(Get_DisplayMode_Port(display), SLR_INPUT_VO_SOURCE_TYPE) != 1) {
						// [K5LG-828] wait for film mode detect done
						unsigned int stc = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
						while(((get_vo_avsync_flag(port) == FALSE) && vo_timeout)|| ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout))
						{
							vo_timeout -- ;
							filmDetect_timeout--;
							if(DbgSclrFlgTkr.Main_Scaler_Stop_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag)
								break;
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								break;
							msleep(1);

						}
						if(filmDetect_timeout != FILM_DETECT_TO)
						    rtd_pr_vsc_notice("[FILM] Disp[%d] P[%d] Wait Detect Done[%d]=%d ms\n", display, port, filmDetect_timeout, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - stc)/90);

						rtd_pr_vsc_notice("\r\n### main vo wait sync & film detect done timeout:%d, %d####\r\n", vo_timeout, filmDetect_timeout);
						}
						if (wait_to_after_avsync_do) {
							wait_to_after_avsync_do = 0;
							down(&SetMainOutPutRegion_Semaphore);
							Scaler_DispWindowSet(main_dispwin);
							if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag)
							{
									DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
									rtd_pr_vsc_info("clear Main_smooth_toggle_set_flag\n");
							}
							if(DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off) {
								DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off=FALSE;
									rtd_pr_vsc_info("clear Main_run_smooth_toggle_from_mute_off\n");
							}
							up(&SetMainOutPutRegion_Semaphore);
							Check_smooth_toggle_update_flag(display);
							winSrcRect = Scaler_DispWindowGet();

							if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
								Convert_Timing_To_fs_Depend_datafs(display);
								down(&SetMainOutPutRegion_Semaphore);
								input_len_tmp = main_input_size.src_height;
								up(&SetMainOutPutRegion_Semaphore);

								down(get_vo_infosemaphore());
								vo_len_tmp =  Scaler_VOInfoPointer(port)->v_length;
								up(get_vo_infosemaphore());
								if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
									vo_len_tmp = vo_len_tmp * 2;
								}
								if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_DISP_WIN){
									/*apative input case need convert  input_len_tmp*/
									input_len_tmp = ((Scaler_VOInfoPointer(port)->progressive ? Scaler_VOInfoPointer(port)->src_v_len : 2*Scaler_VOInfoPointer(port)->src_v_len) *main_input_size.src_height * 100/_DISP_LEN + 50)/100;
								}
								if (input_len_tmp !=vo_len_tmp)
									zoom_clear_input_output_region_record(display); //clear size to run vo smooth toggle
							}

							zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
							Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change
							new_voinfo_flag = 1;
						}
						if((DbgSclrFlgTkr.Main_smooth_toggle_set_flag) || (DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off))
						{
							unsigned int input_len_tmp = 0;
							unsigned int vo_len_tmp = 0;
							new_voinfo_flag = 1;
							down(&SetMainOutPutRegion_Semaphore);
							Scaler_DispWindowSet(main_dispwin);
							DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
							DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
							up(&SetMainOutPutRegion_Semaphore);
							winSrcRect = Scaler_DispWindowGet();

							if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
								Convert_Timing_To_fs_Depend_datafs(display);
								down(&SetMainOutPutRegion_Semaphore);
								input_len_tmp = main_input_size.src_height;
								up(&SetMainOutPutRegion_Semaphore);

								down(get_vo_infosemaphore());
								vo_len_tmp =  Scaler_VOInfoPointer(port)->v_length;
								up(get_vo_infosemaphore());
								if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
									vo_len_tmp = vo_len_tmp * 2;
								}
								if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_DISP_WIN){
									/*apative input case need convert  input_len_tmp*/
									input_len_tmp = ((Scaler_VOInfoPointer(port)->progressive ? Scaler_VOInfoPointer(port)->src_v_len : 2*Scaler_VOInfoPointer(port)->src_v_len) *main_input_size.src_height * 100/_DISP_LEN + 50)/100;
								}
								if (input_len_tmp !=vo_len_tmp)
									zoom_clear_input_output_region_record(display);//clear size to run vo smooth toggle
							}
#ifdef SPEEDUP_NEW_SCALER_FLOW
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//disable arc ready mask. because we will run smooth toggle below
#endif
							smooth_toggle_preset_info(display);
							Check_smooth_toggle_update_flag(display);
							zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
							rtd_pr_vsc_notice("\r\n####scaler to run smooth toggle 3!!!####\r\n");
							Check_smooth_toggle_update_flag(display);
						}
					}
#ifdef CONFIG_DUAL_CHANNEL
					else
					{
						if(Scaler_DispGetInputInfoByDisp(Get_DisplayMode_Port(display), SLR_INPUT_VO_SOURCE_TYPE) != 1) {
						// [K5LG-828] wait for VO film mode detect done
						unsigned int stc = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
						while(((get_vo_avsync_flag(port) == FALSE) && vo_timeout) || ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout))
						{
							vo_timeout -- ;
							filmDetect_timeout--;
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag || DbgSclrFlgTkr.Sub_Run_Scaler_flag)
								break;
							if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								break;
							msleep(1);

						}
						if(filmDetect_timeout != FILM_DETECT_TO)
						    rtd_pr_vsc_notice("[FILM] Disp[%d] P[%d] Wait Detect Done[%d]=%d ms\n", display, port, filmDetect_timeout, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - stc)/90);

						rtd_pr_vsc_notice("\r\n### sub vo wait sync & film detect done timeout:%d, %d####\r\n", vo_timeout, filmDetect_timeout);
						}
					}
#endif
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{
					drvif_Hdmi_WatchDogApply(_ENABLE, HDMI_WD_VSC_COND);
				}

				if((get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) && (new_voinfo_flag == 0) && (display == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_FRAMESYNC) && (!DbgSclrFlgTkr.Main_smooth_toggle_set_flag) && (!DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag)) {
					unsigned int input_wid_tmp = 0;
					unsigned int input_len_tmp = 0;
					unsigned int input_x_tmp = 0;
					unsigned int vo_len_tmp = 0;
					unsigned int vo_src_v_len_tmp = 0;

					down(get_vo_infosemaphore());
					vo_len_tmp =  Scaler_VOInfoPointer(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))->v_length;
					vo_src_v_len_tmp =  Scaler_VOInfoPointer(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))->src_v_len;
					up(get_vo_infosemaphore());

					down(&SetMainOutPutRegion_Semaphore);
					input_wid_tmp = main_input_size.src_wid;
					if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_TIMING){
						input_len_tmp = main_input_size.src_height;
					}else if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_DISP_WIN){
						if(_DISP_LEN != 0)
							input_len_tmp = (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display,SLR_INPUT_IPV_ACT_LEN_PRE)*(Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display, SLR_DISP_INTERLACE)?2:1) *main_input_size.src_height * 100/_DISP_LEN + 50)/100;
						else
							rtd_pr_vsc_emerg( "\r\n### _DISP_LEN is zero !####\r\n");
					}else{ // for INPUT_BASE_ON_HAL_ORIGINAL_INPUT
						if(vo_src_v_len_tmp != 0)
							input_len_tmp = (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display,SLR_INPUT_DI_LEN) *main_input_size.src_height * 100/vo_src_v_len_tmp + 50)/100;
						else
							rtd_pr_vsc_emerg( "\r\n### vo src_v_len is zero !####\r\n");
					}
					input_x_tmp = main_input_size.srcx;
					Scaler_DispWindowSet(main_dispwin);
					up(&SetMainOutPutRegion_Semaphore);



					if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
						vo_len_tmp = vo_len_tmp * 2;
					}
					if (inputType== KADP_VSC_INPUTSRC_AVD) {
						input_wid_tmp = Scaler_CalAVD27MWidth(display,input_wid_tmp);
						input_x_tmp = Scaler_CalAVD27MWidth(display,input_x_tmp);
					}
					if (input_len_tmp !=vo_len_tmp) {
						rtd_pr_vsc_emerg( "\r\n### before open bg, smoothtoggle will let vo do overscan####\r\n");
						Check_smooth_toggle_update_flag(display);
					 	smooth_toggle_preset_info(display);
						winSrcRect = Scaler_DispWindowGet();
						zoom_clear_input_output_region_record(display);
						zoom_imd_smooth_toggle_config(display, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
						Check_smooth_toggle_update_flag(display);
					}
				}

				if(display == SLR_SUB_DISPLAY){
				       if((DbgSclrFlgTkr.Sub_Output_Set_flag || DbgSclrFlgTkr.Sub_Run_Scaler_flag) && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE)){
						rtd_pr_vsc_notice("####(%d) got new output. need to run scaler again ####\n", __LINE__);
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						state_update_disp_info();
						down(&SetSubOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
				        reset_any_srcrect(&sub_dispwin_pre);
				        up(&SetSubOutPutRegion_Semaphore);
						return FALSE;
					}
				}

				if((KADP_VSC_INPUTSRC_AVD == inputType) && (_SRC_TV == get_AVD_Input_Source()))
				{
					if(fwif_color_GetAutoMAFlag() == 0){
						fwif_color_SetAutoMAFlag(1);
					}

					// Ready to clear forceBG, finish channel change
					DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart = FALSE;
					DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount = 0;
					//rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
					rtd_pr_vsc_debug("Ready to Clear forceBG, set DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart=0\n");
				}


#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				// FixMe, 20170602
				//rtd_pr_vsc_debug("[HDR10] src/st/ret=%d/%d/%d\n", Scaler_InputSrcGetType(display), Scaler_HDR10_Hdmi_Get_Detect_Status(), hdmi_is_drm_info_ready());
#endif
#if 0//def CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
				rtd_pr_vsc_debug("[DolbyVision] src/st/ret=%d/%d/%d\n", Scaler_InputSrcGetType(display), Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status(), Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result());
				if((Scaler_InputSrcGetType(display) == _SRC_HDMI)
					&& (Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status() != SLR_DV_HDMI_DETECT_OFF)
					&& Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
				{
					rtd_pr_vsc_debug("[DolbyVision] Skip disable BG...\n");
				}else if((Scaler_InputSrcGetType(display) == _SRC_VO)
					&& (Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status() == SLR_DV_HDMI_DETECT_FOUND_CRC))
				{
					rtd_pr_vsc_debug("[DolbyVision] disable BG later...\n");
				}else
#endif
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				if((Scaler_InputSrcGetType(display) == _SRC_HDMI)
					&& (Scaler_Hdmi_DM_Get_Status() != SLR_HDMI_DM_CLOSE))
					// FixMe, 20170602
					// && hdmi_is_drm_info_ready())
				{
					rtd_pr_vsc_debug("[HDR10] Skip disable BG...\n");
				}else if((Scaler_InputSrcGetType(display) == _SRC_VO)
					&& (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT))
				{
					rtd_pr_vsc_debug("[DolbyVision] disable BG later...\n");
				}else
#endif
				if ((get_HDMI_HDR_mode() == HDR_DOLBY_HDMI && (inputType == KADP_VSC_INPUTSRC_HDMI))
					&& (display == SLR_MAIN_DISPLAY)) {
#ifdef CONFIG_RTK_KDRV_DV
					unsigned char cnt = 50;
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
					while (dolby_adapter_get_g_picModeUpdateFlag() && !DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
#else
					while (g_picModeUpdateFlag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
#endif
						if (cnt == 0)
                        {
                            if (get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER && inputType == KADP_VSC_INPUTSRC_VDEC) {
								/* force set Normal_TEST() */
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
								dolby_adapter_set_g_picModeUpdateFlag(0xFFFFFFFF);
#else
                                g_picModeUpdateFlag = 0xFFFFFFFF;
#endif
							}
                            break;
                        }

						cnt--;
						msleep(1);
					}
#endif
				}
                else if (((get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER && inputType == KADP_VSC_INPUTSRC_VDEC))
						&& (display == SLR_MAIN_DISPLAY))
				{
					    wait_event_freezable_timeout(dolby_apply_wq, dolby_apply_done, 2 * HZ);
				}

				//Race condition isse for HDR HDMI aspect ratio faster changing @Crixus 20160412
				if((get_HDMI_HDR_mode() == HDR_HDR10_HDMI) && (inputType == KADP_VSC_INPUTSRC_HDMI)
					&& (DbgSclrFlgTkr.Main_Run_Scaler_flag == TRUE) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)){
					rtd_pr_vsc_debug("WebOS will run scaler again, do not disable FBG[%s]:%d\n", __FUNCTION__, __LINE__);
				}
				else{
					if(display == SLR_MAIN_DISPLAY) {
						DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag. Means webos can mute off directly
					}
#ifdef CONFIG_I2RND_ENABLE
					//if i2rnd and multivie case, do not disable fbg in sub scaler. @Crixus 20160728
					if((display == SLR_SUB_DISPLAY) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);
						up(get_forcebg_semaphore());
						rtd_pr_vsc_emerg("[I2RND]Do not disable fbg in sub scaler.\n");
					}
					else if((display == SLR_SUB_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_CONNECT)){
						//Eric@0802 if i2rnd dualvo case, do not disable fbg in sub scaler
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);
						up(get_forcebg_semaphore());
						rtd_pr_vsc_emerg("[I2RND] DualVO sub scaler path, do not disable fbg!!\n");
					}
					else
#endif
					{
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
						if(display == SLR_MAIN_DISPLAY)
						{
							if(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
							{//means not run arc yet
								//down(&SetMainOutPutRegion_Semaphore);
								if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
								{
									down(&new_input_output_main_sem);
									reset_pst_sharemem_buffer(SLR_MAIN_DISPLAY);//reset pst buffer data
									set_pst_active_state(SLR_MAIN_DISPLAY, TRUE);//update to enable PST
									up(&new_input_output_main_sem);
								}
								//up(&SetMainOutPutRegion_Semaphore);
							}
						}
#endif
						//HDMI game mode scaler flow, disable forcebg after game mode task done.
						if(((inputType == KADP_VSC_INPUTSRC_HDMI) || (inputType == KADP_VSC_INPUTSRC_VDEC)) && drv_memory_get_low_delay_game_mode_dynamic() && game_mode_ignore_cmd_check ){
							//rtd_pr_vsc_notice("[GAME MODE] HDMI/VDEC wait game mode ready  %d\n",game_mode_wait_timeout);
							while(game_mode_wait_timeout){
								if(!game_mode_ignore_cmd_check){
									break;
								}
								game_mode_wait_timeout--;
								//wait 10ms
								msleep(0);
							}
							//rtd_pr_vsc_notice("[GAME MODE] HDMI/VDEC wait game mode done  %d\n",game_mode_wait_timeout);
							if(game_mode_wait_timeout == 0)
								rtd_pr_vsc_notice("[GAME MODE] HDMI/VDEC game mode wait timeout = %d\n",game_mode_wait_timeout);
						}
                        if(display == SLR_MAIN_DISPLAY)
						{
							if(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY) && vbe_disp_oled_orbit_enable)
							{
#ifndef UT_flag
								ScalerForceUpdateOrbit(1);
#endif // #ifndef UT_flag
								rtd_pr_vsc_info("####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
							}
						}
						trigger_mute_off(display, 1);

						if((drv_memory_get_low_delay_game_mode_dynamic() == drv_memory_get_game_mode_flag()) && (game_mode_ignore_cmd_check == _ENABLE))
							game_mode_ignore_cmd_check = _DISABLE;
					}
					Scaler_MEMC_fbg_control(__func__,__LINE__);

				if ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) {
					pr_info("after scaler, memc unfreeze ATV\n");
					MEMC_Lib_Freeze(0);
					DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = TRUE;
				}

#ifdef CONFIG_SUPPORT_SRC_VGA //for first-timing adjust
					if((inputType == KADP_VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_VGA) && (display == SLR_MAIN_DISPLAY)){

						rtd_pr_vsc_notice("#####[%s(%d)]check_vga_auto_calib_status=%d #####\n", __func__, __LINE__, check_vga_auto_calib_status());
						if(!check_vga_auto_calib_status())
						{
							down(get_adc_adjustsemaphore());
							Scaler_AdjustPCAuto(display);
							up(get_adc_adjustsemaphore());
						}
					}
#endif



				}

				if(!drv_memory_get_low_delay_game_mode_dynamic() && display ==SLR_MAIN_DISPLAY)	//WOSQRTK-10203 already done in Scaler_disp_setting if game mode (patch for QA stage)
				{
					Scaler_MEMC_SetInOutFrameRateByDisp(display);
				}


#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
				cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90 - cost_time;
				rtd_pr_vsc_emerg( "\r\n####vsc cost time:%d ms after mute off####\r\n", cost_time);
#endif
				//state_update_disp_info();//Update the active state
				if(Scaler_InputSrcGetType(display) == _SRC_VO) {
					Scaler_SendDisplayReadyIrc(Scaler_Get_CurVoInfo_VoVideoPlane(display));/*Send display ready to video FW*/
				}
			}

			if (/*Scaler_InputSrcGetType(display) == _SRC_VO && */DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting && (display == SLR_MAIN_DISPLAY)){
			//This is for smooth togggle presetting
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
			#ifdef CONFIG_I2RND_ENABLE
					if (!((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)))
			#endif
				smooth_toggle_preset_info(display);
			}
			else if(Scaler_InputSrcGetType(display) == _SRC_VO && (display == SLR_SUB_DISPLAY))
			{
				smooth_toggle_preset_info(display);
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
				down(&SetSubOutPutRegion_Semaphore);
				if(!DbgSclrFlgTkr.Sub_Scaler_Stop_flag && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					down(&new_input_output_sub_sem);
					reset_pst_sharemem_buffer(SLR_SUB_DISPLAY);//reset pst buffer data
					set_pst_active_state(SLR_SUB_DISPLAY, TRUE);//update to enable PST
					up(&new_input_output_sub_sem);
				}
				up(&SetSubOutPutRegion_Semaphore);
#endif
			}

/////////////////////////////////////////
			break;
		}
		case KADP_VSC_OUTPUT_VENC_MODE:
		{

			if(Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT) == 0)
			{
				rtd_pr_vsc_debug("\r\n####Go VencMode Src:%d!!!#####\r\n", VencModeInputInfo.type);
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();
				rtd_pr_vsc_debug("\r\n######set search state#####\r\n");
			}
			else
			{
				rtd_pr_vsc_debug("######get_displayinfo_proc success!!!#######\n");
			}

#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
 			if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){//capture progressive video data

			}
			else{
				drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
			}

			drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif
#else
			drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif



			if(get_displayinfo_proc(display, (VSC_INPUT_TYPE_T)inputType)== FALSE)
			{
				//rtd_pr_vsc_debug("######get_displayinfo_proc fail fail fail!!!#######\n");
				return FALSE;
			}

			if(Setup_IMD(Scaler_DispGetInfoPtr())==FALSE)
			{
				if(inputType == KADP_VSC_INPUTSRC_ADC)
				{
#ifdef CONFIG_SUPPORT_SRC_ADC
					down(get_adc_detectsemaphore());
					reset_adc_timing_ready();
					p_timing = Get_ADC_Dispinfo();
					p_timing->IPH_ACT_WID_PRE = 0;
					p_timing->IPV_ACT_LEN_PRE = 0;
					p_timing->IVFreq = 0;
					p_timing->IHFreq = 0;
					p_timing->IHTotal = 0;
					p_timing->IVTotal = 0;
					p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
					if(get_ADC_Global_Status() == SRC_CONNECT_DONE) ADC_set_detect_flag(TRUE);
					up(get_adc_detectsemaphore());
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
				}
				rtd_pr_vsc_emerg( "######VSC_OUTPUT_VENC_MODE Setup_IMD fail fail!!!#######\n");
				return FALSE;
			}
			else
			{
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
				if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)){
					rtd_pr_vsc_emerg("apvr flow finish, so didnot re-run sub path\n");
					break;
				}
#endif
#endif
				rtd_pr_vsc_emerg("######VSC_OUTPUT_VENC_MODE Channel:%d src:%d Setup_IMD success!!!#######\n", display, inputType);
				//imd_smooth_toggle_check_pre_double_buffer(display);
				//state_update_disp_info();//Update the active state

				if(inputType == KADP_VSC_INPUTSRC_AVD) //Let AVD detect enable
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
					rtd_pr_vsc_info("#####[%s(%d)] Scaler_AVD_SetRunSearchState(false)\n",__func__,__LINE__);
					Scaler_AVD_SetRunSearchState(display, false);
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
					//I2rnd sub=>vo RPC
					if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){
						vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
						rtd_pr_vsc_emerg("[frank]APVR step 2@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
						Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
						i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
						drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, inputType);
						drivf_Sub_I2rnd_SetupVODMA();
						//i2rnd_debug();
						rtd_pr_vsc_emerg("[frank]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
					}
#endif
#endif
				}

				if (Scaler_InputSrcGetType(display) != _SRC_VO)
				{
						if (Scaler_InputSrcGetType(display) == _SRC_TV)//ATV no need online interrupt
							drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, FALSE);
						else
							drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
				}
			}
			break;
		}

		default:

			break;
	}

	return TRUE;
}
unsigned char (*rtk_run_scaler)(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType, KADP_VSC_OUTPUT_MODE_T outputMode) = rtk_run_scaler_impl;

#ifdef CONFIG_I2RND_ENABLE
unsigned char check_Sub_I2rnd_done(void)
{
	if ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))
		return TRUE;
	else
		return FALSE;
}
#endif

void set_frc_style_input_fast_than_display(bool enable)
{
	unsigned char frc_style = (enable) ? 1 : 0;

	mdomain_disp_ddr_mainsubctrl_RBUS disp_mainsubctrl;
	mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl;

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	if(ddr_mainctrl.main_frc_style == frc_style)
		return;//no need to do

	disp_mainsubctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	disp_mainsubctrl.disp1_double_enable = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, disp_mainsubctrl.regValue);

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	ddr_mainctrl.main_frc_style = frc_style;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, ddr_mainctrl.regValue);

	disp_mainsubctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	disp_mainsubctrl.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, disp_mainsubctrl.regValue);
}

unsigned char get_frc_style_input_fast_than_display(void)
{
	mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl;

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	return ddr_mainctrl.main_frc_style;
}
unsigned char scaler_get_current_framesync_mode(unsigned char display)
{
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	mdomain_disp_ddr_subctrl_RBUS mdomain_disp_ddr_subctrl_reg;

	if(display==SLR_MAIN_DISPLAY){
		mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
		if(mdomain_disp_ddr_mainctrl_reg.main_source_sel == 0x3)
			return TRUE; //data fs
	}
	else if (display==SLR_SUB_DISPLAY){
		mdomain_disp_ddr_subctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_SubCtrl_reg);
		if(mdomain_disp_ddr_subctrl_reg.sub_source_sel == 0x3)
			return TRUE; //data fs
	}

	return FALSE; ////data frc
}

unsigned char scaler_HDMI_signal_error_handler(unsigned char display){
	extern unsigned char decide_do_hdmi_error_handler(void);
	set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
	mute_control(display, TRUE);/*Auto BG*/

	drvif_mode_onlinemeasure_setting(display, _SRC_HDMI, FALSE, FALSE);//Disable online measure watchdog and interrupt
		drvif_mode_disableonlinemeasure(display);//Disable online measure

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
		rtd_pr_vsc_debug("\n HDMI Interrupt already happen\n");
		return TRUE;
	}
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
	if (display == SLR_MAIN_DISPLAY) {
		drivf_scaler_reset_freerun();
	}
	reset_hdmi_timing_ready();
	drvif_Hdmi_set_infoframe_thread_stop(FALSE);

	down(get_hdmi_detectsemaphore());
	if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
#ifndef CONFIG_ENABLE_HDMI_PATTERN
		if(decide_do_hdmi_error_handler())
			vfe_hdmi_drv_handle_on_line_measure_error(0);
#endif
		Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
		HDMI_set_detect_flag(TRUE);
	}
	up(get_hdmi_detectsemaphore());
	return FALSE;
}

unsigned char scaler_VDEC_signal_error_handler(unsigned char display){
	unsigned char inputPort = 0;
	unsigned char plane = 0;//get_vo_plane_flag(display);

	if (display == SLR_MAIN_DISPLAY) {
			if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				inputPort = DisplayModeInputInfo.resourceIndex;
			}
			else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				inputPort = VencModeInputInfo.resourceIndex;
			}
			else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				inputPort = MemoryModeInputInfo.resourceIndex;
			}
			else
			{
				return false;
			}
		}
#ifdef CONFIG_DUAL_CHANNEL
		else if (display == SLR_SUB_DISPLAY){
			if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				inputPort = Sub_DisplayModeInputInfo.resourceIndex;
			}
			else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				inputPort = Sub_VencModeInputInfo.resourceIndex;
			}
			else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				inputPort = Sub_MemoryModeInputInfo.resourceIndex;
			}
			else
			{
				return false;
			}
			//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);//Remove by Will
		}
#endif
	plane = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);//Avoid to print port error

	down(get_vo_infosemaphore());
	if(get_vo_change_flag(inputPort) == TRUE)
	{
		up(get_vo_infosemaphore());
		if(display == SLR_MAIN_DISPLAY) {
			down(&SetMainOutPutRegion_Semaphore);
			reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
			up(&SetMainOutPutRegion_Semaphore);
		} else {
			down(&SetSubOutPutRegion_Semaphore);
			reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
			up(&SetSubOutPutRegion_Semaphore);
		}
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
		state_update_disp_info();
		return TRUE;
	}
	Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
	if (get_vo_run_smooth_toggle_enable(display) && get_vo_imd_disable(display)) {
		set_vo_imd_disable(_DISABLE,display);
	}
	up(get_vo_infosemaphore());

	//Set to search state to avoid race condition with game mode task
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
	state_update_disp_info();

	//disable onms
	drvif_mode_onlinemeasure_setting(display, _SRC_VO, FALSE, FALSE);//Disable online measure watchdog and interrupt
	drvif_mode_disableonlinemeasure(display);//Disable online measure

	Check_smooth_toggle_update_flag(display);
	if(Get_vo_smoothtoggle_timingchange_flag(display))  //framesync fail need vo smooth toggle reset to init
	{
		set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
		smooth_toggle_state_info_rpc(display);
	}
	return FALSE;
}

void request_vo_info(void)
{
	int ret = 0;

	set_force_change_vo_flag(SLR_MAIN_DISPLAY, TRUE);
	ret = Scaler_SendRPC(SCALERIOC_REQUESTVOINFO, VO_VIDEO_PLANE_V1, 1);
	if (ret  < 0) {
		rtd_pr_vsc_info("[%s:%d] SCALERIOC_GETVOINFO %d\n", __func__, __LINE__, ret);
	}

	ret = Scaler_SendRPC(SCALERIOC_GETVOINFO, VO_VIDEO_PLANE_V1, 1);
	if (ret  < 0) {
		rtd_pr_vsc_info("[%s:%d] SCALERIOC_GETVOINFO%d\n", __func__, __LINE__, ret);
	}
}

unsigned char rtk_check_signal(unsigned char display)
{/*This is for source check signal stable or not. Must be _MODE_STATE_ACTIVE*/
	unsigned char result;
	KADP_VSC_OUTPUT_MODE_T outputMode;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;
	unsigned int inputVfreq = 0;
	//unsigned int input_isInterlace = 0;
/*
	unsigned char frame_idicator=0;
	unsigned char b_run_frame_check=0;
	ppoverlay_dtg_frame_cnt1_RBUS dtg_frame_cnt1_reg;
	ppoverlay_new_meas1_linecnt_real_RBUS new_meas1_linecnt_real_reg;
	vgip_vgip_chn1_lc_RBUS vgip_chn1_lc_reg;
	unsigned int count2 = 0x3fffff;
	unsigned int ch1_line_cnt_lower = 0;
	unsigned int ch1_line_cnt_upper = 0;

	//check fix last line lock status @Crixus 20151219
	ppoverlay_fix_last_line_mode_lock_status_RBUS fix_last_line_mode_lock_status_reg;
//	display_timing_ctrl1_RBUS display_timing_ctrl1_reg;
	extern unsigned char modestate_decide_display_timing(void);
	static UINT8 checkStableCnt=0;
*/
	unsigned char plane = 0;//get_vo_plane_flag(display);

#ifdef _VBY1_TO_HDMI_DIRTY_FIX
	static unsigned char bfirst_boot = 1;
#endif


	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = DisplayModeInputInfo.type;
			inputPort = DisplayModeInputInfo.resourceIndex;
		}
		else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
		}
		else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = MemoryModeInputInfo.type;
			inputPort = MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}

#ifdef _VBY1_TO_HDMI_DIRTY_FIX
		if(bfirst_boot == 1){
			scaler_dtg_reconfig(); //vtotal set 0x8ca during boot up, recover to 0x8c9
			bfirst_boot	= 0;
		}
#endif
		//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//Remove by Will
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}
		//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);//Remove by Will
	}
#endif

#ifdef CONFIG_I2RND_ENABLE
if((VSC_OUTPUT_VENC_MODE_FLAG == TRUE) && (Scaler_I2rnd_get_enable())){
	//Eric@0809
	rtd_pr_vsc_emerg( "[OUTPUT_VENC_MODE] timing framesync!\n");
	modestate_set_fll_running_flag(_DISABLE);
	if(modestate_decide_display_timing() != DISPLAY_MODE_FRAME_SYNC){
		if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
            fwif_color_safe_od_enable(0);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			fwif_color_safe_od_enable(1);
		}
	}
	VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
}
#endif

#if 0
	down(get_scaler_fll_running_semaphore());
	if((display == SLR_MAIN_DISPLAY) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
		if(modestate_get_fll_running_flag()){
			if(checkStableCnt> 2){
				if((modestate_decide_display_timing() == DISPLAY_MODE_NEW_FLL_MODE) &&
					(drvif_scaler_get_display_mode() != DISPLAY_MODE_NEW_FLL_MODE)){
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					//add check frame cnt and add 1 frame delay @Crixus 20151221
					if((inputType == KADP_VSC_INPUTSRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)){
						//if HDMI source, not to run check mode until sync OK @Crixus 20151229
						DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 1;
					}
					if(Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) > 1){
						b_run_frame_check = 1;
						frame_idicator = Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO)-1;
						switch (Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR)) {
							case _MODE_480I:
								ch1_line_cnt_lower = MODE_480I_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_480I_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_480P:
								ch1_line_cnt_lower = MODE_480P_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_480P_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_576I:
								ch1_line_cnt_lower = MODE_576I_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_576I_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_576P:
								ch1_line_cnt_lower = MODE_576P_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_576P_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_720P50:
								ch1_line_cnt_lower = MODE_720P50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_720P50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_720P60:
								ch1_line_cnt_lower = MODE_720P60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_720P60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080I25:// Mode 100: YPbPr 1920x1080ix50HZ (802R)
								ch1_line_cnt_lower = MODE_1080I50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080I50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080I30:// Mode 101: YPbPr 1920x1080ix60HZ (802R)
								ch1_line_cnt_lower = MODE_1080I60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080I60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P50:
								ch1_line_cnt_lower = MODE_1080P50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P60:
								ch1_line_cnt_lower = MODE_1080P60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P23:
							case _MODE_1080P24:
							case _MODE_1080P25:
								ch1_line_cnt_lower = MODE_1080P24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P29:
							case _MODE_1080P30:
								//[KTASK-3997]Modify 1080p30Hz line count setting for 60Hz panel @Crixus 20160527
								if((Get_DISPLAY_REFRESH_RATE() == 60) && (Get_DISPLAY_PANEL_CUSTOM_INDEX() == VBY_ONE_PANEL_LG_4K2K_600M_1S_8L)){
									ch1_line_cnt_lower = MODE_1080P30_FRAME_DELAY_LOWER_BOUNDARY_60HZ_PANEL;
									ch1_line_cnt_upper = MODE_1080P30_FRAME_DELAY_UPPER_BOUNDARY_60HZ_PANEL;
								}
								else{
									ch1_line_cnt_lower = MODE_1080P30_FRAME_DELAY_LOWER_BOUNDARY;
									ch1_line_cnt_upper = MODE_1080P30_FRAME_DELAY_UPPER_BOUNDARY;
								}
								break;
							case _MODE_4k2kP24:
								ch1_line_cnt_lower = MODE_4K2K24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP25:
								ch1_line_cnt_lower = MODE_4K2K24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP30:
								ch1_line_cnt_lower = MODE_4K2K30_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K30_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP50:
								ch1_line_cnt_lower = MODE_4K2K50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP60:
								ch1_line_cnt_lower = MODE_4K2K60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K60_FRAME_DELAY_UPPER_BOUNDARY;
								break;

							default:
								ch1_line_cnt_lower = 0;
								ch1_line_cnt_upper = (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN) * 1 / 4);
							break;
						}
						//rtd_pr_vsc_emerg("\n SLR_INPUT_MODE_CURR = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						//rtd_pr_vsc_emerg("\n ch1_line_cnt_lower = %d, ch1_line_cnt_upper = %d\n", ch1_line_cnt_lower, ch1_line_cnt_upper);
					}
					if(b_run_frame_check == 1){
						dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
						if(dtg_frame_cnt1_reg.uzudtg_input_frame_cnt == (frame_idicator-1)){
							dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
							//make sure that we can have a full porch apply timing change settings
							while((dtg_frame_cnt1_reg.uzudtg_input_frame_cnt != frame_idicator)&& --count2){
								dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
							}
							vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
							if((vgip_chn1_lc_reg.ch1_line_cnt >= ch1_line_cnt_lower) && (vgip_chn1_lc_reg.ch1_line_cnt <= ch1_line_cnt_upper)){
								//change to FLL
								rtd_pr_vsc_debug("### set fll new mode 1.###\n");
								framesync_lastlinefinetune_at_new_mode();
								modestate_set_display_timing(0);
								modestate_set_fll_running_flag(FALSE);
								checkStableCnt=0;
								if(inputType == KADP_VSC_INPUTSRC_HDMI){
									DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 0;
								}
								//rtd_pr_vsc_emerg("\n vgip_chn1_lc_reg.ch1_line_cnt = %d\n", vgip_chn1_lc_reg.ch1_line_cnt);
							}
							if(count2 == 0)
								rtd_pr_vsc_notice("count timeout !!!\n");
						}
					}
					else{
						new_meas1_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas1_linecnt_real_reg);
						if(new_meas1_linecnt_real_reg.memcdtg_line_cnt_rt < 200){
							//change to FLL
							rtd_pr_vsc_debug("### set fll new mode 2.###\n");
							framesync_lastlinefinetune_at_new_mode();
							modestate_set_display_timing(0);
							modestate_set_fll_running_flag(FALSE);
							checkStableCnt=0;
						}
					}
					up(&VSC_Semaphore);
				}
			}else{
				checkStableCnt++;
			}
		}else{

			if(vbe_disp_get_adaptivestream_fs_mode() == 1){
                drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			}
			if(Get_DISPLAY_PANEL_OLED_TYPE()==TRUE){
				if((drv_memory_get_game_mode_dynamic() == _ENABLE)&&(drv_memory_get_game_mode() == TRUE)){
                    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
				}
			}
			checkStableCnt = 0;
			//if source is table, change to false
			if(DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 1){
				DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 0;
			}
		}


		fix_last_line_mode_lock_status_reg.regValue = IoReg_Read32(PPOVERLAY_fix_last_line_mode_lock_status_reg);
		fix_last_line_mode_lock_status_reg.lock_th = 0x800;
		IoReg_Write32(PPOVERLAY_fix_last_line_mode_lock_status_reg, fix_last_line_mode_lock_status_reg.regValue);
#if 0//mark redundaent code
		display_timing_ctrl1_reg.regValue = IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg);
		if((display_timing_ctrl1_reg.disp_fix_last_line == 2) && (fix_last_line_mode_lock_status_reg.t_s != 0)){
			//double buffer D0
			ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			double_buffer_ctrl_reg.dreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);

			display_timing_ctrl1_reg.disp_fix_last_line = 0;
			IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, display_timing_ctrl1_reg.regValue);

			//double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			//double_buffer_ctrl_reg.dreg_dbuf_set = 1;
			//IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);

			//display_timing_ctrl1_reg.disp_fix_last_line = 2;
			//IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, display_timing_ctrl1_reg.regValue);
			rtd_pr_vsc_notice("FLL re-sync!!\n");
			modestate_set_fll_running_flag(TRUE);

			//double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			//double_buffer_ctrl_reg.dreg_dbuf_set = 1;
			//IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
		}
#endif
	}else{
		checkStableCnt = 0;
	}
	up(get_scaler_fll_running_semaphore());
#endif

	//check abnormal dvs flag
	drvif_scaler_check_abnormal_dvs_flag();

	// check IVS over threshold error
	// RL6557-448 add ivs over threshold test function
	//drvif_scaler_check_ivs_over_threshold(TRUE);
#if 0
	//check onlinemeasure flag
	if(Scaler_InputSrcGetMainChType() == _SRC_VO){
		drvif_scaler_check_main_onlinemeasure_flag();
	}
#endif
	qms_notify_memc_input_output_frame_rate();//qms update staus to memc

	if (inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC) {
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)//If get_vo_change_flag() == TRUE, VO info change
		{
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)
		//	static unsigned int hdrCrcErrCnt = 0;
#endif
			plane = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);//Avoid to print port error
			down(get_vo_infosemaphore());
			if(get_vo_change_flag(inputPort) == TRUE)
			{
				up(get_vo_infosemaphore());
				if (Get_vo_smoothtoggle_timingchange_flag(display)) {
	               if(get_vo_run_smooth_toggle_enable(display)) {
#if 0
	                   if (get_vo_imd_disable(display)) {
	                       set_vo_change_flag(inputPort, FALSE);
	                       set_vo_imd_disable(_DISABLE,display);
						   inputVfreq = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ);
   	                       rtd_pr_vsc_debug("\n +++ adaptive stream before vfreq:%d\n", inputVfreq);
						   Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
   	                       rtd_pr_vsc_debug("\n +++ adaptive stream after vfreq:%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ));
						   if(inputVfreq!=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ)){
							   scaler_disp_smooth_variable_setting();
						   }
	                       rtd_pr_vsc_debug("\n smooth toggle timing change don't need to go scaler\n");
	                       return TRUE;
	                   }
#endif
	               } else {
                       if (get_vo_smoothtoggle_state(display) == SLR_SMOOTH_TOGGLE_ACTIVE) {
                           //vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(display), display);
                           set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
                           smooth_toggle_state_info_rpc(display);
                           rtd_pr_vsc_debug("set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_INIT\n");
                       }
	               }
				}
				rtd_pr_vsc_debug("\r\n####check_signal vo change active to search####\r\n");

				if(display == SLR_MAIN_DISPLAY) {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetSubOutPutRegion_Semaphore);
				}
				Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);    //WOSQRTK-3464
				state_update_disp_info();

				return TRUE;
			}
			else
			{
				up(get_vo_infosemaphore());
#ifdef CONFIG_RTK_8KCODEC_INTERFACE
				if (Get_vo_smoothtoggle_timingchange_flag(display))
				{
						if(get_vo_run_smooth_toggle_enable(display))
						{
								if (get_vo_imd_disable(display))
								{
										unsigned short len = 0;
										unsigned short wid = 0;
										SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

										len = pVOInfo->src_v_len;
										if(pVOInfo->progressive == 0)
										{
												len = len * 2;
										}

										wid = pVOInfo->src_h_wid;
										set_vo_imd_disable(_DISABLE,display);
										send_srnn_real_size_to_slave(wid, len);
										return TRUE;
								}
						}
				}
#endif
			}

			if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC) == FALSE) || (drvif_framesync_detect()))//If Framesync case, we just check drvif_framesync_detect
			{
				down(get_vo_infosemaphore());
				if (get_vo_run_smooth_toggle_enable(display) && get_vo_imd_disable(display)) {
					set_vo_imd_disable(_DISABLE,display);
					inputVfreq = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ);
					//input_isInterlace = Scaler_DispGetStatus(display,SLR_DISP_INTERLACE);
					rtd_pr_vsc_debug("\n +++ adaptive stream before vfreq:%d\n", inputVfreq);
					Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
					rtd_pr_vsc_debug("\n +++ adaptive stream after vfreq:%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ));
					up(get_vo_infosemaphore());
#if 0
					//add frame rate changing smooth toggle flow @Crixus 20151215
					if((get_vo_frameratechange_enable(display)==1) && (!get_vsc_run_adaptive_stream(display)) && (scaler_get_current_framesync_mode(display) ==0)){
						//before set DTG frame rate, it has to wait for smooth toggle done. @Crixus 20151215
						down(&SetMainOutPutRegion_Semaphore);
						Check_smooth_toggle_update_flag(display);
						scaler_disp_smooth_variable_settingByDisp(0);
						up(&SetMainOutPutRegion_Semaphore);
						set_frc_style_input_fast_than_display(FALSE);
					}
#endif
					drvif_scaler_wclr_abnormal_dvs_long_short();
					rtd_pr_vsc_notice("\n timing:go smooth toggle\n");
				}
				else{
					up(get_vo_infosemaphore());
				}

				if(Get_vo_smoothtoggle_timingchange_flag(display))  //direct vo smooth toggle
				{
					if(get_vo_run_smooth_toggle_enable(display))  //direct_vo :curr display size changed  go smooth toggle
					{
					}
					else
					{
						if (get_reset_smooth_toggle_state(display)) {
							//vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(display), display);
							smooth_toggle_state_info_rpc(display);
							set_reset_smooth_toggle_state(_DISABLE,display);
							rtd_pr_vsc_debug("set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_ACTIVE\n");
						}
					}
				}
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
				if((get_vsc_run_adaptive_stream(display)||scaler_vsc_get_force_pst_lowdelay_mode())&&(scaler_vsc_get_adaptive_pst_lowdelay_mode()==TRUE)&&(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)){
					ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
					ppoverlay_uzudtg_fractional_fsync_RBUS uzudtg_fractional_fsync_reg;
                    pst_i2rnd_top_ctrl_RBUS   top_ctrl;
					top_ctrl.regValue = IoReg_Read32(PST_I2RND_TOP_CTRL_reg);
                    memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
					if(memc_mux_ctrl_reg.memc_outmux_sel == 1){
						uzudtg_fractional_fsync_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_fractional_fsync_reg);
						rtd_pr_vsc_notice("[%s][line:%d] uzudtg_fractional_fsync_reg.regValue:%x\r\n", __FUNCTION__, __LINE__, uzudtg_fractional_fsync_reg.regValue);
						if((uzudtg_fractional_fsync_reg.uzudtg_multiple_vsync == 0) && (uzudtg_fractional_fsync_reg.uzudtg_remove_half_ivs_mode == 0)){
							rtd_pr_vsc_notice("[%s][line:%d] Scaler_MEMC_Bypass_On\r\n", __FUNCTION__, __LINE__);
                            Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
                            Scaler_MEMC_Bypass_On(1);
						}
					}
				}
#endif
				return TRUE;
			}
			else
			{
				rtd_pr_vsc_notice("####VO frame sync error!!!######\r\n");
				mute_control(display, TRUE);/*Auto BG. Add by Will*/
				scaler_set_full_gatting_rpc(FALSE);
				drivf_scaler_reset_freerun();
				if(scaler_VDEC_signal_error_handler(display))
									return TRUE;
			}
		}
		else//if(Scaler_DispGetInputInfo(SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
					return TRUE;
		}
	} else {
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
			return TRUE;/* State is not _MODE_STATE_ACTIVE. No need to check signal*/

		//if HDMI source, not to run check mode until sync OK @Crixus 20151229
		//USER:LewisLee DATE:2016/02/21
		//for zhaodong_yin suggest
		//to fix HDR mode, Scaler_InputSrcGetType() will change to _SRC_VO
		//it need change to Get_DisplayMode_Src()
//		if((Scaler_InputSrcGetType(display) == _SRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)) {
		if((Get_DisplayMode_Src(display) == VSC_INPUTSRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)) {

			unsigned char hdmi_check_mode_err = 0;
			unsigned char cur_vrr_status = 0;
			unsigned char cur_freesync_status = 0;
                        unsigned char cur_qms_status = 0;

			if(drvif_Hdmi_CheckMode() == FALSE)
				hdmi_check_mode_err = 1;
			else
			{
				cur_vrr_status = drvif_Hdmi_GetVRREnable();
				if((vbe_disp_get_VRR_timingMode_flag() != cur_vrr_status) && !get_scaler_qms_mode_flag() && vbe_get_panel_vrr_freesync_timing_is_valid())
				{
					hdmi_check_mode_err = 2;
				}
				else if (flag_vsc_check_dolby_mode_change)
				{
					flag_vsc_check_dolby_mode_change = 0;
					hdmi_check_mode_err = 5;
				}
				else
				{
					cur_freesync_status = drvif_Hdmi_GetAMDFreeSyncEnable();
					if((vbe_disp_get_freesync_mode_flag() != cur_freesync_status) && !get_scaler_qms_mode_flag() && vbe_get_panel_vrr_freesync_timing_is_valid())
						hdmi_check_mode_err = 3;
					else
					{
						cur_qms_status = current_is_hdmi_qms_mode();
						if(get_scaler_qms_mode_flag() != cur_qms_status)
						{
							hdmi_check_mode_err = 4;
						}
					}
				}
			}

			if(hdmi_check_mode_err)
			{
				scaler_vsc_set_gamemode_go_datafrc_mode(_DISABLE);	//reset game mode frc flag for scaler re-run
				if(scaler_HDMI_signal_error_handler(display))
 					return TRUE;

                if(hdmi_check_mode_err == 1)
				{
					rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by drvif_Hdmi_CheckMode error\n");
				}
				else if(hdmi_check_mode_err == 2)
				{
					rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by VRR (%d %d) change\n", vbe_disp_get_VRR_timingMode_flag(), cur_vrr_status);
				}
				else if(hdmi_check_mode_err == 3)
				{
					rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by freesync (%d %d) change\n",vbe_disp_get_freesync_mode_flag(), cur_freesync_status);
				}
				else if(hdmi_check_mode_err == 4)
				{
					rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by QMS (%d %d) change\n", get_scaler_qms_mode_flag(), cur_qms_status);
				}
				else if(hdmi_check_mode_err == 5)
				{
					rtd_pr_vsc_info("\n Hdmi_CheckMode ERROR by DolbyVSIF change\n");
				}
				return false;
			}
		}
		return TRUE; /* Not VO source no need to auto run scaler*/
	}
	check_bsp_error_event(Abnormal_Run_Scaler, FALSE);//Abnormal case to run scaler recover
	down(&VSC_Semaphore);
	Scaler_SetCurrentDispInfo(display);
	result = rtk_run_scaler(display, inputType, outputMode); /*This is for VO frame sync error*/
	Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
	up(&VSC_Semaphore);
	return result;

}

static int GamemodeSaveI3ddmaGetcurMode;

int Get_GamemodeSaveI3ddmaGetcurMode(void)
{
	return GamemodeSaveI3ddmaGetcurMode;
}

void Set_GamemodeSaveI3ddmaGetcurMode(int value)
{
	GamemodeSaveI3ddmaGetcurMode = value;
}

unsigned char rtk_output_connect(unsigned char display)
{
	KADP_VSC_OUTPUT_MODE_T outputMode = KADP_VSC_OUTPUT_MAXN;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;
	unsigned char result;
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
	unsigned short mode_id;
#endif
	if(get_scaler_stop_flag(display) == TRUE)
		  return FALSE;


	//rtd_pr_vsc_emerg("[crixus]@@@@@[%s][%d]\n", __FUNCTION__, __LINE__);
#ifdef CONFIG_I2RND_ENABLE
	if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) &&(vsc_i2rnd_sub_output_mode ==KADP_VSC_OUTPUT_VENC_MODE)){
		//save sub info
		VencModeInputInfo.type = vsc_i2rnd_sub_input_type;
		VencModeInputInfo.resourceIndex = vsc_i2rnd_sub_input_port;
	}

#endif
	if (display == SLR_MAIN_DISPLAY) {
#ifdef CONFIG_I2RND_ENABLE
		if(!(Scaler_I2rnd_get_timing_enable() && ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))))
#endif
		{
			if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
				inputType = DisplayModeInputInfo.type;
				inputPort = DisplayModeInputInfo.resourceIndex;
			}
			else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				outputMode = KADP_VSC_OUTPUT_VENC_MODE;
				inputType = VencModeInputInfo.type;
				inputPort = VencModeInputInfo.resourceIndex;
			}
			else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
				inputType = MemoryModeInputInfo.type;
				inputPort = MemoryModeInputInfo.resourceIndex;
			}
			else
			{
				return false;
			}
		}
		Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);

#ifdef CONFIG_I2RND_ENABLE
	if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) &&(vsc_i2rnd_sub_output_mode ==KADP_VSC_OUTPUT_VENC_MODE)){
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
			DbgSclrFlgTkr.OutputVencMode = TRUE;
	}
	else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE)
		&& ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
		outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
		inputType = Sub_DisplayModeInputInfo.type;
		inputPort = Sub_DisplayModeInputInfo.resourceIndex;

		rtd_pr_vsc_emerg("[crixus][PIP]Sub_DisplayModeInputInfo.resourceIndex = %d\n", Sub_DisplayModeInputInfo.resourceIndex);
	}
	else{
#endif
		if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_MAIN_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort) == FALSE) {
				rtd_pr_vsc_notice("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				return false;
			}
		}
#ifdef CONFIG_I2RND_ENABLE
		}
#endif
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}

		Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);
		if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_SUB_DISPLAY, (VSC_INPUT_TYPE_T)inputType, inputPort) == FALSE) {
				rtd_pr_vsc_notice("\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.sub_opensourceID = _UNKNOWN_INPUT;
				return false;
			}
		}
	}
#endif

#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC || get_line_alternative_3d_mode_enable() == TRUE
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
		#endif
		|| (get_force_i3ddma_enable(display) == true)
#ifdef CONFIG_I2RND_ENABLE
		|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))//VO source
#endif
		) && !((display == SLR_MAIN_DISPLAY) && ((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120))))
#else
	if(inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC || get_line_alternative_3d_mode_enable() == TRUE
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
		#endif
		)//VO source
#endif
	{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
		if((inputType == KADP_VSC_INPUTSRC_AVD) && (display == SLR_MAIN_DISPLAY))
		{
			mode_id = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR);

		}
#endif
		down(get_vo_infosemaphore());
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			|| get_force_i3ddma_enable(display) == true
#ifdef CONFIG_I2RND_ENABLE
			|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) && (vsc_i2rnd_sub_output_mode == KADP_VSC_OUTPUT_DISPLAY_MODE))
#endif
			)
#else
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			)
#endif
		{
#ifdef CONFIG_HDR_SDR_SEAMLESS
			if((display == SLR_MAIN_DISPLAY) && (inputType != KADP_VSC_INPUTSRC_VDEC) && (inputType != KADP_VSC_INPUTSRC_JPEG))
#endif

			inputPort = 0; //hdmi hdr always set vo port0:
		}
#ifdef CONFIG_I2RND_ENABLE
		if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_output_mode == KADP_VSC_OUTPUT_DISPLAY_MODE)
			&& ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) ||(vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
		){
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;; //pip sub use planeV2
			rtd_pr_vsc_emerg("[crixus]sub re-run main scaler, need to use sub inputPort = %d\n", inputPort);
		}
#endif

		set_vo_change_flag(inputPort, FALSE);
	#if 0
		if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF || get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM || get_vo_3d_mode() == VO_3D_FRAME_PACKING)
		{
			drvif_scalerdisplay_force_bg((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), 1);//enable force BG for vo 3d auto detect
		}
	#endif
		if ((Get_sub_from_DI_mux_path()) && (display == SLR_SUB_DISPLAY)) {
			//tmp code
			Scaler_SET_VSCSubDispinfo_Withmain();
		} else {
			Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
		}
		up(get_vo_infosemaphore());

		if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0) && (display == SLR_MAIN_DISPLAY))
		{
			Scaler_SET_VSCSubDispinfo_Withmain();
			Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE));
			Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE));
			Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE));
			Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
		}
		if (vsc_timinginfo_check() == FALSE) {
			rtd_pr_vsc_err("\n####VO info is zero####\n");
			if (display == SLR_MAIN_DISPLAY) {
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				up(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset Main_during_scalerflag
			} else {
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
			}
			return FALSE;
		}
		if(inputType == KADP_VSC_INPUTSRC_VDEC)
		{
			Check_smooth_toggle_update_flag(display);
		}

#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
		if((inputType == KADP_VSC_INPUTSRC_AVD) && (display == SLR_MAIN_DISPLAY))
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR, mode_id);

#endif
	}
	else
	{

	}
	vbe_disp_set_pre_VRR_ALLM_flag(0);	//reset pre vrr allm flag
#ifdef CONFIG_I2RND_ENABLE
	//Update sub source i2r condition @Crixus 20170928
	if(inputType == KADP_VSC_INPUTSRC_VDEC){
		//first time or sub scaler re-run, need to check condition
		//Eric@20170315 only sub display mode go i2rnd flow
		if((display == SLR_SUB_DISPLAY) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))){
			vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_CONNECT;
			//save sub info
			vsc_i2rnd_sub_output_mode= outputMode;
			vsc_i2rnd_sub_input_type = inputType;
			vsc_i2rnd_sub_input_port = Sub_MemoryModeInputInfo.resourceIndex;
			rtd_pr_vsc_emerg( "[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_SUB_CONNECT@@@@@@@@@@\n");
		}
	}
	else{
		//i2rnd sub=>vodma checking @Crixus 2160721
		//Eric@20180315 if sub venc mode , do not go i2rnd flow
		if((display == SLR_SUB_DISPLAY) && (DbgSclrFlgTkr.Sub_OutputVencMode == FALSE) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH))){
			vsc_i2rnd_sub_stage = I2RND_STAGE_DETECT_SOURCE;
			//save sub info
			vsc_i2rnd_sub_output_mode= outputMode;
			vsc_i2rnd_sub_input_type = inputType;
			vsc_i2rnd_sub_input_port = Sub_MemoryModeInputInfo.resourceIndex;
			rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_DETECT_SOURCE\n");
		}
	}


	//I2run case, check sub over 2k1k do not run i2run @Crixus 20170906
	if(display == SLR_SUB_DISPLAY)
		Scaler_I2rnd_condition_check(DbgSclrFlgTkr.OuputDisplayMode, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) , Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_pr_vsc_emerg("[frank]rtk_output_connect %d,%d,%d\n",display,inputType,outputMode);
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
	if((Scaler_I2rnd_b05_get_enable() == _ENABLE) && (inputType == KADP_VSC_INPUTSRC_VDEC)){
		if(display == SLR_MAIN_DISPLAY)
			drvif_scaler_i2rnd_b05_vodma_setting(SLR_MAIN_DISPLAY);
	}
#endif

	//reset film parameter
	film_mode_parameter.enable = 0;
	film_mode_parameter.type= 0;
	film_mode_parameter.v_freq = 0;
	ori_voclk_ratio_num = 0;

	result = rtk_run_scaler(display, inputType, outputMode);
	if (result == TRUE)/*checking vsc freeze flag*/
	{
		if (display == SLR_MAIN_DISPLAY) {
			if (DbgSclrFlgTkr.mainVscFreezeFlag) {

				rtd_pr_vsc_emerg( "\r\n####func:%s line:%d####\r\n", __FUNCTION__, __LINE__);
				Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.mainVscFreezeFlag);
			}
		}
		if (display == SLR_SUB_DISPLAY) {
			if (DbgSclrFlgTkr.subVscFreezeFlag) {
				Scaler_SetFreeze(SLR_SUB_DISPLAY, DbgSclrFlgTkr.subVscFreezeFlag);
			}
		}
	}

	return result;

}

void scaler_i2rnd_run_main(void){
	//rtd_pr_vsc_emerg("[crixus]@@@@@[%s][%d]\n", __FUNCTION__, __LINE__);
	rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
}

extern unsigned char g_ucCurColorStd;
extern unsigned char Scaler_AVD_GetDetectStage(void);
extern unsigned char g_ucColorOK;

void wait_buffer_ready_after_SetupIMD(unsigned char num)
{//this api is for wait buffer ready after Setup_IMD
//num:How many frames to wait for
	unsigned int cur_counter;
	unsigned int need_time, vfreq;
	unsigned char timeout = 10;

	if(num != 0)
	{
		vfreq = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

		if(vfreq)
			need_time = 900000 * num / vfreq;
		else
		{
			rtd_pr_vsc_info("#####[%s(%d)] err frame rate zero####\r\n", __FUNCTION__,__LINE__);
			return;
		}
		while(timeout)
		{
			cur_counter = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
			if(cur_counter < record_Setup_IMD_timer_counter)
			{
				if((cur_counter + (0xFFFFFFFF - record_Setup_IMD_timer_counter)) >= need_time)
					break;

			}
			else if ((cur_counter - record_Setup_IMD_timer_counter) >= need_time)
				break;
			msleep(10);
			timeout --;
		}

		rtd_pr_vsc_info("###[%s(%d)] ori:%d needwait num:%d time:%d cur_counter=%d timeout=%d#####\r\n", __FUNCTION__, __LINE__,record_Setup_IMD_timer_counter, num, need_time,cur_counter,timeout);
		if(!timeout)
			rtd_pr_vsc_info("###[%s(%d)] err wait timeout#####\r\n", __FUNCTION__, __LINE__);
	}
}

#ifdef AV_HSYNC_PULSE_START_REFINE
void crc_check_for_atv(void)
{
	vdtop_hactive_start_RBUS hactive_start_reg;
	h3ddma_hsd_i3ddma_hsd_crc_ctrl_RBUS h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg;
	unsigned int crc_rst1=0,crc_rst2=0;

	if(VDTOP_HACTIVE_START_get_hactive_start(IoReg_Read32(VDTOP_HACTIVE_START_reg))==0xc2){

		h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_HSD_CRC_CTRL_reg);
		h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg.ch1_hsd_crc_conti = 1;
		IoReg_Write32(H3DDMA_HSD_I3DDMA_HSD_CRC_CTRL_reg,h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg.regValue);

		h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg.regValue = IoReg_Read32(H3DDMA_HSD_I3DDMA_HSD_CRC_CTRL_reg);
		if(h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg.ch1_hsd_crc_conti)
			h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg.ch1_hsd_crc_start = 1;
		IoReg_Write32(H3DDMA_HSD_I3DDMA_HSD_CRC_CTRL_reg,h3ddma_hsd_i3ddma_hsd_crc_ctrl_reg.regValue);

		while(1){//crc check
			usleep_range(40000,40000);//delay 40ms
			crc_rst1 = IoReg_Read32(H3DDMA_HSD_I3DDMA_HSD_CRC_Result_left_reg);
			rtd_pr_vsc_info("#####[%s(%d)]crc_rst1=0x%08x\n",__func__,__LINE__,crc_rst1);

			usleep_range(20000,20000);//delay 20ms
			crc_rst2 = IoReg_Read32(H3DDMA_HSD_I3DDMA_HSD_CRC_Result_left_reg);
			rtd_pr_vsc_info("#####[%s(%d)]crc_rst2=0x%08x\n",__func__,__LINE__,crc_rst2);

			if(crc_rst1 == crc_rst2){
				hactive_start_reg.regValue = IoReg_Read32(VDTOP_HACTIVE_START_reg);
				hactive_start_reg.hactive_start= 0x82;
				IoReg_Write32(VDTOP_HACTIVE_START_reg, hactive_start_reg.regValue);
				usleep_range(20000,20000);//delay 20ms
				hactive_start_reg.regValue = IoReg_Read32(VDTOP_HACTIVE_START_reg);
				hactive_start_reg.hactive_start= 0xc2;
				IoReg_Write32(VDTOP_HACTIVE_START_reg, hactive_start_reg.regValue);
				rtd_pr_vsc_info("#####[%s(%d)]crc_rst1 == crc_rst2.\n", __FUNCTION__, __LINE__);
			}else{
				rtd_pr_vsc_info("#####[%s(%d)]crc_rst1 != crc_rst2, break check.\n", __FUNCTION__, __LINE__);
				IoReg_Write32(H3DDMA_HSD_I3DDMA_HSD_CRC_CTRL_reg,0x0);
				break;
			}
		}
	}
}
#endif//#ifdef AV_HSYNC_PULSE_START_REFINE

unsigned char wait_atv_stable_for_bg(unsigned char display,char const* pfunc,unsigned int line)
{
	UINT8 ucVdReady = 0;
	unsigned short Timeout = 0;
	unsigned short Channel_Ch_Timeout = 0;
	unsigned char *p_stop_flag = &DbgSclrFlgTkr.Main_Scaler_Stop_flag;
	unsigned char *p_output_set_flag = &DbgSclrFlgTkr.Main_Output_Set_flag;
	unsigned char *p_run_scaler_flag = &DbgSclrFlgTkr.Main_Run_Scaler_flag;
	if(display == SLR_MAIN_DISPLAY) {
		p_stop_flag = &DbgSclrFlgTkr.Main_Scaler_Stop_flag;
		p_output_set_flag = &DbgSclrFlgTkr.Main_Output_Set_flag;
		p_run_scaler_flag = &DbgSclrFlgTkr.Main_Run_Scaler_flag;
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		p_stop_flag = &DbgSclrFlgTkr.Sub_Scaler_Stop_flag;
		p_output_set_flag = &DbgSclrFlgTkr.Sub_Output_Set_flag;
		p_run_scaler_flag = &DbgSclrFlgTkr.Sub_Run_Scaler_flag;
	}
#endif
	rtd_pr_vsc_info("[%s(%d)] call %s start!!! \n",pfunc,line,__FUNCTION__);
	down(get_avd_power_semaphore());
	if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
	{
		ucVdReady = drvif_module_vdc_OutputStable();
	}
	up(get_avd_power_semaphore());

	if (drvif_module_vdc_GetLockStatus())
	{
		//extern UINT8 dma_3d_ON_count;
		//dma_3d_ON_count = 0;	//init
#if 0
		if(get_AVD_Input_Source() == _SRC_TV){
			while(Scaler_AVD_GetIsChannelChange()){
				msleep(10);
				Channel_Ch_Timeout++;
				if ((Channel_Ch_Timeout >= 30)||
					(Scaler_AVD_GetIsChannelChange()== FALSE)) {
					rtd_pr_vsc_info("drvif_module_vdc_GetLockStatus=%d, Channel_Ch_Timeout=%d, IsChannelChange=%d [%s(line:%d)]\n",drvif_module_vdc_GetLockStatus(), Channel_Ch_Timeout, Scaler_AVD_GetIsChannelChange(), __FUNCTION__, __LINE__);
					break;
				}
			}
		}
#endif
		while (ucVdReady == FALSE)
		{
			//VDC_DEBUG_MSG(VDC_MSG_TVCHCH, "[1]V_state timeout = %d\n",Timeout);
			msleep(10);
			if(*p_stop_flag || *p_output_set_flag || *p_run_scaler_flag){
				rtd_pr_vsc_info("#####[%s(%d)] p_stop_flag=%d, p_output_set_flag=%d, p_run_scaler_flag=%d\n",__FUNCTION__,__LINE__,*p_stop_flag,*p_output_set_flag,*p_run_scaler_flag);
				return FALSE;
			}
			//Timeout++;
			if (Timeout++ >= 100) {
				rtd_pr_vsc_info("[VSC]V_state timeout\n");
				drvif_module_vdc_set_vstate_new2to3_en(_ENABLE);		/* vstate != 3, set */
				VDC_DEBUG_MSG(VDC_MSG_TVCHCH, "[VSC]V_state timeout\n");
				//return FALSE;
				break;  //modify for [KTASKWBS-7166],if vdpq_dma_ctrl4_reg.dma_3d_on_off is always 0, no need keep mute
			}

			down(get_avd_power_semaphore());
			if(get_AVD_Global_Status() == SRC_CONNECT_DONE){
				ucVdReady = drvif_module_vdc_OutputStable();
				rtd_pr_vsc_info("[%s(%d)](Timeout=%d)ucVdReady=%d,vstate=%d,0xb80192d8=0x%08x\n",__FUNCTION__, __LINE__,Timeout,ucVdReady,drvif_module_vdc_Read_Vstate(),IoReg_Read32(VDTOP_VSTATELOCK_TIME_POLLING_reg));
			}
			up(get_avd_power_semaphore());
		}
	}else{
		if(0 == drvif_video_status_reg(VDC_no_signal)){
			rtd_pr_vsc_info("#####[%s(%d)]drvif_video_status_reg(VDC_no_signal) equal 0.", __FUNCTION__, __LINE__);
			return FALSE;
		}else{
			rtd_pr_vsc_info("#####[%s(%d)]drvif_video_status_reg(VDC_no_signal) equal 1.", __FUNCTION__, __LINE__);
#ifdef AV_HSYNC_PULSE_START_REFINE
			if(get_ic_version() == VERSION_A)
				crc_check_for_atv();
#endif//#ifdef AV_HSYNC_PULSE_START_REFINE
		}
	}

	rtd_pr_vsc_info("drvif_module_vdc_GetLockStatus=%x, ucVdReady=%x, Timeout=%d, Channel_Ch_Timeout=%d [%s(line:%d)]\n",drvif_module_vdc_GetLockStatus(), ucVdReady, Timeout, Channel_Ch_Timeout, __FUNCTION__, __LINE__);

#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif

	drvif_module_vdc_new_vdetect_Enable(New_vedetect);
	drvif_module_vdc_set_vstate_speedup(vstate_count_default);
	//Check if there are three frames after Setup_IMD to here
	wait_buffer_ready_after_SetupIMD(3);//For KTASKWBS-9770 AV DC off/on judder
	if(*p_stop_flag || *p_output_set_flag || *p_run_scaler_flag){
		rtd_pr_vsc_info("#####[%s(%d)] p_stop_flag=%d, p_output_set_flag=%d, p_run_scaler_flag=%d\n",__FUNCTION__,__LINE__,*p_stop_flag,*p_output_set_flag,*p_run_scaler_flag);
		return FALSE;
	}else{
		rtd_pr_vsc_info("#####[%s(%d)] p_stop_flag=%d, p_output_set_flag=%d, p_run_scaler_flag=%d\n",__FUNCTION__,__LINE__,*p_stop_flag,*p_output_set_flag,*p_run_scaler_flag);
		return TRUE;
	}
}

//Calc the count of SetWinBlank=0 durning ATV Channel change
void	CalcWinBlankCountForATVChanlChg(unsigned char channel, bool bonoff)
{
	//rtd_pr_vsc_info("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	// VSC is connectd to AVD
	if (!bonoff && (VSC_INPUTSRC_AVD == Get_DisplayMode_Src(channel))
		&& (get_AVD_Input_Source() == _SRC_TV))
	{
		if (TRUE == DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange)
		{
			DbgSclrFlgTkr.g_ucVDCDetectStage = Scaler_AVD_GetDetectStage();

			DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange = FALSE;
			DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart = TRUE;

			rtd_pr_vsc_info("reset DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=0\n");
		}


		if (TRUE == DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart)
		{
			DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount++;
			rtd_pr_vsc_info("DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=%d\n", DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount);
		}
	}
}


unsigned char rtk_hal_vsc_SetWinBlank(VIDEO_WID_T wid, bool bonoff, KADP_VIDEO_DDI_WIN_COLOR_T color)
{
	SCALER_DISP_CHANNEL channel;

	rtd_pr_vsc_info("#####[%s(%d)] wid:%d, enable=%d\n",__func__,__LINE__, wid, bonoff);

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid != VIDEO_WID_0)
	{
		rtd_pr_vsc_info("wid id is not ok\n");
		return FALSE;
	}
#endif

	if((color > KADP_VIDEO_DDI_WIN_COLOR_COLOR_RGB_API) || (color < KADP_VIDEO_DDI_WIN_COLOR_BLACK))
		return FALSE;

	if (wid == VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid == VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}

	if((!bonoff) && MDOMAIN_CAP_DDR_In1Ctrl_get_in1_freeze_enable(IoReg_Read32(MDOMAIN_CAP_DDR_In1Ctrl_reg)) && (scaler_get_current_framesync_mode(channel) == FALSE) && (Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) &&
		(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) && (!(Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()) == SOURCE_DIRECTVO))){
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "mdomain unfreeze must eariler than disable forcebg[%s %d]\n",__FUNCTION__, __LINE__);
		drvif_mdomain_freeze(bonoff);
	}

	if(OutpuLocalDimmingPatMode == TRUE){
        if(bonoff)
            set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);
        else
            set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
		return TRUE;
	}

	if(bonoff)
		set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);
	//Calc the count of SetWinBlank=0 durning ATV Channel change
	CalcWinBlankCountForATVChanlChg(channel, bonoff);
#if 0
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)&&(get_AVD_Input_Source() == _SRC_TV)){//For KTASKWBS-5200
		if (!bonoff && Scaler_AVD_GetIsChannelChange()&& (Scaler_AVD_GetDemodType()==KADP_AVD_EXTERNAL_DEMOD)
			&&(DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount ==1)
			&& 0 == drvif_video_status_reg(VDC_no_signal)){
			set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			rtd_pr_vsc_info("######[%s(line:%d)]external_ch_change_flag =1 don't run rtk_hal_vsc_SetWinBlank\n",__FUNCTION__, __LINE__);
			return TRUE;
		}

		if (!bonoff
#ifndef SPEEDUP_NEW_SCALER_FLOW//need to check
			&& (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
#endif
			&&(Scaler_AVD_GetVDPreMode() == _MODE_UNKNOWN)
			&&(0 == drvif_video_status_reg(VDC_no_signal))
			&&(0 == drvif_video_status_reg(VDC_noisy))
			&&(DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount ==1)){
			set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			rtd_pr_vsc_info("######[%s(line:%d)]fast zapping, flicker garbage.#####\n",__FUNCTION__, __LINE__);
			return TRUE;

		}
	}
#endif
	if (bonoff) {
		if(channel == SLR_MAIN_DISPLAY) {
			DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = FALSE;//ATV can not run smooth toggle
#ifdef CONFIG_DUAL_CHANNEL
		} else {
			DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag = FALSE;//ATV can not run smooth toggle
		}
#endif
		//frank@03102016 DOLBYCERT-144 store mode change playback file osd flash issue ++
		if ((channel == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_FRAMESYNC) &&(get_HDMI_HDR_mode() !=HDR_DOLBY_HDMI) && (get_HDMI_HDR_mode() !=HDR_HDR10_HDMI) &&(!vbe_disp_get_adaptivestream_fs_mode())){
			#ifndef CONFIG_FORCE_RUN_I3DDMA //not define
			drivf_scaler_reset_freerun();
			#endif
		}
		//if((Get_DISPLAY_PANEL_OLED_TYPE()==1)&& get_vsc_run_adaptive_stream() && (channel == SLR_MAIN_DISPLAY)){
		if(get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) && (channel == SLR_MAIN_DISPLAY)&&(Check_AP_Set_Enable_ForceBG(channel) == FALSE)){
			Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
			rtd_pr_vsc_notice("######### [%s]line:%d, enable wdg\n", __FUNCTION__, __LINE__);

			drvif_mode_onlinemeasure_setting(channel, _SRC_VO, TRUE, FALSE);
            drvif_mode_enableonlinemeasure(channel);//Enable online measure
		}
		//frank@03102016 DOLBYCERT-144 store mode change playback file osd flash issue --


		if(color == KADP_VIDEO_DDI_WIN_COLOR_BLACK)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x0000, 0x0000, 0x0000);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_BLUE)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x0000, 0x0000, 0x3FFF);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_GRAY)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x2fff, 0x2fff, 0x2fff);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_COLOR_RGB_API)
		{
			rtd_pr_vsc_info("\r\n rtk_hal_vsc_SetWinBlank display:%d follow RGB color API\n", channel);
		}


		//set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);

		if((channel == SLR_MAIN_DISPLAY) && Get_tv006_wb_pattern())	//WOSQRTK-7731
		{
			return TRUE;
		}

	} else {
		if(channel == SLR_MAIN_DISPLAY) {
			down(&SetMainOutPutRegion_Semaphore);
			if(DbgSclrFlgTkr.Main_Output_Set_flag) {
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
				DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
				cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s request main scaler##########\r\n", __FUNCTION__);
				return TRUE;
			} else  if(DbgSclrFlgTkr.rotate_muteoff_request_flag) {

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				DbgSclrFlgTkr.rotate_run_scaler_flag = TRUE;
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s request main rotate##########\r\n", __FUNCTION__);
				return TRUE;
			} else if(DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) {

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = TRUE;
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s request main smooth toggle##########\r\n", __FUNCTION__);
				return TRUE;
			} else if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off){//Rika
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_info("########func:%s smoothtoggle now##########\r\n", __FUNCTION__);
				return TRUE;
			}
			up(&SetMainOutPutRegion_Semaphore);
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				if(DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag == TRUE){
					if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (drvif_module_vdc_OutputStable() || drvif_video_status_reg(VDC_no_signal))){
						rtd_pr_vsc_notice("#####[%s(%d)]ATV signal stable to trigger_mute_off!\n", __func__, __LINE__);
						trigger_mute_off(SLR_MAIN_DISPLAY, 0);//trigger mute off. switch ratio case
					}
					rtd_pr_vsc_info("########func:%s(%d) atv case##########\r\n", __FUNCTION__,__LINE__);
					return TRUE;
				}
			}
			if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

				rtd_pr_vsc_info("########func:%s Main currently is not active can not disable BG##########\r\n", __FUNCTION__);
				return TRUE;
			}
			else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) ==  VSC_INPUTSRC_VDEC) && DbgSclrFlgTkr.Main_during_scalerflow_flag)
			{
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				rtd_pr_vsc_notice("####func:%s Main during scaler flow so can not disable BG####\r\n", __FUNCTION__);
				return TRUE;
			}

		} else {
			down(&SetSubOutPutRegion_Semaphore);
			if(DbgSclrFlgTkr.Sub_Output_Set_flag) {
				DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetSubOutPutRegion_Semaphore);
				rtd_pr_vsc_debug("\r\n########func:%s request sub scaler##########\r\n", __FUNCTION__);
				return TRUE;
			}
			up(&SetSubOutPutRegion_Semaphore);

			if((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

				rtd_pr_vsc_info("########func:%s(%d) atv case##########\r\n", __FUNCTION__,__LINE__);
				return TRUE;
			}
			if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

				rtd_pr_vsc_info("########func:%s Sub currently is not active can not disable BG##########\r\n", __FUNCTION__);
			}
		}
		set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
	}

	if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) && !bonoff) {
		rtd_pr_vsc_info("########func:%s line:%d signal not stable can not disable BG##########\r\n", __FUNCTION__, __LINE__);
		return TRUE;
	}


	if(channel == SLR_MAIN_DISPLAY)
	{
		if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY))
		{
			mute_control(SLR_MAIN_DISPLAY, TRUE);
				//These are for mute on to wait memc already blck video
			if(sync_memc_ready && bonoff)//if TRUE. when mute on to wait memc buffer
			{
				wait_memc_ready();//wait memc buffer
			}

		}
		else
		{
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
				if(drvif_module_vdc_OutputStable()||drvif_video_status_reg(VDC_no_signal)){
					rtd_pr_vsc_notice("#####[%s(%d)]ATV signal stable to trigger_mute_off!\n", __func__, __LINE__);
					trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off
				}else{
					rtd_pr_vsc_notice("#####[%s(%d)]ATV signal not stable, can not mute off!\n", __func__, __LINE__);
				}
			}else{
				//int port = Get_DisplayMode_Port(channel);
				rtd_pr_vsc_notice("#####[%s(%d)]trigger_mute_off\n", __func__, __LINE__);
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off

			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		if(bonoff)
		{
/*			down(&SetSubOutPutRegion_Semaphore);
			set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
			up(&SetSubOutPutRegion_Semaphore);*/
		}

		if(Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY))
		{
			mute_control(SLR_SUB_DISPLAY, TRUE);
		}
		else
		{
			trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off
		}
	}
#endif

#if 1
//	if (bonoff)
	if (bonoff && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (!get_sub_OutputVencMode()))
	{
		if (get_AVD_Input_Source() == _SRC_TV)
		{
#if 1  //ch_change_flag, 20151221
			vdc_resetTV_Count = 0x0;
#else
			if (drvif_module_vdc_read_Clamping_path() == 0)
			{
				vdc_exTV_chch = TRUE;
				vdc_resetTV_Count = 0x0;
				drvif_module_vdc_set_ch_change_flag(1);
			}/* mark internal ch change
			else {
				vdc_inTV_chch = TRUE;
				vdc_resetTV_Count = 0x0;
			}*/
#endif
		} else if (get_AVD_Input_Source() == _SRC_CVBS)
			vdc_AV_modech = TRUE;
	}
	else
	{
#if 0  //ch_change_flag, 20151221
		vdc_inTV_chch = FALSE;
		vdc_exTV_chch = FALSE;
#endif
		vdc_resetTV_Count = 0x0;
	}
#endif
	return TRUE;
}


unsigned char rtk_hal_vsc_GetInputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pinregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

		rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==KADP_VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			pinregion->x = main_input_size.srcx;
			pinregion->w = main_input_size.src_wid;
			pinregion->y = main_input_size.srcy;
			pinregion->h = main_input_size.src_height;
#ifdef CONFIG_SDNR_CROP
#ifdef CONFIG_I2RND_ENABLE
			if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				pinregion->x = sub_input_size.srcx;
				pinregion->w = sub_input_size.src_wid;
				pinregion->y = sub_input_size.srcy;
				pinregion->h = sub_input_size.src_height;
			}
#endif
#endif
		} else {
			pinregion->x = 0;
			pinregion->y = 0;
			pinregion->w = 0;
			pinregion->h = 0;
		}
	} else if (wid ==KADP_VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			pinregion->x = sub_input_size.srcx;
			pinregion->w = sub_input_size.src_wid;
			pinregion->y = sub_input_size.srcy;
			pinregion->h = sub_input_size.src_height;
		} else {
			pinregion->x = 0;
			pinregion->y = 0;
			pinregion->w = 0;
			pinregion->h = 0;
		}

	}
	return TRUE;
}

unsigned char check_only_xy_shift_case(unsigned char display, StructSrcRect *input, StructSrcRect *inputTiming, StructSrcRect *output);
void apply_only_xy_shift(unsigned char display, StructSrcRect input, StructSrcRect inputTiming, StructSrcRect output);

unsigned char rtk_hal_vsc_SetInputRegion_ForAdaptive(VIDEO_WID_T wid, KADP_VIDEO_RECT_T  inregion)
{
	VSC_INPUT_TYPE_T srctype;

	if(wid == VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

	if((srctype == VSC_INPUTSRC_HDMI) && (wid == VIDEO_WID_0))
	{
		unsigned int input_w;

		input_w = Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID);
		//input_w = Scaler_HDR10_Hdmi_Get_Input_ACT_WID_info();
		if(input_w > 3840){
			rtd_pr_vsc_debug("\n input_w=%d \n",input_w);
			inregion.x = 3840*inregion.x/input_w;
			inregion.w = 3840*inregion.w/input_w;
		}
	}


	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_info("rtk_hal_vsc_SetInputRegion_ForAdaptive x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1)) {
		rtd_pr_vsc_debug("\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);

		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		return TRUE;
	}
	else
	{
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(_DISP_DEFAULT_WID && _DISP_DEFAULT_LEN){
		if(inregion.w + inregion.x > _DISP_DEFAULT_WID){
			inregion.x = 0;
			inregion.w = _DISP_DEFAULT_WID;
			rtd_pr_vsc_emerg( "rtk_hal_vsc_SetInputRegion_ForAdaptive wrong wid\n");
		}
		if(inregion.h + inregion.y > _DISP_DEFAULT_LEN){
			inregion.y = 0;
			inregion.h = _DISP_DEFAULT_LEN;
			rtd_pr_vsc_emerg( "rtk_hal_vsc_SetInputRegion_ForAdaptive wrong len\n");
		}
	}

	if(wid == VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;

		Scaler_AdaptiveStream_InputWindowSet(main_input_size, wid);//for the first time, adpative stream timing change smooth toggle overscan size
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_DISP_WIN);//add this to identify different input region
		hal_main_InputRegionType = INPUT_BASE_ON_DISP_WIN;

		if (srctype == VSC_INPUTSRC_AVD)
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(wid,hal_main_InputRegionType);
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre, &main_dispwin_for_only_xy))
				{
					rtd_pr_vsc_debug("apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_DISP_WIN);
		hal_sub_InputRegionType = INPUT_BASE_ON_DISP_WIN;
		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_size, wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	return TRUE;
}

unsigned char rtk_hal_vsc_GetInputRegion_ForAdaptive(VIDEO_WID_T wid, VIDEO_RECT_T * poutregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			poutregion->x = main_dispwin.srcx;
			poutregion->y = main_dispwin.srcy;
			poutregion->w = main_dispwin.src_wid;
			poutregion->h = main_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}
	} else if (wid ==VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			poutregion->x = sub_dispwin.srcx;
			poutregion->y = sub_dispwin.srcy;
			poutregion->w = sub_dispwin.src_wid;
			poutregion->h = sub_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}

	}

	return TRUE;

}
unsigned char rtk_hal_vsc_SetInputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T  inregion)
{
	VSC_INPUT_TYPE_T srctype;
	if(wid == KADP_VIDEO_WID_0)
    {
    	//if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("rtk_hal_vsc_SetInputRegion main input(%d %d %d %d) \n", inregion.x, inregion.y, inregion.w, inregion.h);
    	}
    }
	else
	{
		//if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("rtk_hal_vsc_SetInputRegion sub input(%d %d %d %d) \n", inregion.x, inregion.y, inregion.w, inregion.h);
    	}
	}

    if(wid == KADP_VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
#if 0 /*remove, because we Check inregion whether it is reasonable later*/
	if((srctype == VSC_INPUTSRC_HDMI)&&(wid == KADP_VIDEO_WID_0))
	{
		unsigned int input_w;

		input_w = Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID);
		//input_w = Scaler_HDR10_Hdmi_Get_Input_ACT_WID_info();
		if(input_w > 3840){
			rtd_pr_vsc_debug("\n input_w=%d \n",input_w);
			inregion.x = 3840*inregion.x/input_w;
			inregion.w = 3840*inregion.w/input_w;
		}
	}
#endif

#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(wid == KADP_VIDEO_WID_0)
	{
		inregion.h = inregion.h/2;
		inregion.y = inregion.y/2;
	}
#endif

	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif
	if(inregion.x >4096) {
		 inregion.x=0;
	}
	if(inregion.w >4096) {
		 inregion.w=0;
	}
	if(inregion.h >4096) {
		 inregion.h=0;
	}
	if(inregion.y >4096) {
		 inregion.y=0;
	}
	//rtd_pr_vsc_debug("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1)) {
		rtd_pr_vsc_debug("\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);

		if (wid == KADP_VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		return TRUE;
	}
	else
	{
		if (wid == KADP_VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(wid == KADP_VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		//rtd_pr_vsc_notice("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);

		Scaler_AdaptiveStream_InputWindowSet(main_input_size,wid);
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
		hal_main_InputRegionType = INPUT_BASE_ON_TIMING;

		if (srctype == VSC_INPUTSRC_AVD)
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);

			inregion.x = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.x);
			inregion.w = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.w);

			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);

		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre,&main_dispwin_for_only_xy))
				{
					rtd_pr_vsc_debug("apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
		hal_sub_InputRegionType = INPUT_BASE_ON_TIMING;

		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_size,wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	return TRUE;
}

unsigned char rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * poutregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN) || (wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==KADP_VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			poutregion->x = main_dispwin.srcx;
			poutregion->y = main_dispwin.srcy;
			poutregion->w = main_dispwin.src_wid;
			poutregion->h = main_dispwin.src_height;
#ifdef CONFIG_SDNR_CROP
#ifdef CONFIG_I2RND_ENABLE
			if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				poutregion->x = sub_dispwin.srcx;
				poutregion->y = sub_dispwin.srcy;
				poutregion->w = sub_dispwin.src_wid;
				poutregion->h = sub_dispwin.src_height;
			}
#endif
#endif
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}
	} else if (wid ==KADP_VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			poutregion->x = sub_dispwin.srcx;
			poutregion->y = sub_dispwin.srcy;
			poutregion->w = sub_dispwin.src_wid;
			poutregion->h = sub_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}

	}

	return TRUE;

}
void vbe_disp_orbit_set_vo_overscan(unsigned char bEnable);
extern StructSrcRect vbe_orbit_input_size;
extern StructSrcRect vbe_orbit_output_size;
extern unsigned char vbe_disp_oled_orbit_enable;
extern unsigned char vbe_disp_oled_orbit_mode;
extern int ori_input_width;
extern int ori_input_height;

//New set input region for K4LP @Crixus 20170608
unsigned char rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_T wid, VIDEO_RECT_T  inregion, VIDEO_RECT_T originalInput)
{
	VSC_INPUT_TYPE_T srctype;

#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	inregion.x =0 ;
	inregion.y =0 ;
	inregion.w = originalInput.w;
	inregion.h = originalInput.h;
#endif

    if(wid == VIDEO_WID_0)
    {
    	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetInputRegionEx main input(%d %d %d %d) ori(%d %d)\n", inregion.x, inregion.y, inregion.w, inregion.h, originalInput.w, originalInput.h);
    	}
    }
	else
	{
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("SetInputRegionEx sub input(%d %d %d %d) ori(%d %d)\n", inregion.x, inregion.y, inregion.w, inregion.h, originalInput.w, originalInput.h);
    	}
	}

    if(wid == VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (srctype == VSC_INPUTSRC_AVD)
	{
#if 0 //ch_change_flag, 20151221
		vdc_inTV_chch = FALSE;
		vdc_exTV_chch = FALSE;
#endif
	}

	//rtd_pr_vsc_debug("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1) || (originalInput.w < 1) || (originalInput.h < 1)) {
		rtd_pr_vsc_debug("\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);

		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		return TRUE;
	}
	else
	{
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(wid == VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		//rtd_pr_vsc_notice("rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);

		main_input_timing.srcx = originalInput.x;
		main_input_timing.srcy = originalInput.y;
		main_input_timing.src_wid = originalInput.w;
		main_input_timing.src_height = originalInput.h;
        /*
        if((vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_AUTO_MODE|| vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_oled_orbit_enable)
        {
        	vbe_disp_orbit_set_vo_overscan_state(_ENABLE);
		vbe_orbit_input_size = main_input_size;
        }*/
		if (srctype == VSC_INPUTSRC_AVD)
		{
			main_input_timing.src_wid = 720; // ATV
			if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)wid)){//AV
				main_input_timing.src_wid = 720;
			}else if(VD_27M_HSD1440_DI3A== fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)wid)){
				main_input_timing.src_wid = 1440;
			}
		}

		Scaler_AdaptiveStream_InputWindowSet(main_input_size,wid);
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
		hal_main_InputRegionType = INPUT_BASE_ON_HAL_ORIGINAL_INPUT;

		if (srctype == VSC_INPUTSRC_AVD)
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(wid,hal_main_InputRegionType);

			//inregion.x = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.x);
			//inregion.w = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.w);

			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			//zoom_imd_smooth_toggle_config(wid, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(wid,hal_main_InputRegionType);
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre,&main_dispwin_for_only_xy))
				{
					rtd_pr_vsc_debug("apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_pr_vsc_debug("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL

	else if(wid == VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		if(DbgSclrFlgTkr.Sub_OutputVencMode && (originalInput.w == 704) && (srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
			rtd_pr_vsc_notice("#####[%s(%d)] reset original input width to 720 #####", __FUNCTION__, __LINE__);
			originalInput.w=720;
		}

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		sub_input_timing.srcx = originalInput.x;
		sub_input_timing.srcy = originalInput.y;
		sub_input_timing.src_wid = originalInput.w;
		sub_input_timing.src_height = originalInput.h;

		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
		hal_sub_InputRegionType = INPUT_BASE_ON_HAL_ORIGINAL_INPUT;
		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		zoom_imd_smooth_toggle_config(wid, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_timing,wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	return TRUE;
}

#if 0
unsigned char vo_overscan_disable(VSC_INPUT_TYPE_T srctype)
{
	VIDEO_RPC_VO_OVERSCAN_INFO overscan_info;
	unsigned int *pulDataTemp = NULL;
	unsigned int ulCount = 0, i = 0;
	int ret = 0;
	if (srctype!=VSC_INPUTSRC_VDEC) {
		return 0;
	}
	if ((get_zoom_smoothtoggle_vo_hwid(SLR_MAIN_DISPLAY)!=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)) &&
		(get_zoom_smoothtoggle_vo_vlen(SLR_MAIN_DISPLAY)!=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE))) {
			overscan_info.input_y=Main_InputRegion_y;
			overscan_info.input_h=Main_InputRegion_h;
			overscan_info.input_w=Main_InputRegion_w;
			overscan_info.input_x=Main_InputRegion_x;
			overscan_info.plane=Scaler_Get_CurVoInfo_VoVideoPlane(SLR_MAIN_DISPLAY);
			overscan_info.vo_source=Scaler_DispGetInputInfoByDisp(Get_DisplayMode_Port(SLR_MAIN_DISPLAY), SLR_INPUT_VO_SOURCE_TYPE);
			overscan_info.vo_overscan_enable=0;
			pulDataTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_SEND_VO_OVERSCAN_INFO);
			ulCount = sizeof(VIDEO_RPC_VO_OVERSCAN_INFO) / sizeof(unsigned int);

			// copy to RPC share memory
			memcpy(pulDataTemp, &overscan_info, sizeof(VIDEO_RPC_VO_OVERSCAN_INFO));

			for (i = 0; i < ulCount; i++)
				pulDataTemp[i] = Scaler_ChangeUINT32Endian(pulDataTemp[i]);

			if (0 != (ret = Scaler_SendRPC(SCALERIOC_SEND_VO_OVERSCAN_INFO,0,0)))//add 0,0 to fix compile error
			{
				rtd_pr_vsc_debug("ret=%d, send VO's overscan info to driver fail !!!\n", ret);
			}
			return 1;
	}
	return 0;
}
unsigned char vo_overscan_adjust(VSC_INPUT_TYPE_T srctype)
{
	unsigned int v_len,interlace;
	VIDEO_RPC_VO_OVERSCAN_INFO overscan_info;
	unsigned int *pulDataTemp = NULL;
	unsigned int ulCount = 0, i = 0;
	unsigned char ch = Scaler_Get_CurVoInfo_plane();
	int ret = 0;
	if (srctype!=VSC_INPUTSRC_VDEC) {
		return 0;
	}
	if ((Scaler_DispWindowGet().src_height == _DISP_LEN)&&(Get_VO_Dispinfo(ch)->IPH_ACT_WID_PRE >= 3000)&&(Get_VO_Dispinfo(ch)->IVFreq>310)) {
		if ((Get_VO_Dispinfo(ch)->disp_status&_BIT8)>>8) { // interlace
			v_len=(Get_VO_Dispinfo(ch)->IPV_ACT_LEN_PRE<<1);
			interlace=1;
		} else {
			v_len=Get_VO_Dispinfo(ch)->IPV_ACT_LEN_PRE;
			interlace=0;
		}
		if ((Main_InputRegion_h<v_len)||(Main_InputRegion_y>0)) {
			set_vo_change_flag(ch, FALSE);
			if (interlace) {
				overscan_info.input_y=Main_InputRegion_y/2;
			} else {
				overscan_info.input_y=Main_InputRegion_y;
			}
			if (Main_InputRegion_h>v_len) {
				overscan_info.input_h=v_len;
			} else {
				overscan_info.input_h=Main_InputRegion_h;
			}
			if (Main_InputRegion_w>Get_VO_Dispinfo(ch)->IPH_ACT_WID_PRE) {
				overscan_info.input_w=Get_VO_Dispinfo(ch)->IPH_ACT_WID_PRE;
			} else {
				overscan_info.input_w=Main_InputRegion_w;
			}
			overscan_info.input_x=Main_InputRegion_x;
			overscan_info.plane=Scaler_Get_CurVoInfo_VoVideoPlane(SLR_MAIN_DISPLAY);
			overscan_info.vo_source=Scaler_DispGetInputInfoByDisp(Get_DisplayMode_Port(SLR_MAIN_DISPLAY), SLR_INPUT_VO_SOURCE_TYPE);
			overscan_info.vo_overscan_enable=1;
			pulDataTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_SEND_VO_OVERSCAN_INFO);
			ulCount = sizeof(VIDEO_RPC_VO_OVERSCAN_INFO) / sizeof(unsigned int);

			// copy to RPC share memory
			memcpy(pulDataTemp, &overscan_info, sizeof(VIDEO_RPC_VO_OVERSCAN_INFO));

			for (i = 0; i < ulCount; i++)
				pulDataTemp[i] = Scaler_ChangeUINT32Endian(pulDataTemp[i]);

			if (0 != (ret = Scaler_SendRPC(SCALERIOC_SEND_VO_OVERSCAN_INFO,0,0)))//add 0,0 to fix compile error
			{
				rtd_pr_vsc_debug("ret=%d, send VO's overscan info to driver fail !!!\n", ret);
			}
			return 1;
		}
	}
	return 0;
}
#endif
//static KADP_VSC_SUB_PURPOSE_T VSC_SUB_PURPOSE = KADP_VSC_SUB_PURPOSE_NONE;


extern void send_vo_freeze_shiftxy_share_memory(void);
unsigned char check_only_xy_shift_case(unsigned char display, StructSrcRect *input, StructSrcRect *inputTiming, StructSrcRect *output)
{
	unsigned char ret = NOT_EQUAL;
	VSC_INPUT_TYPE_T srctype;
#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
	if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT){
		//if hal input timing is different, it will not go shiftxy
		//NEED FIX pool test
		//if input x=50 inputTiming wid=1000, then change to input x=100, inputTiming wid = 2000.
		//the ratio stays the same, so it may run shiftxy flow
		if(inputTiming->srcx != main_input_timing.srcx || inputTiming->srcy != main_input_timing.srcy
		     || inputTiming->src_wid != main_input_timing.src_wid || inputTiming->src_height != main_input_timing.src_height){
			input->srcx = main_input_size.srcx;
			input->srcy = main_input_size.srcy;
			input->src_wid = main_input_size.src_wid;
			input->src_height = main_input_size.src_height;
			inputTiming->srcx = main_input_timing.srcx;
			inputTiming->srcy = main_input_timing.srcy;
			inputTiming->src_wid = main_input_timing.src_wid;
			inputTiming->src_height = main_input_timing.src_height;
			output->srcx = main_dispwin.srcx;
			output->srcy = main_dispwin.srcy;
			output->src_wid = main_dispwin.src_wid;
			output->src_height = main_dispwin.src_height;
			DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
			return ret;
		}
	}
#endif
         if(input->src_wid != main_input_size.src_wid || input->src_height != main_input_size.src_height
         || output->srcx != main_dispwin.srcx || output->srcy != main_dispwin.srcy
         || output->src_wid != main_dispwin.src_wid || output->src_height != main_dispwin.src_height)
         {
         		   input->srcx = main_input_size.srcx;
                   input->srcy = main_input_size.srcy;
                   input->src_wid = main_input_size.src_wid;
                   input->src_height = main_input_size.src_height;
                   output->srcx = main_dispwin.srcx;
                   output->srcy = main_dispwin.srcy;
                   output->src_wid = main_dispwin.src_wid;
                   output->src_height = main_dispwin.src_height;
                   DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
				   return ret;

         }
         else
         {
                   // all region are the same, just run apply_only_xy_shift, but do nothing
                   if(input->srcx == main_input_size.srcx && input->srcy == main_input_size.srcy)
                   {
                            DbgSclrFlgTkr.check_only_xy_shift_same_region = TRUE;
							ret = ALL_EQUAL;
                            return ret;
                   } else if((input->srcx != main_input_size.srcx) &&
				   			(input->srcy != main_input_size.srcy)){
				   			ret = ONLY_SHIFT_XY;
                   } else if(input->srcx != main_input_size.srcx){
				   			ret = ONLY_SHIFT_X;
                   } else if(input->srcy != main_input_size.srcy){
				   			ret = ONLY_SHIFT_Y;
                   }

                   input->srcx = main_input_size.srcx;
                   input->srcy = main_input_size.srcy;
                   input->src_wid = main_input_size.src_wid;
                   input->src_height = main_input_size.src_height;
                   output->srcx = main_dispwin.srcx;
                   output->srcy = main_dispwin.srcy;
                   output->src_wid = main_dispwin.src_wid;
                   output->src_height = main_dispwin.src_height;
                   DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
                   srctype = Get_DisplayMode_Src(display);
                   if(srctype == VSC_INPUTSRC_VDEC)	{
					   if ((!DbgSclrFlgTkr.Main_smooth_toggle_set_flag) && (!DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off)) {// && (!DbgSclrFlgTkr.smoothtoggle_start_flag)) {
							if (!DbgSclrFlgTkr.smoothtoggle_start_flag) {
								 send_vo_freeze_shiftxy_share_memory();
		                           			 return ret;
							} else {
								//wait
								unsigned int timeout = 15;

								while((DbgSclrFlgTkr.Main_smooth_toggle_set_flag ||DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off || DbgSclrFlgTkr.smoothtoggle_start_flag)&&timeout)
									{
										timeout--;
										msleep(10);
									}

								if(!timeout){
									rtd_pr_vsc_info("shiftxf wait smoothtoogh timeout !\n");
									return NOT_EQUAL;
								}else{
									 send_vo_freeze_shiftxy_share_memory();
									return ret;
								}
							}
						} else {
							return NOT_EQUAL;
						}
				  } else {
					return NOT_EQUAL;
				  }
         }
}


void apply_only_xy_shift(unsigned char display, StructSrcRect input, StructSrcRect inputTiming, StructSrcRect output)
{
	int timeout = 30;
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(display);

#ifdef CONFIG_SDNR_CROP// for VGIP overscan
	scaledown_ich1_uzd_ctrl0_RBUS	ich1_uzd_Ctrl0_REG;
	scaledown_ich1_uzd_db_ctrl_RBUS ich1_uzd_db_ctrl_reg;
	scaledown_ich1_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
	scaledown_ich1_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
	//scaledown_ich1_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
	StructSrcRect SDNR_size = input;
	//int mid = 0;
#else
	unsigned char src = Scaler_InputSrcGetType(display);
	unsigned int hstart = 0;
	unsigned int vstart = 0;
	vgip_vgip_chn1_ctrl_RBUS vgip_chn1_ctrl_reg;
	vgip_vgip_chn1_act_hsta_width_RBUS vgip_chn1_act_hsta_width_reg;
	vgip_vgip_chn1_act_vsta_length_RBUS vgip_chn1_act_vsta_length_reg;
#endif

	// all region are the same, just run apply_only_xy_shift, but do nothing
	if(DbgSclrFlgTkr.check_only_xy_shift_same_region == TRUE){
		rtd_pr_vsc_debug("apply_only_xy_shift do nothing\n");
		return;
	}

#ifdef CONFIG_SDNR_CROP	//for SDNR overscan

#if 0
	rtd_pr_vsc_info("========input size============\n");
	rtd_pr_vsc_info("x:%d,y:%d,wid:%d,len:%d\n",input.srcx,input.srcy,input.src_wid,input.src_height);
	rtd_pr_vsc_info("========output size============\n");
	rtd_pr_vsc_info("x:%d,y:%d,wid:%d,len:%d\n",output.srcx,output.srcy,output.src_wid,output.src_height);
	rtd_pr_vsc_info("===============================\n");
#endif
	SDNR_size = drvif_cal_SDNR_size(display,input,inputTiming,output);
	rtd_pr_vsc_emerg("[shiftxy][SDNR]x:%d,y:%d,wid:%d,len:%d\n",SDNR_size.srcx,SDNR_size.srcy,SDNR_size.src_wid,SDNR_size.src_height);
#if 0
	rtd_pr_vsc_info("############SDNR size#############\n");
	rtd_pr_vsc_info("x:%d,y:%d,wid:%d,len:%d\n",SDNR_size.srcx,SDNR_size.srcy,SDNR_size.src_wid,SDNR_size.src_height);
	rtd_pr_vsc_info("################################\n");
#endif
#ifdef CONFIG_I2RND_ENABLE
	if (!Scaler_I2rnd_get_timing_enable())
#endif
	{
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		while(ich1_uzd_db_ctrl_reg.h_db_en && ich1_uzd_db_ctrl_reg.v_db_en && ich1_uzd_db_ctrl_reg.v_db_apply)
		{
			timeout --;
			mdelay(1); /*wait 1ms 30 counts for vsync */
			if(!timeout) break;
			ich1_uzd_db_ctrl_reg.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		}
		if(timeout == 0) rtd_pr_vsc_info("uzd aplly time out !!! :%d\n",timeout);
		//uzu double buffer enbale
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		ich1_uzd_db_ctrl_reg.h_db_en=1;
		ich1_uzd_db_ctrl_reg.h_db_apply=0;
		ich1_uzd_db_ctrl_reg.v_db_en=1;
		ich1_uzd_db_ctrl_reg.v_db_apply=0;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg,ich1_uzd_db_ctrl_reg.regValue);
	}

	ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg);
	ich1_sdnr_cutout_range_hor_reg.hor_front = SDNR_size.srcx;
	ich1_sdnr_cutout_range_hor_reg.hor_width = SDNR_size.src_wid; // chip setting need to +1
	IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

	if(!Scaler_get_data_framesync(SLR_MAIN_DISPLAY))
	{
		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front = SDNR_size.srcy;
		ich1_sdnr_cutout_range_ver0_reg.ver_height = SDNR_size.src_height;// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);
	}

	//mid = ich1_sdnr_cutout_range_ver0_reg.ver_back;
	//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg);
	//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top = mid;
	//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot = mid - 1;
	//IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);

	ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_Ctrl0_reg);
	ich1_uzd_Ctrl0_REG.cutout_en = 1;
	IoReg_Write32(SCALEDOWN_ICH1_UZD_Ctrl0_reg, ich1_uzd_Ctrl0_REG.regValue);
#ifdef CONFIG_I2RND_ENABLE
	if (!Scaler_I2rnd_get_timing_enable())
#endif
	{
		//uzu double buffer apply
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		ich1_uzd_db_ctrl_reg.h_db_apply=1;
		ich1_uzd_db_ctrl_reg.v_db_apply=1;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg,ich1_uzd_db_ctrl_reg.regValue);
	}

#else		// for VGIP overscan

	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	while(vgip_chn1_act_hsta_width_reg.ch1_db_rdy && vgip_chn1_act_hsta_width_reg.ch1_db_en)
	{
		timeout --;
		mdelay(1); /*wait 1ms 30 counts for vsync */
		if(!timeout) break;
		vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	}

	if (Scaler_DispGetStatus(display, SLR_DISP_INTERLACE)) {
		hstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE) + input.srcx;
		vstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE) + input.srcy/2;
	} else {
		hstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE) + input.srcx;
		vstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE) + input.srcy;
	}

	if ((src == _SRC_HDMI) || (src == _SRC_VO)) {
		//if color space is 422 format, it should be even number. @ Crixus
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE) == COLOR_YUV422){
			if((hstart%2) != (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_IPH_ACT_STA_PRE)%2))
				hstart = hstart - 1;//This means that shift value need even
		}
	}
	vgip_chn1_ctrl_reg.regValue = rtd_inl(VGIP_VGIP_CHN1_CTRL_reg);
	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	vgip_chn1_act_hsta_width_reg.ch1_db_en = 1;
	vgip_chn1_act_hsta_width_reg.ch1_db_rdy = 0;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg,vgip_chn1_act_hsta_width_reg.regValue);

	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	if(vgip_chn1_ctrl_reg.ch1_digital_mode)
		vgip_chn1_act_hsta_width_reg.ch1_ih_act_sta = hstart - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE);
	else
		vgip_chn1_act_hsta_width_reg.ch1_ih_act_sta = hstart;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg, vgip_chn1_act_hsta_width_reg.regValue);
	vgip_chn1_act_vsta_length_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_VSTA_Length_reg);
	if(vgip_chn1_ctrl_reg.ch1_digital_mode)
		vgip_chn1_act_vsta_length_reg.ch1_iv_act_sta = vstart - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE);
	else
		vgip_chn1_act_vsta_length_reg.ch1_iv_act_sta = vstart;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_VSTA_Length_reg, vgip_chn1_act_vsta_length_reg.regValue);

	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	vgip_chn1_act_hsta_width_reg.ch1_db_rdy = 1;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg,vgip_chn1_act_hsta_width_reg.regValue);

#endif

	//KTASKWBS-5348  move update info after execution
	if(srctype == VSC_INPUTSRC_VDEC)
		zoom_record_input_output_pre_size(display,main_input_size, main_input_timing, main_dispwin);

}

void Scaler_data_frc_fs_change_adjust_outputregion(unsigned char display,unsigned short disp_height)
{
	return; //k3l always go data frc
#if 0
#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
	if(!vbe_disp_get_adaptivestream_fs_mode())
#endif
	{
		if (!vsc_get_adaptivestream_flag()) {
			if(Get_vo_smoothtoggle_timingchange_flag(display) ||(get_HDMI_HDR_mode() ==HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() ==HDR_HDR10_HDMI)) {
					if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC)) {
						if ((drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==TRUE) || (get_vo_vp9_flag(Get_DisplayMode_Port(display)))) {
							mute_control(display, TRUE);
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							down(&SetMainOutPutRegion_Semaphore);
							DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
							reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
							up(&SetMainOutPutRegion_Semaphore);
						} else {
							if(Get_display_forcebg_mask(display,SLR_FORCE_BG_TYPE_VSC)) {
								if (((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))||(main_input_size.src_height!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE))))
									|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid != main_input_timing.src_wid) || (main_input_size.src_height != main_input_timing.src_height))))
								{
									DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
									Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
									down(&SetMainOutPutRegion_Semaphore);
									reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
									up(&SetMainOutPutRegion_Semaphore);
								}
							}
						}
					} else {
						if(Get_display_forcebg_mask(display,SLR_FORCE_BG_TYPE_VSC)) {
							if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==FALSE) {
								if ((Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE)>=3000)&&(Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_V_FREQ)>310))
								{
									if(((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN)&&(main_input_size.src_wid==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))&&(main_input_size.src_height==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE)))
										|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN) && (main_input_size.src_wid == main_input_timing.src_wid) && (main_input_size.src_height == main_input_timing.src_height)))
									{
										DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
										Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
										down(&SetMainOutPutRegion_Semaphore);
										reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
										up(&SetMainOutPutRegion_Semaphore);
									}
								}
							}
						}
					}
				//}
			} else {//DTV flow
				if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC)) {
					if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==TRUE) {
						mute_control(display, TRUE);
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						down(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetMainOutPutRegion_Semaphore);
					} else {
						if (Get_display_forcebg_mask(display,SLR_FORCE_BG_TYPE_VSC)) {
							if (((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))||(main_input_size.src_height!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE))))
								|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid != main_input_timing.src_wid) || (main_input_size.src_height != main_input_timing.src_height))))
							{
								Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								down(&SetMainOutPutRegion_Semaphore);
								DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
								reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
								up(&SetMainOutPutRegion_Semaphore);
							}
						}
					}
				}
			}
		}
	}
#endif
}
unsigned char Scaler_data_frc_fs_change_adjust_after_scaler(unsigned char display,unsigned short disp_height)
{
	return TRUE; //k3l always go data frc
#if 0
	if (Scaler_InputSrcGetType(display) == _SRC_VO) {
#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
	if(!vbe_disp_get_adaptivestream_fs_mode())
#endif
	{
		if(!vsc_get_adaptivestream_flag() && (Get_vo_smoothtoggle_timingchange_flag(display) || (get_HDMI_HDR_mode() ==HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() ==HDR_HDR10_HDMI))) {
			if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC)) {
				if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==TRUE) {
					mute_control(display, TRUE);
					if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) {
						DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
					}
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					return FALSE;
				} else {
					if (((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))||(main_input_size.src_height!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE))))
						|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid != main_input_timing.src_wid) || (main_input_size.src_height != main_input_timing.src_height))))
					{
						DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						return FALSE;
					}
				}
			} else {
				if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==FALSE) {
					if ((Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE)>=3000)&&(Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_V_FREQ)>310))
					{
						if(((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN)&&(main_input_size.src_wid==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))&&(main_input_size.src_height==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE)))
							|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN) && (main_input_size.src_wid == main_input_timing.src_wid) && (main_input_size.src_height == main_input_timing.src_height)))
						{
							DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
							return FALSE;
						}
					}
				}
			}
		}
	}
	}
	return TRUE;
#endif
}



extern unsigned char drvif_module_vdc_Read_Vstate(void);
extern void drvif_module_vdc_CheckInputStatus(unsigned char ucInputSrc, unsigned char ucCheckStart);
extern unsigned char drvif_HDR_get_VO_Decompress_Status(unsigned char ch);

unsigned char  CompareATVOutputRegion(unsigned char a_ucChannel, VIDEO_RECT_T *a_ptOutputregion)
{
	if (SLR_MAIN_DISPLAY == a_ucChannel)
	{

		if (DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre == a_ptOutputregion->h
		)
		{
			return TRUE;
		}
	}
	else
	{
		if (DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre == a_ptOutputregion->h
		)
		{
			return TRUE;
		}
	}

	return FALSE;
}


unsigned char  CompareATVInputOutputRegion(unsigned char a_ucChannel, KADP_VIDEO_RECT_T *a_ptOutputregion, KADP_VIDEO_RECT_T *a_ptInputRegion)
{
	if (SLR_MAIN_DISPLAY == a_ucChannel)
	{
		if (DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre == a_ptOutputregion->h
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_x_pre == a_ptInputRegion->x
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_y_pre == a_ptInputRegion->y
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_w_pre == a_ptInputRegion->w
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_h_pre == a_ptInputRegion->h
		)
		{
			return TRUE;
		}
	}
	else
	{
		if (DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre == a_ptOutputregion->h
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre == a_ptInputRegion->x
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre == a_ptInputRegion->y
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre == a_ptInputRegion->w
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre == a_ptInputRegion->h
		)
		{
			return TRUE;
		}
	}

	return FALSE;
}

unsigned char uc4_get_main_dispwin_value(unsigned short *x, unsigned short *y, unsigned short *w, unsigned short *h)	//WOSQRTK-7731
{
	if((x !=NULL)&&(y !=NULL)&&(w !=NULL)&&(h !=NULL))
	{
		*x = main_dispwin.srcx;
		*y = main_dispwin.srcy;
		*w = main_dispwin.src_wid;
		*h = main_dispwin.src_height;
	}
	else
		return 1;
	return 0;
}

#if 0
void set_vsc_SetCircle_OutputRegion(KADP_VIDEO_RECT_T outregion, unsigned short W, unsigned short H, UINT32 shape)
{
	//rtd_pr_vsc_debug("rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);

	//rtd_pr_vsc_debug("\n ********************* Sub_circle_center_h = %d ", outregion.x+(outregion.w/2));
	//rtd_pr_vsc_debug("\n ********************* Sub_circle_center_v = %d ", outregion.y+(outregion.h/2));
	//rtd_pr_vsc_debug("\n ********************* Sub_act_rad_a = %d ", (outregion.w/2 * outregion.w/2));
	//rtd_pr_vsc_debug("\n ********************* Sub_act_rad_b = %d ", (outregion.h/2 * outregion.h/2));

	ppoverlay_sub_active_rad_a_RBUS           SUB_Active_Red_A_reg;
	ppoverlay_sub_active_rad_b_RBUS           SUB_Active_Red_B_reg;
	ppoverlay_sub_background_rad_a_RBUS ppoverlay_sub_background_rad_a_reg;
	ppoverlay_sub_background_rad_b_RBUS ppoverlay_sub_background_rad_b_reg;
	ppoverlay_sub_den_rad_a_RBUS ppoverlay_sub_den_rad_a_reg;
	ppoverlay_sub_den_rad_b_RBUS ppoverlay_sub_den_rad_b_reg;
	ppoverlay_sub_circle_center_RBUS		SUB_Circle_center_reg;
	int	Circle_x=0, Circle_y=0, Circle_w=0, Circle_h=0;

	unsigned short temp_w=0, temp_h=0;
	unsigned short true_w=0, true_h=0;

	if (outregion.w%2==0)
		temp_w = (outregion.w-1)/2;
	else
		temp_w = (outregion.w)/2;
	true_w = temp_w;

	if (outregion.h%2==0)
		temp_h = (outregion.h-1)/2;
	else
		temp_h = (outregion.h)/2;
	true_h = temp_h;

	if (shape == VSC_MGF_TYPE_CIRCLE)
	{
		if (W%2==0)
			temp_w = (W-1);
		else
			temp_w = (W);

		if (H%2==0)
			temp_h = (H-1);
		else
			temp_h = (H);
	}

	rtd_pr_vsc_debug("\n ***** 0.SLR_INPUT_DISP_WID=%d ", Scaler_DispGetInputInfoByDisp(1, SLR_INPUT_DISP_WID));
	rtd_pr_vsc_debug("\n ***** 0.SLR_INPUT_DISP_LEN=%d ", Scaler_DispGetInputInfoByDisp(1, SLR_INPUT_DISP_LEN));
	rtd_pr_vsc_debug("\n ***** 1.set_vsc_OutputRegion  x=%d, y=%d, w=%d, h=%d ", outregion.x, outregion.y, outregion.w, outregion.h);
	rtd_pr_vsc_debug("\n ***** 2.virtual_w=%d, virtual_h=%d ", W, H);

	if ((outregion.x== 0) && (outregion.y== 0) && (outregion.w >= W) && (outregion.h >= H))
	{
		Circle_x = (int)(outregion.x + outregion.w - W);
		Circle_y = (int)(outregion.y + outregion.h - H);
		rtd_pr_vsc_debug("\n ***** 3.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ((outregion.x== 0) && (outregion.w >= W) && (outregion.h/2 <=  H))
	{
		Circle_x = (int)(outregion.x + outregion.w - W);
		Circle_y = (int)(outregion.y + H);
		rtd_pr_vsc_debug("\n ***** 4.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.y== 0) && (outregion.w >= W) && (outregion.h >= H))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + outregion.h - H);
		rtd_pr_vsc_debug("\n ***** 5.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.y + outregion.h == 2160) && (outregion.h/2 < H))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + H);
		rtd_pr_vsc_debug("\n ***** 6.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.x + outregion.w == 3840) && (outregion.w/2 < W))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + H);
		rtd_pr_vsc_debug("\n ***** 7.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else
	{
		Circle_x = (int)(outregion.x + true_w);
		Circle_y = (int)(outregion.y + true_h);
		rtd_pr_vsc_debug("\n ***** 8.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}

	SUB_Active_Red_A_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Active_Rad_A_reg);
	SUB_Active_Red_A_reg.sub_act_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Active_Rad_A_reg, SUB_Active_Red_A_reg.regValue);

	SUB_Active_Red_B_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Active_Rad_B_reg);
	SUB_Active_Red_B_reg.sub_act_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Active_Rad_B_reg, SUB_Active_Red_B_reg.regValue);

	ppoverlay_sub_background_rad_a_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Background_Rad_A_reg);
	ppoverlay_sub_background_rad_a_reg.sub_bg_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Background_Rad_A_reg, ppoverlay_sub_background_rad_a_reg.regValue);

	ppoverlay_sub_background_rad_b_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Background_Rad_B_reg);
	ppoverlay_sub_background_rad_b_reg.sub_bg_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Background_Rad_B_reg, ppoverlay_sub_background_rad_b_reg.regValue);

	ppoverlay_sub_den_rad_a_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Den_Rad_A_reg);
	ppoverlay_sub_den_rad_a_reg.sub_den_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Den_Rad_A_reg, ppoverlay_sub_den_rad_a_reg.regValue);

	ppoverlay_sub_den_rad_b_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Den_Rad_B_reg);
	ppoverlay_sub_den_rad_b_reg.sub_den_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Den_Rad_B_reg, ppoverlay_sub_den_rad_b_reg.regValue);

	if (shape == VSC_MGF_TYPE_CIRCLE)
	{
		SUB_Circle_center_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);
		SUB_Circle_center_reg.sub_circle_center_h= (Circle_x)*2;
		SUB_Circle_center_reg.sub_circle_center_v= (Circle_y)*2;
		SUB_Circle_center_reg.sub_window_form_sel= 1;
		IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg.regValue);
	}
	else
	{
	SUB_Circle_center_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);
	SUB_Circle_center_reg.sub_circle_center_h= (outregion.x+temp_w)*2;
	SUB_Circle_center_reg.sub_circle_center_v= (outregion.y+temp_h)*2;
	SUB_Circle_center_reg.sub_window_form_sel= 0;
	IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg.regValue);
	}
}

void set_vsc_SetMagnifire_shape(UINT32 num)
{

	ppoverlay_sub_circle_center_RBUS		SUB_Circle_center_reg_shape;
	SUB_Circle_center_reg_shape.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);

	if(num==1)
		SUB_Circle_center_reg_shape.sub_window_form_sel= 1;//Circle
	//else if(num==2) //no need in arrow
  	//	SUB_Circle_center_reg.sub_window_form_sel= 2; //arrow
	else
  		SUB_Circle_center_reg_shape.sub_window_form_sel= 0; //rectangle

  	IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg_shape.regValue);

}
#endif

unsigned char check_force_rerun_scaler_condition(unsigned char srctype, unsigned char display)
{
    unsigned char result = FALSE;
    if(display == SLR_MAIN_DISPLAY) {
        if((srctype == VSC_INPUTSRC_HDMI) && (scaler_RGB444Mode_pre != rtk_hal_vsc_GetRGB444Mode()))
            result = TRUE;
    }

#ifdef CONFIG_DUAL_CHANNEL
    else
    {
    }
#endif
    return result;
}

void update_force_rerun_scaler_condition(unsigned char srctype, unsigned char display)
{
    if(display == SLR_MAIN_DISPLAY) {
        if(srctype == VSC_INPUTSRC_HDMI){
            scaler_RGB444Mode_pre = rtk_hal_vsc_GetRGB444Mode();
        }
    }

#ifdef CONFIG_DUAL_CHANNEL
    else
    {
    }
#endif
}

#ifdef CONFIG_DYNAMIC_PANEL_SELECT
KADP_VIDEO_RECT_T get_dlg_output_region(KADP_VIDEO_RECT_T outregion)
{
    KADP_VIDEO_RECT_T dlgOutputRegion = {0};

    dlgOutputRegion.x = outregion.x  * _DISP_WID / _DISP_DEFAULT_WID;
    dlgOutputRegion.y = outregion.y  * _DISP_LEN / _DISP_DEFAULT_LEN;
    dlgOutputRegion.w = outregion.w  * _DISP_WID / _DISP_DEFAULT_WID;
    dlgOutputRegion.h = outregion.h  * _DISP_LEN / _DISP_DEFAULT_LEN;

    rtd_pr_vsc_info("change output height (%d %d %d %d -> %d %d %d %d)\n",
        outregion.x, outregion.y, outregion.w, outregion.h, dlgOutputRegion.x, dlgOutputRegion.y, dlgOutputRegion.w, dlgOutputRegion.h);

     return dlgOutputRegion;
}

void dlg_rerun_scaler(void)
{
    //KADP_VIDEO_RECT_T rect;
    extern void request_vo_info(void);

    rtd_pr_vsc_info("[%s] dlg rerun scaler\n", __FUNCTION__);

    mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG*/

    //trigger scaler re-run
    if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
        scaler_HDMI_signal_error_handler(SLR_MAIN_DISPLAY);
    }
    else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG))
    {
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
        drivf_scaler_reset_freerun();
        request_vo_info();
        scaler_VDEC_signal_error_handler(SLR_MAIN_DISPLAY);
#if 0
        rect.x = main_dlg_dispwin.srcx;
        rect.y = main_dlg_dispwin.srcy;
        rect.w = main_dlg_dispwin.src_wid;
        rect.h = main_dlg_dispwin.src_height;

        //dlg update output region
        rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, rect, 0, 0);
#endif
        DbgSclrFlgTkr.Main_Run_Scaler_flag = 1;
    }
    else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)
    {
        Scaler_AVD_ClearTimingInfo();
        set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);
        Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
        drivf_scaler_reset_freerun();
        clear_online_status(SLR_MAIN_DISPLAY);
        Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);
    }
}
extern void GDMA_Clk_Select(int src_type, bool enable);
extern int GAL_Runtime_Suspend_enable_OSD(void);
extern int GAL_Runtime_Suspend_disable_OSD(void);
extern int GAL_Runtime_Resume_receive(void);
void dlg_callback_handler(DLG_CALLBACK_TYPE eType)
{
    switch(eType)
    {
#ifndef UT_flag
        case E_DLG_INIT:
            if(Get_DISPLAY_HSR_ENABLE())
            {
                //HSR 120, bootcode is HSR120
                if(Get_DISPLAY_HSR_MODE() == PANEL_HSR_4k1k120)
                {
                    vbe_set_cur_dlg_mode(PANEL_DLG_4k1k120);
                    vbe_dynamic_set_dlgmode(PANEL_DLG_4k1k120);
                }

                HAL_VBE_Panel_Set_DlgEnable(1);
            }
            break;

        case E_DLG_FREE_RUN:
            drivf_scaler_reset_freerun();
            break;

        case E_DLG_DTG_FRACTION:
            modestate_decide_fractional_framesync();
            scaler_disp_dtg_pre_i_domain_setting(SLR_MAIN_DISPLAY);
            Scaler_wait_for_input_one_frame(SLR_MAIN_DISPLAY);
            break;

        case E_DLG_NOTIFY_VCPU_UPGRAD_PANEL_PARAMETER:
            Set_send_panel_para_flag(true);
            panel_parameter_send_info();
            break;

        case E_DLG_DISABLE_OSD:
            dlgOsdDisable = 1;
            GAL_Runtime_Suspend_disable_OSD();
            IoReg_ClearBits(OSDOVL_Mixer_CTRL2_reg, _BIT0);
            IoReg_SetBits(OSDOVL_OSD_Db_Ctrl_reg,_BIT0| _BIT1);
            rtd_pr_vsc_info("func=%s line=%d OSDOVL_Mixer_CTRL2_reg=%x\n",__FUNCTION__,__LINE__,rtd_inl(OSDOVL_Mixer_CTRL2_reg));
            break;

        case E_DLG_ENABLE_OSD:
            if(dlgOsdDisable == 1)
            {
                dlgOsdDisable = 0;
                IoReg_SetBits(OSDOVL_Mixer_CTRL2_reg, _BIT0);
                IoReg_SetBits(OSDOVL_OSD_Db_Ctrl_reg,_BIT0| _BIT1);
				rtd_pr_vsc_info("func=%s line=%d OSDOVL_Mixer_CTRL2_reg=%x\n",__FUNCTION__,__LINE__,rtd_inl(OSDOVL_Mixer_CTRL2_reg));
                GDMA_Clk_Select(0, true);
                GAL_Runtime_Suspend_enable_OSD();
                GAL_Runtime_Resume_receive();
            }
            break;
#endif // #ifndef UT_flag
        case E_DLG_MEMC:
            set_reset_MEMC_flg(true);
            Scaler_MEMC_Handler();
            //msleep(180);
            break;

        case E_DLG_ENABLE_DLG_MASK:
            set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DLG, 1);
            break;

        case E_DLG_DISABLE_DLG_MASK:
            set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DLG, 0);
            break;

        case E_DLG_SET_PRINT_DLG_MESSAGE_CNT:
            vbe_set_print_dlg_message_cnt(5);
            break;

        case E_DLG_WAIT_MEMC_DTG_PORCH:
            WaitFor_DEN_STOP_MEMCDTG();
            break;

        default:
            break;
    }
}

void check_dlg_mode(void)
{
    PANEL_DLG_MODE dlgMode = PANEL_DLG_DEFAULT;
    unsigned char needRerunScaler = 0;

    if(vbe_check_dlg_mode_change())
    {
        if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
                && (get_scaler_stop_flag(SLR_MAIN_DISPLAY) == FALSE))
        {
            needRerunScaler = 1;
        }

        if(vbe_get_dlg_support_all_timing() == 1)
        {
            //vdec source need set search before when change dlg
            if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG))
            {
                Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
            }

            dlgMode = vbe_get_panel_dlg_mode();
            Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
            vbe_set_panel_dlg_mode(dlgMode);
        }

        if(needRerunScaler)
        {
            dlg_rerun_scaler();
        }
    }
}
#endif

extern unsigned char Scaler_main_imd_pst_get_enable(void);
extern unsigned char check_rotate_ratio_the_same_size(unsigned char display,StructSrcRect input_size,StructSrcRect input_timing,StructSrcRect output_size);
unsigned char rtk_hal_vsc_SetOutputRegion(VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion, unsigned short Wide, unsigned short High)
{
	StructSrcRect m_dispwin ; //temp add by will
	VSC_INPUT_TYPE_T srctype;
	unsigned char channel = SLR_MAIN_DISPLAY;
//	KADP_VIDEO_RECT_T inregion;
//	KADP_VIDEO_RECT_T orgInput_Timing;
//	unsigned char hal_inputType  = 0;
	unsigned char port_num = 0;
	ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
	unsigned char plane=0;
	static unsigned char OutpuLocalDimmingPatMode_pre = FALSE;
	unsigned long flags=0x00;//for spin_lock_irqsave
	//unsigned char avd_small_output_flag = FALSE;
	unsigned char equal_type = NOT_EQUAL;

	extern unsigned char rtk_hal_vsc_dm_connect(unsigned char display, KADP_VSC_HDR_TYPE_T eHdrMode);


	KADP_VIDEO_RECT_T tInputRegion;
	ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
	StructSrcRect winSrcRect = {0, 0, 0, 0};


	//rtd_pr_vsc_debug("rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
	//rtd_pr_vsc_emerg( "rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
	//frank@0323 add TV006_WB_Pattern_En to support output region function

//#ifdef CONFIG_MEMC_BYPASS
	if(get_MEMC_bypass_status_refer_platform_model() == TRUE){
		outregion.x = outregion.x/(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) +1);
		outregion.w = outregion.w/(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) +1);
	//rtd_pr_vsc_notice("after memc_bypass rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
//#endif
	}
    if(wid == VIDEO_WID_0)
    {
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
        if(vbe_check_dlg_mode_change())
        {
            PANEL_DLG_MODE dlgMode = vbe_get_panel_dlg_mode();
            vbe_set_panel_dlg_mode(dlgMode);
        }
        main_dlg_dispwin.srcx = outregion.x;
        main_dlg_dispwin.srcy = outregion.y;
        main_dlg_dispwin.src_wid = outregion.w;
        main_dlg_dispwin.src_height = outregion.h;
        outregion = get_dlg_output_region(outregion);
#endif //CONFIG_DYNAMIC_PANEL_SELECT
    	//if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("rtk_hal_vsc_SetOutputRegion main output(%d %d %d %d) \n", outregion.x, outregion.y, outregion.w, outregion.h);
    	}
    }
	else
	{
		//if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_pr_vsc_info("rtk_hal_vsc_SetOutputRegion sub output(%d %d %d %d) \n", outregion.x, outregion.y, outregion.w, outregion.h);
    	}
	}

    vsc_adaptivestream_save_region((KADP_VIDEO_WID_T)wid, outregion);

	if((OutpuLocalDimmingPatMode == TRUE) || Get_tv006_wb_pattern()){

		osdovl_mixer_ctrl2_RBUS mixer_ctrl2_reg;
		ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
		ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
		ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
		ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
		unsigned int timeout=0x3fffff;
		ppoverlay_main_background_color1_RBUS	main_background_color1_reg;
		ppoverlay_main_background_color2_RBUS main_background_color2_reg;
		ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
		//ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
		//ppoverlay_double_buffer_ctrl2_RBUS double_buffer_ctrl2_reg;
		ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
		if(!Get_tv006_wb_pattern()) {
		if((outregion.x ==0)&&(outregion.y == 0)&&(outregion.w == 3840)&&(outregion.h== 2160))
			return TRUE;
		}
		rtd_pr_vsc_debug("+++OutpuLocalDimmingPatMode");

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

		//set free run timing
		//drivf_scaler_reset_freerun_60Hz();
		//fw_scaler_dtg_double_buffer_enable(TRUE);
		down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
		double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		double_buffer_ctrl_reg.dmainreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
		spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
		up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		if(!Get_tv006_wb_pattern()){
		// turn off osd mixer
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 0;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		rtd_pr_vsc_info("func=%s line=%d OSDOVL_Mixer_CTRL2_reg=%x\n",__FUNCTION__,__LINE__,rtd_inl(OSDOVL_Mixer_CTRL2_reg));
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);
		}

		main_background_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_H_Start_End_reg);
		main_background_h_start_end_reg.mh_bg_sta = outregion.x;
		main_background_h_start_end_reg.mh_bg_end = outregion.x+outregion.w;
		IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);

		main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
		main_active_h_start_end_reg.mh_act_sta= outregion.x;
		main_active_h_start_end_reg.mh_act_end = outregion.x+outregion.w;
		IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);

		main_background_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_V_Start_End_reg);
		main_background_v_start_end_reg.mv_bg_sta = outregion.y;
		main_background_v_start_end_reg.mv_bg_end = outregion.y+outregion.h;
		IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);

		main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
		main_active_v_start_end_reg.mv_act_sta = outregion.y;
		main_active_v_start_end_reg.mv_act_end = outregion.y+outregion.h;
		IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);
		if(!Get_tv006_wb_pattern()){
			main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
			main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
			main_background_color1_reg.m_bg_b = 0x3fff;
			main_background_color1_reg.m_bg_g = 0x3fff;
			main_background_color2_reg.m_bg_r = 0x3fff;
			IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
			IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);
			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
			main_display_control_rsv_reg.m_force_bg = 1;
			IoReg_Write32(PPOVERLAY_Main_Display_Control_RSV_reg, main_display_control_rsv_reg.regValue);
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		}
		dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}

		if(OutpuLocalDimmingPatMode) {
		OutpuLocalDimmingPatMode_pre = TRUE;
		return TRUE;
		}

	}else{

		if(OutpuLocalDimmingPatMode_pre == TRUE){
			ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
			ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
			ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
			ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
			ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
			unsigned int timeout=0x3fffff;

			ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			double_buffer_ctrl_reg.dmainreg_dbuf_en = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			main_background_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_H_Start_End_reg);
			main_background_h_start_end_reg.mh_bg_sta = Get_DISP_ACT_STA_HPOS();
			main_background_h_start_end_reg.mh_bg_end = Get_DISP_ACT_END_HPOS();
			IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);
			main_background_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_V_Start_End_reg);
			main_background_v_start_end_reg.mv_bg_sta = Get_DISP_ACT_STA_VPOS();
			main_background_v_start_end_reg.mv_bg_end = Get_DISP_ACT_END_VPOS();
			IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);
			main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
			main_active_h_start_end_reg.mh_act_sta= outregion.x;
			main_active_h_start_end_reg.mh_act_end = outregion.x+outregion.w;
			IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);
			main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
			main_active_v_start_end_reg.mv_act_sta = outregion.y;
			main_active_v_start_end_reg.mv_act_end = outregion.y+outregion.h;
			IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			do{
				dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
			}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

			if(timeout==0){
				rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
				dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
				IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
				dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
				dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
				IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
				dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
				IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			}else{
				dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
				dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
				IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			}
			OutpuLocalDimmingPatMode_pre = FALSE;
		}
		else
		OutpuLocalDimmingPatMode_pre = FALSE;

	}



#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif
	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}
	srctype = Get_DisplayMode_Src(channel);

	//rtd_pr_vsc_debug("rtk_hal_vsc_SetOutputRegion wid=%x  channel=%x\n", wid, channel);

	if(wid == VIDEO_WID_0) {

#ifdef SPEEDUP_NEW_SCALER_FLOW
			if(main_InputRegion_0000)
			{
				rtd_pr_vsc_err("#####[%s(%d)]input is zero, return\n",__func__,__LINE__);
				return TRUE;
			}
#endif
#if 1//def CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			if ((outregion.w < 1) || (outregion.h < 1)) {
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
				main_dispwin.srcx = outregion.x;
				main_dispwin.srcy = outregion.y;
				main_dispwin.src_height = outregion.h;
				main_dispwin.src_wid = outregion.w;
				check_input_and_output_the_same(SLR_MAIN_DISPLAY);
				up(&SetMainOutPutRegion_Semaphore);
				rtd_pr_vsc_emerg("outputregion is zero, return\n");
				return TRUE;
			}
#endif


			if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{//For ATV case
				unsigned ucVDTimingChange;
				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					m_dispwin.srcx = 0;
					m_dispwin.srcy = 0;
					m_dispwin.src_height = _DISP_LEN;
					m_dispwin.src_wid = _DISP_WID;
				}else {
					m_dispwin.srcx = outregion.x;
					m_dispwin.srcy = outregion.y;
					m_dispwin.src_height = outregion.h;
					m_dispwin.src_wid = outregion.w;
				}
//				if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag){//This means that currently force bg is disabled, so directly run scaler flow
				ucVDTimingChange = Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY); // it will not clear ATV run search state flag
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
				//if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && !avd_small_output_flag)
				if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
#else
				if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
#endif
				{//This means that currently force bg is disabled and color std is not changed, so run smooth toggle flow //For Sub black video issue patch will 20151211
					set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
					set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
					set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
					Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
					rtd_pr_vsc_notice("2 rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_height = m_dispwin.src_height;
					main_dispwin.src_wid = m_dispwin.src_wid;

					//back up output region	//WOSQRTK-6617
					DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre = outregion.x;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre = outregion.y;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre = outregion.w;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre = outregion.h;

					down(&VSC_Semaphore);
					Scaler_DispWindowSet(m_dispwin);
					rtd_pr_vsc_info("####[%s(%d)] atv smooth toggle#####\r\n", __FUNCTION__,__LINE__);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					winSrcRect = Scaler_DispWindowGet();
					//zoom_imd_smooth_toggle_config(wid, outregion.x, outregion.y, outregion.w, outregion.h, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);

					up(&VSC_Semaphore);
				} else {//This means that currently force bg is enabled. Need to check run smooth toggle or scaler
					down(&SetMainOutPutRegion_Semaphore);

					if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && ucVDTimingChange)//This means that currently force bg is disabled and color std is changed, so directly run scaler flow
					{
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Special case:mute off=>set ARC have to run
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						rtd_pr_vsc_notice("####[%s(%d)] [special case]request atv run main scaler flow atv#####\r\n", __FUNCTION__,__LINE__);
					}
					else{
						if((Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE) && (Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY) == FALSE)) {
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//This is special case for VIP test
							DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
							rtd_pr_vsc_notice("####[%s(%d)] no mute on, so request run main scaler flow for atv directly####\r\n",__func__,__LINE__);
						} else {
							//DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//KTASKWBS-11685
						#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
						#endif
							rtd_pr_vsc_info("####[%s(%d)] request atv run main scaler flow atv#####\r\n",__func__,__LINE__);
						}
					}
					reset_any_srcrect(&main_dispwin_for_only_xy);
					DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag = TRUE;//in ATV set this flag to check ATV will run scaler flow.
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_height = m_dispwin.src_height;
					main_dispwin.src_wid = m_dispwin.src_wid;

					//back up output region	//WOSQRTK-6617
					DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre = outregion.x;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre = outregion.y;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre = outregion.w;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre = outregion.h;

					if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
						set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
					}
					up(&SetMainOutPutRegion_Semaphore);
				}
				return TRUE;
			}
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			{
				if (srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG)
				{
					port_num = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);

					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						down(get_vo_infosemaphore());
						if(get_vo_change_flag(port_num))
						{
							up(get_vo_infosemaphore());
							if (Get_vo_smoothtoggle_timingchange_flag(SLR_MAIN_DISPLAY)) {
								if(get_vo_run_smooth_toggle_enable(SLR_MAIN_DISPLAY)) {
								} else {
									if (get_vo_smoothtoggle_state(SLR_MAIN_DISPLAY) == SLR_SMOOTH_TOGGLE_ACTIVE) {
										plane = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);;
										//vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(SLR_MAIN_DISPLAY), SLR_MAIN_DISPLAY);
										set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, SLR_MAIN_DISPLAY,plane);
										smooth_toggle_state_info_rpc(SLR_MAIN_DISPLAY);
										rtd_pr_vsc_notice("set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_INIT\n");
									}
									if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
										Share_Memory_Set_Scaler_Run_Flag(1);
									rtd_pr_vsc_notice("\r\n####Voinfo is change. Active to search 1####\r\n");
									Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								}
							} else {
								rtd_pr_vsc_notice("\r\n####Voinfo is change. Active to search 2####\r\n");
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							}
						} else {
							up(get_vo_infosemaphore());
						}

					}
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetMainOutPutRegion_Semaphore);
					}
				}
			}
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE && get_3D_mode_enable())
			{
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
				up(&SetMainOutPutRegion_Semaphore);
			}

			if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
				m_dispwin.srcx = 0;
				m_dispwin.srcy = 0;
				m_dispwin.src_height = _DISP_LEN;
				m_dispwin.src_wid = _DISP_WID;
			}else {
				m_dispwin.srcx = outregion.x;
				m_dispwin.srcy = outregion.y;
				m_dispwin.src_height = outregion.h;
				m_dispwin.src_wid = outregion.w;
			}
			if (((srctype == VSC_INPUTSRC_VDEC) ||(((srctype == VSC_INPUTSRC_HDMI)&& (get_HDMI_HDR_mode() ==HDR_DOLBY_HDMI)) || (get_HDMI_HDR_mode() ==HDR_HDR10_HDMI))) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
				Scaler_data_frc_fs_change_adjust_outputregion(SLR_MAIN_DISPLAY,m_dispwin.src_height);
			}
#if 0
			if ((srctype == VSC_INPUTSRC_JPEG) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
				ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
				ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
				main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);/* Main Active H pos*/
				main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);

				if((m_dispwin.src_wid != (main_active_h_start_end_reg.mh_act_end - main_active_h_start_end_reg.mh_act_sta))||
				(m_dispwin.src_height != (main_active_v_start_end_reg.mv_act_end - main_active_v_start_end_reg.mv_act_sta))) {
					Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetMainOutPutRegion_Semaphore);
				}
			}
#endif

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			if (((get_rotate_mode(SLR_MAIN_DISPLAY)!=main_rotate_mode) &&((get_rotate_mode(SLR_MAIN_DISPLAY)!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT) ||(main_rotate_mode!=0)))
				|| (((main_rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)||(main_rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270)) && (check_rotate_ratio_the_same_size(SLR_MAIN_DISPLAY, main_input_size,main_input_timing,m_dispwin) == FALSE)))
			{
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
				{
					rtd_pr_vsc_emerg("[Qing]output rotate run=%d,%d\n",get_rotate_mode(SLR_MAIN_DISPLAY),main_rotate_mode);
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_for_only_xy);
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_wid = m_dispwin.src_wid;
					main_dispwin.src_height = m_dispwin.src_height;
					if (main_rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_0) {
						DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
					}
					if (Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE) {
						ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
						DbgSclrFlgTkr.rotate_run_scaler_flag = TRUE;
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						up(&SetMainOutPutRegion_Semaphore);
						rtd_pr_vsc_emerg("[Rotate]active case run rotate scaler\n");
						main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
						if (!main_display_control_rsv_reg.m_force_bg) {
							rtd_pr_vsc_emerg("[Rotate]force to forcbg \n");
							down(get_forcebg_semaphore());
							scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
							up(get_forcebg_semaphore());
						}
					} else {
						DbgSclrFlgTkr.rotate_muteoff_request_flag = TRUE;
						//DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						up(&SetMainOutPutRegion_Semaphore);
						rtd_pr_vsc_emerg("[Rotate] active case mute off go rotate\n");
					}
				} else {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_for_only_xy);
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_wid = m_dispwin.src_wid;
					main_dispwin.src_height = m_dispwin.src_height;
					if(check_input_and_output_the_same(SLR_MAIN_DISPLAY) == FALSE)
					{
						if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
							Share_Memory_Set_Scaler_Run_Flag(1);
						DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;

						if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
							set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
						}

						DbgSclrFlgTkr.rotate_muteoff_request_flag = TRUE;
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						rtd_pr_vsc_emerg("[Rotate] search case mute off go rotate\n");
					}
					up(&SetMainOutPutRegion_Semaphore);
				}
			}else
#endif
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (DbgSclrFlgTkr.OuputDisplayMode || DbgSclrFlgTkr.OutputMemoryMode)) {
				if ((outregion.w == 0) || (outregion.h == 0)) {
					/*if main output region all are zero, do nothing @Crixus 20160118*/
					/*
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_enable_display(SLR_MAIN_DISPLAY, _DISABLE);
					up(get_forcebg_semaphore());
					main_wind0000 = TRUE;
					*/
				} else {
					down(&SetMainOutPutRegion_Semaphore);

					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_wid = m_dispwin.src_wid;
					main_dispwin.src_height = m_dispwin.src_height;
					if(check_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY) == TRUE){
						ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
						main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
						if (!main_display_control_rsv_reg.m_force_bg) {
							mute_control(SLR_MAIN_DISPLAY, TRUE);
						}
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####[ACTIVE] condition changed[RGB444 %d/%d], so force re-run scaler####\r\n", scaler_RGB444Mode_pre , rtk_hal_vsc_GetRGB444Mode());
						Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//trigger run scaler
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
						vsc_force_rerun_main_scaler = TRUE;
						update_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY);
						up(&SetMainOutPutRegion_Semaphore);
					}else if((srctype != VSC_INPUTSRC_AVD) && ((equal_type = check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre, &main_dispwin_for_only_xy)) != 0)//need to updatemain_input_size_pre and main_dispwin_for_only_xy always
						&& (Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)
#ifdef CONFIG_PST_ENABLE
						&& (Scaler_main_imd_pst_get_enable()==FALSE)
#endif
						){
						up(&SetMainOutPutRegion_Semaphore);
					#if 1 //def CONFIG_ALL_SOURCE_DATA_FS
						if ((srctype == VSC_INPUTSRC_VDEC) &&  Scaler_get_data_framesync(SLR_MAIN_DISPLAY)
							&& (equal_type == ONLY_SHIFT_XY || equal_type == ONLY_SHIFT_Y)) {
							down(&VSC_Semaphore);
							Scaler_DispWindowSet(main_dispwin);
							winSrcRect = Scaler_DispWindowGet();
							zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
							up(&VSC_Semaphore);
						} else
					#endif
						{
							rtd_pr_vsc_notice("apply_only_xy_shift...\n");
							apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
						}
					} else {
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
						if(((Scaler_InputRegionType_Get(wid)==INPUT_BASE_ON_TIMING)||(Scaler_InputRegionType_Get(wid)==INPUT_BASE_ON_DISP_WIN)) && get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY))
						{
						    KADP_VIDEO_RECT_T stInputRect;

						    stInputRect.x = main_input_size.srcx;
						    stInputRect.y = main_input_size.srcy;
						    stInputRect.h = main_input_size.src_height;
						    stInputRect.w = main_input_size.src_wid;

						    rtd_pr_vsc_emerg( "[%s, %d] pst flow\n", __FUNCTION__, __LINE__);
						     //copy output region

						    update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, stInputRect, ap_main_originalInput_parm, outregion,hal_main_InputRegionType);
						}
						else
#endif
						if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){
							rtd_pr_vsc_notice("\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
							DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
						} else {
							rtd_pr_vsc_notice("\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
							DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
						}
						up(&SetMainOutPutRegion_Semaphore);

					}
					/*if main output region all are zero, do nothing @Crixus 20160118*/
					/*
					if(main_wind0000 == TRUE) {
						down(get_forcebg_semaphore());
						drvif_scalerdisplay_enable_display(SLR_MAIN_DISPLAY, _ENABLE);
						up(get_forcebg_semaphore());
						main_wind0000 = FALSE;
					}
					*/
				}
			}
			else if (DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode) {
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				main_dispwin.srcx = m_dispwin.srcx;
				main_dispwin.srcy = m_dispwin.srcy;
				main_dispwin.src_height = m_dispwin.src_height;
				main_dispwin.src_wid = m_dispwin.src_wid;
                if(check_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY) == TRUE){
					rtd_pr_vsc_notice("\r\n####[SEARCH] condition changed[RGB444 %d/%d], so force re-run scaler####\r\n", scaler_RGB444Mode_pre , rtk_hal_vsc_GetRGB444Mode());
					DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//trigger run scaler
					DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
					vsc_force_rerun_main_scaler = TRUE;
					update_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY);
				}
				else if(check_input_and_output_the_same(SLR_MAIN_DISPLAY) == FALSE) {
					if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
						Share_Memory_Set_Scaler_Run_Flag(1);
					DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
					if((Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)) {
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//This is special case for VIP test
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
						rtd_pr_vsc_notice("\r\n####no mute on, so request run main scaler flow directly####\r\n");
					} else {
#ifdef SPEEDUP_NEW_SCALER_FLOW
						if((srctype == VSC_INPUTSRC_HDMI) && vfe_hdmi_drv_timing_ready())
						{
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//directly to run scaler
							rtd_pr_vsc_notice("\r\n####func:%s hdmi directly run main scaler flow#####\r\n", __FUNCTION__);
						}
						else
						{
							DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
							rtd_pr_vsc_notice("\r\n####func:%s src:%d request run main scaler flow#####\r\n", __FUNCTION__, srctype);
						}
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
						complete(&vsc_scaler_tsk_completion);
#else
						DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
						rtd_pr_vsc_notice("\r\n####func:%s src:%d request run main scaler flow#####\r\n", __FUNCTION__, srctype);
#endif
					}
					if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
						set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
					}

				} else {
					rtd_pr_vsc_notice("\r\n####func:%s src:%d main the input and output is the same#####\r\n", __FUNCTION__, srctype);
				}
				if(srctype == VSC_INPUTSRC_JPEG) {
					DbgSclrFlgTkr.JPEG_Scaler_SM = 1;
				} else {
					DbgSclrFlgTkr.JPEG_Scaler_SM = 0;
				}
				up(&SetMainOutPutRegion_Semaphore);

			}

	}
	else if (wid == VIDEO_WID_1)
	{
#ifdef CONFIG_DUAL_CHANNEL
		  if ((DbgSclrFlgTkr.Sub_OuputDisplayMode || DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode))
		  {
			if ((outregion.w < 1) || (outregion.h < 1))
			{
					down(&SetSubOutPutRegion_Semaphore);
					DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
					sub_dispwin_pre.srcx = outregion.x;
					sub_dispwin_pre.srcy = outregion.y;
					sub_dispwin_pre.src_height = outregion.h;
					sub_dispwin_pre.src_wid = outregion.w;
					up(&SetSubOutPutRegion_Semaphore);
					rtd_pr_vsc_err("sub outputregion is zero, return\n");
					return TRUE;
			}

			if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{
				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					m_dispwin.srcx = 0;
					m_dispwin.srcy = 0;
					m_dispwin.src_height = _DISP_LEN;
					m_dispwin.src_wid = _DISP_WID;
				}else {
					m_dispwin.srcx = outregion.x;
					m_dispwin.srcy = outregion.y;
					m_dispwin.src_height = outregion.h;
					m_dispwin.src_wid = outregion.w;
				}


				rtd_pr_vsc_debug("SetOutputRegion DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
				rtd_pr_vsc_debug("SetOutputRegion scaler state=%x\n", Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE));
				rtd_pr_vsc_debug("SetOutputRegion Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY)=%x\n", Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY));

				//rtd_pr_vsc_emerg( "SetOutputRegion DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
				//rtd_pr_vsc_emerg( "SetOutputRegion scaler state=%x\n", Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE));
				//rtd_pr_vsc_emerg( "SetOutputRegion Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY)=%x\n", Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY));

				rtk_hal_vsc_GetInputRegion(1, &tInputRegion);

				//rtd_pr_vsc_emerg( "SetOutputRegion rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);
				rtd_pr_vsc_debug("SetOutputRegion rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);


				if (DbgSclrFlgTkr.Sub_OutputVencMode) {
					down(&SetSubOutPutRegion_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;

					set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
					set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
					set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
					Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,hal_sub_InputRegionType);

					Scaler_SubDispWindowSet(sub_dispwin);
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
					DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
					up(&SetSubOutPutRegion_Semaphore);
					return TRUE;
				} else if(DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {//For Sub black video issue patch will 20151211


					if (CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &outregion, &tInputRegion))
					{
						//rtd_pr_vsc_emerg( "0  ATV sub path, no forcebg, intput and output region are the same\n");
						rtd_pr_vsc_debug("0  ATV sub path, no forcebg, intput and output region are the same\n");
						return TRUE;
					}
					mute_control(SLR_SUB_DISPLAY, TRUE);/*Auto BG. Add by Will*/
					down(&SetSubOutPutRegion_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;
					set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
					//Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//For Sub black video issue patch will 20151211
					DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;

					rtd_pr_vsc_debug("\r\n####func:%s sub smooth toggle temp flow#####\r\n", __FUNCTION__);
					up(&SetSubOutPutRegion_Semaphore);
					return TRUE;
				}
				else if(Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					if (CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &outregion, &tInputRegion))
					{
						//rtd_pr_vsc_emerg( "1  ATV sub path, no forcebg, intput and output region are the same\n");
						rtd_pr_vsc_debug("1  ATV sub path, no forcebg, intput and output region are the same\n");
						DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
						return TRUE;
					}
				}
				down(&SetSubOutPutRegion_Semaphore);
				sub_dispwin.srcx = outregion.x;
				sub_dispwin.srcy = outregion.y;
				sub_dispwin.src_height = outregion.h;
				sub_dispwin.src_wid = outregion.w;

				set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area

				if((Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE)) {
					DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;//This is special case for VIP test
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//Let scaler can be run
					rtd_pr_vsc_notice("\r\n####no mute on, so request run sub scaler flow for atv directly####\r\n");
				} else {
					DbgSclrFlgTkr.Sub_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler

					rtd_pr_vsc_debug("\r\n####func:%s request atv run sub scaler flow atv#####\r\n", __FUNCTION__);
				}
				if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
					set_source_info_forPQ(SLR_SUB_DISPLAY);//Set source info for PQ request befor scaler
				}
				up(&SetSubOutPutRegion_Semaphore);
				return TRUE;
			}
#if 1//for sub smooth toggle test
//if sub supports timing change flow ,need mark this code
			if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			{
				if (srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG)
				{
					down(get_vo_infosemaphore());
					if(get_vo_change_flag(Get_DisplayMode_Port(SLR_SUB_DISPLAY)))
					{
							rtd_pr_vsc_debug("\r\n####Voinfo is change. Active to search 3####\r\n");
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					}
					up(get_vo_infosemaphore());
					if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
						down(&SetSubOutPutRegion_Semaphore);
						reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetSubOutPutRegion_Semaphore);
					}
				}
			}
#endif
			if ((outregion.w == 0) || (outregion.h == 0)) {
				sub_dispwin.srcx = 0;
				sub_dispwin.srcy = 0;
				sub_dispwin.src_height = 0;
				sub_dispwin.src_wid = 0;
				Scaler_SubDispWindowSet(sub_dispwin);
				if (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_subdisplay_hidenfunc( _ENABLE);
					up(get_forcebg_semaphore());
					DbgSclrFlgTkr.sub_wind0000 = TRUE;
				}
			} else {
				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					outregion.x = 0;
					outregion.y = 0;
					outregion.h = _DISP_LEN;
					outregion.w = _DISP_WID;
				}
				if (DbgSclrFlgTkr.Sub_OutputVencMode) {
					down(&VSC_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;
					set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
					set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
					set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
					Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,hal_sub_InputRegionType);

					Scaler_SubDispWindowSet(sub_dispwin);
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
					set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
					rtk_output_connect(SLR_SUB_DISPLAY);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//avoid main path display flag wrong
					up(&VSC_Semaphore);

				} else if (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
#if 0
										//Need smooth toggle flow. Not yet
										mute_control(SLR_SUB_DISPLAY, TRUE);/*Auto BG. Add by Will*/
										down(&SetSubOutPutRegion_Semaphore);
										sub_dispwin.srcx = outregion.x;
										sub_dispwin.srcy = outregion.y;
										sub_dispwin.src_height = outregion.h;
										sub_dispwin.src_wid = outregion.w;
										set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
										Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
										DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
#else// for sub smooth toggle test


#if 0//def ENABLE_IMD_PST_SMOOTHTOGGLE
					if(((Scaler_InputRegionType_Get(wid)==INPUT_BASE_ON_TIMING)||(Scaler_InputRegionType_Get(wid)==INPUT_BASE_ON_DISP_WIN)) && vsc_get_adaptivestream_flag(SLR_SUB_DISPLAY))
					{
						KADP_VIDEO_RECT_T stInputRect;

						stInputRect.x = sub_input_size.srcx;
						stInputRect.y = sub_input_size.srcy;
						stInputRect.h = sub_input_size.src_height;
						stInputRect.w = sub_input_size.src_wid;

						rtd_pr_vsc_emerg( "[%s, %d]sub pst flow\n", __FUNCTION__, __LINE__);
						 //copy output region

						update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, stInputRect, ap_sub_originalInput_parm, outregion,hal_sub_InputRegionType);
					}
					else
#endif
					if(decide_run_sub_smoothtoggle_case()){
						down(&SetSubOutPutRegion_Semaphore);
						//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);

						sub_dispwin.srcx = outregion.x;
						sub_dispwin.srcy = outregion.y;
						sub_dispwin.src_height = outregion.h;
						sub_dispwin.src_wid = outregion.w;
						set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
						DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = TRUE;
						//DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
						//DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
						up(&SetSubOutPutRegion_Semaphore);
						rtd_pr_vsc_emerg( "\r\n####func:%s sub smooth toggle flow#####\r\n", __FUNCTION__);
					}else{
						//Need smooth toggle flow. Not yet
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);/*Auto BG. Add by Will*/
						up(get_forcebg_semaphore());
						down(&SetSubOutPutRegion_Semaphore);
						sub_dispwin.srcx = outregion.x;
						sub_dispwin.srcy = outregion.y;
						sub_dispwin.src_height = outregion.h;
						sub_dispwin.src_wid = outregion.w;
						set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
						Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
						DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
						up(&SetSubOutPutRegion_Semaphore);
						rtd_pr_vsc_notice("\r\n####sub smooth toggle: fast mode, re-run scaler#####\r\n");
					}
#endif
					rtd_pr_vsc_debug("\r\n####func:%s sub smooth toggle temp flow#####\r\n", __FUNCTION__);
					up(&SetSubOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;
					set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
					if(check_input_and_output_the_same(SLR_SUB_DISPLAY) == FALSE){//Check input and output parameter is the same or not
						if((Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE)) {
							DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;//This is special case for VIP test
							DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//Let scaler can be run
							rtd_pr_vsc_notice("\r\n####no mute on, so request run sub scaler flow directly####\r\n");
						} else {
							DbgSclrFlgTkr.Sub_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler

							rtd_pr_vsc_debug("\r\n####func:%s src:%d request run sub scaler flow#####\r\n", __FUNCTION__, srctype);
						}
						if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
							set_source_info_forPQ(SLR_SUB_DISPLAY);//Set source info for PQ request befor scaler
						}
					} else {
						rtd_pr_vsc_debug("\r\n####func:%s src:%d sub the input and output is the same#####\r\n", __FUNCTION__, srctype);
					}
					up(&SetSubOutPutRegion_Semaphore);
				}
				if(DbgSclrFlgTkr.sub_wind0000 == TRUE) {
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_subdisplay_hidenfunc( _DISABLE);
					up(get_forcebg_semaphore());
					DbgSclrFlgTkr.sub_wind0000 = FALSE;
				}
			}
		}

#endif
	}
	return TRUE;
}

unsigned char check_input_output_valid(KADP_VIDEO_RECT_T inregion_parm, KADP_VIDEO_RECT_T originalInput_parm, KADP_VIDEO_RECT_T outregion_parm)
{//check input and output parameter is supported or not.  return TURE: valid, return False: unsupport
	#define MAX_SCALING_UP_FACTOR 32
	#define MAX_SCALING_DOWN_FACTOR 32

	if((inregion_parm.w > originalInput_parm.w) || (inregion_parm.h > originalInput_parm.h))
		return FALSE;//crop size bigger than source resolution
	if((outregion_parm.w > _DISP_WID) || (outregion_parm.h > _DISP_LEN))
		return FALSE;// output bigger than panel size.
	if(inregion_parm.w < outregion_parm.w)
	{//w scaling up case
		if((unsigned int)inregion_parm.w * MAX_SCALING_UP_FACTOR < (unsigned int)outregion_parm.w)//scaling up bigger than 32x
			return FALSE;
	}
	else if(inregion_parm.w > outregion_parm.w)
	{//w scaling down case
		if((unsigned int)outregion_parm.w * MAX_SCALING_DOWN_FACTOR < (unsigned int)inregion_parm.w)//scaling down bigger than 32x
			return FALSE;
	}

	if(inregion_parm.h < outregion_parm.h)
	{//h scaling up case
		if((unsigned int)inregion_parm.h * MAX_SCALING_UP_FACTOR < (unsigned int)outregion_parm.h)//scaling up bigger than 32x
			return FALSE;
	}
	else if(inregion_parm.h > outregion_parm.h)
	{//h scaling down case
		if((unsigned int)outregion_parm.h * MAX_SCALING_DOWN_FACTOR < (unsigned int)inregion_parm.h)//scaling down bigger than 32x
			return FALSE;
	}

	return TRUE;
}

void vsc_adaptivestream_save_region(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion)
{
	if((outregion.w == 0) || (outregion.h == 0))
		return;

	rtd_pr_vsc_info("air mode save display%d output(%d %d %d %d)", wid, outregion.x, outregion.y, outregion.w, outregion.h);

	if(wid == KADP_VIDEO_WID_0) {
		air_mode_save_outregion_parm[SLR_MAIN_DISPLAY] = outregion;
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1) {
		air_mode_save_outregion_parm[SLR_SUB_DISPLAY] = outregion;
	}
#endif
}


//airplay mode send orignal display size for smooth  toggle timing change
void scaler_airModeSendDispSize(unsigned char display, KADP_VIDEO_RECT_T outregion)
{
	int ret = 0;
	AIRMODE_DISP_SIZE_INFO sendDispInfo = {0};

	sendDispInfo.display = display;
	if(display == SLR_MAIN_DISPLAY)
	{
		sendDispInfo.main_output_x =  outregion.x;
		sendDispInfo.main_output_y =  outregion.y;
		sendDispInfo.main_output_w =  outregion.w;
		sendDispInfo.main_output_h =  outregion.h;
	} else if(display == SLR_SUB_DISPLAY) {
		sendDispInfo.sub_output_x =  outregion.x;
		sendDispInfo.sub_output_y =  outregion.y;
		sendDispInfo.sub_output_w =  outregion.w;
		sendDispInfo.sub_output_h =  outregion.h;
	}

	// change endian
	sendDispInfo.display = Scaler_ChangeUINT32Endian(sendDispInfo.display);

	sendDispInfo.main_output_x = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_x);
	sendDispInfo.main_output_y = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_y);
	sendDispInfo.main_output_w = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_w);
	sendDispInfo.main_output_h = Scaler_ChangeUINT16Endian(sendDispInfo.main_output_h);

	sendDispInfo.sub_output_x = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_x);
	sendDispInfo.sub_output_y = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_y);
	sendDispInfo.sub_output_w = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_w);
	sendDispInfo.sub_output_h = Scaler_ChangeUINT16Endian(sendDispInfo.sub_output_h);

	// copy from RPC share memory
	memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALER_AIRMODE_SEND_DISP_SIZE), (unsigned char*)&sendDispInfo, sizeof(AIRMODE_DISP_SIZE_INFO));

	if ((ret = Scaler_SendRPC(SCALER_AIRMODE_SEND_DISP_SIZE, 0, 0)) < 0)
	{
		rtd_pr_vsc_emerg("ret = %d, set SCALER_AIRMODE_SEND_DISP_SIZE to video fw fail !!!\n", ret );
		return;
	}

}


//airplay mode scaler calc output region base orignal source size
void vsc_adaptivestream_calc_outregion(unsigned char display)
{
    SLR_VOINFO* VOInfo = Scaler_VOInfoPointer(Get_DisplayMode_Port(display));
    unsigned int panel_ratio = 0;
    unsigned int source_ratio = 0;
    unsigned int oriWidth = 0;
    unsigned int oriHeight = 0;
    unsigned int source_wid = VOInfo->src_h_wid;
    unsigned int source_len = (VOInfo->progressive ? VOInfo->src_v_len : VOInfo->src_v_len*2);
    StructSrcRect* pcustom_win_size = Scaler_GetDispWindowPnt();

    if(display == SLR_MAIN_DISPLAY) {
        if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) == ADAPTIVE_AIR_MODE) {
            panel_ratio = (unsigned int)source_len * main_dispwin.src_wid;
            source_ratio = (unsigned int)source_wid * main_dispwin.src_height;
            oriWidth = main_dispwin.src_wid;
            oriHeight = main_dispwin.src_height;

            if(panel_ratio > source_ratio){//Change panel width
                pcustom_win_size->src_wid = ((main_dispwin.src_height * source_wid * 100) / source_len + 50)/100;
                pcustom_win_size->src_height = main_dispwin.src_height;
                pcustom_win_size->srcx = main_dispwin.srcx + (ABS(pcustom_win_size->src_wid, oriWidth))/2;
                pcustom_win_size->srcy = main_dispwin.srcy;
            }else if(panel_ratio < source_ratio) {//Change panel height
                pcustom_win_size->src_wid = main_dispwin.src_wid;
                pcustom_win_size->src_height = ((source_len* main_dispwin.src_wid *100)/source_wid + 50 )/100 ;
                pcustom_win_size->srcx = main_dispwin.srcx;
                pcustom_win_size->srcy = main_dispwin.srcy + (ABS(pcustom_win_size->src_height, oriHeight))/2;
            } else {
                pcustom_win_size->src_wid = main_dispwin.src_wid;
                pcustom_win_size->src_height = main_dispwin.src_height;
                pcustom_win_size->srcx = main_dispwin.srcx;
                pcustom_win_size->srcy = main_dispwin.srcy;

            }

            //Scaler_DispWindowSet(main_dispwin);

            rtd_pr_vsc_info("adaptive stream air mode change display size (%d,%d,%d,%d)->(%d,%d,%d,%d)\r\n",  main_dispwin.srcx, main_dispwin.srcy,
                main_dispwin.src_wid, main_dispwin.src_height, pcustom_win_size->srcx, pcustom_win_size->srcy, pcustom_win_size->src_wid, pcustom_win_size->src_height);
        }
    }
#ifdef CONFIG_DUAL_CHANNEL
    else if(display == SLR_SUB_DISPLAY) {
        if (vsc_get_adaptivestream_flag(SLR_SUB_DISPLAY) == ADAPTIVE_AIR_MODE) {
            panel_ratio = (unsigned int)source_len * sub_dispwin.src_wid;
            source_ratio = (unsigned int)source_wid * sub_dispwin.src_height;
            oriWidth = sub_dispwin.src_wid;
            oriHeight = sub_dispwin.src_height;

            if(panel_ratio > source_ratio){//Change panel width
                DbgSclrFlgTkr.sub_zoom_disp_hsize = ((sub_dispwin.src_height * source_wid * 100) / source_len + 50)/100;
                DbgSclrFlgTkr.sub_zoom_disp_vsize = sub_dispwin.src_height;
                DbgSclrFlgTkr.sub_zoom_disp_hpos = sub_dispwin.srcx + (ABS(DbgSclrFlgTkr.sub_zoom_disp_hsize, oriWidth))/2;
                DbgSclrFlgTkr.sub_zoom_disp_vpos = sub_dispwin.srcy;
            }
            else if(panel_ratio < source_ratio) {//Change panel height
                DbgSclrFlgTkr.sub_zoom_disp_hsize = sub_dispwin.src_wid;
                DbgSclrFlgTkr.sub_zoom_disp_vsize = ((source_len* sub_dispwin.src_wid *100)/source_wid + 50 )/100 ;
                DbgSclrFlgTkr.sub_zoom_disp_hpos = sub_dispwin.srcx;
                DbgSclrFlgTkr.sub_zoom_disp_vpos = sub_dispwin.srcy + (ABS(DbgSclrFlgTkr.sub_zoom_disp_vsize, oriHeight))/2;
            }
            else
            {
                DbgSclrFlgTkr.sub_zoom_disp_hsize = sub_dispwin.src_wid;
                DbgSclrFlgTkr.sub_zoom_disp_vsize = sub_dispwin.src_height;
                DbgSclrFlgTkr.sub_zoom_disp_hpos = sub_dispwin.srcx;
                DbgSclrFlgTkr.sub_zoom_disp_vpos = sub_dispwin.srcy;
            }

            //Scaler_SubDispWindowSet(sub_dispwin);

            rtd_pr_vsc_info("sub adaptive stream air mode change display size (%d,%d,%d,%d)->(%d,%d,%d,%d)\r\n",  sub_dispwin.srcx, sub_dispwin.srcy,
                sub_dispwin.src_wid, sub_dispwin.src_height, DbgSclrFlgTkr.sub_zoom_disp_hpos, DbgSclrFlgTkr.sub_zoom_disp_vpos, DbgSclrFlgTkr.sub_zoom_disp_hsize, DbgSclrFlgTkr.sub_zoom_disp_vsize);
        }
    }
#endif

    scaler_airModeSendDispSize(display, air_mode_save_outregion_parm[display]);

}



void scaler_SendDispSize(StructSrcRect outregion)
{
	int ret;
	unsigned long i = 0, ulItemCount = 0;
	unsigned short *pulTemp;
    SEND_DISP_SIZE_INFO sendDispInfo;

	ulItemCount = sizeof(SEND_DISP_SIZE_INFO) / sizeof(unsigned short);

    sendDispInfo.output_x =  outregion.srcx;
    sendDispInfo.output_y =  outregion.srcy;
    sendDispInfo.output_w =  outregion.src_wid;
    sendDispInfo.output_h =  outregion.src_height;
    sendDispInfo.rotate_type = (unsigned short)get_rotate_mode(SLR_MAIN_DISPLAY);

    pulTemp = (unsigned short *)&sendDispInfo;

	// change endian
	for (i = 0; i < ulItemCount; i++)
		pulTemp[i] = Scaler_ChangeUINT16Endian(pulTemp[i]);

	// copy from RPC share memory
	memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALER_SEND_DISP_SIZE_RERUN_VO), &sendDispInfo, sizeof(SEND_DISP_SIZE_INFO));

	if ((ret = Scaler_SendRPC(SCALER_SEND_DISP_SIZE_RERUN_VO, 0, 0)) < 0)
	{
		rtd_pr_vsc_emerg( "ret = %d, set SCALER_SEND_DISP_SIZE_RERUN_VO to video fw fail !!!\n", ret );
		return;
	}

}

unsigned char rtk_hal_vsc_SetInputRegion_OutputRegion(KADP_VIDEO_WID_T wid, KADP_VSC_ROTATE_T rotate_type, KADP_VIDEO_RECT_T  inregion,
	KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion, unsigned char null_input, unsigned char null_output)
{


#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
    VSC_INPUT_TYPE_T srctype;

	extern unsigned char check_pst_active_state(unsigned char display);//Return TRUE: active state can run pst. Return False: not active state can not run pst
	unsigned long flags = 0;//for spin_lock_irqsave
	unsigned char is_atv = FALSE;
	static unsigned int pre_inregion_x = 0, pre_inregion_y = 0;


	if(null_input && null_output)
	{
		return TRUE;//input output both are null. directly return for LG spec
	}
#ifndef UT_flag
	if( (pre_inregion_x!=inregion.x) || (pre_inregion_y!=inregion.y)){
		AspectRation_Zoom_MEMCClose_Flag =1;
	}else{
		AspectRation_Zoom_MEMCClose_Flag =0;
	}
#endif // #ifndef UT_flag
	pre_inregion_x=inregion.x;
	pre_inregion_y=inregion.y;
	/*
	rtd_pr_vsc_debug("rtk_hal_vsc_SetInputRegion_OutputRegion()\n");
	rtd_pr_vsc_debug("wid=%x, inregion x=%d, y=%d, width=%d, height=%d\n", wid, inregion.x, inregion.y, inregion.w, inregion.h);
	rtd_pr_vsc_debug("wid=%x, outregion x=%d, y=%d, width=%d, height=%d\n", wid, outregion.x, outregion.y, outregion.w, outregion.h);
	rtd_pr_vsc_debug("null_input=%x, null_output=%x\n", null_input, null_output);
	*/
	if(wid == KADP_VIDEO_WID_0)
	{
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			is_atv = TRUE;//vsc connect atv

		down(&new_input_output_main_sem);//lock semaphore
        if ((get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY) != ADAPTIVE_STREAM_ON) || is_atv || (check_pst_active_state(SLR_MAIN_DISPLAY) == FALSE) || (DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
			|| ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)&& ((drv_memory_get_game_mode()) || drv_memory_get_vdec_direct_low_latency_mode())))//PST not ready state. or ATV case, or cloud game mode or vdec low latency case or sub connect
        {//atv alwasy set original input and output
			if(null_input)
			{//input is null
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{//no need to copy input. input is null
					if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}

					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_main_rotate_type_parm = rotate_type;//copy rotate type
					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{//no need to copy output. output is null
					if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_main_rotate_type_parm = rotate_type;//copy rotate type
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;
					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
				}
			}
			else
			{
				//RTKREQ-456 : patch for scaler flow update osd callback delay to webos.
				if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
					Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region(outregion);

				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else if((inregion.w == 0) || (inregion.h == 0))
				{//input zero but output is not zero
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					}
				}
				else
				{
                    srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
					if(!check_input_output_valid(inregion, originalInput, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
                    if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || ((srctype == VSC_INPUTSRC_VDEC) && (get_vo_avsync_flag(0) == FALSE)))
					{//change source or change channel case
						rtd_pr_vsc_info("### func:%s line:%d change source or channel reset output##\r\n",__FUNCTION__, __LINE__);
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre);
						reset_any_srcrect(&main_dispwin_for_only_xy);
						up(&SetMainOutPutRegion_Semaphore);
					}

					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_main_rotate_type_parm = rotate_type;//copy rotate type
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;

					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						if(is_atv){//avoid of mute off earlier video output
							//rtd_pr_vsc_info("#####[%s(%d)]Scaler_AVD_GetRunSearchState=%d\n",__func__,__LINE__,Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY));
							//if(Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY) == FALSE)
							//	trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}else{

							if (srctype == VSC_INPUTSRC_VDEC) {
								unsigned char wait_mute_off = FALSE;
								int port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
								down(get_vo_infosemaphore());
								if ((get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY)) == false) && (get_vo_avsync_flag(port) == TRUE)) {//vo no change and vo av sync ready
									trigger_mute_off(SLR_MAIN_DISPLAY, 1);
								}
								else
								{
									wait_mute_off = TRUE;
								}
								up(get_vo_infosemaphore());
								if(wait_mute_off)
								{
									rtd_pr_vsc_info("### func:%s line:%d wait scaler or smooth toggle mute off##\r\n",__FUNCTION__, __LINE__);
								}
							} else {
								trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
							}
						}
					}

				}
			}
		}
		else
		{//active state
			if(rotate_type != ap_main_rotate_type_parm)
			{//rotate case
				if(null_input)
				{//input is null
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy input. input is null
						if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}


					}
				}
				else if(null_output)
				{//output is null
					if((inregion.w == 0) || (inregion.h == 0))
					{//input is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy output. output is null
						if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}
					}
				}
				else
				{
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else if((inregion.w == 0) || (inregion.h == 0))
					{//input zero
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
						{
							spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
							ap_main_rotate_type_parm = rotate_type;//copy rotate type
							//copy output region
							ap_main_outregion_parm.x = outregion.x;
							ap_main_outregion_parm.y = outregion.y;
							ap_main_outregion_parm.w = outregion.w;
							ap_main_outregion_parm.h = outregion.h;
							main_arc_change_flag = TRUE;
							spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
							wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						}
					}
					else
					{
						if(!check_input_output_valid(inregion, originalInput, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;

						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;

						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute on. set the mask
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}

					}
				}

			}
			else
			{//non rotate case
#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
				//ensure pst can work on inerrupt.
				scaler_imd_pst_enable_interrupt();
#endif
#endif
				if(null_input)
				{//input is snull
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy input. input is null
						if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}


					}
				}
				else if(null_output)
				{//output is null
					if((inregion.w == 0) || (inregion.h == 0))
					{//input is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy output. output is null
						if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute on. set the mask
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}
					}
				}
				else
				{//input and output is not null
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else if((inregion.w == 0) || (inregion.h == 0))
					{//input zero
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);

					}
					else
					{//normal case
						if(!check_input_output_valid(inregion, originalInput, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_main_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;

						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;

						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}

					}
				}

			}
		}
        /*
		if((vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_AUTO_MODE|| vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_oled_orbit_enable)
	        {
				vbe_disp_orbit_set_vo_overscan(0);
				ori_input_width = inregion.w;
				ori_input_height = inregion.h;
				vbe_orbit_input_size.srcx  = inregion.x;
				vbe_orbit_input_size.srcy = inregion.y;
				vbe_orbit_input_size.src_wid = inregion.w;
				vbe_orbit_input_size.src_height = inregion.h;
				vbe_orbit_output_size.srcx = outregion.x;
				vbe_orbit_output_size.srcy = outregion.y;
				vbe_orbit_output_size.src_wid = outregion.w;
				vbe_orbit_output_size.src_height = outregion.h;
				rtd_pr_vsc_info("[%s(%d)] update orbit input size vbe_orbit_input_size.src_wid =%d,vbe_orbit_input_size.src_height=%d\n",__func__,__LINE__,vbe_orbit_input_size.src_wid,vbe_orbit_input_size.src_height);
	        }
	        */
		vsc_adaptivestream_save_region(wid, ap_main_outregion_parm);
		up(&new_input_output_main_sem);//unlock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_MAXN)
				return TRUE;//no connect source

		down(&new_input_output_sub_sem);//lock semaphore
		if(check_pst_active_state(SLR_SUB_DISPLAY) == FALSE){
			if(null_input)
			{//input is null

				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{

					if(!check_input_output_valid(ap_sub_inregion_parm, ap_sub_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_SUB_DISPLAY, TRUE);
						up(&new_input_output_sub_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					sub_hidden = FALSE;
					if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
						//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					sub_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, ap_sub_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				sub_hidden = FALSE;
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				sub_arc_change_flag = TRUE;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

			}
			else
			{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
						//copy output region
						ap_sub_outregion_parm.x = outregion.x;
						ap_sub_outregion_parm.y = outregion.y;
						ap_sub_outregion_parm.w = outregion.w;
						ap_sub_outregion_parm.h = outregion.h;
						sub_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					}
					up(&new_input_output_sub_sem);//unlock semaphore
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, outregion))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				sub_hidden = FALSE;
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;

				//copy output region
				ap_sub_outregion_parm.x = outregion.x;
				ap_sub_outregion_parm.y = outregion.y;
				ap_sub_outregion_parm.w = outregion.w;
				ap_sub_outregion_parm.h = outregion.h;

				sub_arc_change_flag = TRUE;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

			}
		} else {
#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			//ensure pst can work on inerrupt.
			scaler_imd_pst_enable_interrupt();
#endif
#endif
			if(null_input)
			{//input is null
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{

					if(!check_input_output_valid(ap_sub_inregion_parm, ap_sub_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_SUB_DISPLAY, TRUE);
						up(&new_input_output_sub_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
					if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
					{//previou mute on
						rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
						trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
					#if 0 //for hidden
					if(sub_hidden)
					{
						sub_hidden = FALSE;
						drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
					}
					#endif
				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, ap_sub_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				#if 0//for hidden
				if(sub_hidden)
				{
					sub_hidden = FALSE;
					drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
				}
				#endif
			}
			else
			{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
					up(&new_input_output_sub_sem);//unlock semaphore
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, outregion))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				//copy output region
				ap_sub_outregion_parm.x = outregion.x;
				ap_sub_outregion_parm.y = outregion.y;
				ap_sub_outregion_parm.w = outregion.w;
				ap_sub_outregion_parm.h = outregion.h;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_pr_vsc_info("####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				#if 0//for hidden
				if(sub_hidden)
				{
					sub_hidden = FALSE;
					drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
				}
				#endif
			}
		}
		up(&new_input_output_sub_sem);//unlock semaphore
	}
	return TRUE;
#endif

#else//#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG //original input and output flow
	VIDEO_RECT_T inregion_parm;//for new input output.
	VIDEO_RECT_T originalInput_parm;//for new input output. input resolution parameter
	unsigned char mute_off_flag = FALSE;//currently parameter is normal mute off

	rtd_pr_vsc_info("\r\n#### func:%s null(%d %d) in(%d %d %d %d) ori(%d %d %d %d) out(%d %d %d %d)####\r\n", __FUNCTION__, null_input, null_output, inregion.x, inregion.y, inregion.w, inregion.h,
	originalInput.x, originalInput.y, originalInput.w, originalInput.h, outregion.x, outregion.y, outregion.w, outregion.h);


	if(null_input && null_output)
	{
		return TRUE;//input output both are null. directly return for LG spec
	}

	if(wid == KADP_VIDEO_WID_0)
		;//window_id = VIDEO_WID_0;
	else if(wid == KADP_VIDEO_WID_1)
		;//window_id = VIDEO_WID_1;
	else
	{
		rtd_pr_vsc_err("\r\n### func:%s wid:%d error###\r\n",__FUNCTION__, wid);
		return FALSE;
	}

	if(wid == KADP_VIDEO_WID_0)
	{
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		down(&new_input_output_main_sem);//lock semaphore
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		//rotate part
		down(&SetMainOutPutRegion_Semaphore);
		main_rotate_mode_pre = main_rotate_mode;
		main_rotate_mode = rotate_type;
		up(&SetMainOutPutRegion_Semaphore);

#endif
		virtual_w = true_wide;//magnify and livezoom use
		virtual_h = true_high;//magnify and livezoom use
		if(null_input)
		{//input is snull
			if((outregion.w == 0) || (outregion.h == 0))
			{//output is zero not null. need to mute
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
				mute_control(SLR_MAIN_DISPLAY, TRUE);
				up(&new_input_output_main_sem);//unlock semaphore
				rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
				return TRUE;
			}
			else
			{//no need to copy input. input is null
				//copy output region
				ap_main_outregion_parm.x = outregion.x;
				ap_main_outregion_parm.y = outregion.y;
				ap_main_outregion_parm.w = outregion.w;
				ap_main_outregion_parm.h = outregion.h;
				if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				mute_off_flag = TRUE;//need try mute off
			}
		}
		else if(null_output)
		{//output is null
			if((inregion.w == 0) || (inregion.h == 0))
			{//input is zero not null. need to mute
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
				mute_control(SLR_MAIN_DISPLAY, TRUE);
				up(&new_input_output_main_sem);//unlock semaphore
				rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
				return TRUE;
			}
			else
			{//no need to copy output. output is null

				//copy input region
				ap_main_inregion_parm.x = inregion.x;
				ap_main_inregion_parm.y = inregion.y;
				ap_main_inregion_parm.w = inregion.w;
				ap_main_inregion_parm.h = inregion.h;

				//copy original input region
				ap_main_originalInput_parm.x = originalInput.x;
				ap_main_originalInput_parm.y = originalInput.y;
				ap_main_originalInput_parm.w = originalInput.w;
				ap_main_originalInput_parm.h = originalInput.h;
				if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}

				mute_off_flag = TRUE;//need try mute off
			}
		}
		else
		{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else if((inregion.w == 0) || (inregion.h == 0))
				{//input zero but output is not zero
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					mute_off_flag = FALSE;
				}
				else
				{
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						rtd_pr_vsc_info("\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					mute_off_flag = TRUE;//need try mute off
				}
		}

		//copy input
		inregion_parm.x = ap_main_inregion_parm.x;
		inregion_parm.y = ap_main_inregion_parm.y;
		inregion_parm.w = ap_main_inregion_parm.w;
		inregion_parm.h = ap_main_inregion_parm.h;

		//copy input
		originalInput_parm.x = ap_main_originalInput_parm.x;
		originalInput_parm.y = ap_main_originalInput_parm.y;
		originalInput_parm.w = ap_main_originalInput_parm.w;
		originalInput_parm.h = ap_main_originalInput_parm.h;

		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, inregion_parm, originalInput_parm);//normal parameter case to call input
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, ap_main_outregion_parm, virtual_w, virtual_h);//normal parameter case to call output
		if(mute_off_flag)
		{//norma parameter case need to mute off
			if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
			{//previou mute on
				rtd_pr_vsc_info("#####[%s(%d)] trigger_mute_off\r\n",__func__,__LINE__);
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
			}
		}
		up(&new_input_output_main_sem);//unlock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		down(&new_input_output_sub_sem);//lock semaphore
		virtual_w = true_wide;//magnify and livezoom use
		virtual_h = true_high;//magnify and livezoom use
		//copy input region
		ap_sub_inregion_parm.x = inregion.x;
		ap_sub_inregion_parm.y = inregion.y;
		ap_sub_inregion_parm.w = inregion.w;
		ap_sub_inregion_parm.h = inregion.h;

		//copy original input region
		ap_sub_originalInput_parm.x = originalInput.x;
		ap_sub_originalInput_parm.y = originalInput.y;
		ap_sub_originalInput_parm.w = originalInput.w;
		ap_sub_originalInput_parm.h = originalInput.h;

		//copy output region
		ap_sub_outregion_parm.x = outregion.x;
		ap_sub_outregion_parm.y = outregion.y;
		ap_sub_outregion_parm.w = outregion.w;
		ap_sub_outregion_parm.h = outregion.h;

		inregion_parm.x = ap_sub_inregion_parm.x;
		inregion_parm.y = ap_sub_inregion_parm.y;
		inregion_parm.w = ap_sub_inregion_parm.w;
		inregion_parm.h = ap_sub_inregion_parm.h;


		originalInput_parm.x = ap_sub_originalInput_parm.x;
		originalInput_parm.y = ap_sub_originalInput_parm.y;
		originalInput_parm.w = ap_sub_originalInput_parm.w;
		originalInput_parm.h = ap_sub_originalInput_parm.h;

		vsc_adaptivestream_save_region(wid, ap_sub_outregion_parm);

		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, inregion_parm, originalInput_parm);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, ap_sub_outregion_parm, virtual_w, virtual_h);
		up(&new_input_output_sub_sem);//unlock semaphore


	}
#endif
	return TRUE;
#endif
}


unsigned char rtk_hal_vsc_SetSplitInfoForHDMI(void)
{
	rtd_pr_vsc_info("rtk_hal_vsc_SetSplitInfoForHDMI() called\n");

	//TODO: implement API


	return TRUE;
}


unsigned char rtk_hal_vsc_SetWinFreeze(VIDEO_WID_T wid, bool bonoff)
{
	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;

	if (wid == VIDEO_WID_0) {
  		channel = SLR_MAIN_DISPLAY;
 		// DbgSclrFlgTkr.mainVscFreezeFlag = bonoff;
 	} else if (wid == VIDEO_WID_1) {
  		channel = SLR_SUB_DISPLAY;
 		// DbgSclrFlgTkr.subVscFreezeFlag = bonoff;
	}

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid != VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif
	down(&VSC_Semaphore);
	if (wid == VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
		DbgSclrFlgTkr.mainVscFreezeFlag = bonoff;
	} else if (wid == VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
		DbgSclrFlgTkr.subVscFreezeFlag = bonoff;
	}

	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if ((channel == SLR_MAIN_DISPLAY) && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV) && (Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)) {
		DbgSclrFlgTkr.main_winfreeze=bonoff;
	} else if ((channel == SLR_MAIN_DISPLAY) && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) {
		if(bonoff) {
			DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = FALSE;//ATV can not run smooth toggle
			Scaler_SetFreeze(channel, bonoff);
			pr_notice("atv freeze channel change, freeze on[%d]\n",DbgSclrFlgTkr.mainVscFreezeFlag);
		} else {
			if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
				&& (drvif_module_vdc_OutputStable() || drvif_video_status_reg(VDC_no_signal))) {
				MEMC_Lib_Freeze(0);
			} else {
				pr_notice("need after scaler to do atv memc unfreeze[%d]\n",DbgSclrFlgTkr.mainVscFreezeFlag);
			}
		}

	} else {
		Scaler_SetFreeze(channel, bonoff);
	}
	up(&VSC_Semaphore);
	return TRUE;
}


static unsigned char ForceSmoothtoggleGo = FALSE;

unsigned char get_ForceSmoothtoggleGo(void)
{
	return ForceSmoothtoggleGo;
}

void SelfDiagnosis_mainscaler_run(SCALER_DISP_CHANNEL channel, VIDEO_RECT_T inregion, VIDEO_RECT_T outregion)
{
	if (channel == SLR_MAIN_DISPLAY) {
		/*re run main scaler start*/
		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
		set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
		set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);

		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
		mute_control(SLR_MAIN_DISPLAY, TRUE);
		//Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH); //Remove by Will
		down(&SetMainOutPutRegion_Semaphore);
		if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
			main_dispwin.srcx = 0;
			main_dispwin.srcy = 0;
			main_dispwin.src_height = _DISP_LEN;
			main_dispwin.src_wid = _DISP_WID;
		} else {
			main_dispwin.srcx = outregion.x;
			main_dispwin.srcy = outregion.y;
			main_dispwin.src_height = outregion.h;
			main_dispwin.src_wid = outregion.w;
		}
		Scaler_DispWindowSet(main_dispwin);
		up(&SetMainOutPutRegion_Semaphore);

		down(&VSC_Semaphore);
		DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
		if (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) {
			DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
		}
		set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
		rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);
		mute_control(SLR_MAIN_DISPLAY, FALSE);
	} else if (channel == SLR_SUB_DISPLAY) {
		/*re run sub scaler start*/
		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;
		set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
		set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
		set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
		mute_control(SLR_SUB_DISPLAY, TRUE);
		//Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH); //Remove by Will
		down(&SetSubOutPutRegion_Semaphore);
		if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
			sub_dispwin.srcx = 0;
			sub_dispwin.srcy = 0;
			sub_dispwin.src_height = _DISP_LEN;
			sub_dispwin.src_wid = _DISP_WID;
		} else {
			sub_dispwin.srcx = outregion.x;
			sub_dispwin.srcy = outregion.y;
			sub_dispwin.src_height = outregion.h;
			sub_dispwin.src_wid = outregion.w;
		}
		Scaler_SubDispWindowSet(sub_dispwin);
		up(&SetSubOutPutRegion_Semaphore);

		down(&VSC_Semaphore);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
		set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
		rtk_output_connect(SLR_SUB_DISPLAY);
		up(&VSC_Semaphore);
		mute_control(SLR_SUB_DISPLAY, FALSE);
	}
}



unsigned static char Factory_SelfDiagnosis_Mode = FALSE;

unsigned char Get_Factory_SelfDiagnosis_Mode(void)
{
	return Factory_SelfDiagnosis_Mode;
}

unsigned char change_vscinput_with_vfetiming(SCALER_DISP_CHANNEL channel)
{
	VIDEO_RECT_T  inregion;
	VIDEO_RECT_T outregion;
	unsigned int timeoutcount;

	timeoutcount = 60;
	do {
		if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			&&(Check_ForceBG_Mask_Enable(channel, TRUE)==FALSE))
		{
			break;
		} else {
			msleep(200);
		}
		timeoutcount--;
	} while(timeoutcount);

	if(timeoutcount==0)
		rtd_pr_vsc_notice("wait active timeoutcount 0#####[%s(%d)]\n", __FUNCTION__, __LINE__);


	if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
		if(channel == SLR_MAIN_DISPLAY) {
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
			//self-dianosis AV source have to do no overscan @Crixus 20151201
			if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD){
				//self-dianosis AV source, rzhen@2016-09-01
				if(read_buffer_first_flag) return TRUE;
				read_buffer_first_flag = 1;

				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				main_input_size.srcx = inregion.x;
				main_input_size.srcy = inregion.y;
				main_input_size.src_wid = inregion.w;
				main_input_size.src_height = inregion.h;
				set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;

				main_dispwin.srcx = outregion.x;
				main_dispwin.srcy = outregion.y;
				main_dispwin.src_height = outregion.h;
				main_dispwin.src_wid = outregion.w;
				Scaler_DispWindowSet(main_dispwin);

				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}

				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Let main path run scaler again
				up(&SetMainOutPutRegion_Semaphore);
				msleep(1000);
			}
			else
#endif
			{
				StructSrcRect maindispwind;

				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;
				maindispwind = Scaler_DispWindowGet();
				if((inregion.x != Main_InputRegion_x)
					||(inregion.y != Main_InputRegion_y)
					||(inregion.w != Main_InputRegion_w)
					||(inregion.h != Main_InputRegion_h)
					||(maindispwind.srcx != outregion.x)
					||(maindispwind.srcy != outregion.y)
					||(maindispwind.src_wid != outregion.w)
					||(maindispwind.src_height != outregion.h)
					||dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY)
					){

					rtd_pr_vsc_notice("#####[%s(%d)] \n", __FUNCTION__, __LINE__);
					SelfDiagnosis_mainscaler_run(SLR_MAIN_DISPLAY, inregion, outregion);
					msleep(1000);
				}
			}
		} else if (channel == SLR_SUB_DISPLAY){
#if 0//def CONFIG_ENABLE_VD_27MHZ_MODE
			//self-dianosis AV source have to do no overscan @Crixus 20151201
			if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_AVD){
				if(read_buffer_first_flag == 0){
					read_buffer_first_flag = 1;
					Scaler_AVD_EnableVD27MMode(VD_27M_OFF);
					msleep(1000);
					rtd_pr_vsc_debug("[self-dianosis]read buffrt 27M on !!\n");
				}
			} else
#endif
			{
				StructSrcRect subdispwind;
				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;
				subdispwind = Scaler_SubDispWindowGet();
				if((inregion.x != Main_InputRegion_x)
					||(inregion.y != Main_InputRegion_y)
					||(inregion.w != Main_InputRegion_w)
					||(inregion.h != Main_InputRegion_h)
					||(subdispwind.srcx != outregion.x)
					||(subdispwind.srcy != outregion.y)
					||(subdispwind.src_wid != outregion.w)
					||(subdispwind.src_height != outregion.h)
					) {
					SelfDiagnosis_mainscaler_run(SLR_SUB_DISPLAY, inregion, outregion);
				}
			}
		}
		return TRUE;
	} else {
		rtd_pr_vsc_notice("wait active NG#####[%s(%d)]\n", __FUNCTION__, __LINE__);
		return FALSE;
	}
}

unsigned char rtk_hal_vsc_FreezeVideoFrameBuffer(VIDEO_WID_T wid, bool bonoff)
{
	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}

	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_pr_vsc_notice("change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	drvif_scalerdisplay_set_freeze(channel, bonoff);
	Scaler_SetDisplaySingleBufferMode(channel, bonoff);
	return TRUE;
}

unsigned char rtk_hal_vsc_ReadVideoFrameBuffer(VIDEO_WID_T wid, VIDEO_RECT_T * pin,KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pRead, KADP_VIDEO_DDI_COLOR_STANDARD_T *pColor_standard, KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T * pPixelColorFormat)
{
	unsigned int linesize = 0;
	unsigned char * capturebufferaddr = NULL;
	//unsigned int capturebuffersize = 0;
	//unsigned int capturebufferphyaddr = 0;

	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;
	KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * readaddr = pRead;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	} else {
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}


	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_pr_vsc_notice("change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	if (pRead == NULL) {
		rtd_pr_vsc_debug("pRead == NULL not ok\n");
		return FALSE;
	}

	rtd_pr_vsc_debug("x=%d;;y=%d;;w=%d;;h=%d\n", pin->x, pin->y, pin->w,pin->h);
	if(((pin->x+pin->w)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID)) || ((pin->y+pin->h)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_LEN)))
	{
		rtd_pr_vsc_debug("wrong ReadVideoFrameBuffer size!!!!!!!\n");
		return FALSE;
	}

	//linesize = memory_get_capture_size(channel, MEMCAPTYPE_LINE);
	//linesize = drvif_memory_get_data_align(linesize, DMA_SPEEDUP_ALIGN_VALUE/8);

	//linesize = SHL(linesize, 3); //unit conversion. 64bits to 8bits

	if (channel == SLR_MAIN_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_MainLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_mainblock_viraddr();
		//capturebuffersize = drvif_memory_get_block_size(MEMIDX_MAIN);
		//capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_MAIN);
	} else if (channel == SLR_SUB_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_SubLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_subblock_viraddr();
		//capturebuffersize = drvif_memory_get_block_size(MEMIDX_SUB);
		//capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_SUB);
	}
	else
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}

	//dmac_inv_range(capturebufferaddr, capturebufferaddr + capturebuffersize);
	//outer_inv_range(capturebufferphyaddr, capturebufferphyaddr + capturebuffersize);

	rtd_pr_vsc_debug("linesize==%d\n",linesize);
	if(capturebufferaddr)
	{
		rtd_pr_vsc_debug("capturebufferaddr==%lx\n",drvif_memory_get_mainblock_viraddr());
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[0],capturebufferaddr[1],capturebufferaddr[2],capturebufferaddr[3]);
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[4],capturebufferaddr[5],capturebufferaddr[6],capturebufferaddr[7]);
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[8],capturebufferaddr[9],capturebufferaddr[10],capturebufferaddr[11]);
		rtd_pr_vsc_debug("m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[12],capturebufferaddr[13],capturebufferaddr[14],capturebufferaddr[15]);
	}
	rtd_pr_vsc_notice("SLR_DISP_10BIT = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_10BIT)));
	rtd_pr_vsc_notice("SLR_DISP_422CAP = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_422CAP)));


	if(Scaler_DispGetStatus(channel, SLR_DISP_10BIT))
	{
		rtd_pr_vsc_notice("SLR_DISP_10BIT no support read write m domain\n");
		return FALSE;
#if	0
		* pPixelColorFormat = KADP_VIDEO_DDI_PIXEL_10BIT;
		* pColor_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//10bit 422 format
		{
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			unsigned int arraynum = ((pin->x+pin->w)%2)?(pin->x+pin->w+1):(pin->x+pin->w);
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
				for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					if(remainbit<10)
					{
						lowvalue = value4byte;
						value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
						highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
					}
					else
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCb = highvalue;
							linepixel[i+1].pixelStandardCb = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardY = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardCr= highvalue;
							linepixel[i+1].pixelStandardCr = highvalue;
							colorindex = 3;
							break;
						case 3:
							linepixel[i+1].pixelStandardY = highvalue;
							colorindex = 0;
							i = i+2;
							break;
					}
				}
				memcpy((unsigned char *)(readaddr+p*pin->w), (unsigned char *)(linepixel+pin->x), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		else//10bit 444 format
		{
			unsigned int *linebuffer=NULL;
			unsigned int *srclineptr;
			unsigned int tempvalue;
			unsigned int arraynum = pin->x+pin->w;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<(pin->x+pin->w);)
				{
					if(remainbit<10)
			       		 {
			           		lowvalue = value4byte;
			        		value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
					    	highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
			        	}
					else
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCr = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardCb = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardY= highvalue;
							colorindex = 0;
							i++;
							break;
					}
				}
				memcpy((unsigned char *)(readaddr+p*pin->w), (unsigned char *)(linepixel+pin->x), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		return TRUE;
#endif
	}
	else
	{
		unsigned int i,k;
		* pPixelColorFormat = KADP_VIDEO_DDI_PIXEL_8BIT;
		* pColor_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//8bit 422 format
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					readaddr->pixelStandardY = capturebufferaddr[i*linesize+2*k];
					readaddr->pixelStandardCb = capturebufferaddr[i*linesize+2*(k/2)*2+1];
					readaddr->pixelStandardCr = capturebufferaddr[i*linesize+2*(k/2)*2+3];
					readaddr ++;
				}
			}
		}
		else//8bit 444 fromat
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					readaddr->pixelStandardY= capturebufferaddr[i*linesize+3*k+2];
					readaddr->pixelStandardCb= capturebufferaddr[i*linesize+3*k+1];
					readaddr->pixelStandardCr= capturebufferaddr[i*linesize+3*k];
					readaddr++;
				}
			}
		}
		return TRUE;
	}
}

unsigned char rtk_hal_vsc_WriteVideoFrameBuffer(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pin,KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pWrite)
{
	unsigned int linesize = 0;
	unsigned char * capturebufferaddr = NULL;
	unsigned int capturebuffersize = 0;
	unsigned int capturebufferphyaddr = 0;

	SCALER_DISP_CHANNEL channel =SLR_MAIN_DISPLAY;
	KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * writeaddr = pWrite;
	rtd_pr_vsc_debug("pWrite = %lx\n",(unsigned long)pWrite);
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==KADP_VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==KADP_VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	} else {
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}


	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_pr_vsc_notice("change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	if(pWrite == NULL)
	{
		rtd_pr_vsc_debug("pWrite == NULL not ok\n");
		return FALSE;
	}
	rtd_pr_vsc_debug("x=%d;;y=%d;;w=%d;;h=%d\n", pin->x, pin->y, pin->w, pin->h);

	if(((pin->x+pin->w)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID))||((pin->y+pin->h)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_LEN)))
	{
		rtd_pr_vsc_debug("wrong WriteVideoFrameBuffer size!!!!!!!\n");
		return FALSE;
	}

	//linesize = memory_get_capture_size(channel, MEMCAPTYPE_LINE);
	//linesize = SHL(linesize, 3); //unit conversion. 64bits to 8bits


	if (channel == SLR_MAIN_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_MainLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_mainblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_MAIN);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_MAIN);
	} else if (channel == SLR_SUB_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_SubLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_subblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_SUB);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_SUB);
	}
	else
	{
		rtd_pr_vsc_err("wid id is not ok\n");
		return FALSE;
	}

	rtd_pr_vsc_debug("linesize = %d\n",linesize);
	if(capturebufferaddr)
	{
		rtd_pr_vsc_debug("capturebufferaddr = %lx,capturebufferphyaddr=%x\n",(unsigned long)capturebufferaddr,capturebufferphyaddr);
	}
	rtd_pr_vsc_notice("SLR_DISP_10BIT = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_10BIT)));
	rtd_pr_vsc_notice("SLR_DISP_422CAP = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_422CAP)));

	if(Scaler_DispGetStatus(channel, SLR_DISP_10BIT))
	{
		rtd_pr_vsc_notice("SLR_DISP_10BIT no support read write m domain\n");

		return FALSE;
#if 0
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//422 10bit fomat
		{
			unsigned int arraynum = Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID);
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel=NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;

			rtd_pr_vsc_debug("arraynum = %d\n",arraynum);
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif

			rtd_pr_vsc_debug("linebuffer = %lx\n",(unsigned long)linebuffer);
			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
				for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					rtd_pr_vsc_debug("arraynum = %d\n",arraynum);
					if((remainbit<10)&&(remainbit>=0))
					{
						lowvalue = value4byte;
						value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
						highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
					}
					else if((remainbit>=10)&&(remainbit<=32))
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCb = highvalue;
							linepixel[i+1].pixelStandardCb = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardY = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardCr= highvalue;
							linepixel[i+1].pixelStandardCr = highvalue;
							colorindex = 3;
							break;
						case 3:
							linepixel[i+1].pixelStandardY = highvalue;
							colorindex = 0;
							i = i+2;
							break;
					}
				}
				//write user's pixel to linepixel array
				memcpy((unsigned char *)(linepixel+pin->x),(unsigned char *)(writeaddr+p*pin->w), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
				//clear linebuffer
				memset((unsigned char *)linebuffer, 0,linesize);
				//linepixel is the new pixel line should be written in memory. so next do
				remainbit = 32;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					switch(colorindex)
					{
						case 0:
							value4byte = linepixel[i].pixelStandardCb;
							colorindex = 1;
							break;
						case 1:
							value4byte = linepixel[i].pixelStandardY;
							colorindex = 2;
							break;
						case 2:
							value4byte = linepixel[i].pixelStandardCr;
							colorindex = 3;
							break;
						case 3:
							value4byte = linepixel[i+1].pixelStandardY;
							colorindex = 0;
							i = i+2;
							break;
					}

					if(remainbit==0)
			       	{
						//lowvalue = value4byte&0;
						highvalue = (value4byte&0x000003ff);
						linebuffer[j] = linebuffer[j];
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if(remainbit<10)&&(remainbit>0)
			       	{
						lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff)>>remainbit;
						linebuffer[j] = linebuffer[j] |(lowvalue<<(32-remainbit));
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
				        linebuffer[j] =  linebuffer[j] |(value4byte&0x000003ff)<<(32-remainbit);
				        remainbit = remainbit - 10;
					}
				}
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					srclineptr[i] =( (linebuffer[i]&0x000000ff)<<24 )|( (linebuffer[i]&0x0000ff00)<<8 )| ( (linebuffer[i]&0x00ff0000)>>8 )|( (linebuffer[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = srclineptr[i];
					srclineptr[i] = srclineptr[i+1];
					srclineptr[i+1] = tempvalue;
				}
				//Do Swap end
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		else//444 10bit format
		{
			unsigned int arraynum = Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID);
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;

#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			rtd_pr_vsc_debug("arraynum = %d\n",arraynum);
			rtd_pr_vsc_debug("linebuffer = %lx\n",(unsigned long)linebuffer);

			if(linebuffer == NULL)
			{
				rtd_pr_vsc_debug("rtk_hal_vsc_WriteVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
	    		for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end
				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					if(remainbit<10)
			       	{
			           	lowvalue = value4byte;
			        	value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
					    highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCr = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardCb = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardY= highvalue;
							colorindex = 0;
							i++;
							break;
					}
				}

				//write user's pixel to linepixel array
				memcpy((unsigned char *)(linepixel+pin->x),(unsigned char *)(writeaddr+p*pin->w), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
				//clear linebuffer
				memset((unsigned char *)linebuffer, 0,linesize);
				//linepixel is the new pixel line should be written in memory. so next do
				remainbit = 32;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					switch(colorindex)
					{
						case 0:
							value4byte = linepixel[i].pixelStandardCr;
							colorindex = 1;
							break;
						case 1:
							value4byte = linepixel[i].pixelStandardCb;
							colorindex = 2;
							break;
						case 2:
							value4byte = linepixel[i].pixelStandardY;
							colorindex = 0;
							i++;
							break;
					}

					if(remainbit==0)
			       	{
						//lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff);
						//linebuffer[j] = linebuffer[j];
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit<10)&&(remainbit>0))
			       	{
						lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff)>>remainbit;
						linebuffer[j] = linebuffer[j] |(lowvalue<<(32-remainbit));
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
						linebuffer[j] =  linebuffer[j] |(value4byte&0x000003ff)<<(32-remainbit);
						remainbit = remainbit - 10;
					}
				}
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					srclineptr[i] =( (linebuffer[i]&0x000000ff)<<24 )|( (linebuffer[i]&0x0000ff00)<<8 )| ( (linebuffer[i]&0x00ff0000)>>8 )|( (linebuffer[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = srclineptr[i];
					srclineptr[i] = srclineptr[i+1];
					srclineptr[i+1] = tempvalue;
				}
				//Do Swap end
			}

			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
#endif
	}
	else
	{
		unsigned int i,k;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//422 8bit fomat
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					capturebufferaddr[i*linesize+2*k] = writeaddr->pixelStandardY;
					capturebufferaddr[i*linesize+2*(k/2)*2+1] = writeaddr->pixelStandardCb;
					capturebufferaddr[i*linesize+2*(k/2)*2+3] = writeaddr->pixelStandardCr;
					writeaddr ++;
				}
			}
		}
		else//444 8bit format
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					capturebufferaddr[i*linesize+3*k+2] = writeaddr->pixelStandardY;
					capturebufferaddr[i*linesize+3*k+1] = writeaddr->pixelStandardCb;
					capturebufferaddr[i*linesize+3*k] = writeaddr->pixelStandardCr;
					writeaddr++;
				}
			}
		}
	}
	dmac_flush_range(capturebufferaddr, capturebufferaddr + capturebuffersize);
	outer_flush_range(capturebufferphyaddr, capturebufferphyaddr + capturebuffersize);
	return TRUE;
}

/*New HAL_VSC function*/
//add vsc pattern @Crixus 20170419
unsigned char rtk_hal_vsc_SetPattern(BOOLEAN on_off, VIDEO_WID_T winID, VSC_VIDEO_PATTERN_LOCATION_T pattern_location){
       vgip_vgip_chn1_ctrl_RBUS vgip_vgip_chn1_ctrl_reg;
       sub_vgip_vgip_chn2_ctrl_RBUS sub_vgip_vgip_chn2_ctrl_reg;
       scaleup_d_uzu_globle_ctrl_RBUS scaleup_d_uzu_globle_ctrl_reg;
       scaleup_ds_uzu_globle_ctrl_RBUS scaleup_ds_uzu_globle_ctrl_reg;
       sfg_sfg_force_bg_at_dif_RBUS sfg_sfg_force_bg_at_dif_reg;
	   di_di_ptg_ctrl_RBUS di_di_ptg_ctrl_reg;//ecn RL6543-594
	   di_di_ptg_act_window_RBUS di_di_ptg_act_window_reg;//ecn RL6543-594

#ifdef CONFIG_DUAL_CHANNEL
       if((winID < VIDEO_WID_MIN)||(winID > VIDEO_WID_MAX))
       {
               rtd_pr_vsc_debug("wid id is not ok\n");
               return FALSE;
       }
#else
       if(winID !=VIDEO_WID_0)
       {
               rtd_pr_vsc_debug("wid id is not ok\n");
               return FALSE;
       }
#endif

       rtd_pr_vsc_emerg("[%s]on_off = %d, winID = %d, pattern_location = %d\n", __FUNCTION__, on_off, winID, pattern_location);
       switch(pattern_location){
				case VSC_VIDEO_PATTERN_MUX:
					if(winID == VIDEO_WID_0){
						vgip_vgip_chn1_ctrl_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_CTRL_reg);
						vgip_vgip_chn1_ctrl_reg.ch1_random_en = on_off;
						IoReg_Write32(VGIP_VGIP_CHN1_CTRL_reg, vgip_vgip_chn1_ctrl_reg.regValue);
					}
					else{
						sub_vgip_vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
						sub_vgip_vgip_chn2_ctrl_reg.ch2_random_en = on_off;
						IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, sub_vgip_vgip_chn2_ctrl_reg.regValue);
					}
					break;

				case VSC_VIDEO_PATTERN_DI_NR:
					if(winID == VIDEO_WID_0){
						if(on_off && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE))
						{
							rtd_pr_vsc_err("[%s] scaler not ready\n", __FUNCTION__);
						}
						else
						{
							if(on_off)
							{
								//set PTG color bar
								di_di_ptg_ctrl_reg.regValue = IoReg_Read32(DI_DI_PTG_CTRL_reg);
								di_di_ptg_ctrl_reg.di_color_num = 2;//2'b00:2 color 2'b01:4 color 2'b10:8 color. set 8 color
								di_di_ptg_ctrl_reg.di_color_bar_vertical_mode = 1;//vertical
								IoReg_Write32(DI_DI_PTG_CTRL_reg, di_di_ptg_ctrl_reg.regValue);

								//set PTG size
								di_di_ptg_act_window_reg.regValue = IoReg_Read32(DI_DI_PTG_ACT_WINDOW_reg);
								// @willlin, 20180614
								if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
									di_di_ptg_act_window_reg.di_ptg_length =  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) * 2;
								else
									di_di_ptg_act_window_reg.di_ptg_length =  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
								di_di_ptg_act_window_reg.di_ptg_width = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
								IoReg_Write32(DI_DI_PTG_ACT_WINDOW_reg, di_di_ptg_act_window_reg.regValue);
							}
							di_di_ptg_ctrl_reg.regValue = IoReg_Read32(DI_DI_PTG_CTRL_reg);
							di_di_ptg_ctrl_reg.di_color_bar_mode_en = on_off ? 1 : 0;//enble or disable PTG
							IoReg_Write32(DI_DI_PTG_CTRL_reg, di_di_ptg_ctrl_reg.regValue);
						}
					}
					else{
						rtd_pr_vsc_err("[%s]Do not support sub PATTERN_DI_NR\n", __FUNCTION__);
					}



					break;

				case VSC_VIDEO_PATTERN_SCALER:
					if(winID == VIDEO_WID_0){
						scaleup_d_uzu_globle_ctrl_reg.regValue = IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg);
						scaleup_d_uzu_globle_ctrl_reg.patgen_sel = on_off;
						scaleup_d_uzu_globle_ctrl_reg.patgen_mode = 2;
						IoReg_Write32(SCALEUP_D_UZU_Globle_Ctrl_reg, scaleup_d_uzu_globle_ctrl_reg.regValue);
					}
					else{
						scaleup_ds_uzu_globle_ctrl_reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_Globle_Ctrl_reg);
						scaleup_ds_uzu_globle_ctrl_reg.patgen_sel = on_off;
						scaleup_ds_uzu_globle_ctrl_reg.patgen_mode = 2;
						IoReg_Write32(SCALEUP_DS_UZU_Globle_Ctrl_reg, scaleup_ds_uzu_globle_ctrl_reg.regValue);
					}
					break;

				case VSC_VIDEO_PATTERN_MEMC:
					if(on_off)
					{
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_GB_reg, 0x08000800);//set color
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_R_reg, 0x00000800);//set color
						IoReg_SetBits(PPOVERLAY_MEMC_MUX_CTRL_reg, _BIT12);//enable ptg
						IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL2_reg, _BIT16);//double buffer apply
						//IoReg_SetBits(IPPRE__IPPRE_20_ADDR, _BIT7);

					}
					else
					{
						IoReg_ClearBits(PPOVERLAY_MEMC_MUX_CTRL_reg, _BIT12);//clear color
						IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL2_reg, _BIT16);//double buffer apply
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_GB_reg, 0);//clear color
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_R_reg, 0);//clear color
						//IoReg_ClearBits(IPPRE__IPPRE_20_ADDR, _BIT7);
					}
					break;

				case VSC_VIDEO_PATTERN_DISPLAY:
					sfg_sfg_force_bg_at_dif_reg.regValue = IoReg_Read32(SFG_SFG_FORCE_BG_AT_DIF_reg);
					if(on_off)
						sfg_sfg_force_bg_at_dif_reg.bg_dif_blu = 0x3ff;
					else
						sfg_sfg_force_bg_at_dif_reg.bg_dif_blu = 0;
					sfg_sfg_force_bg_at_dif_reg.en_force_bg_dif = on_off;
					IoReg_Write32(SFG_SFG_FORCE_BG_AT_DIF_reg, sfg_sfg_force_bg_at_dif_reg.regValue);
					break;

				default:
					break;
       }
       return TRUE;
}


unsigned char rtk_hal_vsc_CaptureVideoFrame(KADP_VIDEO_DDI_CAPTURE_PLACE_T place, KADP_VIDEO_DDI_CAPTURE_INFO_T * pCaptureInfo)
{

	rtd_pr_vsc_debug("have VT, V2G and VSCcapture not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}


unsigned char rtk_rerun_scaler(SCALER_DISP_CHANNEL channel)
{
	return TRUE;//No work
}

unsigned char rtk_hal_vsc_SetRGB444Mode(bool bonoff)
{
#ifdef ENABLE_FORCE_PC_MODE
	// Test Only, force set 444 mode
	bonoff = TRUE;
#endif
	rtd_pr_vsc_notice(" function=%s, bonoff: %d\n", __FUNCTION__, bonoff);
	DbgSclrFlgTkr.RGB444Mode = bonoff;
	return TRUE;
}

bool rtk_hal_vsc_GetRGB444Mode(void)
{
	return DbgSclrFlgTkr.RGB444Mode;
}


unsigned char rtk_hal_vsc_setwinprop(VSC_SET_SUB_WINDOW_MODE_TYPE vsc_set_sub_win_mode)
{
   /*for testing
   vsc_set_sub_win_mode.mode = VSC_SUB_MODE_PIP;
   vsc_set_sub_win_mode.connectType = VSC_SUB_CONNECT_TYPE_MIRROR;
   vsc_set_sub_win_mode.memoryUse = VSC_SUB_MEMORY_USE_MULTI;

   rtd_pr_vsc_emerg("[%s][crixus]@@VSC_IOC_SET_SetSubWinMode,mode = %d, connectType = %d, memoryUse = %d\n", __FUNCTION__, vsc_set_sub_win_mode.mode, vsc_set_sub_win_mode.connectType, vsc_set_sub_win_mode.memoryUse);
   */
   sub_mode_type = vsc_set_sub_win_mode.mode;//get sub mode

   if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_MIRROR){

		//disable ST game mode timeout checking task when enter livezoom for quickly switching case @Crixus 20170726
		down(&GameMode_Check_Semaphore);
		if(drv_memory_get_game_mode() == _ENABLE){
			smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
			//smooth_toggle_game_mode_check_cnt = 0;
			rtd_pr_new_game_mode_notice("Disable ST game mode timeout tsk!!(before sub scaler)\n");
		}
		up(&GameMode_Check_Semaphore);
   }
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
   //connect type is non-mirror => multi-view or overlay miracast
   else if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NON_MIRROR){
		   if((sub_mode_type == VSC_SUB_MODE_EX_PBP)){
				   //i2rnd_test_done = 1;
				   rtk_hal_vsc_i2rnd_enable(_ENABLE);
				   rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
		   }else if((sub_mode_type == VSC_SUB_MODE_EX_PIP)){
				   //i2rnd_test_done = 0;
				   rtk_hal_vsc_i2rnd_enable(_DISABLE);
				   rtd_pr_vsc_emerg("[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
		   }
   }
#endif
#endif

   else if((vsc_set_sub_win_mode.mode == VSC_SUB_MODE_EX_NONE) && (vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NONE)
				   && (vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_NONE)){
		   //exit PIP or PBP app.
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
		   if((Scaler_I2rnd_get_enable() == _ENABLE)){
				   //disable i2run mode
				   //i2rnd_test_done = 0;
				   i2rnd_send_table_idx(I2RND_TABLE_OFF);
				   rtk_hal_vsc_i2rnd_enable(_DISABLE);
				   //frank@I2run disable main VENC flag
				   VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
				   DbgSclrFlgTkr.OutputVencMode = FALSE;
				   vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
				   vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
				   //apvr_request_run_main_path();
				   rtd_pr_vsc_emerg("[%s][frank]I2RND close\n", __FUNCTION__);
		   }
#endif
#endif
   }
	return TRUE;
}

unsigned char rtk_hal_vsc_Set3DForScaler(TRIDTV_SCALER_CTRL_T * p3DCfgInfo)
{
	unsigned char curmode;
	unsigned char support3Dinput[INPUT_TYPE_MAX]= {
		SLR_3DMODE_2D, SLR_3DMODE_3D_TB, SLR_3DMODE_3D_SBS, SLR_3DMODE_2D,
		SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_3D_FP,
		SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_3D_SBS, SLR_3DMODE_3D_FP,
		SLR_3DMODE_2D_CVT_3D};

	rtd_pr_vsc_debug("vsc_3d:%d=%d=%d=%d\n",p3DCfgInfo->mode, p3DCfgInfo->in_fmt, p3DCfgInfo->out_fmt, p3DCfgInfo->lr);
	if(p3DCfgInfo == NULL)
	{
		rtd_pr_vsc_debug("scaler vsc Set3DForScaler paramter NULL!!!\n");
		return FALSE;
	}
	if(p3DCfgInfo->mode > TRIDTV_3DMODE_MAX || p3DCfgInfo->mode  < TRIDTV_3DMODE_OFF
		||p3DCfgInfo->in_fmt > INPUT_TYPE_MAX || p3DCfgInfo->in_fmt < INPUT_TYPE_3DOFF
		||p3DCfgInfo->out_fmt > SC_OUT_MAX || p3DCfgInfo->out_fmt < SC_OUT_SINGLE_2D
		||p3DCfgInfo->lr > INPUT_LR_MAX || p3DCfgInfo->lr  < INPUT_LR_SEQ)
	{
		rtd_pr_vsc_debug("scaler vsc Set3DForScaler paramter error!!!\n");
		return FALSE;
	}

	set_field_alternative_3d_mode_enable(FALSE);
#if 1
	if(get_line_alternative_3d_mode_enable() == TRUE)
	{
		Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, false);
		set_line_alternative_3d_mode_enable(FALSE);
		DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	}
#endif
	if(p3DCfgInfo->mode == TRIDTV_3DMODE_OFF  || p3DCfgInfo->mode == TRIDTV_3DMODE_3DTO2D)
	{

		if(get_3D_mode_enable() == TRUE)
		{
			rtd_pr_vsc_debug("scaler vsc Set3DForScaler OFF!change to 2D!\n");
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}
	else if(p3DCfgInfo->mode == TRIDTV_3DMODE_MAX || p3DCfgInfo->in_fmt == INPUT_TYPE_MAX  ||p3DCfgInfo->out_fmt == SC_OUT_MAX ||p3DCfgInfo->lr == INPUT_LR_MAX)
	{

		if(get_3D_mode_enable() == TRUE)
		{
			rtd_pr_vsc_debug("scaler vsc Set3DForScaler MAXNUM!change to 2D!\n");
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}


	/*force set the out_fmt SC_OUT_SINGLE_FS*/
	if(p3DCfgInfo->out_fmt != SC_OUT_SINGLE_FS)
		p3DCfgInfo->out_fmt = SC_OUT_SINGLE_FS;

	if(p3DCfgInfo->out_fmt != SC_OUT_SINGLE_FS)
	{
		rtd_pr_vsc_debug("scaler vsc Set3DForScaler out format no support!change to 2D!\n");
		if(get_3D_mode_enable() == TRUE)
		{
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}

	if(p3DCfgInfo->in_fmt == INPUT_TYPE_DUALSTREAM)
	{
		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);

		return TRUE;
	}

	if(p3DCfgInfo->in_fmt == INPUT_TYPE_LINE_ALTERNATIVE/*&& DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI*/)
	{
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
		HDMI_TIMING_T vfehdmitiminginfo;
#else
		vfe_hdmi_timing_info_t vfehdmitiminginfo;
#endif
		rtd_pr_vsc_debug("input is line alternative\n");
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_LBL, TRUE);

		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);

		 //DisplayModeInputInfo.type = VSC_INPUTSRC_VDEC;

#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
		down(get_hdmi_detectsemaphore());
		if(0 == drvif_Hdmi_GetRawTimingInfo(&vfehdmitiminginfo))
		{
			up(get_hdmi_detectsemaphore());
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_With_NEW_HDMI_TIMING_INFO(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
#else
		if(0!=vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, SLR_MAIN_DISPLAY))
			return FALSE;
		Scaler_SET_VSCDispinfo_WithVFEHMDI(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
#endif
		drvif_I3DDMA_Init();
		HDMI_set_detect_flag(FALSE);
		Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, true);
		set_line_alternative_3d_mode_enable(TRUE);
		drivf_I3DDMA_3D_config();

		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		Scaler_Disp3dSetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE,SLR_3D_FRAME_PACKING);
		Scaler_Set3DMode_Attr(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP);
		set_vo_3d_mode(VO_2D_MODE);

		DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  			rtk_output_connect(SLR_MAIN_DISPLAY);
   		up(&VSC_Semaphore);

		return TRUE;


	}
	else if(p3DCfgInfo->in_fmt == INPUT_TYPE_FIELD_ALTERNATIVE/*&& DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI*/)
	{
		rtd_pr_vsc_debug("input is feild alternative\n");
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,true);
		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		set_field_alternative_3d_mode_enable(TRUE);
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);

		 return TRUE;

	}
	if(p3DCfgInfo->mode == TRIDTV_3DMODE_ON ||p3DCfgInfo->mode == TRIDTV_3DMODE_2DTO3D)
	{
		curmode = p3DCfgInfo->in_fmt;
		curmode = support3Dinput[(curmode < INPUT_TYPE_MAX? curmode: INPUT_TYPE_3DOFF)];

		if(curmode == SLR_3DMODE_2D)
		{
			if(get_3D_mode_enable() == TRUE)
			{
				set_3D_mode_enable(FALSE);
				set_3D_overscan_enable(FALSE);
				Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
				down(&VSC_Semaphore);
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  					rtk_output_connect(SLR_MAIN_DISPLAY);
   				up(&VSC_Semaphore);
				return TRUE;
			}
			else
			{
				return TRUE;
			}
		}

		Scaler_Set3DMode(SLR_MAIN_DISPLAY, curmode, TRUE);
		 if (Get_PANEL_SCALER_2D_3D_CVT_HWSHIFT_ENABLE() && p3DCfgInfo->in_fmt == INPUT_TYPE_2DTO3D)
		{
			// [2D3D] default mode init
			rtd_pr_vsc_debug("2d concvt 3d init\n");
			scaler_2Dcvt3D_init();
		}
		 if( drvif_scaler3d_decide_HDMI_framePacking_interlaced_status() && p3DCfgInfo->in_fmt == INPUT_TYPE_FRAMEPAC)
		 {
		 	rtd_pr_vsc_debug("Interlace Fp 3D, change progress to interlace!\n");
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,true);
		 }

		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  			rtk_output_connect(SLR_MAIN_DISPLAY);
   		up(&VSC_Semaphore);
		//Scaler_Set3DLRSwap(p3DCfgInfo->lr);
	}

	return TRUE;
}

unsigned char rtk_hal_vsc_Get3DAutoDetectmode(VIDEO_WID_T wid, KADP_VIDEO_DDI_3D_FORMAT_TYPE_T * pvideo3DType)
{
	unsigned char  curmode;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	if(pvideo3DType == NULL)
	{
		rtd_pr_vsc_debug("scaler vsc Get3DAutoDetectmode paramter is error!\n");
		return FALSE;
	}

	if (Scaler_InputSrcGetMainChType() == _SRC_VO)
	{
		if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF)
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_SIDEBYSIDE_HALF;
		else if(get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM)
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_TOP_BOTTOM;
		else
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_2D;
		return TRUE;
	}

	Scaler_Set3D_VoAutoDetect_Enable(true);

#ifdef CONFIG_DUAL_CHANNEL
	if(VIDEO_WID_1 == wid)
		check_vo3d_detect_result(SLR_SUB_DISPLAY);
	else// if(VIDEO_WID_0 == wid)
		check_vo3d_detect_result(SLR_MAIN_DISPLAY);
#else //#ifdef CONFIG_DUAL_CHANNEL
	check_vo3d_detect_result(SLR_MAIN_DISPLAY);
#endif //#ifdef CONFIG_DUAL_CHANNEL

	curmode = modestate_get_vo3d_detect_result();
	switch(curmode)
	{
		case VO_2D_MODE:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_2D;
			break;
		case VO_3D_SIDE_BY_SIDE_HALF:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_SIDEBYSIDE_HALF;
			break;
		case VO_3D_TOP_AND_BOTTOM:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_TOP_BOTTOM;
			break;
		default:
			rtd_pr_vsc_debug("Can't detect 3D auto mode!\n");
			break;
	}


	return TRUE;
}

unsigned char rtk_hal_vsc_Set3Dpatternmode(VIDEO_WID_T wid, KADP_VIDEO_DDI_3D_PATTERN_TYPE_T video3DType)
{
	unsigned char curmode;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	switch(video3DType)
	{
		case KADP_VIDEO_DDI_3D_PATTERN_TOP_BOTTOM:
			curmode = SLR_3DMODE_3D_TB;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_SIDEBYSIDE_HALF:
			curmode = SLR_3DMODE_3D_SBS;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_LINE_INTERLEAVE_HALF:
			curmode = SLR_3DMODE_3D_LBL;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_FRAME_PACKING:
			curmode = SLR_3DMODE_3D_FP;
			break;
		default:
			curmode = SLR_3DMODE_2D;
			break;
	}

	Scaler_Set3DMode(SLR_MAIN_DISPLAY, curmode, TRUE);
	rtk_rerun_scaler(SLR_MAIN_DISPLAY);
	return TRUE;
}

unsigned char rtk_hal_vsc_SetVENEMode(unsigned short framerate, unsigned short scantype)
{
	rtd_pr_vsc_debug("VENEMode hal venc support framerate setting,but no scantype setting!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char 	rtk_hal_vsc_OpenV2G(VIDEO_WID_T wid )
{
	rtd_pr_vsc_debug("V2G not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}
unsigned char 	rtk_hal_vsc_CloseV2G(VIDEO_WID_T wid )
{
	rtd_pr_vsc_debug("V2G not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char 	rtk_hal_vsc_GetV2GFramebuffer(VIDEO_WID_T wid , KADP_VIDEO_DDI_CAPTURE_INFO_T* pCaptureInfo)
{
	rtd_pr_vsc_debug("have VT, V2G not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char	rtk_hal_vsc_SetUDInput(KADP_VIDEO_UD_MODE_T videoUDMode)
{
	rtd_pr_vsc_debug("UD not use,keep empty!!\n");
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char 	rtk_hal_vsc_SetUDOutput(KADP_VIDEO_DDI_DIS_FMT_T disFmt)
{
		rtd_pr_vsc_debug("UD not use,keep empty!!\n");
		rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
		return TRUE;
}


unsigned char	rtk_hal_vsc_GetVideoDelayedTime (VIDEO_WID_T wid , unsigned short *pDelayedTime)
{

        unsigned short scaler_dispInfo = 0;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

        scaler_dispInfo = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

        if(scaler_dispInfo != 0)
        {
	        *pDelayedTime = 10000/scaler_dispInfo;
		return TRUE;
        }
	else
	{
                rtd_pr_vsc_debug("DispGetInputInfo is 0\n");
		return FALSE;
	}
}


unsigned char 	rtk_hal_vsc_SetTileMode(BOOLEAN bOnOff)
{
	//pip not support
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("pip pop mode not support!!\n");
	return TRUE;
}

unsigned char 	rtk_hal_vsc_SetTileMaxRowVal(unsigned char uMaxRow, unsigned char uMaxCol)
{
	//pip not support
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("pip pop mode not support!!\n");
	return TRUE;
}

unsigned char 	rtk_hal_vsc_SetTileID(unsigned char uTileID)
{
	//pip not support
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("pip pop mode not support!!\n");
	return TRUE;
}

unsigned char rtk_hal_vsc_SetAdaptiveStream(unsigned char bOnOff)
{
	int ret = -1;
		//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_notice("file=%s, function=%s, line=%d,bOnOff=%d,DbgSclrFlgTkr.adaptive_stream_pre=%d\n", __FILE__, __FUNCTION__, __LINE__, bOnOff,DbgSclrFlgTkr.adaptive_stream_pre);

	if(scaler_vsc_get_force_pst_lowdelay_mode() == TRUE){
		bOnOff = TRUE;
	}
	if((0 == bOnOff) && rtk_hal_vsc_Getdualdecoder())
	{
		rtd_pr_vsc_notice("file=%s, function=%s, line=%d dual decoder case true, not set adaptive stream false, return\n",__FILE__, __FUNCTION__, __LINE__);
		return TRUE;
	}
	if(DbgSclrFlgTkr.adaptive_stream_pre != bOnOff) {
	#if 0
		unsigned int *pulTemp;
		unsigned int i = 0, ulItemCount = 0;
		SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *sm_info_pkg = NULL;
		SMOOTH_TOGGLE_UPDATE_FWINFO_PKG update_info;
		sm_info_pkg = (SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *)Scaler_GetShareMemVirAddr(SCALERIOC_SMOOTHTOGGLE_SHARE_INFO);
		if (sm_info_pkg)
			{
			memcpy(&update_info, sm_info_pkg, sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG));
			ulItemCount = sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG) /  sizeof(UINT32);
			pulTemp = (unsigned int *)&update_info;
			for (i = 0; i < ulItemCount; i++)
				pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
			update_info.sm_info[SLR_MAIN_DISPLAY].vodma_plane = get_vo_plane_flag(SLR_MAIN_DISPLAY);
			}
	#endif
#if /*defined(CONFIG_REALTEK_2K_MODEL_ENABLED) &&*/defined(ENABLE_IMD_PST_SMOOTHTOGGLE)//k5ap and enable force frame rate
		if(get_MEMC_bypass_status_refer_platform_model() == TRUE) {
			drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));
		}
#endif
		DbgSclrFlgTkr.adaptive_stream = bOnOff;
		DbgSclrFlgTkr.adaptive_stream_pre = bOnOff;
		if (0 != (ret = Scaler_SendRPC(SCALERIOC_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
			rtd_pr_vsc_err("ret=%d, SCALERIOC_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
				}
		}
		return TRUE;

}

unsigned char rtk_hal_vsc_SetAdaptiveStreamEX(VIDEO_WID_T wid,unsigned char bOnOff)
{
	int ret = -1;
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_notice("file=%s, function=%s, line=%d,bOnOff=%d,DbgSclrFlgTkr.adaptive_stream_pre=%d\n", __FILE__, __FUNCTION__, __LINE__, bOnOff,DbgSclrFlgTkr.adaptive_stream_pre);
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_pr_vsc_debug("wid id is not ok\n");
		return FALSE;
	}
	if (wid == VIDEO_WID_0) {

		if(scaler_vsc_get_force_pst_lowdelay_mode() == TRUE){
			bOnOff = TRUE;
		}

        if((0 == bOnOff) && rtk_hal_vsc_Getdualdecoder())
    	{
    		rtd_pr_vsc_notice("function=%s, line=%d dual decoder case true, not set adaptive stream false, return\n", __FUNCTION__, __LINE__);
    		return TRUE;
    	}

		if(DbgSclrFlgTkr.adaptive_stream_pre != bOnOff) {
		#if 0
			unsigned int *pulTemp;
			unsigned int i = 0, ulItemCount = 0;
			SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *sm_info_pkg = NULL;
			SMOOTH_TOGGLE_UPDATE_FWINFO_PKG update_info;
			sm_info_pkg = (SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *)Scaler_GetShareMemVirAddr(SCALERIOC_SMOOTHTOGGLE_SHARE_INFO);
			if (sm_info_pkg) {
				memcpy(&update_info, sm_info_pkg, sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG));
				ulItemCount = sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG) /  sizeof(UINT32);
				pulTemp = (unsigned int *)&update_info;
				for (i = 0; i < ulItemCount; i++)
					pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
				update_info.sm_info[SLR_MAIN_DISPLAY].vodma_plane = get_vo_plane_flag(SLR_MAIN_DISPLAY);
			}
		#endif

#if /*defined(CONFIG_REALTEK_2K_MODEL_ENABLED) && */defined(ENABLE_IMD_PST_SMOOTHTOGGLE)//k5ap and enable force frame rate
		if(get_MEMC_bypass_status_refer_platform_model() == TRUE)
			drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));
#endif

			DbgSclrFlgTkr.adaptive_stream = bOnOff;
			DbgSclrFlgTkr.adaptive_stream_pre = bOnOff;
			if (0 != (ret = Scaler_SendRPC(SCALERIOC_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
				rtd_pr_vsc_err("ret=%d, SCALERIOC_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
			}
		}
	}else if(wid == VIDEO_WID_1){
		if(DbgSclrFlgTkr.sub_adaptive_flag != bOnOff)
		{
			DbgSclrFlgTkr.sub_adaptive_flag = bOnOff;
			if (0 != (ret = Scaler_SendRPC(SCALERIOC_SUB_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
				rtd_pr_vsc_err("ret=%d, SCALERIOC_SUB_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
			}
		}
	}

	return TRUE;

}
EXPORT_SYMBOL(rtk_hal_vsc_SetAdaptiveStreamEX);

static bool is_adaptive_stream_source(unsigned char display)
{
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(display);


#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	return 0;
#endif

	return srctype == VSC_INPUTSRC_VDEC;
}

unsigned char vsc_get_adaptivestream_flag(unsigned char display)
{
	bool had_adaptive_stream = is_adaptive_stream_source(display);

	if(display == SLR_MAIN_DISPLAY)
		return (had_adaptive_stream) ? DbgSclrFlgTkr.adaptive_stream : 0;
	else
		return (had_adaptive_stream) ? DbgSclrFlgTkr.sub_adaptive_flag : 0;
}

#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
unsigned char vsc_decide_timingframesync(unsigned char display)
{
	if(display==SLR_MAIN_DISPLAY){
		if (Scaler_InputSrcGetType(display) == _SRC_VO){

			if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)&& vbe_disp_get_adaptivestream_fs_mode())
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		else {
			return FALSE;
		}
	}
	else if (display==SLR_SUB_DISPLAY){
			return FALSE;
	}

	return FALSE;


}
#endif

void Scaler_DualChannelRpc(unsigned char flag)
{
	int ret = 0;
	unsigned char *pulTemp = NULL;

	pulTemp = (unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_DUAL_CHANNEL_FLAG);

	// copy to RPC share memory
	//memcpy(pulTemp, &DbgSclrFlgTkr.dvo_dual_decoder_flag, sizeof(unsigned char));

	//pulTemp[0] = htonl(pulTemp[0]);
	if (pulTemp) {
		*pulTemp = flag;
		if (0 != (ret = Scaler_SendRPC(SCALERIOC_DUAL_CHANNEL_FLAG,0,0)))
		{
			rtd_pr_vsc_debug("ret=%d, set dual channel fail !!!\n", ret );
			return;
		}
	}
}

unsigned char dualdecoder_notchange_flag;
void scaler_Setdualdecoder_notchange(unsigned char flag)
{
	dualdecoder_notchange_flag = flag;
}
unsigned char scaler_Getdualdecoder_notchange(void)
{
	return dualdecoder_notchange_flag;
}

void rtk_hal_vsc_Setdualdecoder(unsigned char enable)
{
	rtd_pr_vsc_info("file=%s, function=%s, enable=%d\n", __FILE__, __FUNCTION__, enable);

	DbgSclrFlgTkr.dvo_dual_decoder_flag = enable;
	if ( 0== enable) {
		if (0 ==scaler_Getdualdecoder_notchange()) {
			rtk_hal_vsc_Setdualdecoder_run(0);
			Scaler_DualChannelRpc(0);
		}
	} else {
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
			rtk_hal_vsc_Setdualdecoder_run(1);
			Scaler_DualChannelRpc(1);
			rtd_pr_vsc_info("dual decoder start to run 1\n");
		}
	}
}

unsigned char rtk_hal_vsc_Getdualdecoder(void)
{
	return DbgSclrFlgTkr.dvo_dual_decoder_flag;
}

void  rtk_hal_vsc_Setdualdecoder_run(unsigned char flag)
{
	DbgSclrFlgTkr.dvo_dual_decoder_run = flag;
}
unsigned char rtk_hal_vsc_Getdualdecoder_run(void)
{
	return DbgSclrFlgTkr.dvo_dual_decoder_run;
}

unsigned char 	rtk_hal_vsc_SetSOCOutputFMT(KADP_VIDEO_UD_MODE_T videoUDMode)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}

unsigned char 	rtk_hal_vsc_SetFRCType(unsigned char frcType)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}

unsigned char 	rtk_hal_vsc_GetFRCType(unsigned char frcType)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}

unsigned char	rtk_hal_vsc_GetMVOPStatus(VIDEO_WID_T wId, BOOLEAN *bMVOPEnable)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}
/*api which have protect by forcebg_semaphore*/
void set_ATV_passthrought_output_flag(unsigned char display, unsigned char flag)
{
	if(display == SLR_MAIN_DISPLAY)
		DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag = flag;
}

unsigned int osdsample_addr = 0;
#if 0
unsigned char rtk_hal_vsc_showosdsample(unsigned char bonoff)
{

	GRAPHIC_LAYERS_OBJECT grahpic_obj;
	GDMA_LAYER_OBJECT *picObj;

	memset(&grahpic_obj, 0, sizeof(GRAPHIC_LAYERS_OBJECT));
	picObj = &grahpic_obj.layer[0];
	grahpic_obj.layer_num = 1;

	picObj->src_type = SRC_NORMAL;
	picObj->format = VO_OSD_COLOR_FORMAT_ARGB8888_LITTLE;
	/*picObj->plane = VO_GRAPHIC_OSD1;*/
	picObj->colorkey = -1;
	picObj->alpha = 0;
	picObj->x = 0;
	picObj->y = 0;
	picObj->width = 260;				// image width
	picObj->height = 200;				// image height
	picObj->pitch = picObj->width*4;

	if(bonoff == TRUE)
	{
		osdsample_addr = (unsigned int)dvr_malloc(1024*1024*3);
	}

	//picObj->address = (unsigned int)virt_to_phys((void*)osdsample_addr);	// set image address
	picObj->address = (unsigned int)dvr_to_phys((void*)osdsample_addr);	// set image address
	picObj->dst_x = 0;
	picObj->dst_y = 0;
	picObj->dst_width = 260;	 // image width
	picObj->dst_height = 200; // image height
	picObj->plane_ar.value = 0xffffffff;
	picObj->plane_gb.value = 0xffffffff;
	picObj->clear_x.value = 0;
	picObj->clear_y.value = 0;
	picObj->syncstamp = 0;
	picObj->show = bonoff;	  // always show the picture by normal update pic flow
	picObj->compressed = 0;
	/*picObj->layer_used = 1;*/
	/*osd_comp_receive_picture(&com_picObj);*/
#if IS_ENABLED(CONFIG_RTK_KDRV_GDMA)
	GDMA_ReceiveGraphicLayers(&grahpic_obj);
#endif

	if(bonoff == FALSE)
	{
		dvr_free((void *)osdsample_addr);
		osdsample_addr = 0;
	}
	return 0;
}
#endif

// Dolby Vision IDMA enable control

#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
// HDR10 IDMA enable control
unsigned char rtk_hal_vsc_SetHdr10IdmaEnable(unsigned char bEnable)
{
	rtd_pr_vsc_debug("[HDR10] %s.%d\n", __FUNCTION__, __LINE__);
	rtd_pr_vsc_debug("en=%d, type/idma=%d/%d\n", bEnable, DisplayModeInputInfo.type, Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA));
	if(bEnable){
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
		{
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
			HDMI_TIMING_T vfehdmitiminginfo;
#else
			vfe_hdmi_timing_info_t vfehdmitiminginfo;
#endif
			DisplayModeInputInfo.type = KADP_VSC_INPUTSRC_VDEC;
			DisplayModeInputInfo.resourceIndex = 0;
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
			down(get_hdmi_detectsemaphore());
			if(0 == drvif_Hdmi_GetRawTimingInfo(&vfehdmitiminginfo))
			{
				up(get_hdmi_detectsemaphore());
				return FALSE;
			}
			Scaler_SET_VSCDispinfo_With_NEW_HDMI_TIMING_INFO(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
#else
			if(0!=vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, SLR_MAIN_DISPLAY))
				return FALSE;
			Scaler_SET_VSCDispinfo_WithVFEHMDI(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
#endif


			set_HDMI_HDR_mode(HDR_HDR10_HDMI);
			drvif_I3DDMA_Init();
			Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, true);
			drivf_I3DDMA_3D_config();
			DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;

			if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
			down(&VSC_Semaphore);
	  		rtk_output_connect(SLR_MAIN_DISPLAY);
			if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
	   		up(&VSC_Semaphore);

			return TRUE;
		}else{
			rtd_pr_vsc_debug("[WARN][HDR10][%d] Not in HDMI source\n", DisplayModeInputInfo.type);
		}
	}
	else if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC){
		if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == true)
		{
			if(IoReg_Read32(H3DDMA_I3DDMA_enable_reg) & _BIT0){
				rtd_pr_vsc_debug("[HDR10] Disable IDMA HW\n");
				I3DDMA_Setup3DDMA(&i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
				msleep(40/*100*/); // wait DMA write done

				// [IDMA] allocate/release IDMA memory dynamic
				if(I3DDMA_Get3DAllocReleaseMemoryDynamic() == TRUE)
					drvif_I3DDMA_DeInit();
			}

			Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, false);
			DisplayModeInputInfo.type = KADP_VSC_INPUTSRC_HDMI;
			DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
		}
		if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
		down(&VSC_Semaphore);
  		rtk_output_connect(SLR_MAIN_DISPLAY);
		if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
   		up(&VSC_Semaphore);
	}

	if(!bEnable)
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	return 0;
}
#endif


unsigned char rtk_hal_vsc_SetZorder(VSC_SET_ZORDER_T zOrderMain,VSC_SET_ZORDER_T zOrderSub)//(unsigned char uZorder,unsigned char uAlpha)
{
	unsigned int main_blendingFactor = zOrderMain.uAlpha;
	unsigned int sub_blendingFactor = zOrderSub.uAlpha;

	//rtd_pr_vsc_err("[hal] zorder main:%d, sub:%d\n",zOrderMain.uZorder,zOrderSub.uZorder);
	//rtd_pr_vsc_err("[hal] alpha main:%d, sub:%d\n",main_blendingFactor,sub_blendingFactor);

	main_blendingFactor = zOrderMain.uAlpha * 256 / (zOrderMain.uAlpha + zOrderSub.uAlpha);
	sub_blendingFactor = zOrderSub.uAlpha * 256 / (zOrderMain.uAlpha + zOrderSub.uAlpha);

	rtd_pr_vsc_err("[vsc] blending factor main:%d, sub:%d\n",main_blendingFactor,sub_blendingFactor);

	if((sub_blendingFactor + main_blendingFactor) != 256){
		if((sub_blendingFactor + main_blendingFactor) > 256){
			rtd_pr_vsc_err("[ERROR]wrong blending factor(%d, %d) @func:%s, line:%d\n",main_blendingFactor,sub_blendingFactor,__FUNCTION__,__LINE__);
			return 0;
		}
		sub_blendingFactor = 256 - main_blendingFactor;
	}

	if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		&&(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
	{
		//int ret = 0;
		//drvif_color_setpiprgbcontrastbrightness(zOrderMain.uAlpha);
		drvif_color_setBrightnessDualplayOverlay(main_blendingFactor,sub_blendingFactor);
		/*if (0 != (ret =Scaler_SendRPC(SCALERIOC_SENDZORDER, ((zOrderMain.uZorder<<8) + zOrderSub.uZorder), RPC_SEND_VALUE_ONLY))) {
			rtd_pr_vsc_emerg("ret=%d, rtk_hal_vsc_SetZorder SCALERIOC_SENDZORDER fail !!!\n", ret);
			return FALSE;
		}*/
	}
	return TRUE;
}

unsigned char rtk_hal_vsc_set_localDimmingCtrlDemoMode(unsigned char bType, unsigned char bCtrl)
{
	LocalDimmingDemoCtrlType = bType;
	LocalDimmingDemoCtrlMode = bCtrl;
	rtd_pr_vsc_notice("rtk_hal_vsc_set_localDimmingCtrlDemoMode (type:%d. ctrl:%d) \n", bType,bCtrl);
	return _TRUE;
}


unsigned char rtk_hal_vsc_makeColoredVideo(KADP_VSC_VIDEO_COLOR_TYPE_T videoColor)
{
	osdovl_mixer_ctrl2_RBUS mixer_ctrl2_reg;
	ppoverlay_main_background_color1_RBUS main_background_color1_reg;
	ppoverlay_main_background_color2_RBUS main_background_color2_reg;
	ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
	ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
	ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
	ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
	ppoverlay_double_buffer_ctrl2_RBUS double_buffer_ctrl_reg;
	static unsigned char m_memc_bg_en = 0;

	static KADP_VIDEO_RECT_T originalSize={0,0,0,0};
	unsigned int timeout=0x3fffff;
	rtd_pr_vsc_notice("rtk_hal_vsc_makeColoredVideo (%d) \n", videoColor);

	if(videoColor == KADP_VSC_VIDEO_COLOR_WHITE){

		rtd_pr_vsc_notice("rtk_hal_vsc_makeColoredVideo KADP_VSC_VIDEO_COLOR_WHITE \n");
		if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
			rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_0, &originalSize);
			if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
				rtd_pr_vsc_notice("no originalSize,reset to default.\n");
				originalSize.x = 0;
				originalSize.y = 0;
				originalSize.w = _DISP_WID;
				originalSize.h = _DISP_LEN;
			}
			rtd_pr_vsc_notice("originalSize (%d.%d.%d.%d) \n", originalSize.x, originalSize.y, originalSize.w, originalSize.h);
		}
		down(&VPQ_ld_running_Semaphore);
		drvif_HAL_VPQ_LED_LDEnable(1);
		up(&VPQ_ld_running_Semaphore);
		OutpuLocalDimmingPatMode = TRUE;
		//set free run timing
		drivf_scaler_reset_freerun_60Hz();
		// turn off osd mixer
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 0;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);
		rtd_pr_vsc_info("func=%s line=%d OSDOVL_Mixer_CTRL2_reg=%x\n",__FUNCTION__,__LINE__,rtd_inl(OSDOVL_Mixer_CTRL2_reg));

		//frank@0220 check memc bg status and clear memc bg
		memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
		m_memc_bg_en = memc_mux_ctrl_reg.memc_out_bg_en;
		if(m_memc_bg_en){
			//enable UZU DTG double buffer.
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
			double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 1;
			double_buffer_ctrl_reg.uzudtg_dbuf_vsync_sel = 3;//using uzudtg vsync
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
			memc_mux_ctrl_reg.memc_out_bg_en = 0;
			IoReg_Write32(PPOVERLAY_MEMC_MUX_CTRL_reg, memc_mux_ctrl_reg.regValue);
			//set apply
			double_buffer_ctrl_reg.uzudtgreg_dbuf_set = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
		}

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

		main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
		main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
		main_background_color1_reg.m_bg_b = 0x3fff;
		main_background_color1_reg.m_bg_g = 0x3fff;
		main_background_color2_reg.m_bg_r = 0x3fff;
		IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
		IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);
		down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
		main_display_control_rsv_reg.m_force_bg = 1;
		IoReg_Write32(PPOVERLAY_Main_Display_Control_RSV_reg, main_display_control_rsv_reg.regValue);
		up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}
/*
		int x=0;
		VIDEO_RECT_T output_region;

		while(1){
			output_region.x= x;
			output_region.y = 0;
			output_region.w = 150;
			output_region.h = 2160;

			rtk_hal_vsc_SetOutputRegion(0, output_region);

			if(x<=3690){
				x+=20;
			}else
				x=0;
		}
*/
	}else{
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 1;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
		main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
		main_background_color1_reg.m_bg_b = 0;
		main_background_color1_reg.m_bg_g = 0;
		main_background_color2_reg.m_bg_r = 0;
		IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
		IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);


		//frank@0220 revert memc bg
		if(m_memc_bg_en){
			//disable UZU DTG double buffer.
			double_buffer_ctrl_reg.regValue =  IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
			double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
			memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
			memc_mux_ctrl_reg.memc_out_bg_en = m_memc_bg_en;
			m_memc_bg_en = 0;
			IoReg_Write32(PPOVERLAY_MEMC_MUX_CTRL_reg, memc_mux_ctrl_reg.regValue);
		}
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_pr_vsc_info("[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}
		rtd_pr_vsc_notice("recovery originalSize (%d.%d.%d.%d) \n", originalSize.x, originalSize.y, originalSize.w, originalSize.h);
		OutpuLocalDimmingPatMode = FALSE;

		if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
			//do nothing
		}else{
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, originalSize, 0, 0);
		}
		memset((void*)&originalSize, 0, sizeof(VIDEO_RECT_T));
		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		scaler_disp_smooth_variable_settingByDisp(0);

        //frank@01062016 add below flow to avoid demo mode exit will have garbage
        if(!Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY)){
            if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
            {
                mute_control(SLR_MAIN_DISPLAY, FALSE);/*disable forcebg*/
            }
        }
	}
	return 1;
}

unsigned char rtk_hal_vsc_dm_open(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	//rtd_pr_vsc_emerg( "pinyen======DM open\n");
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_open, It is OTT, so return true!");
		up(&DM_HDR_Semaphore);
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_open, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_OPEN);
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}


unsigned char rtk_hal_vsc_dm_close(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	rtd_maskl(H3DDMA_I3DDMA_MDP_CR_reg,~(_BIT3|_BIT4), 0);
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_close, It is OTT, so return true!");
		up(&DM_HDR_Semaphore);
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_close, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
	DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}

void Share_Memory_Set_DM_Connect_Flag(unsigned char enable)
{
	unsigned int *dm_connect_flag = NULL;
	unsigned int *pulTemp = NULL;
	unsigned int i = 0, ulItemCount = 0;

	dm_connect_flag = (unsigned int *)Scaler_GetShareMemVirAddr(SCALERIOC_DM_CONNECT_FLAG);
	*dm_connect_flag = enable;

	ulItemCount = sizeof(unsigned int) /  sizeof(UINT32);
	pulTemp = dm_connect_flag;
	for (i = 0; i < ulItemCount; i++)
		pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
}


unsigned char rtk_hal_vsc_dm_connect(unsigned char display, KADP_VSC_HDR_TYPE_T eHdrMode)
{
    if(display != SLR_MAIN_DISPLAY)
        return TRUE;//no sub case
    rtd_pr_vsc_notice("#####[%s(%d)] display:%d, eHdrMode=%d\n",__func__,__LINE__, display, eHdrMode);

    if(MAIN_VSC_HDRTYPE == eHdrMode)
        return TRUE;

    down(&DM_HDR_Semaphore);

    if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
    {
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
    #ifdef CONFIG_RTK_KDRV_DV
#ifdef CONFIG_DOLBY_IDK_1_6_1_1
    dolby_adapter_Check_DV_Mode();
#else
        Check_DV_Mode();//Check dolby mode again. Dolby 64 patch
#endif
    #endif
#endif
        rtd_pr_vsc_debug("rtk_hal_vsc_dm_connect, It is OTT, so so return true!");
        Share_Memory_Set_DM_Connect_Flag(true);
        up(&DM_HDR_Semaphore);

    if(get_OTT_HDR_mode() != HDR_DOLBY_COMPOSER)
    {
        switch(eHdrMode)
        {
            case KADP_VSC_HDR_DOLBY:
                 break;
            case KADP_VSC_HDR_HDR10:
            case KADP_VSC_HDR_VP9:
            case KADP_VSC_HDR_HLG:
            case KADP_VSC_HDR_PRIME:
            case KADP_VSC_HDR_HDR10_PLUS:
            case KADP_VSC_HDR_AUTO://old dm connect parameter. decide dolby or hdr
            set_OTT_HDR_mode(HDR_HDR10_VDEC);
                break;
            case KADP_VSC_HDR_DOLBY_LL:
                rtd_pr_vsc_err("rtk_hal_vsc_dm_connect, vdec mode hdrtype dolbyLL error");
                break;
            default:
                break;

        }
    }
        MAIN_VSC_HDRTYPE = eHdrMode;
        return TRUE;
    }
    else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
    {
        rtd_pr_vsc_debug("rtk_hal_vsc_dm_connect, It is not hdmi source, so can not call dm funciton!");
        up(&DM_HDR_Semaphore);
        return FALSE;
    }

    if(eHdrMode == KADP_VSC_HDR_AUTO)
    {//auto detetck hdrtype for demo board
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
        if(Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
        {
            DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE;
        }
        else
        {
#ifdef CONFIG_SUPPORT_DOLBY_VSIF
            /*HDR10 flow*/
        if(get_HDMI_Dolby_VSIF_mode() != DOLBY_HDMI_VSIF_DISABLE)
        {
            DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE; // DOLBY VSIF STD OR LL also need to set as Dolby_Hdmi_mode
        }
        else
        {
            DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;//in HDR10 HDMI, disable Dolby version flag @Crixus 20160313
        }
#else
            DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;//in HDR10 HDMI, disable Dolby version flag @Crixus 20160313
#endif
        }
#else
        DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
#endif
    }
    else
    {
        if((eHdrMode == KADP_VSC_HDR_DOLBY) || (eHdrMode == KADP_VSC_HDR_DOLBY_LL))
            DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE;
        else
            DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
    }
    MAIN_VSC_HDRTYPE = eHdrMode;
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CLOSE)//dm not open or not connect
	{
		rtd_pr_vsc_debug("hdmi hdr10 is not open\n");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CONNECT);

	if ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_HDMI))
	{
		rtd_pr_vsc_notice("sub hdmi hdr, so no enable hdr\n");
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
#endif



	/*hdmi dolby detect ok, set dolby_vision_flag=true*/
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
	{

		//set_HDMI_HDR_mode(HDR_DOLBY_HDMI);
	}
	else{
		/*HDR10 flow*/
		set_HDMI_HDR_mode(HDR_HDR10_HDMI);
	}


	if(!DbgSclrFlgTkr.hdmi_dolby_vision_flag)//HDMI HDR10 case. Wait OTT dolby run. should no wait
	{
#ifdef CONFIG_RTK_KDRV_DV
		unsigned char timeout = 10;
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
		while(dolby_adapter_check_ott_dolby_update_run() && timeout)
#else
		while(check_ott_dolby_update_run() && timeout)
#endif
		{
			msleep(1);
			timeout --;
		}
#endif
	}

#ifdef CONFIG_HDR_SDR_SEAMLESS
	if(get_HDMI_HDR_mode() == HDR_HDR10_HDMI && (!DbgSclrFlgTkr.hdmi_dolby_vision_flag))
	{
		unsigned char hdr_type = HDR_DM_MODE_NONE;//typedef enum PQ_HDR_TYPE
		switch(eHdrMode)
    	{
			case KADP_VSC_HDR_DOLBY:
			case KADP_VSC_HDR_DOLBY_LL:
				hdr_type = HDR_DM_DOLBY;
				break;
			case KADP_VSC_HDR_HDR10:
			case KADP_VSC_HDR_VP9:
			case KADP_VSC_HDR_PRIME:
				hdr_type = HDR_DM_HDR10;
				break;

			case KADP_VSC_HDR_HLG:
				hdr_type = HDR_DM_HLG;
				break;

			case KADP_VSC_HDR_HDR10_PLUS:
				hdr_type = HDR_DM_ST2094;
				break;

			case KADP_VSC_HDR_AUTO://old dm connect parameter. decide dolby or hdr
			default:
        		hdr_type = HDR_DM_HDR10;
				break;

    	}
		down(&HDR_Setting_Semaphore);
		if(get_hdr_semaless_active())
		{
			//set_target_i3ddma_color_format(decide_i3ddma_output_foramt(get_backup_hdmi_info()));
			trigger_seamless_flow(VSC_INPUTSRC_HDMI, TRUE, hdr_type);
			//recode current hdr mode for seamless change @Crixus 20170110
			set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());
		}
		up(&HDR_Setting_Semaphore);
	}
	else
	{
#ifdef CONFIG_RTK_KDRV_DV
		if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {
			reset_dolby_md_crc_error_cnt();
			HDR_DolbyVision_HDMI_Quick_Mute_Reset();
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_DV_HDMI_Init();
#else
			DV_HDMI_Init();
#endif
		}
#endif
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
	}
#else
	Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,255);

#ifdef CONFIG_RTK_KDRV_DV
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {
			reset_dolby_md_crc_error_cnt();
		HDR_DolbyVision_HDMI_Quick_Mute_Reset();
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_DV_HDMI_Init();
#else
		DV_HDMI_Init();
#endif
	}
#endif
	//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, true);
	DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
#endif
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		if (get_HDMI_Dolby_VSIF_mode() == DOLBY_HDMI_VSIF_STD
				|| get_HDMI_Dolby_VSIF_mode() == DOLBY_HDMI_h14B_VSIF)
			check_and_set_dolby_vision_detect();
#endif
		set_HDMI_HDR_mode(HDR_DOLBY_HDMI);
		dolby_adapter_release_hdmi_backlight_delay_queue();
	}
	up(&DM_HDR_Semaphore);
	return TRUE;
}


unsigned char rtk_hal_vsc_dm_disconnect(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	rtd_pr_vsc_notice("#####[%s(%d)] display:%d\n",__func__,__LINE__, display);
	down(&DM_HDR_Semaphore);
	//reset Dolby HDR
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) || get_HDMI_HDR_mode() == HDR_DOLBY_HDMI){
		//Scaler_Dolby_HDR_reset(); //Mark by will. Move to scaler
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_disconnect, reset Dolby HDR\n");
	}

	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_disconnect, It is OTT, so return true!");
		Share_Memory_Set_DM_Connect_Flag(false);
		up(&DM_HDR_Semaphore);
        if(get_OTT_HDR_mode() == HDR_HDR10_VDEC)
        {
            set_OTT_HDR_mode(HDR_MODE_DISABLE);
        }
		MAIN_VSC_HDRTYPE = KADP_VSC_HDR_MAXN;//reset hdr type
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_pr_vsc_debug("rtk_hal_vsc_dm_disconnect, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
	MAIN_VSC_HDRTYPE = KADP_VSC_HDR_MAXN;//reset hdr type
	//if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == true)
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
	{
		//DV_Stop(void)
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		Scaler_HDR_DolbyVision_Hdmi_SetDisplaytEnable(_DISABLE);
#endif
	}

#ifdef CONFIG_HDR_SDR_SEAMLESS
	if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) ==VSC_INPUTSRC_HDMI)
			Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
		//willychou add WOSQRTK-8674/WOSQRTK-9024,HDMI clock change -> _MODE_STATE_SEARCH -> stop rtk_check_signal and HDMI_set_detect_flag(TRUE)
		//-> no signal happen -> util HDMI_set_detect_flag(TRUE) again
		down(get_hdmi_detectsemaphore());
		if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
		up(get_hdmi_detectsemaphore());
            scaler_vsc_set_gamemode_go_datafrc_mode(_DISABLE);
	}

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_OPEN);
#endif

	if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
	{
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
		dolby_adapter_release_hdmi_backlight_delay_queue();
	}
	else
	{
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
		dolby_adapter_release_hdmi_backlight_delay_queue();
		down(&HDR_Setting_Semaphore);
		if(get_hdr_semaless_active())
		{
			set_target_i3ddma_color_format(decide_i3ddma_output_foramt(get_backup_hdmi_info()));
			trigger_seamless_flow(VSC_INPUTSRC_HDMI, FALSE, HDR_DM_MODE_NONE);
			//recode current hdr mode for seamless change @Crixus 20170110
			set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());
		}
		up(&HDR_Setting_Semaphore);
	}


#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	Scaler_HDR_DolbyVision_Hdmi_SetDetectEnable(_ENABLE, _DISABLE);
#endif


#else
	if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_HDMI)
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == KADP_VSC_INPUTSRC_HDMI)
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

	//willychou add WOSQRTK-8674/WOSQRTK-9024,HDMI clock change -> _MODE_STATE_SEARCH -> stop rtk_check_signal and HDMI_set_detect_flag(TRUE)
	//-> no signal happen -> util HDMI_set_detect_flag(TRUE) again
	down(get_hdmi_detectsemaphore());
	if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
	up(get_hdmi_detectsemaphore());

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
#endif
	drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_HDMI, FALSE, FALSE);
    drvif_mode_disableonlinemeasure(SLR_MAIN_DISPLAY);//Disable online measure

    Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, false);
	DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 255);

#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	Scaler_HDR_DolbyVision_Hdmi_SetDetectEnable(_ENABLE, _DISABLE);
#endif
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}

void scaler_dolby_hdmi_smooth_toggle(UINT8 isSDRtoEDR)/*1==SDR->EDR   0==EDR->SDR*/
{
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(isSDRtoEDR)
	{
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CONNECT);
	}
	else
	{
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
	}
#endif

	DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
	DbgSclrFlgTkr.Main_Run_Scaler_flag =TRUE;
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
}

extern void I3DDMA_Set_Metadata_Vgip(void);

#ifdef CONFIG_FORCE_RUN_I3DDMA
unsigned char scaler_force_run_idma_impl(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)
{
	if(DbgSclrFlgTkr.Main_Scaler_Stop_flag)
		return FALSE;

	set_force_change_vo_flag(0, TRUE);//force update vo info

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  255);
	else
#endif
	{
		Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  0xfa);
	}

	down(&VSC_Semaphore);
	drvif_mode_resetmode(display);
	drvif_I3DDMA_Init();

	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG))
	{
		rtd_pr_vsc_emerg("vo source,return\n");
		up(&VSC_Semaphore);
		return TRUE;
	}
#ifdef CONFIG_SUPPORT_SRC_ADC
	else if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
	{
		down(get_adc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_ADC_Dispinfo());//now for test, only for ypp timing info
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_adc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_err("adc vsc_timinginfo_check error\n");
			return FALSE;
		}
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 2000)//mean 4095 no support
		{
			up(get_adc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_err("scaler_force_run_idma adc vsc_timinginfo_check no support error\n");
			return FALSE;
		}
		ADC_set_detect_flag(FALSE);
		up(get_adc_detectsemaphore());

		// Scart RGB
		if(get_ADC_Input_Source() == _SRC_SCART_RGB)
		{
			if(!drivf_i3ddma_config(display, VGIP_SRC_ATV))
			{
				up(&VSC_Semaphore);
				rtd_pr_vsc_emerg("adc drivf_i3ddma_config error\n");
				return FALSE;
			}
		}
		// YPP and VGA
		else
		{
			if(!drivf_i3ddma_config(display, VGIP_SRC_ADC))
			{
				up(&VSC_Semaphore);
				rtd_pr_vsc_emerg("adc drivf_i3ddma_config error\n");
				return FALSE;
			}
			fw_scaler_set_sample(display, _ENABLE);
		}

		if(!check_verify_mode_enable()){
			rtd_pr_vsc_notice("#####[%s(%d)] call ADC_VSC_Setting\n",__func__,__LINE__);
			ADC_VSC_Setting(get_ADC_Input_Source());//if ADC verify mode no need this
		}

		fw_scaler_adc_nolock_wdg_ctrl(display, FALSE);//Disable adc_nolock_wdg
		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
	}
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
	else if(inputSrctype == VSC_INPUTSRC_AVD)
	{
		down(get_vdc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_AVD_ScalerDispinfo());
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_vdc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("avd vsc_timinginfo_check error\n");
			return FALSE;
		}
		up(get_vdc_detectsemaphore());
		if(!drivf_i3ddma_config(display, VGIP_SRC_ATV))
		{
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("avd drivf_i3ddma_config error\n");
			return FALSE;
		}
		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
	}
	else if(inputSrctype == VSC_INPUTSRC_HDMI)
	{

#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
		HDMI_TIMING_T vfehdmitiminginfo;
		down(get_hdmi_detectsemaphore());
		if(0 == drvif_Hdmi_GetRawTimingInfo(&vfehdmitiminginfo))
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("vfe_hdmi_drv_get_display_timing_info error\n");
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_With_NEW_HDMI_TIMING_INFO(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
#else
		vfe_hdmi_timing_info_t vfehdmitiminginfo;
		down(get_hdmi_detectsemaphore());
		if(0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, display))
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("vfe_hdmi_drv_get_display_timing_info error\n");
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_WithVFEHMDI(display, vfehdmitiminginfo);
#endif
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
		Scaler_HDR10_Hdmi_Set_Input_ACT_WID_info(vfehdmitiminginfo.h_act_len);
#else
		Scaler_HDR10_Hdmi_Set_Input_ACT_WID_info(vfehdmitiminginfo.active.w);
#endif
#endif

		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("hdmi vsc_timinginfo_check error\n");
			return FALSE;
		}

		HDMI_set_detect_flag(FALSE);
		up(get_hdmi_detectsemaphore());
		if((drvif_Hdmi_GetRawColorSpace() == COLOR_YUV420) && (drvif_Hdmi_GetFrlMode() == 0))
		{//hdmi2.0 and color yuv420
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
			{
				drvif_Hdmi_EnableBypassYUV420Engine(1);//bypass hmdi yuv420 to yuv444
			}
			else
			{
				drvif_Hdmi_EnableBypassYUV420Engine(0);//orignal hmdi yuv420 to yuv444
			}
		}
		if(!drivf_i3ddma_config(display, VGIP_SRC_TMDS))
		{
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("hdmi drivf_i3ddma_config error\n");
			return FALSE;
		}

		#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
		{
			Scaler_HDR_DolbyVision_Hdmi_ResetDisplay();
		}
		#endif

		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
		save_online_enable_time(SLR_MAIN_DISPLAY);//save online measure satrt time for check_online_measure_result_unstable check
	}
	up(&VSC_Semaphore);
#ifdef _PRINT_AVD_COST_TIME
	rtd_pr_vsc_info("_PRINT_AVD_COST_TIME:  %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif
	return TRUE;
}
unsigned char (*scaler_force_run_idma)(unsigned char, VSC_INPUT_TYPE_T) = scaler_force_run_idma_impl;//replace function pointer for UT function

unsigned char scaler_nn_force_run_idma(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)
{
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
		HDMI_TIMING_T vfehdmitiminginfo;
#else
		vfe_hdmi_timing_info_t vfehdmitiminginfo;
#endif
	drvif_I3DDMA_Init();


	if(inputSrctype == VSC_INPUTSRC_HDMI)
	{
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
		down(get_hdmi_detectsemaphore());
		if(0 == drvif_Hdmi_GetRawTimingInfo(&vfehdmitiminginfo))
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("vfe_hdmi_drv_get_display_timing_info error\n");
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_With_NEW_HDMI_TIMING_INFO(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
#else
		down(get_hdmi_detectsemaphore());
		if(0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, display))
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("vfe_hdmi_drv_get_display_timing_info error\n");
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_WithVFEHMDI(display, vfehdmitiminginfo);
#endif

		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_pr_vsc_emerg("scaler_nn_force_run_idma check timing info error\n");
			return FALSE;
		}

		set_nn_force_i3ddma_enable(TRUE);
		HDMI_set_detect_flag(FALSE);
		up(get_hdmi_detectsemaphore());
		//this function will make onms error, so mark it
		//drvif_Hdmi_EnableBypassYUV420Engine(0);

		if(!drivf_i3ddma_config(display, VGIP_SRC_TMDS))
		{
			up(&VSC_Semaphore);
			set_nn_force_i3ddma_enable(FALSE);
			rtd_pr_vsc_emerg("scaler_nn_force_run_idma config i3ddma error\n");
			return FALSE;
		}
	}
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG))
		{
			if(vsc_timinginfo_check() == FALSE)
			{
				rtd_pr_vsc_emerg("scaler_nn_force_run_idma check timing info error %d\n", __LINE__);
				return FALSE;
			}

			set_nn_force_i3ddma_enable(TRUE);

			if(!drivf_i3ddma_config(display, VGIP_SRC_VODMA1))
			{
				set_nn_force_i3ddma_enable(FALSE);
				rtd_pr_vsc_emerg("scaler_nn_force_run_idma config i3ddma error %d\n", __LINE__);
				return FALSE;
			}
		}

	return TRUE;
}

unsigned char scaler_atv_force_run_idma(void)
{
	if (ATV_forcei3ddma == 1)
		;	//	ATV will force i3ddma scaler flow
#ifndef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
	else if(DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.Main_Scaler_Stop_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag)
		return FALSE;
#endif
	set_force_change_vo_flag(0, TRUE);//force update vo info
	Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  0xfa);
	down(&VSC_Semaphore);
	drvif_mode_resetmode(SLR_MAIN_DISPLAY);
	drvif_I3DDMA_Init();

	down(get_vdc_detectsemaphore());
	Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_AVD_ScalerDispinfo());
	if(vsc_timinginfo_check() == FALSE)
	{
		up(get_vdc_detectsemaphore());
		up(&VSC_Semaphore);
		rtd_pr_vsc_emerg("avd vsc_timinginfo_check error\n");
		return FALSE;
	}
	up(get_vdc_detectsemaphore());
	if(!drivf_i3ddma_config(SLR_MAIN_DISPLAY, VGIP_SRC_ATV))
	{
		up(&VSC_Semaphore);
		rtd_pr_vsc_emerg("atv drivf_i3ddma_config error\n");
		return FALSE;
	}
	drvif_mode_enable_dma_onlinemeasure();//Enable online measure

	up(&VSC_Semaphore);

	return TRUE;
}
#endif


#ifdef CONFIG_I2RND_ENABLE
void rtk_hal_vsc_i2rnd_enable(unsigned char enable){
	return;
	if(enable == _ENABLE){
		//Eric@20170904 move i2rnd initial to vsc initial
		if(vsc_i2rnd_initial_done == _DISABLE){
			//Eric@0809 Dual VO i2rnd case use this flag to default run i2rnd flow fill s0 cmd table, but not enable i2rnd timing.
			//Scaler_I2rnd_set_force_cmd(_ENABLE);
			//Scaler_I2rnd_set_force_cmd(_DISABLE);
			Scaler_I2rnd_set_enable(_ENABLE);
			i2rnd_default_register_setting();
		}
		else{
			//Scaler_I2rnd_set_force_cmd(_ENABLE);
			Scaler_I2rnd_set_enable(_ENABLE);
			i2rnd_default_register_setting();
		}
	}
	else{
		Scaler_I2rnd_set_enable(_DISABLE);//uninitial i2rnd  to disable I2rnd flag @Crixus 20160801
		Scaler_I2rnd_set_force_cmd(_DISABLE);
	}
}
#endif

#ifdef CONFIG_PST_ENABLE
extern unsigned char Scaler_sub_md_pst_get_enable(void);
void rtk_hal_vsc_pst_enable(unsigned char enable){
	//Eric@20170904 move pst initial to vsc initial
	if(enable == _ENABLE){
		//enable main pst
		Scaler_main_md_pst_set_enable(_ENABLE);
		//enable sub pst
		Scaler_sub_md_pst_set_enable(_ENABLE);
	}
	else{
		//disable main pst
		Scaler_main_md_pst_set_enable(_DISABLE);
		//disable sub pst
		Scaler_sub_md_pst_set_enable(_DISABLE);
	}
}
#endif


#ifdef CONFIG_I2RND_B05_ENABLE
unsigned char rtk_hal_vsc_i2rnd_b05_enable(unsigned char enable)
{
	if(enable == _ENABLE) {
	//               rtd_pr_vsc_info("in_b05_initial\n");
		drvif_scaler_i2rnd_b05_initial();
		Scaler_I2rnd_b05_set_enable(_ENABLE);
	//                drvif_scaler_i2rnd_b05_vodma_setting(SLR_MAIN_DISPLAY);
	} else {
		drvif_scaler_i2rnd_b05_uninitial();
		Scaler_I2rnd_b05_set_enable(_DISABLE);//uninitial i2rnd_b05  to disable I2rnd flag
		//rtd_pr_vsc_info("in_b05_uninitial\n");
	}
	return TRUE;
}
#endif


unsigned char rtk_hal_vsc_SetDelayBuffer(VIDEO_WID_T wId, UINT8 buffer)
{
#ifdef CONFIG_REALTEK_2K_MODEL_ENABLED
	if(wId == VIDEO_WID_0){
		if(buffer >=3 && buffer <=7)
		{
			Check_smooth_toggle_update_flag(wId);
			drv_memory_Set_multibuffer_number(buffer);
			drv_memory_Set_multibuffer_flag(_ENABLE);

		}
		else
		{
			drv_memory_Set_multibuffer_flag(_DISABLE);
			drv_memory_Set_multibuffer_number(0);
		}
		drv_memory_send_multibuffer_number_to_smoothtoogh();
		rtd_pr_vsc_emerg("function=%s,buffernub=%d\n",__FUNCTION__,buffer);
	}
#endif
	return TRUE;
}


SMOOTH_TOGGLE_INFO temp_info_main;
void scaler_save_main_info(void)
{
	temp_info_main.IMD_SMOOTH_H_ACT_WID_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE);
	temp_info_main.IMD_SMOOTH_H_ACT_STA_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_V_ACT_LEN_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE);
	temp_info_main.IMD_SMOOTH_V_ACT_STA_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_H_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID);
	temp_info_main.IMD_SMOOTH_H_ACT_STA= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA);
	temp_info_main.IMD_SMOOTH_V_ACT_LEN= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN);
	temp_info_main.IMD_SMOOTH_V_ACT_STA= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA);
	temp_info_main.IMD_SMOOTH_FRAMESYNC = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC);
	temp_info_main.IMD_SMOOTH_DI_WID= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID);

#ifdef CONFIG_SDNR_CROP
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN);
#endif
	temp_info_main.IMD_SMOOTH_CapWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID);
	temp_info_main.IMD_SMOOTH_CapLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN);
	temp_info_main.IMD_SMOOTH_MEM_ACT_HSTA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA);
	temp_info_main.IMD_SMOOTH_MEM_ACT_VSTA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA);
	temp_info_main.IMD_SMOOTH_MEM_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN);
	temp_info_main.IMD_SMOOTH_MEM_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID);
	temp_info_main.IMD_SMOOTH_DispLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN);
	temp_info_main.IMD_SMOOTH_DispWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID);
	temp_info_main.IMD_SMOOTH_DISP_RTNR =Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR);
	temp_info_main.IMD_SMOOTH_DISP_10BIT = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT);
	temp_info_main.IMD_SMOOTH_DISP_THRIP = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP);
	temp_info_main.IMD_SMOOTH_DISP_MA3A = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A);
	temp_info_main.IMD_SMOOTH_DISP_422CAP= Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP);
	temp_info_main.IMD_SMOOTH_DISP_422= Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422);
}
void scaler_update_struct_info(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY) {
		rtd_pr_vsc_emerg("update main scaler struct info\n");
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE, temp_info_main.IMD_SMOOTH_H_ACT_WID_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_H_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE, temp_info_main.IMD_SMOOTH_V_ACT_LEN_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_V_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID, temp_info_main.IMD_SMOOTH_H_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA, temp_info_main.IMD_SMOOTH_H_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN, temp_info_main.IMD_SMOOTH_V_ACT_LEN);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA, temp_info_main.IMD_SMOOTH_V_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC, temp_info_main.IMD_SMOOTH_FRAMESYNC);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID, temp_info_main.IMD_SMOOTH_DI_WID);

#ifdef CONFIG_SDNR_CROP
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE, temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE, temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA, temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA, temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID, temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN, temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN);
#endif
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID, temp_info_main.IMD_SMOOTH_CapWid);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN, temp_info_main.IMD_SMOOTH_CapLen);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA, temp_info_main.IMD_SMOOTH_MEM_ACT_HSTA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA, temp_info_main.IMD_SMOOTH_MEM_ACT_VSTA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN, temp_info_main.IMD_SMOOTH_MEM_ACT_LEN );
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID, temp_info_main.IMD_SMOOTH_MEM_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN, temp_info_main.IMD_SMOOTH_DispLen);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID, temp_info_main.IMD_SMOOTH_DispWid);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, temp_info_main.IMD_SMOOTH_DISP_RTNR);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT, temp_info_main.IMD_SMOOTH_DISP_10BIT);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP, temp_info_main.IMD_SMOOTH_DISP_THRIP);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A, temp_info_main.IMD_SMOOTH_DISP_MA3A);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP, temp_info_main.IMD_SMOOTH_DISP_422CAP);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422, temp_info_main.IMD_SMOOTH_DISP_422);
	} else {
		rtd_pr_vsc_emerg("update sub scaler struct info\n");
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_WID,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_FRAMESYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DI_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID));

#ifdef CONFIG_SDNR_CROP
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN));
#endif
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_LEN,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_HSTA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_VSTA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_MA3A, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	}
}

/*//no used
unsigned int VSC_PM_REGISTER_DATA[][2]
=
{
	//VGIP
	{SUB_VGIP_VGIP_CHN2_DELAY_reg, 0},
	{SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg, 0},
	{SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg, 0},
	{SUB_VGIP_VGIP_CHN2_CTRL_reg, 0},

	{VGIP_VGIP_CHN1_MISC_reg, 0},
	{VGIP_Data_Path_Select_reg, 0},
	{VGIP_VGIP_CHN1_DELAY_reg, 0},
	{VGIP_VGIP_CHN1_ACT_HSTA_Width_reg, 0},
	{VGIP_VGIP_CHN1_ACT_VSTA_Length_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL1_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL2_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL3_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL4_reg, 0},
	{VGIP_FRAMEPACKING_CTRL1_reg, 0},
	{VGIP_FRAMEPACKING_CTRL2_reg, 0},
	{VGIP_VGIP_CHN1_CTRL_reg, 0},
	{VGIP_INT_CTL_reg, 0},

	//RGB2YUV
	{RGB2YUV_Tab1_M11_M12_reg, 0},
	{RGB2YUV_Tab1_M13_M21_reg, 0},
	{RGB2YUV_Tab1_M22_M23_reg, 0},
	{RGB2YUV_Tab1_M31_M32_reg, 0},
	{RGB2YUV_Tab1_M33_YGain_reg,0},
	{RGB2YUV_Tab1_Yo_reg, 0},
	{RGB2YUV_ICH1_422to444_CTRL_reg, 0},
	{RGB2YUV_ICH1_RGB2YUV_CTRL_reg, 0},

	{RGB2YUV_Tab2_M11_M12_reg, 0},
	{RGB2YUV_Tab2_M13_M21_reg, 0},
	{RGB2YUV_Tab2_M22_M23_reg, 0},
	{RGB2YUV_Tab2_M31_M32_reg, 0},
	{RGB2YUV_Tab2_M33_Y_Gain_reg, 0},
	{RGB2YUV_Tab2_Yo_reg, 0},
	{RGB2YUV_ICH2_422to444_CTRL_reg, 0},
	{RGB2YUV_ICH2_RGB2YUV_CTRL_reg, 0},
	//UZD
	{SCALEDOWN_ICH1_sdnr_444to422_CTRL_reg, 0},
	{SCALEDOWN_ICH1_IBUFF_CTRLI_BUFF_CTRL_reg, 0},
	{SCALEDOWN_ICH1_UZD_FIR_Coef_Tab1_C0_reg, 0},
	{SCALEDOWN_ICH1_UZD_FIR_Coef_Tab2_C0_reg, 0},
	{SCALEDOWN_ICH1_hsd_3d_boundary_reg, 0},
	{SCALEDOWN_ICH1_UZD_Scale_Hor_Factor_reg, 0},
	{SCALEDOWN_ICH1_UZD_Scale_Ver_Factor_reg, 0},
	{SCALEDOWN_ICH1_UZD_Initial_Value_reg, 0},
	{SCALEDOWN_ICH1_UZD_Hor_Segment_reg, 0},
	{SCALEDOWN_ICH1_UZD_Hor_Delta1_reg, 0},
	{SCALEDOWN_ICH1_UZD_Ctrl0_reg, 0},
	{SCALEDOWN_ICH1_UZD_Ctrl1_reg, 0},

	{HSD_DITHER_DI_UZD_FIR_Coef_Tab1_C0_reg, 0},
	{HSD_DITHER_DI_HSD_Scale_Hor_Factor_reg, 0},
	{HSD_DITHER_DI_HSD_Initial_Value_reg, 0},
	{HSD_DITHER_DI_HSD_Hor_Delta1_reg, 0},
	{HSD_DITHER_DI_HSD_Hor_Segment_reg, 0},
	{HSD_DITHER_DI_HSD_Ctrl0_reg, 0},

	{SCALEDOWN_ICH2_UZD_H_Output_Size_reg, 0},
	{SCALEDOWN_ICH2_UZD_Scale_Hor_Factor_reg, 0},
	{SCALEDOWN_ICH2_UZD_Scale_Ver_Factor_reg, 0},
	{SCALEDOWN_ICH2_UZD_Initial_Value_reg, 0},
	{SCALEDOWN_ICH2_UZD_Ctrl0_reg, 0},
	{SCALEDOWN_ICH2_UZD_Ctrl1_reg, 0},
	//DI
	//{EXSRAM_CTRL_reg, 0},
	{DI_Color_Recovery_Option_reg, 0},
	{DI_DI_DMA_Multi_Req_Num_reg, 0},
	{DI_IM_DI_WEAVE_WINDOW_CONTROL_reg, 0},
	{DI_db_reg_ctl_reg, 0},
	{DI_IM_DI_DMA_reg, 0},
	{DI_DDR_RDATDMA_WTLENNUM_reg, 0},
	{DI_DDR_RINFDMA_WTLENNUM_reg, 0},
	{DI_DDR_WDATDMA_WTLENNUM_reg, 0},
	{DI_DDR_DATDMA_RM_reg, 0},
	{DI_DDR_WINFDMA_WTLENNUM_reg, 0},
	{DI_DDR_INFDMA_RM_reg, 0},
	{DI_DI_DATMemoryStartAdd1_reg, 0},
	{DI_DI_DATMemoryStartAdd2_reg, 0},
	{DI_DI_DATMemoryStartAdd3_reg, 0},
	{DI_DI_DATMemoryStartAdd4_reg, 0},
	{DI_DI_INFMemoryStartAdd1_reg, 0},
	{DI_DI_INFMemoryStartAdd2_reg, 0},
	{DI_DI_DATMemoryStartAdd1_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd2_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd3_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd4_3D_reg, 0},
	{DI_DI_INFMemoryStartAdd1_3D_reg, 0},
	{DI_DI_INFMemoryStartAdd2_3D_reg, 0},
	{DI_IM_DI_ACTIVE_WINDOW_CONTROL_reg, 0},
	{DI_IM_DI_BTR_CONTROL_reg, 0},
	{DI_IM_DI_MPEG_SEQUENCE_APP_reg, 0},
	{DI_IM_DI_FRAMESOBEL_STATISTIC_reg, 0},
	{DI_IM_DI_CONTROL_reg, 0},
	//MTG:
	{PPOVERLAY_MAIN_DEN_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_DEN_V_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Background_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Background_V_Start_End_reg, 0},
	{PPOVERLAY_Main_Background_Color1_reg, 0},
	{PPOVERLAY_Main_Background_Color2_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color1_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color2_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color3_reg, 0},
	{PPOVERLAY_MAIN_Active_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Active_V_Start_End_reg, 0},

	{PPOVERLAY_SUB_DEN_H_Start_Width_reg, 0},
	{PPOVERLAY_SUB_DEN_V_Start_Length_reg, 0},
	{PPOVERLAY_SUB_Background_H_Start_End_reg, 0},
	{PPOVERLAY_SUB_Background_V_Start_End_reg, 0},
	{PPOVERLAY_SUB_Background_Color1_reg, 0},
	{PPOVERLAY_SUB_Background_Color2_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color1_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color2_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color3_reg, 0},
	{PPOVERLAY_SUB_Active_H_Start_End_reg, 0},
	{PPOVERLAY_SUB_Active_V_Start_End_reg, 0},

	//UZU
	{SCALEUP_DM_UZUMAIN_H_PARTIAL_DROP_reg, 0},
	{SCALEUP_DM_UZUMAIN_V_PARTIAL_DROP_reg, 0},
	//{SCALEUP_DM_UZUMAIN_Adapt12tap_reg, 0},
	{SCALEUP_DM_UZU_8tap_deringv_reg, 0},
	{SCALEUP_DM_UZU_V8CTRL_reg, 0},
	//{SCALEUP_DM_UZU_AdaptV8CTRL_reg, 0},
	{SCALEUP_DM_UZU_Scale_Hor_Factor_reg, 0},
	{SCALEUP_DM_UZU_Scale_Ver_Factor_reg, 0},
	{SCALEUP_DM_UZU_Hor_Delta1_reg, 0},
	{SCALEUP_DM_UZU_Hor_Delta2_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment1_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment2_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment3_reg, 0},
	{SCALEUP_DM_UZU_Initial_Value_reg, 0},
	{SCALEUP_DM_UZU_Input_Size_reg, 0},
	{SCALEUP_D_UZU_Globle_Ctrl_reg, 0},
	{SCALEUP_DM_UZU_Ctrl_reg, 0},

	{SCALEUP_DS_UZU_Scale_Ver_Factor_reg, 0},
	{SCALEUP_DS_UZU_Scale_Hor_Factor_reg, 0},
	{SCALEUP_DS_UZU_Initial_Value_reg, 0},
	{SCALEUP_DS_UZU_Input_Size_reg, 0},
	{SCALEUP_DS_UZU_Ctrl_reg, 0},
	//Data FRC:m cap
	{MDOMAIN_CAP_Main_SDNR_cxxto64_reg, 0},
	{MDOMAIN_CAP_DDR_In1WTLVL_Num_reg, 0},
	{MDOMAIN_CAP_DDR_In1WrLen_Rem_reg, 0},
	{MDOMAIN_CAP_DDR_In1Addr_reg, 0},
	{MDOMAIN_CAP_DDR_In1LineStep_reg, 0},
	{MDOMAIN_CAP_DDR_In1BlkStep_reg, 0},
	{MDOMAIN_CAP_DDR_In1_2ndAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In1_3rdAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In1LineNum_reg, 0},
	{MDOMAIN_CAP_DDR_In1Ctrl_reg, 0},
	{MDOMAIN_CAP_CapMain_BoundaryAddr1_reg, 0},
	{MDOMAIN_CAP_CapMain_BoundaryAddr2_reg, 0},
	{MDOMAIN_CAP_CapMain_SBS_VSD_CAP_CTRL_reg, 0},
	{MDOMAIN_CAP_CapMain_SBS_VSD_CAP_OFFSET_reg, 0},
	{MDOMAIN_CAP_Capture1_byte_swap_reg, 0},
	{MDOMAIN_CAP_Cap_In1_enable_reg, 0},

	{MDOMAIN_CAP_Sub_SDNR_cxxto64_reg, 0},
	{MDOMAIN_CAP_DDR_In2WTLVL_reg, 0},
	{MDOMAIN_CAP_DDR_In2WrLen_Rem_reg, 0},
	{MDOMAIN_CAP_DDR_In2Addr_reg, 0},
	{MDOMAIN_CAP_DDR_In2LineStep_reg, 0},
	{MDOMAIN_CAP_DDR_In2BlkStep_reg, 0},
	{MDOMAIN_CAP_DDR_In2_2ndAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In2LineNum_reg, 0},
	{MDOMAIN_CAP_DDR_In2Ctrl_reg, 0},
	{MDOMAIN_CAP_CapSub_BoundaryAddr1_reg, 0},
	{MDOMAIN_CAP_CapSub_BoundaryAddr2_reg, 0},
	{MDOMAIN_CAP_Cap_In2_enable_reg, 0},
	//m disp
	{MDOMAIN_DISP_DDR_MainPreVStart_reg, 0},
	{MDOMAIN_DISP_DDR_MainNumWTL_reg, 0},
	{MDOMAIN_DISP_DDR_MainRdNumLenRem_reg, 0},
	{MDOMAIN_DISP_DDR_MainAddr_reg, 0},
	{MDOMAIN_DISP_DDR_MainAddrDropBits_reg, 0},
	{MDOMAIN_DISP_DDR_MainLineStep_reg, 0},
	{MDOMAIN_DISP_DDR_MainBlkStep_reg, 0},
	{MDOMAIN_DISP_DDR_MainLineNum_reg, 0},
	{MDOMAIN_DISP_DDR_MainCtrl_reg, 0},
	{MDOMAIN_DISP_DDR_Main2ndAddr_reg, 0},
	{MDOMAIN_DISP_DDR_Main3rdAddr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_1ST_Addr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_2ND_Addr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_3RD_Addr_reg, 0},
	{MDOMAIN_DISP_Display_byte_channel_swap_reg, 0},
	{MDOMAIN_DISP_Disp_main_enable_reg, 0},

	{MDOMAIN_DISP_DDR_SubPreVStart_reg, 0},
	{MDOMAIN_DISP_DDR_SubPixNumWTL_reg, 0},
	{MDOMAIN_DISP_DDR_SubRdNumLenRem_reg, 0},
	{MDOMAIN_DISP_DDR_SubAddr_reg, 0},
	{MDOMAIN_DISP_DDR_SubAddrDropBits_reg, 0},
	{MDOMAIN_DISP_DDR_SubLineStep_reg, 0},
	{MDOMAIN_DISP_DDR_SubBlkStep_reg, 0},
	{MDOMAIN_DISP_DDR_SubLineNum_reg, 0},
	{MDOMAIN_DISP_DDR_SubCtrl_reg, 0},
	{MDOMAIN_DISP_DDR_Sub2ndAddr_reg, 0},
	{MDOMAIN_DISP_Disp_sub_enable_reg, 0},

};
*/

#ifdef CONFIG_PM
static int vsc_suspend (struct device *p_dev)
{
#if 0//No need vsc suspend
	int i,size;

	/*rtd_pr_vsc_debug("func=%s line=%d \n", __FUNCTION__, __LINE__);*/

	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		VSC_PM_REGISTER_DATA[i][1] = rtd_inl(VSC_PM_REGISTER_DATA[i][0]);
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
//Eric@20171127 Disable i2rnd & pst when DC off
#ifdef CONFIG_I2RND_ENABLE
	//Initial Main path & Sub path stage
	vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
	vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
	vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_DISABLE;
	rtd_pr_vsc_emerg("[%s]I2RND close\n", __FUNCTION__);
#endif
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
	scaler_pst_suspend();
#endif
	return 0;
}

static int vsc_resume (struct device *p_dev)
{
#if 0//No need vsc resume
	int i, size;
	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		IoReg_Write32(VSC_PM_REGISTER_DATA[i][0],VSC_PM_REGISTER_DATA[i][1]);
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
#ifdef CONFIG_I2RND_ENABLE
	//Eric@20171127I2rnd & pst init
	drvif_scaler_i2rnd_initial();
	drvif_scaler_pst_initial(_MAIN_MD);
	drvif_scaler_pst_initial(_SUB_MD);
#endif
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
	scaler_pst_resume();
#endif
	reset_any_srcrect(&main_dispwin_for_only_xy);
	reset_any_srcrect(&main_dispwin_pre);
#ifdef CONFIG_DUAL_CHANNEL
	reset_any_srcrect(&sub_dispwin_pre);
#endif
	//set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#ifdef CONFIG_DUAL_CHANNEL
	//set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#endif
	//update game_mode_cmd_pre and st_game_mode_cmd_pre flag
	game_mode_cmd_pre = game_mode_cmd_check;
	st_game_mode_cmd_pre = smooth_toggle_game_mode_check_cnt;
	DbgSclrFlgTkr.adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
#ifndef UT_flag
	vpq_ld_running_flag = FALSE;
#endif // #ifndef UT_flag
	DbgSclrFlgTkr.vpq_ld_first_boot = TRUE;
	sub_mode_type = KADP_VSC_SUB_MODE_PIP;//reset sub mode.
	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();
	data_access_enable = 0;//avoid access the register
	sub_data_access_enable = 0;//avoid access the register
	return 0;
}

#ifdef CONFIG_HIBERNATION
static int vsc_resume_std (struct device *p_dev)
{
#if 0//No need vsc resume
	int i, size;
	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		IoReg_Write32(VSC_PM_REGISTER_DATA[i][0],VSC_PM_REGISTER_DATA[i][1]);
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_pr_vsc_debug("func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
	ResetShareMem();//reset share memory to 0
	Set_send_panel_para_flag(TRUE);//Need to send panel parameter
	//set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#ifdef CONFIG_DUAL_CHANNEL
	//set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#endif
	game_mode_cmd_pre = game_mode_cmd_check;	//Update game_mode_cmd_pre to avoid fll task break.
	st_game_mode_cmd_pre = smooth_toggle_game_mode_check_cnt;
	DbgSclrFlgTkr.adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
#ifndef UT_flag
	vpq_ld_running_flag = FALSE;
#endif // #ifndef UT_flag
	DbgSclrFlgTkr.vpq_ld_first_boot = TRUE;
	sub_mode_type = KADP_VSC_SUB_MODE_PIP;//reset sub mode.
	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();
	data_access_enable = 0;//avoid access the register
	sub_data_access_enable = 0;//avoid access the register
	return 0;
}
#endif
#endif

#ifdef ENABLE_SMOOTHTOGGLE_TEST
static bool smt_tsk_running_flag = FALSE;//Record vsc_scaler_tsk status. True: Task is running
static struct task_struct *p_smt_tsk = NULL;
typedef enum _SMT_TEST_CASE{
	NULL_TEST_CASE=0,
	OUTPUT_4_3_CASE,
	OUTPUT_16_9_CASE,
	OUTPUT_SMALL_SCREEN_CASE,
	OUTPUT_ORIGIN_CASE,
	INPUT_X_W_CASE,
	INPUT_Y_H_CASE,
	INPUT_X_Y_CASE,
	INPUT_W_H_CASE,
	OUTPUT_X_W_CASE,
	OUTPUT_Y_H_CASE,
	OUTPUT_X_Y_CASE,
	OUTPUT_W_H_CASE,
	INPUT_OUTPUT_X_Y_W_H_CASE,
}SMT_TEST_CASE;

typedef enum _SMT_TEST_TYPE{
	NULL_TEST_TYPE=0,
	RATIO_TEST_TYPE,
	PST_TEST_TYPE,
	TIMING_CHANGE_TEST_TYPE,
}SMT_TEST_TYPE;

SMT_TEST_CASE smt_test_case[MAX_DISP_CHANNEL_NUM];
void set_smoothtoggle_test_case(unsigned char display,SMT_TEST_CASE test_case)
{
#ifndef CONFIG_DUAL_CHANNEL
	if (SLR_MAIN_DISPLAY!=display) {
		return;
	}
#else
	if (SLR_SUB_DISPLAY<display) {
		return;
	}
#endif
	smt_test_case[display]=test_case;
}

SMT_TEST_CASE get_smoothtoggle_test_case(unsigned char display)
{
#ifndef CONFIG_DUAL_CHANNEL
	if (SLR_MAIN_DISPLAY!=display) {
		return NULL_TEST_CASE;
	}
#else
	if (SLR_SUB_DISPLAY<display) {
		return NULL_TEST_CASE;
	}
#endif
	return smt_test_case[display];
}

SMT_TEST_TYPE smt_test_type[MAX_DISP_CHANNEL_NUM];
void set_smoothtoggle_test_type(unsigned char display,SMT_TEST_TYPE test_case)
{
#ifndef CONFIG_DUAL_CHANNEL
	if (SLR_MAIN_DISPLAY!=display) {
		return;
	}
#else
	if (SLR_SUB_DISPLAY<display) {
		return;
	}
#endif
	smt_test_type[display]=test_case;
}

SMT_TEST_TYPE get_smoothtoggle_test_type(unsigned char display)
{
#ifndef CONFIG_DUAL_CHANNEL
	if (SLR_MAIN_DISPLAY!=display) {
		return NULL_TEST_TYPE;
	}
#else
	if (SLR_SUB_DISPLAY<display) {
		return NULL_TEST_TYPE;
	}
#endif
	return smt_test_type[display];
}

unsigned char smt_test_wid;
void set_smoothtoggle_test_window(unsigned char display)
{
#ifndef CONFIG_DUAL_CHANNEL
	if (SLR_MAIN_DISPLAY!=display) {
		return;
	}
#else
	if (SLR_SUB_DISPLAY<display) {
		return;
	}
#endif
	smt_test_wid = display;
}

unsigned char get_smoothtoggle_test_window(void)
{
	return smt_test_wid;
}

void smt_test_delay(void)
{
	mdelay(1000);
}

unsigned int smt_cnt_w=0;
unsigned int smt_cnt_h=0;
unsigned int size_w=0;
unsigned int size_h=0;

void smoothtoggle_test_case(KADP_VIDEO_WID_T wid,SMT_TEST_CASE test_case)
{
	VIDEO_RECT_T inputregion,source_info;
	KADP_VIDEO_RECT_T outputregion;

	if(Scaler_DispGetInputInfoByDisp(wid, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
		return;

	source_info.x = 0;
	source_info.y = 0;
	source_info.w=Scaler_DispGetInputInfoByDisp(wid, SLR_INPUT_IPH_ACT_WID_PRE);
	if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)wid, SLR_DISP_INTERLACE)) {
		source_info.h=Scaler_DispGetInputInfoByDisp(wid, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
	} else {
		source_info.h=Scaler_DispGetInputInfoByDisp(wid, SLR_INPUT_IPV_ACT_LEN_PRE);
	}
	if (OUTPUT_4_3_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		outputregion.x=_DISP_WID/8;
		outputregion.y=0;
		outputregion.w=_DISP_WID*3/4;
		outputregion.h=_DISP_LEN;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
		set_smoothtoggle_test_case(wid,NULL_TEST_CASE);
	}else if (OUTPUT_16_9_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		outputregion.x=0;
		outputregion.y=0;
		outputregion.w=_DISP_WID;
		outputregion.h=_DISP_WID*9/16;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
		set_smoothtoggle_test_case(wid,NULL_TEST_CASE);
	}else if (OUTPUT_SMALL_SCREEN_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		outputregion.x=_DISP_WID/4;
		outputregion.y=_DISP_LEN/4;
		outputregion.w=_DISP_WID/2;
		outputregion.h=_DISP_LEN/2;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
		set_smoothtoggle_test_case(wid,NULL_TEST_CASE);
	}else if (OUTPUT_ORIGIN_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		outputregion.x=0;
		outputregion.y=0;
		outputregion.w=source_info.w;
		outputregion.h=source_info.h;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
		set_smoothtoggle_test_case(wid,NULL_TEST_CASE);
	}else if (INPUT_X_W_CASE==get_smoothtoggle_test_case(wid)) {
		size_w=smt_cnt_w*source_info.w*10/100;
		if(size_w >= source_info.w){
			smt_cnt_w=0;
			size_w=0;
		}
		inputregion.x=size_w;
		inputregion.y=0;
		inputregion.w=source_info.w - size_w;
		inputregion.h=source_info.h;
		outputregion.x=0;
		outputregion.y=0;
		outputregion.w=_DISP_WID;
		outputregion.h=_DISP_LEN;
		smt_cnt_w++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}else if(INPUT_Y_H_CASE==get_smoothtoggle_test_case(wid)) {
		size_h=smt_cnt_h*source_info.h*10/100;
		if(size_h >= source_info.h){
			smt_cnt_h=0;
			size_h=0;
		}
		inputregion.x=0;
		inputregion.y=size_h;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h - size_h;

		outputregion.x=0;
		outputregion.y=0;
		outputregion.w=_DISP_WID;
		outputregion.h=_DISP_LEN;
		smt_cnt_h++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}else if(INPUT_X_Y_CASE==get_smoothtoggle_test_case(wid)) {
		size_w=smt_cnt_w*source_info.w*10/100;
		if(size_w >= source_info.w/2){
			smt_cnt_w=0;
			size_w=0;
		}
		inputregion.x=size_w;

		size_h=smt_cnt_h*source_info.h*10/100;
		if(size_h >= source_info.h/2){
			smt_cnt_h=0;
			size_h=0;
		}
		inputregion.y=size_h;

		inputregion.w=source_info.w-size_w;
		inputregion.h=source_info.h-size_h;

		outputregion.x=0;
		outputregion.y=0;
		outputregion.w=_DISP_WID;
		outputregion.h=_DISP_LEN;
		smt_cnt_w++;
		smt_cnt_h++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}else if(INPUT_W_H_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;

		size_w=(smt_cnt_w+1)*source_info.w*10/100;
		if(size_w >= source_info.w){
			smt_cnt_w=0;
			size_w=source_info.w*10/100;
		}

		size_h=(smt_cnt_h+1)*source_info.h*10/100;
		if(size_h >= source_info.h){
			smt_cnt_h=0;
			size_h=source_info.h*10/100;
		}

		inputregion.w=size_w;
		inputregion.h=size_h;

		outputregion.x=0;
		outputregion.y=0;
		outputregion.w=_DISP_WID;
		outputregion.h=_DISP_LEN;

		smt_cnt_w++;
		smt_cnt_h++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}
	//
	else if (OUTPUT_X_W_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		size_w=smt_cnt_w*_DISP_WID*10/100;
		if(size_w >= _DISP_WID){
			smt_cnt_w=0;
			size_w=0;
		}

		outputregion.x=size_w;
		outputregion.y=0;
		outputregion.w=_DISP_WID-2*size_w;
		outputregion.h=_DISP_LEN;

		smt_cnt_w++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}else if(OUTPUT_Y_H_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		size_h=smt_cnt_h*_DISP_LEN*10/100;
		if(size_h >= _DISP_LEN){
			smt_cnt_h=0;
			size_h=0;
		}

		outputregion.x=0;
		outputregion.y=size_h;
		outputregion.w=_DISP_WID;
		outputregion.h=_DISP_LEN-2*size_h;
		smt_cnt_h++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}else if(OUTPUT_X_Y_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		size_w=smt_cnt_w*_DISP_WID*10/100;
		if(size_w >= _DISP_WID/2){
			smt_cnt_w=0;
			size_w=0;
		}
		outputregion.x=size_w;

		size_h=smt_cnt_h*_DISP_LEN*10/100;
		if(size_h >= _DISP_LEN/2){
			smt_cnt_h=0;
			size_h=0;
		}
		outputregion.y=size_h;

		outputregion.w=_DISP_WID-2*size_w;
		outputregion.h=_DISP_LEN-2*size_h;
		smt_cnt_w++;
		smt_cnt_h++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}else if(OUTPUT_W_H_CASE==get_smoothtoggle_test_case(wid)) {
		inputregion.x=0;
		inputregion.y=0;
		inputregion.w=source_info.w;
		inputregion.h=source_info.h;

		outputregion.x=0;
		outputregion.y=0;

		size_w=(smt_cnt_w+1)*_DISP_WID*10/100;
		if(size_w >= _DISP_WID){
			smt_cnt_w=0;
			size_w=_DISP_WID*10/100;
		}

		size_h=(smt_cnt_h+1)*_DISP_LEN*10/100;
		if(size_h >= _DISP_LEN){
			smt_cnt_h=0;
			size_h=_DISP_LEN*10/100;
		}

		outputregion.w=size_w;
		outputregion.h=size_h;

		smt_cnt_w++;
		smt_cnt_h++;
		rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)wid,inputregion,source_info);
		rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)wid,outputregion,0,0);
		//rtk_hal_vsc_SetInputRegion_OutputRegion(wid,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		smt_test_delay();
	}
}

void smoothtoggle_test(KADP_VIDEO_WID_T wid,SMT_TEST_TYPE test_type,SMT_TEST_CASE test_case)
{
	if(RATIO_TEST_TYPE == test_type){
		smoothtoggle_test_case(wid,test_case);
	}else if(PST_TEST_TYPE == test_type){
		if (ADAPTIVE_STREAM_OFF==vsc_get_adaptivestream_flag(wid)) {
			rtk_hal_vsc_SetAdaptiveStreamEX((VIDEO_WID_T)wid,ADAPTIVE_STREAM_ON);
		}
		smoothtoggle_test_case(wid,test_case);
	}else if(TIMING_CHANGE_TEST_TYPE == test_type){
		smoothtoggle_test_case(wid,test_case);
	}
}

static int smooth_toggle_test_tsk(void *p)//This task run smooth toggle test case
{
	//StructDisplayInfo* info;
	//unsigned int size=0;
	//info = Scaler_DispGetInfoPtr();
    unsigned char display = 0;
	set_freezable();
	rtd_pr_vsc_debug("smooth_toggle_test_tsk()\n");
/*    struct cpumask vsc_cpumask;
	cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);*/

    while (1)
    {
        display = get_smoothtoggle_test_window();
		if(RATIO_TEST_TYPE == get_smoothtoggle_test_type(display)){
			smoothtoggle_test_case(display,get_smoothtoggle_test_case(display));
		}else if(PST_TEST_TYPE == get_smoothtoggle_test_type(display)){
			if (ADAPTIVE_STREAM_OFF==vsc_get_adaptivestream_flag(display)) {
				rtk_hal_vsc_SetAdaptiveStreamEX(display,ADAPTIVE_STREAM_ON);
			}
			set_vsc_run_adaptive_stream(display, vsc_get_adaptivestream_flag(display));//save vsc run adaptive stream or not
			smoothtoggle_test_case(display,get_smoothtoggle_test_case(display));
		}else if(TIMING_CHANGE_TEST_TYPE == get_smoothtoggle_test_type(display)){
			//rtk_hal_vsc_SetAdaptiveStreamEX(display,0);
			//smoothtoggle_test_case(display,get_smoothtoggle_test_case(display));
		}

		//if ((0==DbgSclrFlgTkr.Main_Scaler_Stop_flag) &&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){}
		if (freezing(current))
       	{//for some continue case
			try_to_freeze();
        }
		if (kthread_should_stop()) {
         	break;
      	}
		msleep(1000);
    }
    rtd_pr_vsc_debug("\r\n####smooth_toggle_test_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_smt_test_tsk(void)
{
	int err;
	if (smt_tsk_running_flag == FALSE) {
		p_smt_tsk = kthread_create(smooth_toggle_test_tsk, NULL, "smt_test_tsk");

	    if (p_smt_tsk) {
			wake_up_process(p_smt_tsk);
			smt_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_smt_tsk);
	    	rtd_pr_vsc_debug("Unable to start create_smt_test_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_smt_test_tsk(void)
{
	int ret;
	if (smt_tsk_running_flag) {
		if(p_smt_tsk){
	 		ret = kthread_stop(p_smt_tsk);
	 		if (!ret) {
	 			p_smt_tsk = NULL;
	 			smt_tsk_running_flag = FALSE;
				rtd_pr_vsc_debug("smt_test thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_debug("smt_test thread stopped already\n");
		}
	}
}
#endif

#ifndef UT_flag
int vsc_open(struct inode *inode, struct file *filp) {
	return 0;
}

ssize_t  vsc_read(struct file *filep, char *buffer, size_t count, loff_t *offp)
{
	return 0;

}

void scaler_main_sub_test(void);
ssize_t vsc_write(struct file *filep, const char *buffer, size_t count, loff_t *offp)
{
	long ret = count;
	char cmd_buf[100] = {0};
#ifdef ENABLE_SMOOTHTOGGLE_TEST
	KADP_VIDEO_RECT_T inputregion,outputregion,source_info;
#endif

	#ifndef CONFIG_ARM64
	rtd_pr_vsc_notice("%s(): count=%d, buf=0x%08lx\n", __func__, count, (long)buffer);
	#endif

	if (count >= 100)
		return -EFAULT;

	if (copy_from_user(cmd_buf, buffer, count)) {
		ret = -EFAULT;
	}

	if(count > 0) {
	   cmd_buf[count] = '\0';
	}

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
	if ((cmd_buf[0] == 't') && (cmd_buf[1] == 'e') && (cmd_buf[2] == 's') && (cmd_buf[3] == 't') && (cmd_buf[4] == 'm')
            && (cmd_buf[5] == 'o') && (cmd_buf[6] == 'd') && (cmd_buf[7] == 'e') && (cmd_buf[8] == '='))

    {
            // shell command as: echo testmode=1 testresult=/tmp/var/log/xxxxx > /dev/vodev
            if((cmd_buf[9] == '1') && (cmd_buf[11] == 't') && (cmd_buf[20] == 't') && (cmd_buf[21] == '=')){
			rtd_pr_vsc_notice("\n=== rtkscaler: enable dump CRC =============\n");
                   rtkscaler_dumpCRC_enable(&cmd_buf[22], (count-22)-1);
			rtd_pr_vsc_notice("\n=======================================\n");
            } // shell command as: echo testmode=1 /tmp/var/log/xxxxx > /dev/vodev
		else if ((cmd_buf[9] == '1') && (cmd_buf[11] == '/')) {
			rtd_pr_vsc_notice("\n=== rtkvo: enable dump CRC =============\n");
                   rtkscaler_dumpCRC_enable(&cmd_buf[11], (count-11)-1);
			rtd_pr_vsc_notice("\n=======================================\n");
            } // shell command as: echo testmode=0 > /dev/vodev
		else if (cmd_buf[9] == '0') {
			rtd_pr_vsc_notice("\n=== rtkvo: disable dump CRC =============\n");
			rtkscaler_dumpCRC_disable();
			rtd_pr_vsc_notice("\n=======================================\n");
		}
		else {
			rtd_pr_vsc_notice("%s\n", cmd_buf);
		}
	}
        else {
		rtd_pr_vsc_notice("%s\n", cmd_buf);
	}
#endif

#ifdef ENABLE_SMOOTHTOGGLE_TEST
		if(strcmp(cmd_buf, "close smooth toggle test\n") == 0){
			//shell command: echo close smooth toggle test > /dev/vscdev
			IoReg_ClearBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_CONTROL_BIT);//close video fw timing change test flow
			set_smoothtoggle_test_window(2);
			set_smoothtoggle_test_type(SLR_MAIN_DISPLAY,NULL_TEST_TYPE);
			set_smoothtoggle_test_type(SLR_SUB_DISPLAY,NULL_TEST_TYPE);
			set_smoothtoggle_test_case(SLR_MAIN_DISPLAY,NULL_TEST_CASE);
			set_smoothtoggle_test_case(SLR_SUB_DISPLAY,NULL_TEST_CASE);
			//recover main
			source_info.w=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
			if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
				source_info.h=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
			} else {
				source_info.h=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
			}
			inputregion.x=0;
			inputregion.y=0;
			inputregion.w=source_info.w;
			inputregion.h=source_info.h;
			outputregion.x=0;
			outputregion.y=0;
			outputregion.w=_DISP_WID;
			outputregion.h=_DISP_LEN;
			rtk_hal_vsc_SetInputRegion_OutputRegion(KADP_VIDEO_WID_0,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);

			//recover sub
			source_info.w=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
			if (Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE)) {
				source_info.h=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
			} else {
				source_info.h=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
			}
			inputregion.x=0;
			inputregion.y=0;
			inputregion.w=source_info.w;
			inputregion.h=source_info.h;
			outputregion.x=0;
			outputregion.y=0;
			outputregion.w=_DISP_WID/3;
			outputregion.h=_DISP_LEN/3;
			rtk_hal_vsc_SetInputRegion_OutputRegion(KADP_VIDEO_WID_1,KADP_VSC_ROTATE_0,inputregion,source_info,outputregion,0,0);
		}

		if(strcmp(cmd_buf, "start smooth toggle test\n") == 0){
			//	 echo 1 > /proc/sys/kernel/printk
			//	 echo start smooth toggle test > /dev/vscdev
			rtd_pr_vsc_emerg( "Start smooth toggle test_case, please choose test window:\n");
			rtd_pr_vsc_emerg( "Main window:echo main window > /dev/vscdev \n");
			rtd_pr_vsc_emerg( "Sub window:echo sub window > /dev/vscdev \n");
		}

	//window
		if(strcmp(cmd_buf, "main window\n") == 0){
			set_smoothtoggle_test_window(SLR_MAIN_DISPLAY);
			rtd_pr_vsc_emerg( "You choose main window, please input test type:\n");
			rtd_pr_vsc_emerg( "Ratio smooth toggle: echo ratio smooth toggle test > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "PST: echo PST test > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "Timing change smooth toggle: echo timing change test > /dev/vscdev\n");
		}else if(strcmp(cmd_buf, "sub window\n") == 0){
			set_smoothtoggle_test_window(SLR_SUB_DISPLAY);
			rtd_pr_vsc_emerg( "You choose sub window, please input test type:\n");
			rtd_pr_vsc_emerg( "Ratio smooth toggle: echo ratio smooth toggle test > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "PST: echo PST test > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "Timing change smooth toggle: echo timing change test > /dev/vscdev\n");
		}

	//test type
		if(strcmp(cmd_buf, "ratio smooth toggle test\n") == 0){
			set_smoothtoggle_test_type(get_smoothtoggle_test_window(),RATIO_TEST_TYPE);
			rtd_pr_vsc_emerg( "ratio smooth toggle test, please input test case\n");
			rtd_pr_vsc_emerg( "output region 4:3: echo output 4:3> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region 16:9: echo output 16:9> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output small screen: echo output small screen> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output origin: echo output origin> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region xw change: echo input xw change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region yh change: echo input yh change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region xy change: echo input xy change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region wh change: echo input wh change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region xw change: echo output xw change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region yh change: echo output yh change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region xy change: echo output xy change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region wh change: echo output wh change> /dev/vscdev\n");
		}else if(strcmp(cmd_buf, "PST test\n") == 0){
			set_smoothtoggle_test_type(get_smoothtoggle_test_window(),PST_TEST_TYPE);
			rtd_pr_vsc_emerg( "ratio smooth toggle test, please input test case\n");
			rtd_pr_vsc_emerg( "output region 4:3: echo output 4:3> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region 16:9: echo output 16:9> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output small screen: echo output small screen> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output origin: echo output origin> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region xw change: echo input xw change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region yh change: echo input yh change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region xy change: echo input xy change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "input region wh change: echo input wh change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region xw change: echo output xw change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region yh change: echo output yh change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region xy change: echo output xy change> /dev/vscdev\n");
			rtd_pr_vsc_emerg( "output region wh change: echo output wh change> /dev/vscdev\n");
		}else if(strcmp(cmd_buf, "timing change test\n") == 0){
			set_smoothtoggle_test_type(get_smoothtoggle_test_window(),TIMING_CHANGE_TEST_TYPE);
			rtd_pr_vsc_emerg( "timing change test,please input test case\n");
			rtd_pr_vsc_emerg( "echo framerate change to 24hz > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo framerate change to 30hz > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo framerate change to 48hz > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo framerate change to 50hz > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo framerate change to 60hz > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo framerate change to 120hz > /dev/vscdev\n");
	#if 1
			rtd_pr_vsc_emerg( "echo resolution change 3840*2160p > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo resolution change 1920*1080p > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo resolution change 1280*720p > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo resolution change 960*540p > /dev/vscdev\n");

			rtd_pr_vsc_emerg( "echo resolution change 1920*1080i > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo resolution change 1440*480i > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo resolution change 720*576i > /dev/vscdev\n");
			rtd_pr_vsc_emerg( "echo resolution change 720*480i > /dev/vscdev\n");
	#endif
		}
	//test case
		if((get_smoothtoggle_test_type(get_smoothtoggle_test_window()) == RATIO_TEST_TYPE)||(get_smoothtoggle_test_type(get_smoothtoggle_test_window()) == PST_TEST_TYPE)){
			if(strcmp(cmd_buf, "output 4:3\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_4_3_CASE);
			}else if(strcmp(cmd_buf, "output 16:9\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_16_9_CASE);
			}else if(strcmp(cmd_buf, "output small screen\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_SMALL_SCREEN_CASE);
			}else if(strcmp(cmd_buf, "output origin\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_ORIGIN_CASE);
			}else if(strcmp(cmd_buf, "input xw change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),INPUT_X_W_CASE);
			}else if(strcmp(cmd_buf, "input yh change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),INPUT_Y_H_CASE);
			}else if(strcmp(cmd_buf, "input xy change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),INPUT_X_Y_CASE);
			}else if(strcmp(cmd_buf, "input wh change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),INPUT_W_H_CASE);
			}else if(strcmp(cmd_buf, "output xw change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_X_W_CASE);
			}else if(strcmp(cmd_buf, "output yh change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_Y_H_CASE);
			}else if(strcmp(cmd_buf, "output xy change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_X_Y_CASE);
			}else if(strcmp(cmd_buf, "output wh change\n") == 0){
				set_smoothtoggle_test_case(get_smoothtoggle_test_window(),OUTPUT_W_H_CASE);
			}
		}else if(get_smoothtoggle_test_type(get_smoothtoggle_test_window()) == TIMING_CHANGE_TEST_TYPE){
			//use dummy register b80290e0[31:4] to control timing change smooth toggle
			IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_CONTROL_BIT);//open video fw timing change test flow
			IoReg_ClearBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_TIMING_CHANGE_BITS);
			if(strcmp(cmd_buf, "framerate change to 24hz\n") == 0){
				IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_24HZ_BIT);
			}else if(strcmp(cmd_buf, "framerate change to 30hz\n") == 0){
				IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_30HZ_BIT);
			}else if(strcmp(cmd_buf, "framerate change to 48hz\n") == 0){
				IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_48HZ_BIT);
			}else if(strcmp(cmd_buf, "framerate change to 50hz\n") == 0){
				IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_50HZ_BIT);
			}else if(strcmp(cmd_buf, "framerate change to 60hz\n") == 0){
				IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_60HZ_BIT);
			}else if(strcmp(cmd_buf, "framerate change to 120hz\n") == 0){
				IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_120HZ_BIT);
			}
			else if(strcmp(cmd_buf, "resolution change 3840*2160p\n") == 0){
				if(!Scaler_DispGetStatus(get_smoothtoggle_test_window(),SLR_DISP_INTERLACE)){
					IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_2160P_BIT);
				}else{
					rtd_pr_vsc_emerg( "interlace video ,cannot do progressive resolution change\n");
				}
			}else if(strcmp(cmd_buf, "resolution change 1920*1080p\n") == 0){
				if(!Scaler_DispGetStatus(get_smoothtoggle_test_window(),SLR_DISP_INTERLACE)){
					IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_1080P_BIT);
				}else{
					rtd_pr_vsc_emerg( "interlace video ,cannot do progressive resolution change\n");
				}
			}else if(strcmp(cmd_buf, "resolution change 1280*720p\n") == 0){
				if(!Scaler_DispGetStatus(get_smoothtoggle_test_window(),SLR_DISP_INTERLACE)){
					IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_720P_BIT);
				}else{
					rtd_pr_vsc_emerg( "interlace video ,cannot do progressive resolution change\n");
				}
			}else if(strcmp(cmd_buf, "resolution change 960*540p\n") == 0){
				if(!Scaler_DispGetStatus(get_smoothtoggle_test_window(),SLR_DISP_INTERLACE)){
					IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_540P_BIT);
				}else{
					rtd_pr_vsc_emerg( "interlace video ,cannot do progressive resolution change\n");
				}
			}else if(strcmp(cmd_buf, "resolution change 1920*1080i\n") == 0){
				if(Scaler_DispGetStatus(get_smoothtoggle_test_window(),SLR_DISP_INTERLACE)){
					IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_1080I_BIT);
				}else{
					rtd_pr_vsc_emerg( "progressive video ,cannot do interlace resolution change\n");
				}
			}else if(strcmp(cmd_buf, "resolution change 720*576i\n") == 0){
				if(Scaler_DispGetStatus(get_smoothtoggle_test_window(),SLR_DISP_INTERLACE)){
					IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_576I_BIT);
				}else{
					rtd_pr_vsc_emerg( "progressive video ,cannot do interlace resolution change\n");
				}
			}else if(strcmp(cmd_buf, "resolution change 720*480i\n") == 0){
				if(Scaler_DispGetStatus(get_smoothtoggle_test_window(),SLR_DISP_INTERLACE)){
					IoReg_SetBits(SMT_TEST_DUMMY_REGISTER,SMT_TEST_480I_BIT);
				}else{
					rtd_pr_vsc_emerg( "progressive video ,cannot do interlace resolution change\n");
				}
			}
		}
#endif

	// shell command : echo test_videolatency=1 > /dev/vscdev
	if(strcmp(cmd_buf, "test_videolatency=1\n") == 0){
		set_latency_pattern_self_test(1);
		rtd_pr_vsc_emerg( "enable test_videolatency \n");
	}else if(strcmp(cmd_buf, "test_videolatency=0\n") == 0){
		set_latency_pattern_self_test(0);
		rtd_pr_vsc_emerg( "disable test_videolatency \n");
	}else if(strcmp(cmd_buf, "enable main_sub_test=1\n") == 0){
		scaler_main_sub_test();
		rtd_pr_vsc_emerg( "enable main_sub_test \n");
	}

	// shell command : echo test_vo_framerate=0 > /dev/vscdev
	if(strcmp(cmd_buf, "test_vo_framerate=0\n") == 0){
		vo_set_force_framerate_control(_VO_FORCE_FRAMERATE_NONE);
	}else if(strcmp(cmd_buf, "test_vo_framerate=24\n") == 0){
		vo_set_force_framerate_control(_VO_FORCE_FRAMERATE_24HZ);
	}else if(strcmp(cmd_buf, "test_vo_framerate=25\n") == 0){
		vo_set_force_framerate_control(_VO_FORCE_FRAMERATE_25HZ);
	}else if(strcmp(cmd_buf, "test_vo_framerate=30\n") == 0){
		vo_set_force_framerate_control(_VO_FORCE_FRAMERATE_30HZ);
	}else if(strcmp(cmd_buf, "test_vo_framerate=50\n") == 0){
		vo_set_force_framerate_control(_VO_FORCE_FRAMERATE_50HZ);
	}else if(strcmp(cmd_buf, "test_vo_framerate=60\n") == 0){
		vo_set_force_framerate_control(_VO_FORCE_FRAMERATE_60HZ);
	}

	return ret;
}

int vsc_release(struct inode *inode, struct file *filep)
{
	return 0;
}
#endif // #ifndef UT_flag
unsigned char vsc_set_vd_ptg(unsigned char bOnOff)
{
	//rtd_pr_vsc_emerg( "function=%s, line=%d\n", __FUNCTION__, __LINE__);

	if(bOnOff == _ENABLE) {
		//Set VD PatternGen
		IoReg_SetBits(VDTOP_PATTERN_CONTROL_reg,_BIT0);
		IoReg_Write32(VDTOP_AD_SW_CTRL0_reg, 0x0);
		//Set VGIP PatternGen
		IoReg_SetBits(SUB_VGIP_VGIP_CHN2_CTRL_reg,_BIT27);
	}
	else {
		//Clear VD PatternGen
		IoReg_ClearBits(VDTOP_PATTERN_CONTROL_reg,_BIT0);
		IoReg_Write32(VDTOP_AD_SW_CTRL0_reg, 0xc9);
		//Clear VGIP PatternGen
		IoReg_ClearBits(SUB_VGIP_VGIP_CHN2_CTRL_reg,_BIT27);
	}
	return TRUE;
}

unsigned char vsc_get_uzu_crc(VIDEO_WID_T wid, unsigned int *CRC_Rsult)
{
	//rtd_pr_vsc_emerg( "function=%s, line=%d\n", __FUNCTION__, __LINE__);
	unsigned int iResult = 0x00;
	unsigned int golden = 0x3d8e33a2;

	//Set M-Domain CRC Bits
	if(wid == VIDEO_WID_0) {
		IoReg_SetBits(SCALEUP_DM_MEM_CRC_CTRL_reg,_BIT1|_BIT0);
	}
	else if(wid == VIDEO_WID_1) {
		IoReg_SetBits(SCALEUP_DS_MEM_CRC_CTRL_reg,_BIT1|_BIT0);
	}
	msleep(1000);
	//Get M-Domain CRC Result
	if(wid == VIDEO_WID_0) {
		iResult = IoReg_Read32(SCALEUP_DM_MEM_CRC_Result_reg);
	}
	else if(wid == VIDEO_WID_1) {
		iResult = IoReg_Read32(SCALEUP_DS_MEM_CRC_Result_reg);
	}

	if(iResult == golden)
		*CRC_Rsult = TRUE;
	else
		*CRC_Rsult = FALSE;

	return TRUE;
}

unsigned char i3dma_uzd_flag=1;
void set_i3dma_uzd(unsigned char i3dma_uzd)
{
	i3dma_uzd_flag=i3dma_uzd;
}

unsigned char get_i3dma_uzd(void)
{
	return i3dma_uzd_flag;
}

unsigned char vsc_set_uzd_path(unsigned char i3dma_uzd)
{
	//rtd_pr_vsc_emerg( "function=%s, line=%d\n", __FUNCTION__, __LINE__);

	set_i3dma_uzd(i3dma_uzd);

	return TRUE;
}

extern void scalerVIP_Set_BlackDetection_EN(unsigned char bEnable_main, unsigned char bEnable_sub);
long vsc_ioctl(struct file *file, unsigned int cmd,  unsigned long arg)
{
	extern KADP_VFE_AVD_TIMING_INFO_T *Get_AVD_LGETiminginfo(void);
	unsigned int before_time = 0;
	unsigned int after_time = 0;
	KADP_VFE_AVD_TIMING_INFO_T *ptLGETimingInfo = NULL;
#ifdef CONFIG_SUPPORT_SRC_ADC
	StructDisplayInfo * p_adc_dispinfo = NULL;
#endif
	//HDMI_TIMING_T hdmi_timing_info = {0, COLOR_RGB, HDMI_COLORIMETRY_NOSPECIFIED, 0 ,HDMI3D_2D_ONLY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
	HDMI_TIMING_T hdmi_timing_info;
#else
	vfe_hdmi_timing_info_t hdmi_timing_info;
#endif

	int retval = 0;
	//rtd_pr_vsc_debug("VSC: vsc_ioctl, %x;;agr:%x\n", cmd, *((unsigned int *)arg));

	if (_IOC_TYPE(cmd) != VSC_IOC_MAGIC || _IOC_NR(cmd) > VSC_IOC_MAXNR) return -ENOTTY ;

	switch (cmd)
	{
		case VSC_IOC_INITIALIZE:
		{
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(rtk_hal_vsc_initialize()==FALSE)
				retval =  -1;
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_pr_vsc_debug("VSC intial time=%d ms", (after_time-before_time));
			break;
		}
		case VSC_IOC_UNINITIALIZE:
		{
			if(rtk_hal_vsc_uninitialize()==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_OPEN:
		{
			VIDEO_WID_T widid;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_OPEN copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_open(widid) == FALSE)
					retval =  -1;
				after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
				rtd_pr_vsc_debug("VSC open time=%d ms", (after_time-before_time));
			}
			break;
		}
		case VSC_IOC_CLOSE:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CLOSE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_close(widid)==FALSE)
					retval =  -1;
			}
			break;

		}
		case VSC_IOC_CONNECT:
		{
			VSC_CONNECT_PARA_T connectPara;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(copy_from_user((void *)&connectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
                                if(connectPara.vsc_input.type == KADP_VSC_INPUTSRC_VDEC)
                                {
                                    if(connectPara.connectwid == KADP_VIDEO_WID_0)//current sub always live zoom case. Need to add livezoom condition later
                                    {
                                        if(!vdo0_connect)//means no call vdo connect
                                        {
                                            vdo_connect(connectPara.connectwid, connectPara.vsc_input.resourceIndex);
                                        }
                                    } else {

                                            if(!vdo1_connect)//means no call vdo connect
                                            {
                                                vdo_connect(connectPara.connectwid, connectPara.vsc_input.resourceIndex);
                                            }
                                    }
                                }
#endif
				if(rtk_hal_vsc_Connect((VIDEO_WID_T)connectPara.connectwid, connectPara.vsc_input, connectPara.outputmode)==FALSE)
				{
					retval =  -1;
				}
				after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
				rtd_pr_vsc_debug("VSC connect time=%d ms",(after_time-before_time));

			}
			break;
		}
		case VSC_IOC_DISCONNECT:
		{
			VSC_CONNECT_PARA_T disconnectPara;
			if(copy_from_user((void *)&disconnectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Disconnect((VIDEO_WID_T)disconnectPara.connectwid, disconnectPara.vsc_input, disconnectPara.outputmode) == FALSE)
				{
					retval =  -1;
				}
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
                                if(disconnectPara.vsc_input.type == KADP_VSC_INPUTSRC_VDEC)
                                {
                                    if(disconnectPara.connectwid == KADP_VIDEO_WID_0)//current sub always live zoom case. Need to add livezoom condition later
                                    {
                                        if(vdo0_connect)//means no call vdo connect
                                        {
                                            vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                                        }
                                    } else {

                                            if(vdo1_connect)//means no call vdo connect
                                            {
                                                vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                                            }
                                    }
                                }
#endif

			}
			break;
		}
		case VSC_IOC_SET_WINBLANK:
		{
			VSC_WINBLANK_PARA_T winblankpara;
			if(copy_from_user((void *)&winblankpara, (const void __user *)arg, sizeof(VSC_WINBLANK_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_WINBLANK copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_debug("winblankpara.winblankwid=%d,winblankpara.winblankbonoff=%d,winblankpara.winblankcolor=%d\n", winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor);
				if(rtk_hal_vsc_SetWinBlank((VIDEO_WID_T)winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_ADAPTIVE_INPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			VIDEO_DDI_RECT_T inregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(VSC_GET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_ADAPTIVE_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetInputRegion_ForAdaptive((VIDEO_WID_T)pframeregion.setframewid, &inregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &inregion, sizeof(VIDEO_DDI_RECT_T)) )
					{
	                			rtd_pr_vsc_err("[ERR] VSC_IOC_GET_INPUTREGION copy_to_user error \n");
						retval = EFAULT;
	            			}
				}

			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVE_INPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVE_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetInputRegion_ForAdaptive((VIDEO_WID_T)frameregion.setframewid, frameregion.inregion) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_INPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			KADP_VIDEO_RECT_T inregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(KADP_VIDEO_RECT_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetInputRegion(pframeregion.setframewid, &inregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &inregion, sizeof(KADP_VIDEO_RECT_T)) )
					{
	                	rtd_pr_vsc_err("[ERR] VSC_IOC_GET_INPUTREGION copy_to_user error \n");
						retval = EFAULT;
	            	}
				}

			}
			break;
		}
		case VSC_IOC_SET_INPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetInputRegion(frameregion.setframewid, frameregion.inregion) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_OUTPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			KADP_VIDEO_RECT_T outregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(VSC_GET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetOutputRegion(pframeregion.setframewid, &outregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &outregion, sizeof(VIDEO_DDI_RECT_T)) )
					{
	                	rtd_pr_vsc_err("[ERR] VSC_IOC_GET_OUTPUTREGION copy_to_user error \n");
						retval = EFAULT;
	            	}
				}
			}
			break;
		}
		case VSC_IOC_SET_OUTPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				virtual_w = true_wide;
				virtual_h = true_high;

				if(rtk_hal_vsc_SetOutputRegion((VIDEO_WID_T)frameregion.setframewid, frameregion.inregion, virtual_w, virtual_h)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_WINFREEZE:
		{
			VSC_FREEZE_ACTION_T freezeact;
			if(copy_from_user((void *)&freezeact, (const void __user *)arg, sizeof(VSC_FREEZE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_WINFREEZE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_debug("freezeact.freezewid=%d,freezeact.freezeonoff=%d\n", freezeact.freezewid, freezeact.freezeonoff);
				if(rtk_hal_vsc_SetWinFreeze((VIDEO_WID_T)freezeact.freezewid, freezeact.freezeonoff)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_FREEZE_VIDEOFRAMEBUFFER:
		{
			VSC_FREEZE_ACTION_T freezeact;
			if(copy_from_user((void *)&freezeact, (const void __user *)arg, sizeof(VSC_FREEZE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_FREEZE_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Factory_SelfDiagnosis_Mode = TRUE;
				if(rtk_hal_vsc_FreezeVideoFrameBuffer((VIDEO_WID_T)freezeact.freezewid, freezeact.freezeonoff)==FALSE)
					retval =  -1;
				Factory_SelfDiagnosis_Mode = FALSE;
			}
			break;
		}
		case VSC_IOC_READ_VIDEOFRAMEBUFFER:
		{
			VSC_READ_BUFFER_ACTION_T readaction;
			if(copy_from_user((void *)&readaction, (const void *)arg, sizeof(VSC_READ_BUFFER_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				VIDEO_RECT_T kernelInregion;
				KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *kernelPRead;
				KADP_VIDEO_DDI_COLOR_STANDARD_T Color_standard ;
				KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T PixelColorFormat;
				Factory_SelfDiagnosis_Mode = TRUE;

				if(copy_from_user((void *)&kernelInregion, (const void *)to_user_ptr(readaction.pinregion), sizeof(VIDEO_DDI_RECT_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER kernelInregion copy_from_user failed!!!!!!!!!!!!!!!\n");
				}
				if(kernelInregion.x > 7680 ||kernelInregion.y > 4320 ||kernelInregion.w > 7680||kernelInregion.h > 4320||kernelInregion.w ==0||kernelInregion.h==0)
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("kernelInregion error x=%d y=%d w=%d h=%d\n",kernelInregion.x,kernelInregion.y,kernelInregion.w,kernelInregion.h);
					break;
				}
				kernelPRead = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific((unsigned int)kernelInregion.w * kernelInregion.h* sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);

				Color_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
				PixelColorFormat = KADP_VIDEO_DDI_PIXEL_8BIT;
				if(rtk_hal_vsc_ReadVideoFrameBuffer((VIDEO_WID_T)readaction.bufferwid, &kernelInregion, kernelPRead, &Color_standard, &PixelColorFormat) == FALSE)
					retval =  -1;

				if(copy_to_user(to_user_ptr(readaction.pcolor_standard), (void *)&Color_standard, sizeof(KADP_VIDEO_DDI_COLOR_STANDARD_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER pcolor_standard copy_to_user failed!!!!!!!!!!!!!!!\n");
				}

				if(copy_to_user(to_user_ptr(readaction.ppixelcolorformat), (void *)&PixelColorFormat, sizeof(KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER ppixelcolorformat copy_to_user failed!!!!!!!!!!!!!!!\n");
				}

				if(copy_to_user(to_user_ptr(readaction.pRead), (void *)kernelPRead, (unsigned int)kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER pRead copy_to_user failed!!!!!!!!!!!!!!!\n");
				}
				dvr_free((void *)kernelPRead);
				Factory_SelfDiagnosis_Mode = FALSE;
			}
			break;
		}
		case VSC_IOC_WRITE_VIDEOFRAMEBUFFER:
		{
			VSC_WRITE_BUFFER_ACTION_T writeaction;
			if(copy_from_user((void *)&writeaction, (const void *)arg, sizeof(VSC_WRITE_BUFFER_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				KADP_VIDEO_RECT_T kernelInregion;
				KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *kernelPWrite;
				Factory_SelfDiagnosis_Mode = TRUE;
				if(copy_from_user((void *)&kernelInregion, (const void __user *)to_user_ptr(writeaction.pinregion), sizeof(VIDEO_DDI_RECT_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER kernelInregion copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				kernelPWrite = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);

				if(copy_from_user((void *)kernelPWrite, (const void __user *)to_user_ptr(writeaction.pWrite), kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T)))
				{
					retval = -EFAULT;
					rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER kernelPWrite copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				if(rtk_hal_vsc_WriteVideoFrameBuffer(writeaction.bufferwid, &kernelInregion, kernelPWrite) == FALSE)
					retval =  -1;

				dvr_free((void *)kernelPWrite);
				Factory_SelfDiagnosis_Mode = FALSE;
			}

			break;
		}
		case VSC_IOC_CAPTURE_VIDEOFRAME:
		{
			VSC_CAPTURE_FRAME_ACTION_T capaction;
			if(copy_from_user((void *)&capaction, (const void __user *)arg, sizeof(VSC_CAPTURE_FRAME_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CAPTURE_VIDEOFRAME copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
#if 0//now have VT,no use vsc capture,but these code must keep:qiang_zhou
				if(rtk_hal_vsc_CaptureVideoFrame(capaction.place, capaction.pcaptureinfo) == FALSE)
					retval =  -1;
#endif
			}
			break;
		}
		case VSC_IOC_SET_RGB444MODE:
		{
			bool boffon;
			bool recheck_shp = FALSE;

			if(copy_from_user((void *)&boffon, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_RGB444MODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_debug("VSC_IOC_SET_RGB444MODE=%x\n", boffon);
				if(boffon != rtk_hal_vsc_GetRGB444Mode()){
					recheck_shp = TRUE;
				}
				if( (0 != HAL_VPQ_MEMC_SetRGBYUVMode(boffon)) || (rtk_hal_vsc_SetRGB444Mode(boffon)==FALSE) )
					retval =  -1;
				if(recheck_shp){
					Scaler_recheck_sharpness_table();
					rtd_pr_vsc_debug("Scaler_recheck_sharpness_table()\n");
				}
			}
			break;
		}
		case VSC_IOC_SET_3DFORSCALER:
		{

			TRIDTV_SCALER_CTRL_T p3dcfginfo;
			if(copy_from_user((void *)&p3dcfginfo, (const void __user *)arg, sizeof(TRIDTV_SCALER_CTRL_T )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_3DFORSCALER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Set3DForScaler(&p3dcfginfo) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_3DAUTODETECTMODE:
		{
			VSC_3DAUTODET_ACTION_T autodet;
			KADP_VIDEO_DDI_3D_FORMAT_TYPE_T threedtype = KADP_VIDEO_DDI_3D_FORMAT_MAX;
			if(copy_from_user((void *)&autodet, (const void __user *)arg, sizeof(VSC_3DAUTODET_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_3DAUTODETECTMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Get3DAutoDetectmode((VIDEO_WID_T)autodet.wid, &threedtype) == FALSE)
				{
					retval =  -1;
				}
				if (copy_to_user(to_user_ptr(autodet.pvideo3dtype), (void *)&threedtype, sizeof(KADP_VIDEO_DDI_3D_FORMAT_TYPE_T)) )
				{
                	rtd_pr_vsc_err("[ERR] VSC_IOC_GET_3DAUTODETECTMODE copy_to_user error \n");
					retval = EFAULT;
            	}
			}
			break;
		}
		case VSC_IOC_SET_3DPATTERNMODE:
		{
			VSC_3DPATTERNMODE_ACTION_T patternaction;
			if(copy_from_user((void *)&patternaction, (const void __user *)arg, sizeof(VSC_3DPATTERNMODE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_3DPATTERNMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Set3Dpatternmode((VIDEO_WID_T)patternaction.wid, patternaction.video3dtype) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_VENCMODE:
		{
			VSC_SET_VENCMODE_ACTION_T venc;
			if(copy_from_user((void *)&venc, (const void __user *)arg, sizeof(VSC_SET_VENCMODE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_VENCMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetVENEMode(venc.framerate,venc.scantype)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_OPENV2G:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_OPENV2G copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_OpenV2G(widid)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_CLOSEV2G:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_CLOSEV2G copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_CloseV2G(widid)==FALSE)
					retval =  -1;
			}

			break;
		}
		case VSC_IOC_GET_V2GFRAMEBUFFER:
		{
			VSC_GET_V2GFRAMEBUFFER_T v2gbf;
			if(copy_from_user((void *)&v2gbf, (const void __user *)arg, sizeof(VSC_GET_V2GFRAMEBUFFER_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_V2GFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
#if 0//now have VT,no use V2G,but these code must keep:qiang_zhou
				if(rtk_hal_vsc_GetV2GFramebuffer(v2gbf.wid,v2gbf.pCaptureInfo) == FALSE)
					retval =  -1;
#endif
			}
			break;
		}
		case VSC_IOC_SET_UDINPUT:
		{
			KADP_VIDEO_UD_MODE_T udmode;
			if(copy_from_user((void *)&udmode, (const void __user *)arg, sizeof(udmode)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_UDINPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetUDInput(udmode)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_UDOUTPUT:
		{
			KADP_VIDEO_DDI_DIS_FMT_T disfmt;
			if(copy_from_user((void *)&disfmt, (const void __user *)arg, sizeof(KADP_VIDEO_DDI_DIS_FMT_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_UDOUTPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetUDOutput(disfmt)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_VIDEODELAYEDTIME:
		{
			VSC_GET_VIDEODELAYEDTIME_T vddelaytime;
			unsigned short delaytime = 0;
			if(copy_from_user((void *)&vddelaytime, (const void __user *)arg, sizeof(VSC_GET_VIDEODELAYEDTIME_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_VIDEODELAYEDTIME copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetVideoDelayedTime((VIDEO_WID_T)vddelaytime.wid, &delaytime) == FALSE)
				{
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(vddelaytime.pDelayedTime) , (void *)&delaytime, sizeof(unsigned short)) )
					{
	                	rtd_pr_vsc_err("[ERR] VSC_IOC_GET_VIDEODELAYEDTIME copy_to_user error \n");
						retval = EFAULT;
	            	}
				}
			}
			break;
		}
		case VSC_IOC_SET_TITLEMODE:
		{
			bool bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_TITLEMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetTileMode(bonoff)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_TILEMAXROWVAL:
		{
			VSC_SET_TILEMAXROWVAL_T titlerowval;
			if(copy_from_user((void *)&titlerowval, (const void __user *)arg, sizeof(VSC_SET_TILEMAXROWVAL_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_TILEMAXROWVAL copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetTileMaxRowVal(titlerowval.uMaxRow,titlerowval.uMaxCol)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_TILEID:
		{
			unsigned char titleid;
			if(copy_from_user((void *)&titleid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_TILEID copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetTileID(titleid)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVESTREAM:
		{
			bool bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVESTREAM copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetAdaptiveStream(bonoff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVESTREAMEX:
		{
			VSC_ADAPTIVESTREAM_PARA_T adpstream;

			if(copy_from_user((void *)&adpstream, (const void __user *)arg, sizeof(VSC_ADAPTIVESTREAM_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVESTREAMEX copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetAdaptiveStreamEX((VIDEO_WID_T)adpstream.adaptivestreamwid,adpstream.adaptivestreambonoff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_SOCOUTPUTFMT:
		{
			KADP_VIDEO_UD_MODE_T socoutputfmt;
			if(copy_from_user((void *)&socoutputfmt, (const void __user *)arg, sizeof(KADP_VIDEO_UD_MODE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SOCOUTPUTFMT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetSOCOutputFMT(socoutputfmt) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_FRCTYPE:
		{
			unsigned char  frctype;
			if(copy_from_user((void *)&frctype, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_FRCTYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetFRCType(frctype) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_FRCTYPE:
		{
			unsigned char frctypeget;
			if(copy_from_user((void *)&frctypeget, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_FRCTYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetFRCType(frctypeget) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_GETMVOPSTATUS:
		{
			VSC_GET_GETMVOPSTATUS_T mvopstatus;
			BOOLEAN MVOPEnable = FALSE;
			if(copy_from_user((void *)&mvopstatus, (const void __user *)arg, sizeof(VSC_GET_GETMVOPSTATUS_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_GETMVOPSTATUS copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetMVOPStatus((VIDEO_WID_T)mvopstatus.wid, &MVOPEnable) == FALSE)//Current not use
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_VENCI3DDMA:
		{
			IDMA_DISPD_CAPTURE_INFO capInfo;
			if(copy_from_user((void *)&capInfo, (const void __user *)arg, sizeof(IDMA_DISPD_CAPTURE_INFO)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_VENCI3DDMA copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				drvif_I3DDMA_dispD_to_IdmaVI_idmaConfig(capInfo);
			}
			break;
		}
		case VSC_IOC_STOPVO:
		{
			/*
			down(get_vo_infosemaphore());
			set_vo_change_flag(TRUE);
   			memset(Get_VO_Dispinfo(), 0, sizeof(StructDisplayInfo));
			up(get_vo_infosemaphore());
			*/
			break;
		}
		case VSC_IOC_GETINPUTINFO:
		{
			VSC_GET_INPUT_INFO info;
			SCALER_INPUT_INFO input_info = {0, 0, 0, 0, 0, 0};
			if(copy_from_user((void *)&info, (const void __user *)arg, sizeof(VSC_GET_INPUT_INFO )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GETINPUTINFO copy_from_user failed!!!!!!!!!!!!!!!\n");
			}

			rtd_pr_vsc_err("[FRANK]iINFO1 VSC_IOC_GETINPUTINFO %x \n",info.wid);
			if (info.wid == KADP_VIDEO_WID_0) {
				state_update_disp3d_info();
				I3DDMA_Parse_HDMI3D_pattern();
				switch(Get_DisplayMode_Src(SLR_MAIN_DISPLAY))
				{
#ifdef CONFIG_SUPPORT_SRC_ADC
					case KADP_VSC_INPUTSRC_ADC:
						down(get_adc_detectsemaphore());
						p_adc_dispinfo = Get_ADC_Dispinfo();
						input_info.inputWid = p_adc_dispinfo->IPH_ACT_WID_PRE;
						input_info.inputLen = p_adc_dispinfo->IPV_ACT_LEN_PRE;
		           		input_info.capWid = p_adc_dispinfo->IPH_ACT_WID_PRE;
		           		input_info.capLen = p_adc_dispinfo->IPV_ACT_LEN_PRE;
						input_info.inputFramerate = p_adc_dispinfo->IVFreq;
						input_info.interlace = (p_adc_dispinfo->disp_status&_BIT8)>>8;
						up(get_adc_detectsemaphore());
						break;
#endif
					case KADP_VSC_INPUTSRC_HDMI:
/*
						newbase_hdmi_get_timing(newbase_hdmi_get_current_display_port(), &hdmi_timing_info);
						input_info.inputWid = hdmi_timing_info.h_act_len;
						input_info.inputLen = hdmi_timing_info.v_act_len;
		           		input_info.capWid = hdmi_timing_info.h_act_len;
		           		input_info.capLen = hdmi_timing_info.v_act_len;
						input_info.inputFramerate = hdmi_timing_info.v_freq;
*/
#ifdef USE_NEW_HDMI_TIMING_INFO_STRUCTURE
						drvif_Hdmi_GetRawTimingInfo(&hdmi_timing_info);
						input_info.inputWid = hdmi_timing_info.h_act_len;
						input_info.inputLen = hdmi_timing_info.v_act_len;
						input_info.capWid = hdmi_timing_info.h_act_len;
						input_info.capLen = hdmi_timing_info.v_act_len;
						input_info.inputFramerate = Scaler_Get_HDMI_VFREQ(hdmi_timing_info.v_freq);
						input_info.interlace = hdmi_timing_info.is_interlace;
#else
						hdmi_timing_info.port = drvif_Hdmi_GetCurrentPhysicalPort();
						vfe_hdmi_drv_get_port_timing_info(&hdmi_timing_info);
						input_info.inputWid = hdmi_timing_info.active.w;
						input_info.inputLen = hdmi_timing_info.active.h;
						input_info.capWid = hdmi_timing_info.active.w;
						input_info.capLen = hdmi_timing_info.active.h;
						input_info.inputFramerate = hdmi_timing_info.v_freq;
						input_info.interlace = !hdmi_timing_info.scan_type;
#endif
						break;

					case KADP_VSC_INPUTSRC_AVD:
						ptLGETimingInfo = Get_AVD_LGETiminginfo();
						input_info.inputWid = ptLGETimingInfo->active.w;
						input_info.inputLen = ptLGETimingInfo->active.h/2;
						input_info.capWid = ptLGETimingInfo->active.w;
						input_info.capLen = ptLGETimingInfo->active.h/2;
						input_info.inputFramerate = ptLGETimingInfo->vFreq;
						input_info.interlace = !ptLGETimingInfo->scanType;
						break;

					default:
						rtd_pr_vsc_err("[FRANK]iINFO2 VSC_IOC_GETINPUTINFO \n");
						input_info.inputWid = 0;
						input_info.inputLen = 0;
		           		input_info.capWid = 0;
		           		input_info.capLen = 0;
						input_info.inputFramerate = 0;
						input_info.interlace = 0;
						break;
				}
				if (copy_to_user(to_user_ptr(info.inputInfo), (void *)&input_info, sizeof(SCALER_INPUT_INFO)) )
				{
	                rtd_pr_vsc_err("[ERR] VSC_IOC_GETINPUTINFO main copy_to_user error \n");
					retval = EFAULT;
	            }
			} else {
				if(DbgSclrFlgTkr.Sub_OutputVencMode && (Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)) {
					ptLGETimingInfo = Get_AVD_LGETiminginfo();
					input_info.inputWid = ptLGETimingInfo->active.w;
					input_info.inputLen = ptLGETimingInfo->active.h/2;
					input_info.capWid = sub_dispwin.src_wid;
					input_info.capLen = sub_dispwin.src_height;
					input_info.inputFramerate = ptLGETimingInfo->vFreq;
					input_info.interlace = !ptLGETimingInfo->scanType;
				} else {
					rtd_pr_vsc_err("[FRANK]iINFO3 VSC_IOC_GETINPUTINFO %x, %x\n",DbgSclrFlgTkr.Sub_OutputVencMode, (Get_DisplayMode_Src(SLR_SUB_DISPLAY)));
					input_info.inputWid = 0;
					input_info.inputLen = 0;
					input_info.capWid = 0;
					input_info.capLen = 0;
					input_info.inputFramerate = 0;
					input_info.interlace = 0;
				}
				if (copy_to_user(to_user_ptr(info.inputInfo), (void *)&input_info, sizeof(SCALER_INPUT_INFO)) )
				{
	                rtd_pr_vsc_err("[ERR] VSC_IOC_GETINPUTINFO sub copy_to_user error \n");
					retval = EFAULT;
	            }
			}
			break;
		}
		case VSC_IOC_SHOWOSDSAMPLE:
		{
			// Sync from Demo version.
#if 0
			unsigned char bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SHOWOSDSAMPLE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_showosdsample(bonoff) == FALSE)
					retval =  -1;
			}
#endif
			retval =  -1;
			break;
		}
		case VSC_IOC_GETPANELSIZE:
		{
			VSC_PANEL_SIZE_T  panel_size;
			panel_size.display_wid = _DISP_WID;
			panel_size.display_len = _DISP_LEN;
			if(copy_to_user((void __user *)arg, (void *)&panel_size, sizeof(VSC_PANEL_SIZE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GETPANELSIZE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			break;
		}
		case VSC_IOC_SET_DOLBYVISION_IDMA_ENABLE:
		{

			break;
		}
		case VSC_IOC_SETZORDER:
		{
			VSC_SET_ZORDER_T zorderNO[2];
			if(copy_from_user((void *)zorderNO, (const void __user *)arg, 2*sizeof(VSC_SET_ZORDER_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetZorder(zorderNO[0],zorderNO[1]) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_MAKECOLOREDVIDEO:
		{
			KADP_VSC_VIDEO_COLOR_TYPE_T colorType;

			rtd_pr_vsc_debug("Scaler vsc disp: Get VSC_IOC_MAKECOLOREDVIDEO!!!!!!!\n");

			if(copy_from_user((void *) &colorType, (const void __user *)arg, sizeof(KADP_VSC_VIDEO_COLOR_TYPE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_MAKECOLOREDVIDEO copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_makeColoredVideo(colorType) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_DM_OPEN:
		{
			if(rtk_hal_vsc_dm_open(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_CLOSE:
		{
			if(rtk_hal_vsc_dm_close(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_CONNECT:
		{
			if(rtk_hal_vsc_dm_connect(SLR_MAIN_DISPLAY, KADP_VSC_HDR_AUTO) == FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_DISCONNECT:
		{
			if(rtk_hal_vsc_dm_disconnect(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_ISDOLBYHDR:
		{

			unsigned char isdolbyHdr = 0;
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
			if(Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
				isdolbyHdr = 1;
			else
				isdolbyHdr = 0;
#endif

			if(copy_to_user((void __user *)arg, (void *)&isdolbyHdr, sizeof(unsigned char)))
        		{
           			retval = -EFAULT;
            			rtd_pr_vsc_debug("scaler hdcp2 ioctl code=VSC_IOC_ISDOBLYHDR copy_to_user failed!!!!!!!!!!!!!!!\n");
            			break;
        		}

			break;
		}

		case VSC_IOC_UPDATE_ADAPTIVE_STREAMING_INFO:
		{//no use
			break;
		}

		case VSC_IOC_NOTICE_GST_VO_UPDATE:
		{
			VSC_NOTICE_GST_VO_UPDATE_INFO temp_vsc_notice_gst_vo_update;
			unsigned char update_flag = TRUE;
			if(copy_from_user((void *)&temp_vsc_notice_gst_vo_update, (const void __user *)arg, sizeof(VSC_NOTICE_GST_VO_UPDATE_INFO)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_NOTICE_GST_VO_UPDATE copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			update_flag = TRUE;
			if(temp_vsc_notice_gst_vo_update.update_flag)
			{
				if (copy_to_user(to_user_ptr(temp_vsc_notice_gst_vo_update.update_flag), (void *)&update_flag, sizeof(unsigned char)) )
				{
	                rtd_pr_vsc_err("[ERR] VSC_IOC_NOTICE_GST_VO_UPDATE copy_to_user error 1 \n");
					retval = EFAULT;
	            }
			}


			break;
		}

		case VSC_IOC_APP_CONTRO_FORCEBG:
		{//no used
			break;
		}

		case VSC_IOC_HDR_OPEN:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_HDR_OPEN copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			if(wid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_open(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_open(SLR_SUB_DISPLAY) == FALSE)
					return -1;
			}
			break;

		}
		case VSC_IOC_HDR_CLOSE:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_HDR_CLOSE copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}

			if(wid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_close(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_close(SLR_SUB_DISPLAY) == FALSE)
					return -1;
			}
			break;
		}
		case VSC_IOC_HDR_CONNECT:
		{
			KADP_VSC_HDR_INFO_T VSC_HDR_INFO;
			if(copy_from_user((void *)&VSC_HDR_INFO, (const void __user *)arg, sizeof(KADP_VSC_HDR_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_HDR_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}

			if(VSC_HDR_INFO.winid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_connect(SLR_MAIN_DISPLAY, VSC_HDR_INFO.hdrtype) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_connect(SLR_SUB_DISPLAY, VSC_HDR_INFO.hdrtype) == FALSE)
					return -1;
			}

			break;
		}
		case VSC_IOC_HDR_DISCONNECT:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl VSC_IOC_HDR_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}


			if(wid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_disconnect(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_disconnect(SLR_SUB_DISPLAY) == FALSE)
					return -1;
			}
			break;
		}

		case VSC_IOC_SET_SubWinShape:
		{
			//Evance->VSC_SUB_SHAPE_INFO_T
			KADP_VSC_SUB_SHAPE_INFO_T shape_info;
	//		VIDEO_RECT_T  shape_region;
	//		int shape_type;
			if(copy_from_user((void *)&shape_info, (const void __user *)arg, sizeof(KADP_VSC_SUB_SHAPE_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=KADP_VSC_SUB_SHAPE_INFO_T copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				{
					//virtual_x =shape_info.rect.x;
					//virtual_y =shape_info.rect.y;
					true_wide =shape_info.rect.w;
					true_high=shape_info.rect.h;
				if (shape_info.shapeinfo == 0)
					sub_shape_type = VSC_MGF_TYPE_CIRCLE;
				else if (shape_info.shapeinfo == 1)
					sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
				else
					sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
//				subWin_LGowner =1;
#if 0
				rtd_pr_vsc_info("\n ***************************virtual_x = %d", virtual_x);
				rtd_pr_vsc_info("\n ***************************virtual_y = %d", virtual_y);
				rtd_pr_vsc_info("\n ***************************virtual_w = %d", virtual_w);
				rtd_pr_vsc_info("\n ***************************virtual_h = %d", virtual_h);
				rtd_pr_vsc_info("\n ***************************sub_shape_type = %d", sub_shape_type);
#endif
			}
			}

			break;
		}

		case  VSC_IOC_SET_SetSubWinModeEx:
          	{
                       VSC_SET_SUB_WINDOW_MODE_TYPE vsc_set_sub_win_mode;
  //                     int mode_type = 0;
                       //if(copy_from_user((void *)&mode_type, (const void __user *)arg, sizeof(VSC_SUB_MODE_T)))
                       if(copy_from_user((void *)&vsc_set_sub_win_mode, (const void __user *)arg, sizeof(VSC_SET_SUB_WINDOW_MODE_TYPE)))
                       {
                               retval = -EFAULT;
                               rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SetSubWinMode copy_from_user failed!!!!!!!!!!!!!!!\n");
                       }
                       else
                       {
                               /*for testing
                               vsc_set_sub_win_mode.mode = VSC_SUB_MODE_PIP;
                               vsc_set_sub_win_mode.connectType = VSC_SUB_CONNECT_TYPE_MIRROR;
                               vsc_set_sub_win_mode.memoryUse = VSC_SUB_MEMORY_USE_MULTI;

                               rtd_pr_vsc_emerg("[%s][crixus]@@VSC_IOC_SET_SetSubWinMode,mode = %d, connectType = %d, memoryUse = %d\n", __FUNCTION__, vsc_set_sub_win_mode.mode, vsc_set_sub_win_mode.connectType, vsc_set_sub_win_mode.memoryUse);
                               */
                               sub_mode_type = vsc_set_sub_win_mode.mode;//get sub mode

                               //connect type is mirror => livezoom or magnifier
                               if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_MIRROR){

									//disable ST game mode timeout checking task when enter livezoom for quickly switching case @Crixus 20170726
									down(&GameMode_Check_Semaphore);
									if(drv_memory_get_game_mode() == _ENABLE){
										smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
										//smooth_toggle_game_mode_check_cnt = 0;
										rtd_pr_new_game_mode_notice("Disable ST game mode timeout tsk!!(before sub scaler)\n");
									}
									up(&GameMode_Check_Semaphore);
                               }
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
                               //connect type is non-mirror => multi-view or overlay miracast
                               else if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NON_MIRROR){
                                       if((sub_mode_type == VSC_SUB_MODE_EX_PBP)){
                                               //i2rnd_test_done = 1;
                                               rtk_hal_vsc_i2rnd_enable(_ENABLE);
                                               rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
                                       }else if((sub_mode_type == VSC_SUB_MODE_EX_PIP)){
                                               //i2rnd_test_done = 0;
                                               rtk_hal_vsc_i2rnd_enable(_DISABLE);
                                               rtd_pr_vsc_emerg("[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
                                       }
                               }
#endif
#endif

                               else if((vsc_set_sub_win_mode.mode == VSC_SUB_MODE_EX_NONE) && (vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NONE)
                                               && (vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_NONE)){
                                       //exit PIP or PBP app.
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
                                       if((Scaler_I2rnd_get_enable() == _ENABLE)){
                                               //disable i2run mode
                                               //i2rnd_test_done = 0;
                                               i2rnd_send_table_idx(I2RND_TABLE_OFF);
                                               rtk_hal_vsc_i2rnd_enable(_DISABLE);
                                               //frank@I2run disable main VENC flag
                                               VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
                                               DbgSclrFlgTkr.OutputVencMode = FALSE;
                                               vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
                                               vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
                                               //apvr_request_run_main_path();
                                               rtd_pr_vsc_emerg("[%s][frank]I2RND close\n", __FUNCTION__);
                                       }
#endif
#endif
                               }
                       }
                       break;
               }

		case  VSC_IOC_SET_SetSubWinMode:
		{
			int mode_type = 0;


			if(copy_from_user((void *)&mode_type, (const void __user *)arg, sizeof(KADP_VSC_SUB_MODE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SetSubWinMode copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_emerg("[%s][crixus]@@VSC_IOC_SET_SetSubWinMode, mode_type = %d\n", __FUNCTION__, (unsigned int)mode_type);
				sub_mode_type = mode_type;//get sub mode
#if 0//def CONFIG_I2RND_ENABLE
				if((i2rnd_test_done == 0) && (sub_mode_type == VSC_SUB_MODE_PBP)){
					i2rnd_test_done = 1;
					rtk_hal_vsc_i2rnd_enable(_ENABLE);
					rtd_pr_vsc_emerg("[%s][crixus]I2RND initial done\n", __FUNCTION__);
				}else if((i2rnd_test_done == 1) && (sub_mode_type == VSC_SUB_MODE_PIP)){
					i2rnd_test_done = 0;
					rtk_hal_vsc_i2rnd_enable(_DISABLE);
					rtd_pr_vsc_emerg("[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
				}
#endif
			}
			break;
		}

		case  VSC_IOC_SET_SetSubWinPurpose:
		{
			KADP_VSC_SUB_PURPOSE_T purpose_type;


			if(copy_from_user((void *)&purpose_type, (const void __user *)arg, sizeof(KADP_VSC_SUB_PURPOSE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_SetSubWinPurpose copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				//Set_Magnifier_LiveZoom_Mode(purpose_type);
				rtd_pr_vsc_emerg("[qiangzhou]@@VSC_IOC_SET_SetSubWinPurpose, purpose_type = %d\n", (unsigned int)purpose_type);

			}
			break;
		}

		case  VSC_IOC_SET_SetDelayBuffer:
		{
			VSC_SET_DELAY_BUFFER_TYPE delay_buffer_type;


			if(copy_from_user((void *)&delay_buffer_type, (const void __user *)arg, sizeof(VSC_SET_DELAY_BUFFER_TYPE)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_SET_DELAY_BUFFER_TYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtk_hal_vsc_SetDelayBuffer(delay_buffer_type.window, delay_buffer_type.buffer);
				rtd_pr_vsc_info("VSC_SET_DELAY_BUFFER_TYPE, delay_buffer_type.window = %d\n", (unsigned int)delay_buffer_type.window);
				rtd_pr_vsc_info("VSC_SET_DELAY_BUFFER_TYPE, delay_buffer_type.buffer = %d\n", (unsigned int)delay_buffer_type.buffer);

			}
			break;
		}

		case VSC_IOC_GET_BLACDETECTION_INFO_T:
		{
			//static unsigned int cnt;
			//rtd_pr_vsc_info("Enter VSC_IOC_GET_BLACDETECTION_INFO_T\n");
			VSC_GET_BLACDETECTION_INFO_T BLACKDETECTION_INFO;
			VIP_BlackDetectionInfo vip_info;

			BLACKDETECTION_INFO.ready_flag = fwif_color_get_black_detection_info_tv006(&vip_info);

			memcpy(&(BLACKDETECTION_INFO.window.original), &(vip_info.OriRegion), sizeof(VIDEO_RECT_T));
			memcpy(&(BLACKDETECTION_INFO.window.active), &(vip_info.ActRegion), sizeof(VIDEO_RECT_T));
			BLACKDETECTION_INFO.connectwid = BLK_WID;//Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL);

			if (copy_to_user((void __user *)arg, (void *)&BLACKDETECTION_INFO, sizeof(VSC_GET_BLACDETECTION_INFO_T))) {
				retval = -EFAULT;
				rtd_pr_vsc_err("kernel VSC_IOC_GET_BLACDETECTION_INFO_T fail\n");
			}
			#if 0
			if (cnt % 600 == 0)
				rtd_pr_vsc_info("BLACKDETECTION_INFO.window = %d, %d %d %d, %d %d %d %d\n", BLACKDETECTION_INFO.window.original.x,BLACKDETECTION_INFO.window.original.y,BLACKDETECTION_INFO.window.original.w,BLACKDETECTION_INFO.window.original.h,BLACKDETECTION_INFO.window.active.x,BLACKDETECTION_INFO.window.active.y,BLACKDETECTION_INFO.window.active.w,BLACKDETECTION_INFO.window.active.h);
			cnt ++;
			#endif
			break;

		}
		case VSC_IOC_SET_BLACDETECTION_EN:
		{
			VSC_SET_BLACDETECTION_INFO_T BLK_Info;
			unsigned char bEnable_main = 0;
			unsigned char bEnable_sub = 0;
			if(copy_from_user((void *)&BLK_Info, (const void __user *)arg, sizeof(VSC_SET_BLACDETECTION_INFO_T))) {
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_BLACDETECTION_EN copy_from_user failed!!!!!!!!!!!!!!!\n");
			} else {
				rtd_pr_vsc_info("1. wId=%d, EN=%d, bEnable_main=%d, bEnable_sub=%d",BLK_Info.connectwid,BLK_Info.enable,bEnable_main,bEnable_sub);
				if (BLK_Info.enable == TRUE) {
					if (BLK_Info.connectwid == VIDEO_WID_0) {
						bEnable_main = 1;
						BLK_WID = VIDEO_WID_0;
					}
					else if (BLK_Info.connectwid == VIDEO_WID_1) {
						BLK_WID = VIDEO_WID_1;
						bEnable_sub = 1;
					}
					else
						retval = -EFAULT;
				} else {

					if (BLK_Info.connectwid == VIDEO_WID_0)
						bEnable_main = 0;
					else if (BLK_Info.connectwid == VIDEO_WID_1)
						bEnable_sub = 0;
					else
						retval = -EFAULT;

				}
				rtd_pr_vsc_info("2. wId=%d, EN=%d, bEnable_main=%d, bEnable_sub=%d",BLK_Info.connectwid,BLK_Info.enable,bEnable_main,bEnable_sub);
#ifndef UT_flag
				scalerVIP_Set_BlackDetection_EN(bEnable_main, bEnable_sub);
#endif // #ifndef UT_flag
			}
			break;

		}
		case VSC_IOC_RotateVideo:
		{
			KADP_VSC_ROTATE_T rotate_type;
			if(copy_from_user((void *)&rotate_type, (const void __user *)arg, sizeof(KADP_VSC_ROTATE_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_RotateVideo copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
				down(&SetMainOutPutRegion_Semaphore);
				main_rotate_mode_pre = main_rotate_mode;
				main_rotate_mode = (DIRECT_VO_FRAME_ORIENTATION)rotate_type;
				up(&SetMainOutPutRegion_Semaphore);
#endif
			}
			break;
		}

		case VSC_IOC_SetVideoPattern:
        	{
         		VSC_VIDEO_PATTERN_LOCATION_TYPE vsc_pattern_type;
         		if(copy_from_user((void *)&vsc_pattern_type, (const void __user *)arg, sizeof(VSC_VIDEO_PATTERN_LOCATION_TYPE))) {
                 		retval = -EFAULT;
                 		rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SetVideoPattern copy_from_user failed!!!!!!!!!!!!!!!\n");
         		} else {
                 		rtk_hal_vsc_SetPattern(vsc_pattern_type.on_off, vsc_pattern_type.window, vsc_pattern_type.pattern_location);
         		}
         		break;
		}

		case VSC_IOC_GetLimitedWindow:
		{
			VSC_GET_LIMIT_WINDOW_T info;
			KADP_VSC_SCALER_RATIO_T input_info = {0, 0, 0, 0};

			if(copy_from_user((void *)&info, (const void __user *)arg, sizeof(VSC_GET_LIMIT_WINDOW_T )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_GetLimitedWindow copy_from_user failed!!!!!!!!!!!!!!!\n");
			}

			input_info.h_scaledown_ratio = 32;
			input_info.v_scaledown_ratio = 32;
			input_info.h_scaleup_ratio = 256;
			input_info.v_scaleup_ratio = 256;

			if (copy_to_user(to_user_ptr(info.limit_window), (void *)&input_info, sizeof(KADP_VSC_SCALER_RATIO_T)) )
			{
	                	rtd_pr_vsc_err("[ERR] VSC_IOC_GetLimitedWindow main copy_to_user error \n");
				retval = EFAULT;
	            }
			break;
		}

		case VSC_IOC_SET_INPUTREGION_EX:
		{
			VSC_SET_FRAME_REGION_EX_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_EX_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_INPUTREGION_EX copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetInputRegionEx((VIDEO_WID_T)frameregion.setframewid, frameregion.inregion, frameregion.originalInput) == FALSE)
					retval =  -1;
			}
			break;
		}

		case VSC_IOC_SET_UZD_PATH:
		{
			unsigned char i3dma_uzd = 0;
			if(copy_from_user((void *)&i3dma_uzd, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_SET_UZD_PATH copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				if(vsc_set_uzd_path(i3dma_uzd) == FALSE)
					retval =  -1;
			}
			break;
		}

		case VSC_IOC_WAIT_MUTEOFF_QUEUE:
		{
			unsigned char winid = 0;
			wait_event_freezable(MUTEOFF_CB_WAIT_QUEUE, sub_muteoff_cb_trigger || main_muteoff_cb_trigger);
			if(main_muteoff_cb_trigger)
			{
				down(&muteoff_cb_sem);
				main_muteoff_cb_trigger = FALSE;
				up(&muteoff_cb_sem);
				winid |= WIN_MAIN_ONLY;//main path mute off
			}
			if(sub_muteoff_cb_trigger)
			{
				down(&muteoff_cb_sem);
				sub_muteoff_cb_trigger = FALSE;
				up(&muteoff_cb_sem);
				winid |= WIN_SUB_ONLY;//sub path mute off
			}
			if(copy_to_user((void __user *)arg, (void *)&winid, sizeof(unsigned char)))
			{
				rtd_pr_vsc_err("[ERR] VSC_IOC_WAIT_MUTEOFF_QUEUE copy_to_user error \n");
				retval = EFAULT;
			}
			break;
		}
		case VSC_IOC_VDO_CONNECT:
		{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
            VSC_CONNECT_PARA_T connectPara;
            rtd_pr_vsc_debug("\033[10;32m [%s:%d]:VSC_IOC_VDO_CONNECT \033[0m \n", __FUNCTION__, __LINE__);
            if(copy_from_user((void *)&connectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
            {
                retval = -EFAULT;
                rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_VDO_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
            }
            else
            {

				if(!vdo_connect((unsigned char)connectPara.connectwid, (unsigned char)connectPara.vsc_input.resourceIndex))
				{
					retval =  -1;
				}

            }
#endif
            break;
		}
		case VSC_IOC_VDO_DISCONNECT:
		{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
                VSC_CONNECT_PARA_T disconnectPara;
                rtd_pr_vsc_debug("\033[10;32m [%s:%d]:VSC_IOC_VDO_DISCONNECT \033[0m \n", __FUNCTION__, __LINE__);
                if(copy_from_user((void *)&disconnectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
                {
                    retval = -EFAULT;
                    rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_VDO_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
                }
                else
                {
					vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                }
#endif
                break;
		}

		case VSC_IOC_SetVideoLatencyPattern:
		{
			VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern;

			if(copy_from_user((void *)&set_video_latency_pattern, (const void __user *)arg, sizeof(VSC_VIDEO_LATENCY_PATTERN_T )))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SetVideoLatencyPattern copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				set_latency_pattern_info(set_video_latency_pattern);
			}
			break;
		}

		case VSC_IOC_Set_VD_PTG:
		{
			unsigned char bOnOff = 0;
			if(copy_from_user((void *)&bOnOff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_Set_VD_PTG copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				if(vsc_set_vd_ptg(bOnOff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_UZD_CRC:
		{
			VSC_UZD_CRC pUZD_CRC;
			unsigned int iCRC_Result = 0;
			if(copy_from_user((void *)&pUZD_CRC, (const void __user *)arg, sizeof(VSC_UZD_CRC)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_GET_UZD_CRC copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				if(vsc_get_uzu_crc((VIDEO_WID_T)pUZD_CRC.wid,&iCRC_Result) == FALSE)
					retval =  -1;
				else{
					pUZD_CRC.CRC_Result= iCRC_Result;
					if(copy_to_user((void __user *)arg, &pUZD_CRC, sizeof(VSC_UZD_CRC)))
					{
						retval = -EFAULT;
						rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_GET_UZD_CRC copy_to_user failed!!!!!!!!!!!!!!!\n");
					}
				}
			}
			break;
		}
		case VSC_IOC_SET_DRIVER_PATTERN:
		{
			break;

		}
		case VSC_IOC_SET_DRIVER_TABLE:
		{
			break;

		}

		case VSC_IOC_SET_WINBLANK_SYNC_MEMC:
		{//this is for mute on to sync memc ready
			VSC_WINBLANK_PARA_T winblankpara;
			if(copy_from_user((void *)&winblankpara, (const void __user *)arg, sizeof(VSC_WINBLANK_PARA_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_WINBLANK_SYNC_MEMC copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_pr_vsc_debug("winblankpara.winblankwid=%d,winblankpara.winblankbonoff=%d,winblankpara.winblankcolor=%d\n", winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor);

				//These are for mute on to wait memc already blck video
				sync_memc_ready = TRUE;//if TRUE. when mute on to wait memc buffer

				if(rtk_hal_vsc_SetWinBlank((VIDEO_WID_T)winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor) == FALSE)
					retval =  -1;
				//These are for mute on to wait memc already blck video
				sync_memc_ready = FALSE;//if TRUE. when mute on to wait memc buffer
			}
			break;
		}



		case VSC_IOC_SET_INPUT_OUTPUT:
		{//this is for new input output hal
			KADP_ARC_INFO_T ARC_info;
			if(copy_from_user((void *)&ARC_info, (const void __user *)arg, sizeof(KADP_ARC_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl code=VSC_IOC_SET_INPUT_OUTPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{

				if(rtk_hal_vsc_SetInputRegion_OutputRegion(ARC_info.wid, ARC_info.rotation, ARC_info.input, ARC_info.original_input, ARC_info.ouput, ARC_info.null_input, ARC_info.null_output) == FALSE)
					retval =  -1;
			}
			break;
		}


		case VSC_IOC_SetSplitInfoForHDMI:
		{
			KADP_HAL_VSC_SPLIT_INFO_T splitInfo;
			if(copy_from_user((void *)&splitInfo, (const void __user *)arg, sizeof(KADP_HAL_VSC_SPLIT_INFO_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_err("scaler vsc ioctl code=VSC_IOC_SetSplitInfoForHDMI copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetSplitInfoForHDMI() == FALSE)
					retval =  -1;
			}
			break;

		}
		case VSC_IOC_WAIT_NOTIFY_WIN_DELAY:
		{
			KADP_SCALER_WIN_CALLBACK_DELAY_INFO scaler_win_delay_cb_info = {0};
			unsigned long flags = 0;
			wait_event_freezable(WIN_DELAY_CB_WAIT_QUEUE, delay_info_cb_trigger);
			if(delay_info_cb_trigger)
			{
				spin_lock_irqsave(get_delay_info_cb_spin_lock(), flags);
				delay_info_cb_trigger = FALSE;
				spin_unlock_irqrestore(get_delay_info_cb_spin_lock(), flags);
				update_win_apply_delay_info_for_cb(SLR_MAIN_DISPLAY, &scaler_win_delay_cb_info);
			}
			if(copy_to_user((void __user *)arg, (void *)&scaler_win_delay_cb_info, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO)))
			{
				rtd_pr_vsc_err("[ERR] VSC_IOC_WAIT_NOTIFY_WIN_DELAY copy_to_user error \n");
				retval = EFAULT;
			}

			break;
		}

		case VSC_IOC_SET_HFRMode:
		{
			unsigned char bOnOff;
			if(copy_from_user((void *)&bOnOff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SET_HFRMode copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				set_HFR_mode(bOnOff);
			}
			break;
		}
		case VSC_IOC_SET_DUALDECODER:
		{
			unsigned char dual_decoder_flag = 0;
			if(copy_from_user((void *)&dual_decoder_flag, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_emerg( "scaler vsc ioctl code=VSC_IOC_SET_DUALDECODER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				rtk_hal_vsc_Setdualdecoder(dual_decoder_flag);
			}
			break;
		}

		case VSC_IOC_SUBSCRIBE_VIDEO_DELAY:
		{
			VSC_GET_SCALER_VIDEO_DELAY_T delay_result;
			unsigned int video_delay = 0;
			if(copy_from_user((void *)&delay_result, (const void __user *)arg, sizeof(VSC_GET_SCALER_VIDEO_DELAY_T)))
			{
				retval = -EFAULT;
				rtd_pr_vsc_debug("scaler vsc ioctl code=VSC_IOC_SUBSCRIBE_VIDEO_DELAY copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
#ifndef UT_flag
				if(rtk_hal_vsc_scaler_check_video_delay((VIDEO_WID_T)delay_result.wid, &video_delay) == FALSE){
					retval = -1;
				}else
#endif // #ifndef UT_flag
				{
					delay_result.get_delay_Result = video_delay;
					if (copy_to_user((void __user *)arg, &delay_result, sizeof(VSC_GET_SCALER_VIDEO_DELAY_T)) )
					{
						rtd_pr_vsc_err(	"[ERR] VSC_IOC_SUBSCRIBE_VIDEO_DELAY copy_to_user error \n");
						retval = EFAULT;
					}
				}
			}
			break;
		}
		case VSC_IOC_SET_VCOMFLAG:
		{
			if(copy_from_user((void *)&vcom_flag, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_VCOMFLAG copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC_IOC_SET_VCOMFLAG=%x\n", vcom_flag);
			}
			break;
		}

		default:
			rtd_pr_vsc_debug("Scaler vsc disp: ioctl code = %d is invalid!!!!!!!!!!!!!!!1\n", cmd);
			break ;
		}
	return retval;


}

#if defined(CONFIG_COMPAT) && defined(CONFIG_ARM64)
long vsc_compat_ioctl(struct file *file, unsigned int cmd,  unsigned long arg)
{
	return vsc_ioctl(file,cmd,arg);
}
#endif

#define REGULAR_PST_VIDEO_DELAY 1

void Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region(KADP_VIDEO_RECT_T  OutputRegion)
{
	UINT32 framePeriod = 0;
	framePeriod =16;

	g_scaler_win_delay_cb_info.wid = 0;
	g_scaler_win_delay_cb_info.delayTime = framePeriod;
	g_scaler_win_delay_cb_info.OutputRegion.x = OutputRegion.x;
	g_scaler_win_delay_cb_info.OutputRegion.y = OutputRegion.y;
	g_scaler_win_delay_cb_info.OutputRegion.w = OutputRegion.w;
	g_scaler_win_delay_cb_info.OutputRegion.h = OutputRegion.h;
	g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 1;

	rtd_pr_vsc_notice("[Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region] (%x.%x.%x.%x.%d)\n", g_scaler_win_delay_cb_info.OutputRegion.x,g_scaler_win_delay_cb_info.OutputRegion.y,
		g_scaler_win_delay_cb_info.OutputRegion.w, g_scaler_win_delay_cb_info.OutputRegion.h, framePeriod);

	wakeup_window_delay_info_callback(SLR_MAIN_DISPLAY,FALSE);
}

void Scaler_Reset_ForceUpdate_Callback_Delay_Info(void)
{
	g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 0;
	memset((void*) &g_scaler_win_delay_cb_info, 0, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO));
}


void Scaler_Fulfill_Callback_Delay_Info(KADP_SCALER_WIN_CALLBACK_DELAY_INFO *pCallBack_info)
{
	SCALER_WIN_CALLBACK_DELAY_INFO* pPstDelaySetting = NULL;
	UINT32 framePeriod = 0;
	SLR_VOINFO* pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
	extern SCALER_WIN_CALLBACK_DELAY_INFO* Scaler_Get_Pst_Window_Delay_Setting(void);
	extern void Scaler_Reset_Pst_Window_Delay_Setting(void);

	pPstDelaySetting = Scaler_Get_Pst_Window_Delay_Setting();

	if((pPstDelaySetting)&&(pPstDelaySetting->validinfo)){
		Scaler_Reset_Pst_Window_Delay_Setting();

		//rtd_pr_vsc_notice("pVOInfo->v_freq=%d \n", pVOInfo->v_freq);

		framePeriod = ((100000/pVOInfo->v_freq)*REGULAR_PST_VIDEO_DELAY)/10;

		if(pCallBack_info){
			pCallBack_info->wid = 0;
			pCallBack_info->delayTime = framePeriod;
			pCallBack_info->OutputRegion.x = pPstDelaySetting->region_x;
			pCallBack_info->OutputRegion.y = pPstDelaySetting->region_y;
			pCallBack_info->OutputRegion.w = pPstDelaySetting->region_w;
			pCallBack_info->OutputRegion.h = pPstDelaySetting->region_h;
		}
		#if 0
		rtd_pr_vsc_notice("[Scaler_Fulfill_Callback_Delay_Info] (%x.%x.%x.%x.%d)\n", pPstDelaySetting->region_x,pPstDelaySetting->region_y,
			pPstDelaySetting->region_w, pPstDelaySetting->region_h, framePeriod);
		#endif
	}
}

void Convert_Timing_To_fs_Depend_datafs(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY) {
		if ((drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC)
			&& (1==Scaler_get_data_framesync(SLR_MAIN_DISPLAY))
			&& !((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) && (Get_DISPLAY_PANEL_CUSTOM_INDEX() == VBY_ONE_PANEL_COMMERCIAL_4K2K_600M_1S_8L_DUPLICATE)))
		{ //data frc change to data fs,display timing need change
			modestate_set_fll_running_flag(_DISABLE);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			Scaler_Set_Display_Timing_Mode(DISPLAY_MODE_FRAME_SYNC);
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC,TRUE);
			rtd_pr_vsc_info("Convert_Timing_To_fs_Depend_datafs:framesync\n");
		}
	}
}

extern void i2rnd_debug(void);
static bool vsc_tsk_running_flag = FALSE;//Record vsc_scaler_tsk status. True: Task is running
static struct task_struct *p_vsc_tsk = NULL;

void scaler_main_sub_test(void)
{
	static int isOpend=0;
	static int step=0;
	// subpath
	KADP_VSC_INPUT_SRC_INFO_T InputsourceInfo = {KADP_VSC_INPUTSRC_MAXN, 0 , 0};
	KADP_VIDEO_RECT_T  outregion;
	VIDEO_RECT_T inregion,oriregion;
	int hdmi_source_w = 0;
	int hdmi_source_h = 0;

	if(isOpend==0){
		InputsourceInfo.type = KADP_VSC_INPUTSRC_HDMI;
		rtk_hal_vsc_open(VIDEO_WID_1);
		rtk_hal_vsc_Connect(VIDEO_WID_1, InputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
		isOpend=1;
	}

	hdmi_source_w = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID);
	hdmi_source_h = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN);

#if 1
	inregion.x = step;
	inregion.y = 0;
#endif
	inregion.w = hdmi_source_w/2;/*default*/
	inregion.h = hdmi_source_h/2;/*default*/

	oriregion.w = hdmi_source_w;/*default*/
	oriregion.h = hdmi_source_h;/*default*/

#if 1
 	outregion.x = 0;
#else
	outregion.x = 0+step;
#endif
	outregion.y = 0;
	outregion.w = 960;
	outregion.h = 540;

	rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, inregion, oriregion);
	rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, outregion, 0, 0);
	rtk_hal_vsc_SetWinBlank(VIDEO_WID_1, 0, KADP_VIDEO_DDI_WIN_COLOR_BLACK);

	//msleep(1000);//1 ok
	step=step+96;
	if(step>960)
		step=0;


}

#ifdef CONFIG_RTK_KDRV_DV
void dolby_vision_parser_vsem_packet(bool set_type)
{
	int port;
	//enum VSEM_PACKET_SIZE { MAX_EM_HDR_INFO_LEN = 736 };
	for (port = 0; port < 4; ++port) {
		extern unsigned char newbase_hdmi_get_current_display_port(void);
		extern unsigned char newbase_hdmi_get_dolby_vsem_infoframe(unsigned char port, unsigned char *p_vsem);
		extern HDMI_PORT_INFO_T hdmi_rx[HDMI_PORT_TOTAL_NUM];
		int vsem_type = 0;
		char dolby_vsem_packet[MAX_EM_HDR_INFO_LEN] = { 0 };

		if (newbase_hdmi_get_dolby_vsem_infoframe(port, dolby_vsem_packet)) {
			bool apply_setting = (port == newbase_hdmi_get_current_display_port());
			int result = dolby_adapter_handle_vsem_packet(dolby_vsem_packet, MAX_EM_HDR_INFO_LEN, apply_setting);

			rtd_pr_vsc_debug("[DolbyVision][%s:%d] get vsem packet\n", __func__, __LINE__);
			vsem_type = (result > 0) ? result : 0;
		}

		if (set_type && (vsem_type || hdmi_rx[port].no_dolby_vsem_emp_cnt > 1)) {
			rtd_pr_vsc_debug("[DolbyVision][%s:%d] set vsem type\n", __func__, __LINE__);
			dolby_adapter_set_dolby_vsem_type(port, vsem_type);
		}
	}
}
#endif

static int vsc_scaler_tsk(void *p)//This task run scaler or check signal stable or not
{
    unsigned short vsc_task_alive_print = 200;//4 second

	StructSrcRect winSrcRect;
	VSC_INPUT_TYPE_T srctype;
	int timeout, filmDetect_timeout;
	unsigned char port;
#ifdef CONFIG_ENABLE_HDMI_NN
	unsigned ulNNYAddr = 0, ulNNCAddr = 0, ulCropYAddr = 0, ulCropCAddr = 0;
#endif

#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
	static int ld_debug_cnt=0;
#endif
#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif // #ifndef UT_flag
	rtd_pr_vsc_debug("vsc_scaler_tsk()\n");
    set_freezable();

/*    struct cpumask vsc_cpumask;
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);*/

    while (1)
    {
		msleep(10);

       if (freezing(current))
        {//for some continue case
        	update_vsc_task_status(1, VSC_FREEZE_DISABLE_MAIN_IP);
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
			update_vsc_task_status(0, VSC_FREEZE_DISABLE_MAIN_IP);
#ifdef CONFIG_DUAL_CHANNEL
			update_vsc_task_status(1, VSC_FREEZE_DISABLE_SUB_IP);
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
			update_vsc_task_status(0, VSC_FREEZE_DISABLE_SUB_IP);
#endif
			try_to_freeze();
        }

		check_enable_data_access_background();

		if(vsc_task_alive_print == 0)
		{
			rtd_pr_vsc_info(" vsc_scaler_tsk alive \n");
			vsc_task_alive_print = 200;//print alive 4 second
		}
		else
		{
			vsc_task_alive_print--;
		}
#ifdef CONFIG_DYNAMIC_PANEL_SELECT
        check_dlg_mode();
        //print dlg info
        printf_dlg_msg();
#endif
		fwif_color_framerate_detect();

		output_data_access_data();//print data access data

		if(vbe_disp_orbit_get_vo_overscan()==1 ){

			vbe_disp_orbit_set_vo_overscan(0);
			if(!(IoReg_Read32(VGIP_VGIP_VBISLI_reg)&_BIT26)){

				if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					vbe_disp_orbit_sub_overscan();
				}
                else
				{
					vbe_disp_orbit_set_sub_overscan(0);
				}

				if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					&& !(SCALEUP_D_UZU_Globle_Ctrl_get_patgen_sel(IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg)))
					&&(main_rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_0)
					)
				{
#ifndef UT_flag
					if(ScalerCheckOrbitFinish())
						vbe_disp_orbit_vo_overscan();
#endif // #ifndef UT_flag
				}
				else
				{
					SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
					orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
					orbit_shift_info->orbit_enable = 0;
					orbit_shift_info->active_state = 0;
				}

				vbe_disp_orbit_set_osd_overscan(1);

				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
				{
#ifndef UT_flag
					unsigned int counter  = 5;
					while(counter && !(ScalerCheckOrbitFinish()))
					{
						msleep(10);
						counter--;
					}
					rtd_pr_vsc_info("wait orbit ready counter:%d\n", counter);
#endif // #ifndef UT_flag
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
					trigger_mute_off(SLR_MAIN_DISPLAY, 1);
				}
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
				{
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
					trigger_mute_off(SLR_SUB_DISPLAY, 1);
				}
			}
		}
		else if(vbe_disp_orbit_get_frc_overscan()==1  ){

			vbe_disp_orbit_set_frc_overscan(0);

			if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
			{
				vbe_disp_orbit_sub_overscan();
			}
            else
			{
				vbe_disp_orbit_set_sub_overscan(0);
			}

			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
				&& !(SCALEUP_D_UZU_Globle_Ctrl_get_patgen_sel(IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg)))
				&&(main_rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_0)
				)
			{
#ifndef UT_flag
				if(ScalerCheckOrbitFinish())
					vbe_disp_orbit_frc_overscan();
#endif // #ifndef UT_flag
			}
			else{
				SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
				orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
				orbit_shift_info->orbit_enable = 0;
				orbit_shift_info->active_state = 0;
			}

			vbe_disp_orbit_OSD_overscan();
			if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
			{
#ifndef UT_flag
				unsigned int counter  = 5;
				while(counter && !(ScalerCheckOrbitFinish()))
				{
					msleep(10);
					counter--;
				}
				rtd_pr_vsc_info("wait orbit ready counter:%d\n", counter);
#endif // #ifndef UT_flag
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);
			}
			if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
			{
				set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
				trigger_mute_off(SLR_SUB_DISPLAY, 1);
			}
		}
		else if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
		{
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
			trigger_mute_off(SLR_MAIN_DISPLAY, 1);
		}
		else
		{
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) || (SCALEUP_D_UZU_Globle_Ctrl_get_patgen_sel(IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg))))
			{
				SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
				orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
				orbit_shift_info->orbit_enable = 0;
				orbit_shift_info->active_state = 0;
			}
		}

#ifdef CONFIG_ENABLE_HDMI_NN
			// Test NN read buffer, check 0xB8025800[27]=1 ?
				update_vsc_task_status(1, VSC_I3DDMA_NN);
				if ((IoReg_Read32(H3DDMA_LR_Separate_CTRL1_reg)) & _BIT27)
				{
					h3ddma_get_NN_read_buffer(&ulNNYAddr, &ulNNCAddr, NULL ,&ulCropYAddr, &ulCropCAddr, NULL);

					rtd_pr_vsc_emerg("NNYAddr=%x, NNCAddr=%x, ulCropYAddr=%x, ulCropCAddr=%x\n", ulNNYAddr, ulNNCAddr, ulCropYAddr, ulCropCAddr);

					//h3ddma_get_NN_read_buffer_test(&ulNNYAddr, &ulNNCAddr);

					//rtd_pr_vsc_emerg("test NNYAddr=%x, NNCAddr=%x\n", ulNNYAddr, ulNNCAddr);
				}
#if 0
			if((IoReg_Read32(0xB8022214)) & _BIT17)
			{
				h3ddma_open_i3ddma_capture(I3DDMA_NN_ENABLE_CAP);
				IoReg_ClearBits(0xB8022214, _BIT17);
			}

			if((IoReg_Read32(0xB8022214)) & _BIT18)
			{
				h3ddma_close_i3ddma_capture(I3DDMA_NN_ENABLE_CAP);
				IoReg_ClearBits(0xB8022214, _BIT18);
			}
#endif
				// Dump NN data once, 0xB8025800[28]=1
				if ((IoReg_Read32(H3DDMA_LR_Separate_CTRL1_reg)) & _BIT28)
				{
#ifdef CONFIG_FORCE_RUN_I3DDMA
					i3ddma_dump_data_to_file();
#endif
					IoReg_ClearBits(H3DDMA_LR_Separate_CTRL1_reg, _BIT28);
				}
			//i3ddma nn cap re-config here
#ifndef UT_flag
		if(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG))
				&& (scalerAI_get_AIPQ_mode_enable_flag()) && h3ddma_nn_get_recfg_flag())
			{
				down(&Force_Run_Idma_Semaphore);
				h3ddma_nn_set_recfg_flag(FALSE);
				if(scaler_nn_force_run_idma(SLR_MAIN_DISPLAY, Get_DisplayMode_Src(SLR_MAIN_DISPLAY)) == FALSE)
				{
					set_nn_force_i3ddma_enable(FALSE);
					rtd_pr_vsc_err("scaler_nn_force_run_idma vdec fail !!!\n");
				}
				up(&Force_Run_Idma_Semaphore);
			}
#endif // #ifndef UT_flag
				update_vsc_task_status(0, VSC_I3DDMA_NN);
#endif


#ifdef MSPG_AUTO_TEST
		if(MSPG_AUTO_TEST_START == IoReg_Read32(MSPG_AUTO_TEST_REGISTER))
		{
            update_vsc_task_status(1, VSC_MESPG_AUTO_TEST);
#ifndef UT_flag
			if(TRUE == Check_DisplayFrame_isRightColorbar())
			{
				IoReg_Write32(MSPG_AUTO_TEST_REGISTER, MSPG_AUTO_TEST_SUCCESS);
			}else{
				IoReg_Write32(MSPG_AUTO_TEST_REGISTER, MSPG_AUTO_TEST_FAIL);
			}
#endif // #ifndef UT_flag
            update_vsc_task_status(0, VSC_MESPG_AUTO_TEST);
		}
#endif

		if(OutpuLocalDimmingPatMode == TRUE){
			rtd_pr_vsc_debug("#Enter LocalDimming debug mode#\n");
			continue;
		}

		if(Get_tv006_wb_pattern() == TRUE){
			if(DbgSclrFlgTkr.Main_Reset_Mode_flag)	//WOSQRTK-7881 should go reset after close in WB background
			{
                update_vsc_task_status(1, VSC_MAIN_RESET_MODE);
				down(&Main_ResetMode_Semaphore);
				DbgSclrFlgTkr.Main_Reset_Mode_flag = FALSE;
				up(&Main_ResetMode_Semaphore);
				rtd_pr_vsc_debug("\r\n#####func:%s DO Main reset mode during WB#####\r\n", __FUNCTION__);
				down(&VSC_Semaphore);
				drvif_mode_resetmode(SLR_MAIN_DISPLAY);//Reset Mode for Main
				up(&VSC_Semaphore);
                update_vsc_task_status(0, VSC_MAIN_RESET_MODE);
			}
			rtd_pr_vsc_debug("#Enter WB Pattern debug mode#\n");	//WOSQRTK-7731
			continue;
		}
#ifndef UT_flag
		if(vpq_ld_running_flag == TRUE){
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
			if(DbgSclrFlgTkr.vpq_ld_first_boot==FALSE /*||(((IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)-ld_time_tick)/90) > 1100)*/){
                update_vsc_task_status(1, VSC_VPQ_LD);
				if(DbgSclrFlgTkr.vpq_ld_first_boot==TRUE){ // protect first enter after resume 1.1sec, otherwise no need to check time
					//rtd_pr_vsc_notice("[%s] ld tick time = %d (cnt:%d)\n", __FUNCTION__, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)-ld_time_tick)/90, ld_debug_cnt);
				}
				DbgSclrFlgTkr.vpq_ld_first_boot = FALSE;
				down(&VPQ_ld_running_Semaphore);
				drvif_HAL_VPQ_LED_LDEnable(vpq_led_LDEnable);
				vpq_ld_running_flag = FALSE;
				up(&VPQ_ld_running_Semaphore);
				ld_debug_cnt = 0;
                update_vsc_task_status(0, VSC_VPQ_LD);
			}else{
				ld_debug_cnt++;
			}
#endif
		}
#endif // #ifndef UT_flag
#ifdef BRING_UP_I2RND
		//Eric@20180518 for i2rnd bring up HW verify
		if((IoReg_Read32(VGIP_VGIP_VBISLI_reg) & _BIT9) && (i2rnd_brungup_setting_done == 0)){
			i2rnd_bring_up_verify();
			i2rnd_brungup_setting_done = 1;
		}
#endif
		#if 1
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE){
#ifdef CONFIG_I2RND_ENABLE
			if(Scaler_I2rnd_get_timing_enable() && (Scaler_main_md_pst_get_enable() == _DISABLE)){
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = _DISABLE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = _DISABLE;
			}
#endif
			zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY,0);//update vo smooth toggle info
			if (rtk_hal_vsc_Getdualdecoder() && (0 == rtk_hal_vsc_Getdualdecoder_run()))
			{
				rtk_hal_vsc_Setdualdecoder_run(1);
				Scaler_DualChannelRpc(1);
				rtd_pr_vsc_info("dual decoder start to run\n");
			}
			if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off) {
				unsigned char Main_smoothtoggle_forcebg_flag=0;
				unsigned char Main_smoothtoggle_from_mute_off = FALSE;//if TRUE, means mute off trigger smooth toggle
				srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
                update_vsc_task_status(1, VSC_MAIN_SMOOTHTOGGLE);
				down(&SetMainOutPutRegion_Semaphore);
				if(DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off)
					Main_smoothtoggle_from_mute_off = TRUE;//if TRUE, means mute off trigger smooth toggle
				DbgSclrFlgTkr.smoothtoggle_start_flag = TRUE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = false;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				if (DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) {
					Main_smoothtoggle_forcebg_flag=TRUE;
					DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag =false;
				}

				Scaler_DispWindowSet(main_dispwin);
				//Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
				/*if(srctype != KADP_VSC_INPUTSRC_AVD) {
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height, ZOOM_CROP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
				}*/
				up(&SetMainOutPutRegion_Semaphore);
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY)) {
					ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
					main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
					timeout = 30;
					while(!main_display_control_rsv_reg.m_force_bg && timeout) {
						timeout -- ;
						msleep(10);
						main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
					}
					rtd_pr_vsc_info("before smoothtoggle,need wait forcebg ok timeout=%d\n",timeout);
				}
				//when change to data fs,need change timing to fs
				Convert_Timing_To_fs_Depend_datafs(SLR_MAIN_DISPLAY);
				if(srctype == VSC_INPUTSRC_AVD)
				{
#ifdef SPEEDUP_NEW_SCALER_FLOW
					if(get_AVD_Input_Source() != _SRC_TV)
					{//do h v start compensation
						avd_start_compensation();//compensation h v start
					}
#endif
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					winSrcRect = Scaler_DispWindowGet();
					//zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, winSrcRect.srcx, winSrcRect.srcy, winSrcRect.src_wid, winSrcRect.src_height, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
					up(&VSC_Semaphore);
#endif

				}
				else
				{
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					winSrcRect = Scaler_DispWindowGet();
					//zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, winSrcRect.srcx, winSrcRect.srcy, winSrcRect.src_wid, winSrcRect.src_height, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
					up(&VSC_Semaphore);
				}

				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
				{
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//display arc ready mask, becasue we already apply ARC
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);//wait smooth toggle ready to avoid to see ARC change
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
					down(&SetMainOutPutRegion_Semaphore);
					if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
					{
						down(&new_input_output_main_sem);
						reset_pst_sharemem_buffer(SLR_MAIN_DISPLAY);//reset pst buffer data
						set_pst_active_state(SLR_MAIN_DISPLAY, TRUE);//update to enable PST
						up(&new_input_output_main_sem);
					}
					up(&SetMainOutPutRegion_Semaphore);
#endif

				}
				if((DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off == FALSE) && (DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag == FALSE)){
					rtd_pr_vsc_debug("\r\n#####open forcebg after smoothtoggle\r\n");
					if((Main_smoothtoggle_forcebg_flag==TRUE)/*&&(srctype == VSC_INPUTSRC_VDEC)*/&&(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_VSC)))
					{
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
						if (srctype == VSC_INPUTSRC_ADC) {//componet 5A wait at least two frame in case of shaking
							int timingMode = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MODE_CURR);
							if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE)) && (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_YPBPR)&&((timingMode == _MODE_480I)||(timingMode == _MODE_576I)))
							{
								unsigned int waitsec = 3*10000/(int)Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ);
								msleep(waitsec);
							}
						}
					}

					if(srctype == VSC_INPUTSRC_VDEC)
					{
						if(Scaler_DispGetInputInfoByDisp(Get_DisplayMode_Port(SLR_MAIN_DISPLAY), SLR_INPUT_VO_SOURCE_TYPE) != 1) {
						// [K5LG-828] wait for VO film mode detect done
						unsigned int stc = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
						filmDetect_timeout = FILM_DETECT_TO;
						port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
						timeout = 30;
						while((((get_vo_avsync_flag(port) == FALSE) && timeout)|| ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout)) && Main_smoothtoggle_from_mute_off)
						{
							timeout -- ;
							filmDetect_timeout--;
							if(DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off || DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_Scaler_Stop_flag)
								break;
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								break;
							msleep(1);
						}
						if(filmDetect_timeout != FILM_DETECT_TO)
						    rtd_pr_vsc_notice("[FILM] P[%d] Wait Detect Done[%d]=%d ms\n",  port, filmDetect_timeout, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - stc)/90);

						rtd_pr_vsc_notice("\r\n### smooth toggle vo wait sync & film detect done timeout:%d, %d####\r\n", timeout, filmDetect_timeout);
						}

						//Set FLL flag when DTV channel changing
						if(vbe_disp_get_adaptivestream_fs_mode() == 1){
							//drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							modestate_set_fll_running_flag(_DISABLE);
							//rtd_pr_vsc_emerg("@@@@@@@@@@@FLL disable for adaptive stream\n");
						}else{
							if (Main_smoothtoggle_forcebg_flag && DbgSclrFlgTkr.check_only_xy_shift_same_region) {//only the same timing DTV exchange need reset_freerun
								#ifdef CONFIG_I2RND_ENABLE
								if(Scaler_I2rnd_get_timing_enable() == _DISABLE)
								#endif

#ifdef ENABLE_VR360_DATA_FS_FLOW
								if(get_vt_EnableFRCMode() != FALSE)	//VR360 cannot set freerun
#endif
								{
									if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)==FALSE
										&& (drvif_scaler_get_display_mode() == DISPLAY_MODE_NEW_FLL_MODE)) {
										//for enter fixlastline condition, reset timing to freerun
										drivf_scaler_reset_freerun();
									}
								}
								if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)==FALSE) {
									if((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))
										modestate_set_fll_running_flag(_DISABLE);
									else
										modestate_set_fll_running_flag(_ENABLE);
								}
							}
						}
					}
					DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
					if((DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off == FALSE) && (DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag == FALSE) &&
						(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {

                        if(vbe_disp_oled_orbit_enable)
                        {
#ifndef UT_flag
                            ScalerForceUpdateOrbit(1);
#endif // #ifndef UT_flag
                            rtd_pr_vsc_info("####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
                            set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
                        }

                        if (!Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_VSC)) {
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);
						}
					}
				}

                update_vsc_task_status(0, VSC_MAIN_SMOOTHTOGGLE);
			} else {
			#if 0
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)&& (Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_VDEC)) {
					onms_onms1_ctrl_RBUS onms_onms1_ctrl_reg;
					onms_onms1_ctrl_reg.regValue =  IoReg_Read32(ONMS_onms1_ctrl_reg);
					if(!onms_onms1_ctrl_reg.on1_start_ms) {
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
						drvif_mode_enableonlinemeasure(SLR_MAIN_DISPLAY);
						drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_VO, TRUE, FALSE);
					}
				}
			#endif
			}
		}else{
			if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag) {
               rtd_pr_vsc_info("not active clear Main_smooth_toggle_set_flag start\n");
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
				up(&SetMainOutPutRegion_Semaphore);
                rtd_pr_vsc_info("not active clear Main_smooth_toggle_set_flag end\n");
			}
		}

		#endif

		if(DbgSclrFlgTkr.run_iv2dv_slow_tuning_flag)
		{
			if(drv_memory_get_game_mode_iv2dv_slow_enable() == TRUE){
				rtd_pr_vsc_notice("\r\n#drv_run_GameMode_iv2dv_slow_tuning#\r\n");
                update_vsc_task_status(1, VSC_IV2DV_TUNING);
                down(&Iv2dv_Slow_Tuning_Semaphore);
				drv_run_GameMode_iv2dv_slow_tuning();
				up(&Iv2dv_Slow_Tuning_Semaphore);
                update_vsc_task_status(0, VSC_IV2DV_TUNING);
			}
		}

		if(DbgSclrFlgTkr.Main_Reset_Mode_flag)
		{
            update_vsc_task_status(1, VSC_MAIN_RESET_MODE);
			down(&Main_ResetMode_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
			Scaler_I2rnd_set_display(I2RND_TABLE_OFF);
			rtd_pr_vsc_emerg("[%s]I2RND_TABLE_OFF in main reset mode!!!!\n",__FUNCTION__);
#endif
			DbgSclrFlgTkr.Main_Reset_Mode_flag = FALSE;
			up(&Main_ResetMode_Semaphore);
			rtd_pr_vsc_debug("\r\n#####func:%s DO Main reset mode#####\r\n", __FUNCTION__);
			down(&VSC_Semaphore);
			drvif_mode_resetmode(SLR_MAIN_DISPLAY);//Reset Mode for Main
			//not control memc mux in reset mode, it will cause garbage if memc input 120hz
			//vbe_disp_game_mode_memc_bypass(0);
			fw_set_vsc_GameMode(0);
			up(&VSC_Semaphore);
            update_vsc_task_status(0, VSC_MAIN_RESET_MODE);
		}
		else
		{
            update_vsc_task_status(1, VSC_MAIN_BBD_VGIP);
			check_bdb_vgip_driver_request(SLR_MAIN_DISPLAY);
            update_vsc_task_status(0, VSC_MAIN_BBD_VGIP);
		}
#ifdef CONFIG_RTK_KDRV_DV
		if(
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
				dolby_adapter_get_request_letter_dtg_change()
#else
				request_letter_dtg_change
#endif
				&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && ((rtd_inl(VGIP_Smooth_tog_ctrl_reg)&_BIT0)==0))

		{
			ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
			ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
			unsigned char dolby_dtg_black_flag;
			unsigned long flags;//for spin_lock_irqsave
			update_vsc_task_status(1, VSC_DOLBY_LB);
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_dolby_letter_box_spin_lock_irq_save(&flags);
			main_background_h_start_end_reg.regValue = dolby_adapter_get_dolby_proverlay_background_h_start_end();
			main_background_v_start_end_reg.regValue = dolby_adapter_get_dolby_proverlay_background_v_start_end();
			dolby_dtg_black_flag = dolby_adapter_get_letter_box_black_flag();
			dolby_adapter_set_request_letter_dtg_change(FALSE);
			dolby_adapter_dolby_letter_box_spin_unlock_irqrestore(&flags);
#else
			spin_lock_irqsave(dolby_letter_box_spinlock(), flags);
			main_background_h_start_end_reg.regValue = dolby_proverlay_background_h_start_end;
			main_background_v_start_end_reg.regValue = dolby_proverlay_background_v_start_end;
			dolby_dtg_black_flag = letter_box_black_flag;
			request_letter_dtg_change = FALSE;
			spin_unlock_irqrestore(dolby_letter_box_spinlock(), flags);
#endif
			IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);
			IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);
			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			if(dolby_dtg_black_flag)
				IoReg_SetBits(PPOVERLAY_Main_Display_Control_RSV_reg, _BIT2);
			else
				IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg, _BIT2);
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT0);//Aplly double buffer
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
            update_vsc_task_status(0, VSC_DOLBY_LB);
}
#endif

        if(Get_decide_dtg_m_mode_set_cinema_mode_flag())
        {
            Set_decide_dtg_m_mode_set_cinema_mode_flag(false);
            modestate_decide_dtg_m_mode_scaler_set_cinema_mode();
        }

		if((DbgSclrFlgTkr.memc_realcinema_run_flag)&&((rtd_inl(VGIP_Smooth_tog_ctrl_reg)&_BIT0)==0) && (scaler_get_VoTrackingI3DDMA_frequency_update_in_isr() == FALSE)) //wait smooth toggle finish
		{
            update_vsc_task_status(1, VSC_MEMC_REALCINEMA);
            Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
			down(&Memc_Realcinema_Semaphore);
			DbgSclrFlgTkr.memc_realcinema_run_flag=FALSE;
			up(&Memc_Realcinema_Semaphore);


			down(&VSC_Semaphore);
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			if((scaler_vsc_get_adaptive_pst_lowdelay_mode()==1)&&((get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY))||scaler_vsc_get_force_pst_lowdelay_mode()==1)){
				scaler_vsc_set_adaptive_pst_lowdelay_mode(1);
			}else{
				memc_realcinema_framerate();
			}
#else
			memc_realcinema_framerate();
#endif
			up(&VSC_Semaphore);
			update_vsc_task_status(0, VSC_MEMC_REALCINEMA);
		}

#ifdef CONFIG_I2RND_ENABLE
		//trigger I2rnd sub => vo => main flow
		if(/*(Scaler_I2rnd_get_timing_enable() == _ENABLE) && */(vsc_i2rnd_sub_stage == I2RND_STAGE_TRIGGER_RUN_MAIN)){
				vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_GET_RPC;
				rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_MAIN_GET_RPC\n");
				rtd_pr_vsc_emerg("[I2RND]Scaler_I2rnd_get_display = %d\n", Scaler_I2rnd_get_display());
				//check timing enable
				Scaler_I2rnd_wait_timing_enable();
				//run main patch
				down(&VSC_Semaphore);
				//disable s0 db_en when i2r timing enable @Crixus 20171219
				Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
				set_zoom_reset_double_state(_DISABLE, SLR_MAIN_DISPLAY);//always disable double buffer
				//check di setting
				i2rnd_default_register_setting();
				//rtd_pr_vsc_emerg("[%s][sub connect]I2RND default setting done\n", __FUNCTION__);
				Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
				scaler_i2rnd_run_main();
				if ((get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY)) && (vo_timing_change_for_adaptive == 1)) {
					//Eric@20170922 update main structure info for adaptive stream
					Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_VO_Dispinfo(DisplayModeInputInfo.resourceIndex));
					vo_timing_change_for_adaptive = 0;
				}
				vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_I2RND_FINISH;
				rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_MAIN_I2RND_FINISH\n");
				rtd_pr_vsc_emerg("[I2RND]DbgSclrFlgTkr.Sub_Run_Scaler_flag = %d\n", DbgSclrFlgTkr.Sub_Run_Scaler_flag);

				//Disable main force cmd buffer flag after sub done because i2r enable at vo. @Crixus 20171128
				down(&I2RND_Semaphore);
				Scaler_I2rnd_set_force_cmd(_DISABLE);
				up(&I2RND_Semaphore);
				rtd_pr_vsc_emerg("[I2RND]Disable main force cmd buffer flag after sub done.\n");

				if(DbgSclrFlgTkr.Sub_Run_Scaler_flag == TRUE){
					rtd_pr_vsc_emerg("[I2RND]run sub scaler again, do not disable sub fbg\n");

				}
				else{
					//Disable sub fbg after sub=>vo=>mcap2 done @Crixus 20160728
					//down(get_forcebg_semaphore());
					//scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, FALSE);
					//up(get_forcebg_semaphore());

					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
					trigger_mute_off(SLR_SUB_DISPLAY, 1);
					rtd_pr_vsc_emerg("[I2RND]Disable fbg after sub => vo => main mcap2 done.\n");
				}

				up(&VSC_Semaphore);
		}

		//move APVR run scaler to tsk @Crixus 20160824
		if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
			vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_TRIGGER_RUN_MAIN;
//			apvr_request_run_main_path();
		}
#endif
#if 0
		if (LiveZoom_MEMCClose_Flag == TRUE) {
			down(&VSC_Semaphore);
			if (LiveZoom_MEMCClose_Flag == TRUE) {
				down(get_livezoom_memcclose_Semaphore());
				LiveZoom_MEMCClose_Flag = FALSE;
				up(get_livezoom_memcclose_Semaphore());
				memc_setting_displayDtiming_framerate();
			}
			up(&VSC_Semaphore);
		}
#endif
		if ((DbgSclrFlgTkr.rotate_run_scaler_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag || decide_auto_scaler_run(SLR_MAIN_DISPLAY)) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (DbgSclrFlgTkr.Main_Reset_Mode_flag == FALSE)//wait vsc close reset mode ready
#ifdef CONFIG_I2RND_ENABLE
			&& (((vsc_i2rnd_sub_input_type != VSC_INPUTSRC_VDEC) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) ||(vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH)))
				|| ((vsc_i2rnd_sub_input_type == VSC_INPUTSRC_VDEC) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))))
#endif
			) {
			update_vsc_task_status(1, VSC_MAIN_PRE_CHECK);
			set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
			srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
			// reset hdmi invalid info before first use.
			// scaler_set_invalid_hdmi_info_timing(0);
			// scaler_vsc_set_check_ARC_flag_done(FALSE);
			drvif_set_hdmi_dp_force_framerate_flag(FALSE);
			// set_pre_display_refresh_rate(Get_DISPLAY_REFRESH_RATE());
#ifdef SPEEDUP_NEW_SCALER_FLOW
			if((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) || (srctype == VSC_INPUTSRC_VDEC) || (srctype == VSC_INPUTSRC_JPEG) || ((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV)))
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
				rtd_pr_vsc_notice("######[%s(%d)] run scaler start:%d %d#####\n", __func__, __LINE__, DbgSclrFlgTkr.Main_Run_Scaler_flag, decide_auto_scaler_run(SLR_MAIN_DISPLAY));

				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
				set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode(SLR_MAIN_DISPLAY));
				set_rotate_mode(SLR_MAIN_DISPLAY, main_rotate_mode);
				up(&SetMainOutPutRegion_Semaphore);
				if(srctype == VSC_INPUTSRC_AVD)
					set_avd_start_need_compensation(TRUE);
			}
			else
			{//Need to remove
#ifndef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
				DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
				set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
				set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
				Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
				Scaler_DispWindowSet(main_dispwin);
				//Fixed ATV all direction zoom non-working issue. @Crixus 20160829
				if(!((srctype == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
					//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
					zoom_record_input_output_pre_size(SLR_MAIN_DISPLAY,main_input_size,main_input_timing,main_dispwin);
				}
				set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode(SLR_MAIN_DISPLAY));
				set_rotate_mode(SLR_MAIN_DISPLAY, main_rotate_mode);
				up(&SetMainOutPutRegion_Semaphore);
#endif
			}

#else
			down(&SetMainOutPutRegion_Semaphore);
			DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
			DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
			DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
			DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
			DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
			Scaler_DispWindowSet(main_dispwin);
			//Fixed ATV all direction zoom non-working issue. @Crixus 20160829
			if(srctype != VSC_INPUTSRC_AVD){
				//rtd_pr_vsc_emerg("[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(SLR_MAIN_DISPLAY,main_input_size,main_input_timing,main_dispwin);
			}
			set_ori_rotate_mode(SLR_MAIN_DISPLAY, get_rotate_mode(SLR_MAIN_DISPLAY));
			set_rotate_mode(SLR_MAIN_DISPLAY, main_rotate_mode);
			up(&SetMainOutPutRegion_Semaphore);
#endif
			port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
			rtd_pr_vsc_emerg("[%s]I2RND_MAIN_S0_TABLE!!!!\n",__FUNCTION__);
#endif
#ifdef CONFIG_HDR_SDR_SEAMLESS
			reset_seamless_trigger_flag();//reset trigger flag when run scaler flow. avoid keep previous source trigger flag
#endif
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
			set_pst_active_state(SLR_MAIN_DISPLAY, FALSE);//reste activer state
#endif
			flag_vsc_check_dolby_mode_change = false;
            update_vsc_task_status(0, VSC_MAIN_PRE_CHECK);
			switch(srctype)
			{
				case KADP_VSC_INPUTSRC_AVD:
					if(get_AVD_Input_Source() != _SRC_TV)
						rtd_pr_vsc_notice("####Main path VSC_Src:KADP_VSC_INPUTSRC_AVD(AV)#####\r\n");
				break;

				case KADP_VSC_INPUTSRC_ADC:
					rtd_pr_vsc_notice("####Main path VSC_Src:KADP_VSC_INPUTSRC_ADC#####\r\n");
				break;

				case KADP_VSC_INPUTSRC_HDMI:
					set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());//recode current hdr mode
					rtd_pr_vsc_notice("####Main path VSC_Src:KADP_VSC_INPUTSRC_HDMI#####\r\n");
				break;

				case VSC_INPUTSRC_VDEC:
					rtd_pr_vsc_notice("####Main path VSC_Src:VSC_INPUTSRC_VDEC#####\r\n");
				break;

				case VSC_INPUTSRC_JPEG:
					rtd_pr_vsc_notice("####Main path VSC_Src:VSC_INPUTSRC_JPEG#####\r\n");
				break;

				default:
					break;
			}
#if 0 //remove in k4lp
			//game mode search status checking:ex:change input source
			if(drv_memory_get_game_mode_dynamic() != drv_memory_get_game_mode_flag()){
				if(drv_memory_get_game_mode_dynamic() == _ENABLE){
					drv_memory_set_game_mode(_ENABLE);
				} else {
					drv_memory_set_game_mode(_DISABLE);
				}
			}
#endif
            update_vsc_task_status(1, VSC_WAIT_GAME_MODE);
			wait_game_mode_finish();//wait game mode finish
			update_vsc_task_status(0, VSC_WAIT_GAME_MODE);
			decide_scaler_hdmi_hfr_mode();
                        set_scaler_qms_mode_flag(current_is_hdmi_qms_mode());//decide current hdmi is qms mode or not
                        ///qms porting, fixme, set qms that could conflict with PC mode.
            set_vsc_run_pc_mode(rtk_hal_vsc_GetRGB444Mode());//save vsc run pc mode or not
	    sync_pc_mode_info();//this position  scaler info is from input source
#ifdef CONFIG_FORCE_RUN_I3DDMA
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH)
			{
				//rtd_pr_vsc_emerg("######fw_set_vsc_GameMode(0) Line=%d #######\n", __LINE__);
				fw_set_vsc_GameMode(0);
				modestate_set_fll_running_flag(FALSE);
                	//	set_vsc_run_pc_mode(rtk_hal_vsc_GetRGB444Mode());//save vsc run pc mode or not
                		set_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY, vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY));//save vsc run adaptive stream or not
				set_vsc_gamemode_datafrc_mode_flag(scaler_vsc_get_gamemode_go_datafrc_mode());
				/*main path always run i3ddma->vodma->scaler*/
				if(((srctype == VSC_INPUTSRC_HDMI) && ((get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1) && (get_hdmi_4k_hfr_mode() != HDMI_3K120)))
				|| (srctype == VSC_INPUTSRC_ADC) || ((srctype == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))
				{
					update_vsc_task_status(1, VSC_I3DDMA_DRIVE);
				    down(&Force_Run_Idma_Semaphore);
					set_force_i3ddma_enable(TRUE);
					if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
					{
						set_i3ddma_4k120_flag(1);//hdmi2.0 4k120 case
					}
					else
					{
						set_i3ddma_4k120_flag(0);//not hdmi2.0 4k120 case
					}

					if(scaler_force_run_idma(SLR_MAIN_DISPLAY, srctype) == FALSE)
					{
						set_force_i3ddma_enable(false);
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
						up(&Force_Run_Idma_Semaphore);
						rtd_pr_vsc_err("######scaler_force_run_idma fail fail fail!!!#######\n");
						reset_ARC_cmd(SLR_MAIN_DISPLAY);
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre);
						up(&SetMainOutPutRegion_Semaphore);
						if(srctype  == VSC_INPUTSRC_ADC)
						{//Need to rerun scaler
#ifdef CONFIG_SUPPORT_SRC_ADC
							StructDisplayInfo  *p_timing = NULL;
							down(get_adc_detectsemaphore());
							reset_adc_timing_ready();
							p_timing = Get_ADC_Dispinfo();
							if(p_timing!=NULL)
							{
								p_timing->IPH_ACT_WID_PRE = 0;
								p_timing->IPV_ACT_LEN_PRE = 0;
								p_timing->IVFreq = 0;
								p_timing->IHFreq = 0;
								p_timing->IHTotal = 0;
								p_timing->IVTotal = 0;
								p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
							}
							if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
								ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
								Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
								ADC_set_detect_flag(TRUE);
							}
							up(get_adc_detectsemaphore());
#endif//#ifdef CONFIG_SUPPORT_SRC_ADC
						}
						else if(srctype  == VSC_INPUTSRC_HDMI)
						{//Need to rerun scaler
							reset_hdmi_timing_ready();
							down(get_hdmi_detectsemaphore());
							if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
								vfe_hdmi_drv_handle_on_line_measure_error(0);
								Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
								HDMI_set_detect_flag(TRUE);
							}
							up(get_hdmi_detectsemaphore());
						}
						else if(srctype  == VSC_INPUTSRC_AVD)
						{//Need to rerun scaler
							/*//no need because AVD don't stop detect task
							down(get_vdc_detectsemaphore());
							if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {
								VDC_set_detect_flag(TRUE);
							}
							up(get_vdc_detectsemaphore());
							*/
							reset_avd_timing_ready();
							Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						}
						I3DDMA_Setup3DDMA(&i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
                        continue;
					}
					else
					{
						/*stored for iv2pv delay(i3ddma and vodma) setting at gamemode*/
						//rtd_pr_vsc_info("[qiangzhou22]SLR_INPUT_MODE_CURR = %d\n",Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						Set_GamemodeSaveI3ddmaGetcurMode(Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
					    up(&Force_Run_Idma_Semaphore);
						rtd_pr_vsc_notice("\r\n########func:%s force i3ddma_success (modeidx: %d)##########\r\n", __FUNCTION__, Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						port = 0;
                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
					}
					rpc_send_hdmi_2_1_flag(FALSE);//not hdmi2.1
				}
				else
				{
					int ret =0;
					if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)&&((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120))){//4k120
						down(&Force_Run_Idma_Semaphore);
						set_force_i3ddma_enable(false);
						if(I3DDMA_DolbyVision_HDMI_Init())
						{//borrow  memory fail
							up(&Force_Run_Idma_Semaphore);
							reset_hdmi_timing_ready();
							down(get_hdmi_detectsemaphore());
							if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
								vfe_hdmi_drv_handle_on_line_measure_error(0);
								Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
								HDMI_set_detect_flag(TRUE);
							}
							up(get_hdmi_detectsemaphore());
							rtd_pr_vsc_err("###[ERR] 4k120 can not borrow memory ###\r\n");
							continue;
						}
						else
							up(&Force_Run_Idma_Semaphore);
					}
					else if((srctype != VSC_INPUTSRC_AVD) && (get_force_i3ddma_enable(SLR_MAIN_DISPLAY) || i3ddmaCtrl.cap_buffer[0].phyaddr))	//for vdec, jpeg case
						rtk_i3ddma_disable();
					set_i3ddma_4k120_flag(0);//not hdmi2.0 4k120 case
					if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
					{//for hdmi 2.1 4k120 mode
						vbe_disp_set_freesync_mode_flag(drvif_Hdmi_GetAMDFreeSyncEnable());//save current freesync mode
						vbe_disp_set_VRR_timingMode_flag(drvif_Hdmi_GetVRREnable());//save current vrr mode
						if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1) || (get_hdmi_4k_hfr_mode() == HDMI_3K120))
						{
							if (0 != (ret = Scaler_SendRPC(SCALERIOC_SET_VO_FREERUN,0,1)))//set vo free run for orbit
							{
								rtd_pr_vsc_err("ret=%d, SCALERIOC_SET_VO_FREERUN RPC fail !!!\n", ret);
							}
							rpc_send_hdmi_2_1_flag(TRUE);//hdmi2.1
						}

						down(&Force_Run_Idma_Semaphore);
						if(scaler_nn_force_run_idma(SLR_MAIN_DISPLAY, srctype) == FALSE)
						{
							set_nn_force_i3ddma_enable(FALSE);
							rtd_pr_vsc_err("scaler_nn_force_run_idma fail !!!\n");
						}
						up(&Force_Run_Idma_Semaphore);
					}
					else
					{
						vbe_disp_set_freesync_mode_flag(0);//save current freesync mode
						vbe_disp_set_VRR_timingMode_flag(0);//save current vrr mode
						rpc_send_hdmi_2_1_flag(FALSE);//not hdmi2.1
					}
					if(srctype == VSC_INPUTSRC_VDEC){
						Set_GamemodeSaveI3ddmaGetcurMode(Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
					}
				}
			}
			//sync_pc_mode_info();//this position  scaler info is from input source

			if(srctype == VSC_INPUTSRC_HDMI)
			{
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				set_source_info_forPQ(SLR_MAIN_DISPLAY);
				up(&SetMainOutPutRegion_Semaphore);
			}
#endif

#ifdef CONFIG_FORCE_RUN_I3DDMA
			if(((srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG) && ((DbgSclrFlgTkr.Main_force_frc_flag == FALSE)&&(DbgSclrFlgTkr.Main_force_frc_fs_flag==FALSE)))
				|| (((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) || (srctype == VSC_INPUTSRC_AVD && (get_AVD_Input_Source() != _SRC_TV))) && get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
				)
#else
			if ((srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG) && ((DbgSclrFlgTkr.Main_force_frc_flag == FALSE)&&(DbgSclrFlgTkr.Main_force_frc_fs_flag==FALSE)))
#endif
			{
                update_vsc_task_status(1, VSC_WAIT_VO_INFO);
				if(get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY))
					timeout = 300;
                else if(srctype == VSC_INPUTSRC_JPEG)
					timeout = 500;
				else
					timeout = 200;
				while (timeout--) {
					if(DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
						rtd_pr_vsc_notice("\r\n####VO already disconnet#####\r\n");
						break;
					}
					if(get_vo_change_flag(port)) {
						break;
					}
					if((get_ori_rotate_mode(SLR_MAIN_DISPLAY) != get_rotate_mode(SLR_MAIN_DISPLAY) || main_rotate_mode != main_rotate_mode_pre)&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE)==_MODE_STATE_ACTIVE)){
						break;
					}
					if((get_ori_rotate_mode(SLR_MAIN_DISPLAY) == get_rotate_mode(SLR_MAIN_DISPLAY))
						&& ((get_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_ROTATE_90) || (get_rotate_mode(SLR_MAIN_DISPLAY)==DIRECT_VO_FRAME_ORIENTATION_ROTATE_270))
						&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE)==_MODE_STATE_ACTIVE)){
						break;
					}
					msleep(10);
				}
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
				//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
				if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
					vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_I3DDMA_RPC;
					//rtd_pr_vsc_emerg("[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
				}
#endif
#endif

				if((srctype == VSC_INPUTSRC_VDEC) || (srctype == VSC_INPUTSRC_JPEG))
					rtd_pr_vsc_notice("####Go VO case. timeout:%d#####\r\n", timeout);
				else if(timeout <= 0)
					rtd_pr_vsc_notice("####Go i3ddma case. timeout err#####\r\n");


				if((srctype == VSC_INPUTSRC_VDEC) && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
				{
					DbgSclrFlgTkr.Main_during_scalerflow_flag = TRUE;//WOSQRTK-7524 patch. Avoid webos call mute off during scaler flow
				}

                update_vsc_task_status(0, VSC_WAIT_VO_INFO);
			}
#if 0
            if(DbgSclrFlgTkr.Main_force_frc_fs_flag) {
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_force_frc_fs_flag=FALSE;
				up(&SetMainOutPutRegion_Semaphore);
			}
#endif
#ifdef SPEEDUP_NEW_SCALER_FLOW
			if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
#else
			if(srctype ==VSC_INPUTSRC_AVD)
#endif
			{
				// If signal is locked, needs to wait VDC_DETECT_STAGE_FINAL
				if((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (drvif_video_status_reg(VDC_no_signal)==1)
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
					|| 	decide_auto_scaler_run(SLR_MAIN_DISPLAY)
#endif
					) // Need wait detect ready. (0 == drvif_module_vdc_GetLockStatus()) means snow screen

				{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
					if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && !Scaler_AVD_GetIsChannelChange())
#else
					if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
					{
#ifndef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
						if(get_AVD_Input_Source() == _SRC_TV)
							rtd_pr_vsc_notice("####[%s(%d)] Main path VSC_Src:KADP_VSC_INPUTSRC_AVD(ATV)####\n",__func__,__LINE__);
#endif
                        update_vsc_task_status(1, VSC_ATV_WAIT_STABLE);
						if (0 == drvif_video_status_reg(VDC_no_signal))
						{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
							{
								if(check_atv_mode_id_change()||Scaler_AVD_CheckATVTimingChange(SLR_MAIN_DISPLAY)) {
									Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
									if(get_AVD_Input_Source() == _SRC_TV)
										rtd_pr_vsc_info("#######[%s(%d)] Switch ATV different format##########\n",__func__,__LINE__);
								} else {
									if(get_AVD_Input_Source() == _SRC_TV)
										rtd_pr_vsc_info("#######[%s(%d)] Switch ATV same format########## \n",__func__,__LINE__);

									modestate_set_fll_running_flag(_ENABLE);
								}
							}
#else
							if(Scaler_AVD_CheckATVTimingChange(SLR_MAIN_DISPLAY)) {
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								if(get_AVD_Input_Source() == _SRC_TV)
									rtd_pr_vsc_debug("#######Switch ATV different format##########\r\n");
							} else {
								if(get_AVD_Input_Source() == _SRC_TV)
									rtd_pr_vsc_debug("#######Switch ATV same format##########\r\n");
								modestate_set_fll_running_flag(_ENABLE);
							}
#endif
						}
						else
						{
							rtd_pr_vsc_debug("vsc_scaler_tsk  ATV no-signal\n");
						}
                        update_vsc_task_status(0, VSC_ATV_WAIT_STABLE);
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
							if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
							{
#ifdef CONFIG_FORCE_RUN_I3DDMA
								if(get_AVD_Input_Source() == _SRC_TV)
								{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
									rtd_pr_vsc_notice("####[%s(%d)] Main path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\n",__func__,__LINE__);
#endif
				                                    update_vsc_task_status(1, VSC_I3DDMA_DRIVE);
				                                    set_vsc_run_pc_mode(0);//save vsc run pc mode or not
				                                    set_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY, FALSE);
									set_vsc_gamemode_datafrc_mode_flag(FALSE);
								    down(&Force_Run_Idma_Semaphore);
									set_force_i3ddma_enable(TRUE);

									if(scaler_atv_force_run_idma()) {
										up(&Force_Run_Idma_Semaphore);
										port = 0;
										timeout = 200;
										while (timeout--) {
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
											if(DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
											if(DbgSclrFlgTkr.Main_Scaler_Stop_flag || DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
											{
												rtd_pr_vsc_info("####[%s(%d)]avd already disconnet#####\r\n",__func__,__LINE__);
												break;
											}
											if(get_vo_change_flag(port)) {
												rtd_pr_vsc_info("####[%s(%d)]vo change flag#####\r\n",__func__,__LINE__);
												break;
											}
											msleep(1);
										}
#ifdef CONFIG_I2RND_ENABLE
										//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
										if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
											vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_I3DDMA_RPC;
											//rtd_pr_vsc_emerg("[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
										}
#endif
                                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
										if(timeout <= 0)
											rtd_pr_vsc_notice("#####[%s(%d)]Go ATV VO case. timeout err#####\r\n",__func__,__LINE__);

									} else {
										if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag) {	//if not disconnected
											set_force_i3ddma_enable(FALSE);
											Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
											rtd_pr_vsc_info("####[%s(%d)]Main_Scaler_Stop_flag is false.#####\r\n",__func__,__LINE__);
										}
										up(&Force_Run_Idma_Semaphore);
                                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
									}
									//if(DbgSclrFlgTkr.Main_Scaler_Stop_flag)
										//set_force_i3ddma_enable(FALSE);
								}
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
								if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
#else
								if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
								{
                                    update_vsc_task_status(1, VSC_ATV_SCALER);
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
									set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
									rtd_pr_vsc_notice("#####[%s(%d)] run scaler start:%d %d#####\n", __func__, __LINE__, DbgSclrFlgTkr.Main_Run_Scaler_flag, decide_auto_scaler_run(SLR_MAIN_DISPLAY));

									down(&SetMainOutPutRegion_Semaphore);
									DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
									up(&SetMainOutPutRegion_Semaphore);
									set_avd_start_need_compensation(TRUE);
#endif
									down(&VSC_Semaphore);
									rtd_pr_vsc_debug("\r\n####atv run scaler flow#####\r\n");

									rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
#ifdef CONFIG_I2RND_ENABLE
									//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
									if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_I3DDMA_RPC)){
										vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_RERUN_MAIN_DONE;
										//rtd_pr_vsc_emerg("[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
									}

									//send RPC let video fw do not write to memory after i2rnd donw @Crixus 20160808
									//i2rnd_send_table_idx(I2RND_TABLE_OFF);
#endif
									up(&VSC_Semaphore);
                                    update_vsc_task_status(0, VSC_ATV_SCALER);

								}
								else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
									DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
								}
#else//#ifdef CONFIG_FORCE_RUN_I3DDMA
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
								if(get_AVD_Input_Source() == _SRC_TV)
									rtd_pr_vsc_notice("####[%s(%d)] Main path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\n",__func__,__LINE__);
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
								rtd_pr_vsc_notice("###[%s(%d)] run scaler start:%d %d#####\r\n",__func__,__LINE__, DbgSclrFlgTkr.Main_Run_Scaler_flag, decide_auto_scaler_run(SLR_MAIN_DISPLAY));
								down(&SetMainOutPutRegion_Semaphore);
								DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
								up(&SetMainOutPutRegion_Semaphore);
								set_avd_start_need_compensation(TRUE);
#endif
								down(&VSC_Semaphore);
								rtd_pr_vsc_debug("####atv run scaler flow#####\r\n");
								rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
								up(&VSC_Semaphore);
#endif//#ifdef CONFIG_FORCE_RUN_I3DDMA
							} else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
							}
						} else {
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							if(((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (drvif_video_status_reg(VDC_no_signal) == 1)) && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#endif
							{
                                update_vsc_task_status(1, VSC_ATV_SMOOTHTOGGLE);
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
								down(&SetMainOutPutRegion_Semaphore);
								DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
								DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
								Scaler_DispWindowSet(main_dispwin);
								up(&SetMainOutPutRegion_Semaphore);
								set_avd_start_need_compensation(TRUE);
								avd_start_compensation();

#endif
								if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag){
									rtd_pr_vsc_debug("####atv run smooth toggle flow#####\r\n");
									down(&VSC_Semaphore);
									Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
									//before ATV smooth toggle flow, sync start address. @Crixus 20161019
									//send_memory_mapping_for_adaptive_streaming();
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
									winSrcRect = Scaler_DispWindowGet();
									zoom_imd_smooth_toggle_config(VIDEO_WID_0, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
#else
									winSrcRect = Scaler_DispWindowGet();
									zoom_imd_smooth_toggle_config(VIDEO_WID_0, hal_main_InputRegionType, main_input_size, main_input_timing, winSrcRect);
#endif
									up(&VSC_Semaphore);


									if (FALSE == CheckAVDandWebOSInfo(SLR_MAIN_DISPLAY))
									{
										rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
										rtd_pr_vsc_debug("CheckAVDandWebOSInfo() fail\n");

										if (0xff == DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount)
										{
											rtd_pr_vsc_debug("Set DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0\n");
											DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0;
										}

										DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount++;

										if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE && DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount < CHECK_AVD_WEBOS_INFO_TIMEOUT){
											DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
										}
										else
										{
											rtd_pr_vsc_debug("DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount timeout\n");
											DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
										}
									}
									else
									{
										rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
										rtd_pr_vsc_debug("CheckAVDandWebOSInfo ok, DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount=%d\n", DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount);
										DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
									}


									if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
									{
										if(wait_atv_stable_for_bg(SLR_MAIN_DISPLAY,__func__,__LINE__) == FALSE)
										{
											if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag){
												rtd_pr_vsc_info("####[%s(%d)] #####\r\n",__FUNCTION__, __LINE__);
												DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE; // Set output again, switch channel
											}

											if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
												&&(get_AVD_Input_Source() == _SRC_TV)
												&&((drvif_module_vdc_GetLockStatus() == 0)||(drvif_module_vdc_OutputStable()==FALSE)||(Scaler_AVD_GetDetectStage() != VDC_DETECT_STAGE_FINAL))
												&&(0 == drvif_video_status_reg(VDC_no_signal))){
												rtd_pr_vsc_info("####[%s(%d)] #####\r\n",__FUNCTION__, __LINE__);
												DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
											}
										} else {
											if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
												Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

												if ((get_AVD_Input_Source() == _SRC_TV)
													&&(DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange == TRUE)
													&&(Scaler_AVD_GetVDPreMode() != _MODE_UNKNOWN)
													&&(drvif_module_vdc_OutputStable() == FALSE)
													&&(1 == drvif_module_vdc_GetLockStatus())){
													rtd_pr_vsc_notice("#####[%s(%d)]set output again\n", __func__, __LINE__);
													DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE; // Set output again, switch channel
												}else{
													if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
													{
														rtd_pr_vsc_info("####[%s(%d)] disable arc mask\r\n",__func__, __LINE__);
														set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//display arc ready mask, becasue we already apply ARC
													}

                                                    if(vbe_disp_oled_orbit_enable)
													{
#ifndef UT_flag
														ScalerForceUpdateOrbit(1);
#endif // #ifndef UT_flag
														rtd_pr_vsc_info("####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
														set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
													}
													trigger_mute_off(SLR_MAIN_DISPLAY, 1);
													if ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) {
														pr_info("wait atv stable, memc unfreeze ATV\n");
														MEMC_Lib_Freeze(0);
														DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = TRUE;
													}
												}
											}

#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
											cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90 - cost_time;
											rtd_pr_vsc_debug("\r\n####vsc cost time:%d ms after mute off atv smooth toggle####\r\n", cost_time);
#endif
										}
									} else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
										DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
									}

								}
								else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
									DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
								}

                                update_vsc_task_status(0, VSC_ATV_SMOOTHTOGGLE);

							}


						}
					} else {
						if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag)
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
					}
				} else {

					if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
				}

			} else {
				if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
                    update_vsc_task_status(1, VSC_NON_ATV_MAIN_SCALER);
					down(&VSC_Semaphore);
					rtk_output_connect(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
					//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
					if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_I3DDMA_RPC)){
						vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_RERUN_MAIN_DONE;
						//rtd_pr_vsc_emerg("[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
					}

					//send RPC let video fw do not write to memory after i2rnd donw @Crixus 20160808
					//i2rnd_send_table_idx(I2RND_TABLE_OFF);
#endif
					up(&VSC_Semaphore);
                    update_vsc_task_status(0, VSC_NON_ATV_MAIN_SCALER);

				}
			}
			if (DbgSclrFlgTkr.main_winfreeze) {
				Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.main_winfreeze);
			}
			DbgSclrFlgTkr.main_winfreeze=0;
		} else if ((DbgSclrFlgTkr.OuputDisplayMode == TRUE)  && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
#ifndef BRING_UP_AUTO_FLOW
			update_vsc_task_status(1, VSC_MAIN_CHECK_MODE);
			rtk_check_signal(SLR_MAIN_DISPLAY);
			update_vsc_task_status(0, VSC_MAIN_CHECK_MODE);
#endif
		}
		if (freezing(current))
        {
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_MAIN_IP);
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_MAIN_IP);
#ifdef CONFIG_DUAL_CHANNEL
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_SUB_IP);
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_SUB_IP);
#endif
			try_to_freeze();
        }

#ifdef CONFIG_DUAL_CHANNEL
		if(DbgSclrFlgTkr.Sub_Reset_Mode_flag)
		{
            update_vsc_task_status(1, VSC_SUB_RESET_MODE);
			down(&Sub_ResetMode_Semaphore);
			DbgSclrFlgTkr.Sub_Reset_Mode_flag = FALSE;
			up(&Sub_ResetMode_Semaphore);
			rtd_pr_vsc_debug("\r\n#####func:%s DO Sub reset mode#####\r\n", __FUNCTION__);
			down(&VSC_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
			Scaler_I2rnd_set_display(I2RND_TABLE_OFF);
			rtd_pr_vsc_emerg("[%s]I2RND_TABLE_OFF in sub reset mode!!!!\n",__FUNCTION__);
#endif
			drvif_mode_resetmode(SLR_SUB_DISPLAY);//Reset Mode for sub
			up(&VSC_Semaphore);
            update_vsc_task_status(0, VSC_SUB_RESET_MODE);
		}
		else
		{
            update_vsc_task_status(1, VSC_SUB_BBD_VGIP);
			check_bdb_vgip_driver_request(SLR_SUB_DISPLAY);
            update_vsc_task_status(0, VSC_SUB_BBD_VGIP);
		}

		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) != VSC_INPUTSRC_MAXN)
		{
			msleep(10);
		#if 1//sub
			// for sub smooth toggle test
			if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE){
				zoom_update_scaler_info_from_vo_smooth_toggle(SLR_SUB_DISPLAY,0);//update vo sub smooth toggle info
				if(DbgSclrFlgTkr.Sub_smooth_toggle_set_flag) {
                    update_vsc_task_status(1, VSC_SUB_SMOOTHTOGGLE);
					down(&SetSubOutPutRegion_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);
					DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
					//DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
					//DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
					up(&SetSubOutPutRegion_Semaphore);

					down(&VSC_Semaphore);
					set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
					Scaler_SubDispWindowSet(sub_dispwin);
					winSrcRect = Scaler_SubDispWindowGet();
					zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, hal_sub_InputRegionType, sub_input_size, sub_input_timing, winSrcRect);
					up(&VSC_Semaphore);
					if(!DbgSclrFlgTkr.Sub_OutputVencMode)
					{
						drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
						trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
                    update_vsc_task_status(0, VSC_SUB_SMOOTHTOGGLE);
				}
			}
		#endif
			if (DbgSclrFlgTkr.Sub_Run_Scaler_flag && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && (DbgSclrFlgTkr.Sub_Reset_Mode_flag == FALSE)//wait vsc close reset mode ready
#ifdef CONFIG_I2RND_ENABLE
				&& ((((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH))	//[K3LG-1721]Eric@0413 Fix sub not rerun scaler when NTSC switch to PAL
				//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
				&& ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)/* && (get_AVD_Input_Source() == _SRC_TV)*/ && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE)))
				//Eric@0606 Dual VDEC Needs to Run Sub Path
				|| ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))
				//PIP run sub-scaler path
				|| ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH)))
#endif
				) {

				KADP_VIDEO_RECT_T tOutRegion, tInputRegion;
                update_vsc_task_status(1, VSC_SUB_PRE_CHECK);
                set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
				DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;


#ifdef CONFIG_I2RND_ENABLE
				Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
				rtd_pr_vsc_emerg("[%s]I2RND_SUB_S1_TABLE!!!!\n",__FUNCTION__);
#endif
				set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
				set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
				set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
				Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,hal_sub_InputRegionType);
				Scaler_SubDispWindowSet(sub_dispwin);
				set_vsc_run_adaptive_stream(SLR_SUB_DISPLAY, vsc_get_adaptivestream_flag(SLR_SUB_DISPLAY));//save vsc run adaptive stream or not
				rtk_hal_vsc_GetInputRegion(KADP_VIDEO_WID_1, &tInputRegion);
				rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_1, &tOutRegion);

				up(&SetSubOutPutRegion_Semaphore);
                update_vsc_task_status(0, VSC_SUB_PRE_CHECK);
				srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
                set_pst_active_state(SLR_SUB_DISPLAY, FALSE);
				switch(srctype)
				{
					case VSC_INPUTSRC_AVD:
						if(get_AVD_Input_Source() != _SRC_TV)
							rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_AVD(AV)#####\r\n");
					break;

					case VSC_INPUTSRC_ADC:
						rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_ADC#####\r\n");
					break;

					case VSC_INPUTSRC_HDMI:
						rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_HDMI#####\r\n");
					break;

					case VSC_INPUTSRC_VDEC:
						rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_VDEC#####\r\n");
					break;

					case VSC_INPUTSRC_JPEG:
						rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_JPEG#####\r\n");
					break;

					default:
						break;
				}

				if(srctype == VSC_INPUTSRC_VDEC)
				{
					timeout = 200;
					while (timeout--) {
						if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag) {
							rtd_pr_vsc_notice("\r\n####Sub VO already disconnet#####\r\n");
							break;
						}
						if(get_vo_change_flag(1)) {
							break;
						}
						msleep(10);
					}
					rtd_pr_vsc_notice("####Sub Go VO case. timeout:%d#####\r\n", timeout);
				}

				if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
				{
					if((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (0 == drvif_module_vdc_GetLockStatus()))
					{//If APVR, need to wait main ready
						if(!DbgSclrFlgTkr.Sub_Output_Set_flag && !DbgSclrFlgTkr.Sub_Scaler_Stop_flag && !DbgSclrFlgTkr.Sub_Run_Scaler_flag) {
							rtd_pr_vsc_notice("####Sub path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\r\n");
							#if 0
							rtd_pr_vsc_emerg( "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
							rtd_pr_vsc_emerg( "rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);
							rtd_pr_vsc_emerg( "rtk_hal_vsc_GetOutputRegion OutputRegion_x=%d, y=%d, w=%d, h=%d\n", tOutRegion.x, tOutRegion.y, tOutRegion.w, tOutRegion.h);

							rtd_pr_vsc_emerg( "Pre InputRegion_x=%d, y=%d, w=%d, h=%d\n", DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre);
							rtd_pr_vsc_emerg( "Pre OutputRegion_x=%d, y=%d, w=%d, h=%d\n", DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre);

							rtd_pr_vsc_emerg( "DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
							rtd_pr_vsc_emerg( "CompareATVInputOutputRegion()=%x\n", CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion));
							#endif

							rtd_pr_vsc_debug("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
							rtd_pr_vsc_debug("DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
							rtd_pr_vsc_debug("CompareATVInputOutputRegion()=%x\n", CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion));

                            update_vsc_task_status(1, VSC_ATV_SCALER);
							if (DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag && CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion))
							{
								rtd_pr_vsc_debug("vsc_scaler_task ATV sub path don't run scaler flow\n");
								//rtd_pr_vsc_emerg( "vsc_scaler_task ATV sub path don't run scaler flow\n");
							}
							else
							{
								rtd_pr_vsc_debug("Set ATV output/input pre\n");
								//rtd_pr_vsc_emerg( "Set ATV output/input pre\n");

								DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre = tOutRegion.x;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre = tOutRegion.y;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre = tOutRegion.w;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre = tOutRegion.h;

								DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre = tInputRegion.x;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre = tInputRegion.y;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre = tInputRegion.w;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre = tInputRegion.h;


								rtd_pr_vsc_debug("\r\n####atv run sub scaler flow#####\r\n");
								down(&VSC_Semaphore);
								rtk_output_connect(SLR_SUB_DISPLAY); // different format to go normal scaler
								if(!DbgSclrFlgTkr.Sub_OutputVencMode)
									drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
								Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
								//I2rnd sub=>vo RPC
								if(vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE){
									vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
									rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
									//Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
									//i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
									//drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, srctype);
									drivf_Sub_I2rnd_SetupVODMA();
									//i2rnd_debug();
									rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
								}
#endif
								up(&VSC_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
								//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
								if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE)){
									vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
								}
#endif
							}
                            update_vsc_task_status(0, VSC_ATV_SCALER);
						} else if((DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Sub_Output_Set_flag) {
							DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
						}
					} else {

						if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE)
							DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
					}
				} else {
					if(!DbgSclrFlgTkr.Sub_Scaler_Stop_flag) {
                        update_vsc_task_status(1, VSC_NON_ATV_SUB_SCALER);
						down(&VSC_Semaphore);
						rtk_output_connect(SLR_SUB_DISPLAY);
						if(!DbgSclrFlgTkr.Sub_OutputVencMode)
							drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
						Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
						if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_CONNECT)) && (DbgSclrFlgTkr.Sub_Run_Scaler_flag == FALSE)){
							vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1;
							rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1@@@@@@@@@@\n");
							//check timing enable
							Scaler_I2rnd_wait_timing_enable();
							//disable s0 db_en when i2r timing enable @Crixus 20171219
							Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
							set_zoom_reset_double_state(_DISABLE, SLR_MAIN_DISPLAY);//always disable double buffer
							//check di setting
							i2rnd_default_register_setting();
							//rtd_pr_vsc_emerg("[%s][sub connect]I2RND default setting done\n", __FUNCTION__);
							scaler_i2rnd_run_main();

							//before disable sub fbg, need to check sub disconnect or not @Crixus 20180110
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag){
								rtd_pr_vsc_emerg("[I2RND]sub already disconnect, do not disable fbg!!\n");
							}
							else{
								//Disable main force cmd buffer flag after sub done because i2r enable at vo. @Crixus 20171128
								down(&I2RND_Semaphore);
								Scaler_I2rnd_set_force_cmd(_DISABLE);
								up(&I2RND_Semaphore);
								rtd_pr_vsc_emerg("[I2RND]Disable main force cmd buffer flag after sub done.\n");
								if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_DONE)){
									vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH;
									rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH@@@@@@@@@@\n");
								}

								set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
								trigger_mute_off(SLR_SUB_DISPLAY, 1);

								//down(get_forcebg_semaphore());
								//scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, FALSE);
								//up(get_forcebg_semaphore());
								rtd_pr_vsc_emerg("[I2RND] DualVO rerun main path done, disable fbg!!\n");
							}

							if ((get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY)) && (vo_timing_change_for_adaptive == 1)) {
								//Eric@20170922 update main structure info for adaptive stream
								Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_VO_Dispinfo(DisplayModeInputInfo.resourceIndex));
								vo_timing_change_for_adaptive = 0;
							}
						}

						//I2rnd sub=>vo RPC
						if(vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE){
							vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
							rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
							//Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
							//i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
							//drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, srctype);
							drivf_Sub_I2rnd_SetupVODMA();
							//i2rnd_debug();
							rtd_pr_vsc_emerg("[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
						}
#endif
						up(&VSC_Semaphore);
                        update_vsc_task_status(0, VSC_NON_ATV_SUB_SCALER);

					}
				}
			} else if ((DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				&& (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
#ifndef BRING_UP_AUTO_FLOW

				update_vsc_task_status(1, VSC_SUB_CHECK_MODE);
				rtk_check_signal(SLR_SUB_DISPLAY);
				update_vsc_task_status(0, VSC_SUB_CHECK_MODE);
#endif
			}
		}

#ifdef CONFIG_RTK_KDRV_DV
		/* check dolby vsem packet */
		if (drvif_Hdmi_get_infoframe_thread_stop() == _FALSE) {
			static int vsem_parser_count_down = 5;

			if (vsem_parser_count_down > 0) {
				--vsem_parser_count_down;
			} else {
				dolby_vision_parser_vsem_packet(true);
				vsem_parser_count_down = 5;
			}
		}
#endif

		if (freezing(current))
       	{
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_MAIN_IP);
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_MAIN_IP);
#ifdef CONFIG_DUAL_CHANNEL
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_SUB_IP);
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_SUB_IP);
#endif
			try_to_freeze();
        }
#endif
		if (kthread_should_stop()) {
         	break;
      	}
    }
    rtd_pr_vsc_debug("\r\n####vsc_scaler_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

/* Start
20170524 pinyen create new game mode tsk
*/
#ifdef BRING_UP_K4L_TEST
static bool new_game_mode_tsk_flag = FALSE;//Record new_game_mode_tsk status. True: Task is running
static struct task_struct *p_new_game_mode_tsk = NULL;

unsigned char get_new_game_mode_vdec_memc_bypass_condition(void){

	if( is_DTV_flag_get() && (!get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY))){
	//if(!get_vsc_run_adaptive_stream(SLR_MAIN_DISPLAY)){
		// non vdec source need exclusive vdec_direct, so add  !adaptive stream flag
		return TRUE;
	}
	else
		return FALSE;
}

//to check the condition which can enter game mode or not
unsigned char get_new_game_mode_condition(void){
	 VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	 mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl_reg;
	 ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
	 ppoverlay_dtg_m_remove_input_vsync_RBUS ppoverlay_dtg_m_remove_input_vsync_reg;
	 ppoverlay_dtg_m_multiple_vsync_RBUS ppoverlay_dtg_m_multiple_vsync_reg;

	 ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	 main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
	 ppoverlay_dtg_m_multiple_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_multiple_vsync_reg);
	 ppoverlay_dtg_m_remove_input_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_Remove_input_vsync_reg);
	if (((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) ||((srctype == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))
		/*Only support HDMI and Component and AV*/
		&& !(vbe_disp_get_adaptivestream_fs_mode() && (ddr_mainctrl_reg.main_source_sel == 0x3))/*Adaptive stream & Data frame sync case do not set game mode!!*/
		&& !Get_Factory_SelfDiagnosis_Mode()/*factory self diagnosis grab pixel from third buffer,so not support single buffer mode*/
		/*&& !Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)*//*Data frame sync do not set game mode*/
		//&& (get_HDMI_HDR_mode() != HDR_DOLBY_HDMI)/*20170908, pinyen add dolby hdmi case should set iv2pv delay default value*/
		//&& !((main_active_v_start_end_reg.mv_act_end - main_active_v_start_end_reg.mv_act_sta) < _DISP_LEN)
		/* if SOC had MEMC, could support game mode
		 * if SOC had no MEMC, only support when m-dmain 1:1
		 */
	    &&((get_MEMC_bypass_status_refer_platform_model()==FALSE)||
				((ppoverlay_dtg_m_multiple_vsync_reg.dtg_m_multiple_vsync==0)&&(ppoverlay_dtg_m_remove_input_vsync_reg.remove_half_ivs_mode2==0)))
	){
		return TRUE;
	}
	else{
		return FALSE;
	}
}

unsigned char get_new_game_mode_small_window_condition(void){
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl_reg;
	//ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
	//ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
	ppoverlay_dtg_m_remove_input_vsync_RBUS ppoverlay_dtg_m_remove_input_vsync_reg;
	ppoverlay_dtg_m_multiple_vsync_RBUS ppoverlay_dtg_m_multiple_vsync_reg;
	StructSrcRect m_dispwin = Scaler_DispWindowGet();
	ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	//main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
	//main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
	ppoverlay_dtg_m_multiple_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_multiple_vsync_reg);
	ppoverlay_dtg_m_remove_input_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_Remove_input_vsync_reg);

	if (((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) ||((srctype == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))
		/*Only support HDMI and Component and AV*/
		&& !(vbe_disp_get_adaptivestream_fs_mode() && (ddr_mainctrl_reg.main_source_sel == 0x3))/*Adaptive stream & Data frame sync case do not set game mode!!*/
		&& !Get_Factory_SelfDiagnosis_Mode()/*factory self diagnosis grab pixel from third buffer,so not support single buffer mode*/
		//&& (((main_active_h_start_end_reg.mh_act_end - main_active_h_start_end_reg.mh_act_sta) < _DISP_WID) &&
		//((main_active_v_start_end_reg.mv_act_end - main_active_v_start_end_reg.mv_act_sta) < _DISP_LEN)) //check PIP case does not apply game mode. check vertical and horizontal both
		&& ((m_dispwin.src_height < _DISP_WID) && (m_dispwin.src_height < _DISP_LEN))
		&&((get_MEMC_bypass_status_refer_platform_model()==FALSE)||
				(get_panel_res() != PANEL_RES_FHD)||((ppoverlay_dtg_m_multiple_vsync_reg.dtg_m_multiple_vsync==0)&&(ppoverlay_dtg_m_remove_input_vsync_reg.remove_half_ivs_mode2==0)))
	){
		return TRUE;
	}
	else{
		return FALSE;
	}
}

void game_mode_enable_mute_mask_ctrl(void)
{//the api is used to enable game mode mask and mute on
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, TRUE);
	mute_control(SLR_MAIN_DISPLAY, TRUE);//mute on
	if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LB_MODE_GATTING_NOT_READY))
	{//line buffer mode mask disable. Becasue game mode flow already handle mute
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LB_MODE_GATTING_NOT_READY, FALSE);
	}
}
/* return ture scaler would run data fs when game mode is true
 *
 */
bool is_game_mode_set_line_buffer(void)
{
//decide game mode can use line buffer mode  when full vertical size
	bool ret = FALSE;

	if ((Get_DISPLAY_REFRESH_RATE() >= 120) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			&& (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1)
			&& (get_hdmi_4k_hfr_mode() == HDMI_NON_4K120)
			&& !(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())
			//&& (Scaler_DispWindowGet().src_height ==  _DISP_LEN)
			)
	{
		ret = TRUE;
	}
	else if((Get_DISPLAY_REFRESH_RATE() == 60) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			&& (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1)
			&& ((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 480)||
			    (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI_MEMC_FREERUN)) //converted board game mode 4k60 need use line buffer mode
			&& !(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())
			//&& (Scaler_DispWindowGet().src_height ==  _DISP_LEN)
			)
	{
		ret = TRUE;
	}
	return ret;
}


static bool is_rerun_scaler_for_go_into_game_mode(void)
{

//decide rerun scaler or not. when game mode switch to trigger line buffer and data frc switch
	bool ret = false;
	if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)) {
		if (/* (is_game_mode_set_line_buffer() && Scaler_Get_FreeRun_To_FrameSync_By_Reset_VODMA() == TRUE) || */
			 (scaler_vsc_get_gamemode_go_datafrc_mode() == TRUE)) {
			ret = true;
		}
	}

	return ret;
}


void drv_update_game_mode_frc_fs_flag(void) {
	extern bool is_caveout_memory_buffer_source(SCALER_DISP_CHANNEL display);

	int ret = -1;
	uint8_t *data = (uint8_t *)Scaler_GetShareMemVirAddr(SCALERIOC_GAMEMODE_DATA);

	GAME_MODE_DATA game_mode_data;
	GAMEMODE_TYPE game_mode_type;

	if (!drv_memory_get_game_mode()) {
		game_mode_type = GAMEMODE_NONE;
	} else if (is_game_mode_set_line_buffer()) {
		game_mode_type = GAMEMODE_FS;
	} else {
		game_mode_type = GAMEMODE_FRC;
	}

	game_mode_data.game_mode_type = htonl(game_mode_type);
	game_mode_data.is_2k_memory_buffer_source = htonl(is_caveout_memory_buffer_source(SLR_MAIN_DISPLAY));

	memcpy(data, (uint8_t *)&game_mode_data, sizeof(GAME_MODE_DATA));

	if (0 != (ret = Scaler_SendRPC(SCALERIOC_GAMEMODE_DATA, 0, 0))) {
		rtd_pr_vsc_emerg("[drv_memory_set_game_mode] ret=%d, SCALERIOC_GAMEMODE_DATA RPC fail !!!\n", ret);
	}
}

// add function to decide game mode freerun_to_framesync_method
// in small window game mode case, iv2dv delay need to tunning as a large value
// so we need to use hw_ctrl4 to avoid disp timing change to impact panel timing
void decide_game_mode_freerun_to_framesync_method(void) {
	if(vbe_get_HDMI_run_timing_framesync_condition()){
		if((get_new_game_mode_small_window_condition() && (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1))
			|| (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag() || get_scaler_qms_mode_flag())){//use hw ctrl 4
			Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
			Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
			Scaler_Set_FreeRun_To_FrameSync_By_Reset_VODMA(FALSE);
		}else{
			Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(FALSE);
			Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
			Scaler_Set_FreeRun_To_FrameSync_By_Reset_VODMA(TRUE);
		}
	}
}

void game_mode_resume_i3_vo_sw_mode(void)
{
	int ret = 0;
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_SET_VO_I3_BUF_SW_MODE,1,1)))
	{
		rtd_pr_vsc_err("ret=%d, send SCALERIOC_SET_VO_I3_BUF_SW_MODE to driver fail !!!\n", ret);
	}
}

void vo_set_force_framerate_control(unsigned int framerate)
{
	int ret = 0;

	rtd_pr_vsc_info("### func:%s framerate:%d####\r\n",__FUNCTION__, framerate);
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_SET_VO_FORCE_FRAMERATE,framerate,1)))
	{
		rtd_pr_vsc_err("ret=%d, send SCALERIOC_SET_VO_FORCE_FRAMERATE to driver fail !!!\n", ret);
	}
}

// FixMe, 20190925
extern void Scaler_MEMC_Set_BlueScreen(unsigned char is_BlueScreen);
extern unsigned char Scaler_MEMC_Lib_UltraLowDelayMode_Judge(void);
//extern bool is_hdmi_dolby_vision_sink_led(void);
extern void drv_I3ddmaVodma_config_hdmi_ivs_src(void);
extern void drvif_color_od_enable_set(unsigned char od_enable);
unsigned int frameChangeStep = 0;
extern unsigned short framerate_update_delay;

static int new_game_mode_tsk(void *p)//This task run new_game_mode_tsk
{
//    int ret = 0;
    rtd_pr_new_game_mode_debug("new_game_mode_tsk()\n");
    //rtd_pr_vsc_emerg( "new_game_mode_tsk()\n");
#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif // #ifndef UT_flag
    while (1) {
		msleep(10);//need to switch

		if (!frameChangeStep) {

		} else if (frameChangeStep < 400) {
			frameChangeStep++;
		} else if (400 == frameChangeStep) {
			frameChangeStep++;

			if(framerate_update_delay == 0xff){
				drvif_color_od_enable_set(1);/*step1: setting OD*/
			}
			printk("new_game_mode_tsk,frameChangeStep:%d,\n",frameChangeStep);

			frameChangeStep = 0;
		}
		if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			&& (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE) ) {
			if(smooth_toggle_game_mode_timeout_trigger_flag == _ENABLE) {
				rtd_pr_vsc_debug("gamemode task break for scaler trigger smooth toggle\n");
				continue;
			}

			//game mode dynamic checking
			if((drv_memory_get_low_delay_game_mode_dynamic() != drv_memory_get_game_mode_flag())
				|| (scaler_linebuffer_mode_finish && Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LB_MODE_GATTING_NOT_READY))
			//	|| (!is_game_mode_set_line_buffer() && (get_new_game_mode_condition() && (drv_memory_get_game_mode_dynamic() != scaler_vsc_get_gamemode_go_datafrc_mode())))
			) {
				/* scaler flow will reset drv_memory_get_game_mode_flag(), so need update gamemode_go_datafrc_mode flag by this condition
				    for example, fast switch picture mode, and finally exit game mode, drv_memory_get_game_mode_dynamic and drv_memory_get_game_mode_flag will be zero
				    so gamemode_go_datafrc_mode=1 cannot reset, cause non game mode go frc.
				    (scaler_linebuffer_mode_finish && Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LB_MODE_GATTING_NOT_READY) this is gatting not enable case so need to force run game mode*/
					rtd_pr_new_game_mode_emerg("game mode condition(%d.%d.%d.%d)\n",
					drv_memory_get_game_mode_dynamic(),scaler_vsc_get_gamemode_go_datafrc_mode(),drv_memory_get_game_mode_flag(),drv_memory_get_low_delay_game_mode_dynamic());
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

                    if(mutex_trylock(&gamemode_fixlastline_mutex) == 0)
                    {
                        continue; //wait fix last line done
                    }
#ifndef UT_flag
                    if(!(ScalerCheckOrbitFinish()) && ((Get_DISPLAY_PANEL_OLED_TYPE() == TRUE)))
                    {
                        unsigned int counter  = 5;
                        while(counter && !(ScalerCheckOrbitFinish()))///make sure video finish isr clear active state
                        {
                            msleep(10);
                            counter--;
                        }
                    }
#endif // #ifndef UT_flag
					if(drv_memory_get_low_delay_game_mode_dynamic() == _ENABLE){
						drv_memory_set_game_mode(_ENABLE);
					} else {
						drv_memory_set_game_mode(_DISABLE);
					}

					//update memc video latency info
					scaler_config_video_latency_info_for_memc((KADP_VSC_INPUT_TYPE_T)Get_DisplayMode_Src(SLR_MAIN_DISPLAY));

					decide_game_mode_freerun_to_framesync_method();
					if (get_new_game_mode_condition()) {
						//qiangzhou:only need run av hdmi ypp, DTV ATV Playback,CP no need run these
						/*New Game Mode Flow: Seprate the game mode setting with scaler flow.
						Enter game mode:
							change to timing frame sync => Iv2dv delay done => change to 1-buffer.

						Exit game mode:
							change to timing free run => change to 3-buffer => Iv2dv delay => change to timing FLL */

						rtd_pr_new_game_mode_emerg("[Started]New game mode flow !!\n");
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY); //check smooth toggle already done

						if(drv_memory_get_low_delay_game_mode_dynamic() == TRUE) {
							if (is_game_mode_set_line_buffer()) {
								if (Scaler_DispWindowGet().src_height == _DISP_LEN) {
									scaler_vsc_set_gamemode_go_datafrc_mode(FALSE);//game mode use line buffer mode
								} else {
									scaler_vsc_set_gamemode_go_datafrc_mode(TRUE);///game mode use data frc mode
								}
							}
							else {
								scaler_vsc_set_gamemode_go_datafrc_mode(TRUE);
							}

							if (is_rerun_scaler_for_go_into_game_mode()
#ifdef CONFIG_MDOMAIN_FORCE_FRC
							 || TRUE ==  modestate_check_mdomain_frc_scaler_rerun(SLR_MAIN_DISPLAY)
#endif
							 )
							{
								rtd_pr_new_game_mode_emerg("Enter game mode,  re-run scaler flow\n");
								// game mode data fs, need re run for go data frc
								game_mode_set_ignore_cmd_check(FALSE);
								down(&GameMode_Check_Semaphore);
								//set game_mode_dynamic_flag to avoid unmute task disable fbg
								DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE; //DbgSclrFlgTkr.game_mode_dynamic_flag means game mode during switching
								up(&GameMode_Check_Semaphore);
								game_mode_enable_mute_mask_ctrl();//enable game mode mask and mute on
								down(&VSC_Semaphore);
								rtd_pr_new_game_mode_emerg("enter re-run data frc flow++++\n");
								scaler_set_full_gatting_rpc(false);
								drivf_scaler_reset_freerun();
#ifdef CONFIG_FORCE_RUN_I3DDMA
								drvif_mode_dma_onlinemeasure_setting(FALSE, FALSE);//Disable online measure watchdog and interrupt
								drvif_mode_disable_dma_onlinemeasure();//Disable online measure
#endif
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
								DbgSclrFlgTkr.Main_Run_Scaler_flag = 1;
								up(&VSC_Semaphore);
								down(&GameMode_Check_Semaphore);
								//disable game_mode_dynamic_flag for line buffer mode change case
								DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE; //DbgSclrFlgTkr.game_mode_dynamic_flag means game mode during switching
								up(&GameMode_Check_Semaphore);
                                mutex_unlock(&gamemode_fixlastline_mutex);
								continue;
							}
							else {
								//game mode follow correct , no act
							}
							#endif
						}
						else { //if (get_new_game_mode_condition())
							// HDMI data fs, need re run scaler for data fs when exit game mode
							scaler_vsc_set_gamemode_go_datafrc_mode(FALSE);
							if((vbe_get_HDMI_run_datafs_condition()
								&& ((!Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))
								 /* || (is_game_mode_set_line_buffer(1) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC) && Scaler_Get_FreeRun_To_FrameSync_By_Reset_VODMA() == FALSE)) */
                                                         //game mode small window case use data frc no need rerun scaler
						         && (Scaler_DispWindowGet().src_height == _DISP_LEN)
							   ))
#ifdef CONFIG_MDOMAIN_FORCE_FRC
							   || TRUE ==  modestate_check_mdomain_frc_scaler_rerun(SLR_MAIN_DISPLAY)
#endif
							   ) {
								rtd_pr_new_game_mode_emerg("Exit game mode, re-run scaler flow\n");
								// game mode data fs, need re run for go data frc
								game_mode_set_ignore_cmd_check(FALSE);
								down(&GameMode_Check_Semaphore);
								//set game_mode_dynamic_flag to avoid unmute task disable fbg
								DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE; //DbgSclrFlgTkr.game_mode_dynamic_flag means game mode during switching
								up(&GameMode_Check_Semaphore);
								game_mode_enable_mute_mask_ctrl();//enable game mode mask and mute on
								down(&VSC_Semaphore);
								fw_scalerip_set_di_gamemode_setting(fw_scalerip_get_di_gamemode());
								rtd_pr_new_game_mode_emerg("exit re-run data fs flow++++\n");
								drivf_scaler_reset_freerun();
#ifdef CONFIG_FORCE_RUN_I3DDMA
								drvif_mode_dma_onlinemeasure_setting(FALSE, FALSE);//Disable online measure watchdog and interrupt
								drvif_mode_disable_dma_onlinemeasure();//Disable online measure
#endif
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
								DbgSclrFlgTkr.Main_Run_Scaler_flag = 1;
								up(&VSC_Semaphore);
								down(&GameMode_Check_Semaphore);
								//disable game_mode_dynamic_flag for line buffer mode change case
								DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE; //DbgSclrFlgTkr.game_mode_dynamic_flag means game mode during switching
								up(&GameMode_Check_Semaphore);
                                mutex_unlock(&gamemode_fixlastline_mutex);
								continue;
							}
							else {
								//game mode follow correct , no act
							}
						}

						down(&GameMode_Check_Semaphore);

						//check smooth toggle already done
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

						//sync value in game mode flow, in case break other flow
						set_vsc_gamemode_datafrc_mode_flag(scaler_vsc_get_gamemode_go_datafrc_mode());

						//re-enter game mode flow, need to disable timeout tsk.
						smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
						//smooth_toggle_game_mode_check_cnt = 0;

						//set the game mode dynamic flag.
						down(&GameMode_SCALER_SYNC_Semaphore);
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
							DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
						}
						else {
							up(&GameMode_SCALER_SYNC_Semaphore);
							up(&GameMode_Check_Semaphore);
                            mutex_unlock(&gamemode_fixlastline_mutex);
							continue;
						}
						up(&GameMode_SCALER_SYNC_Semaphore);

						//mute on
						//set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);
						game_mode_enable_mute_mask_ctrl();//enable game mode mask and mute on
						//rtd_pr_new_game_mode_emerg("Mute on\n");
#if 1/*config for game mode*/
						//Set timing free run
						if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE)
							&& ((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO) == 1)
							&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) == 1))
							&& ((drvif_scaler_get_display_mode() == DISPLAY_MODE_FRAME_SYNC) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC) == FALSE))) {
							//IoReg_ClearBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
							scaler_set_full_gatting_rpc(false);
							drivf_scaler_reset_freerun();
						}

						//DI game mode
						fw_scalerip_set_di_gamemode_setting(fw_scalerip_get_di_gamemode());
						// set edge smooth line mode
						drvif_IESM_frontporch_set(1);
						//game mode use line mode, other use frame mode for compression setting
						if(drv_memory_get_game_mode() == _ENABLE) {
							dvrif_i3ddma_set_compression_mode(I3DDMA_COMP_LINE_MODE);
							dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);
							//rtd_pr_vsc_emerg("[crixus]compression line mode\n");
                        	if(get_hdmi_4k_hfr_mode()== HDMI_4K120_2_1) {
                            	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
                                	dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, COMPRESSION_LINE_MODE);
                            	}
                        	}
							//rtd_pr_vsc_emerg("[crixus]compression line mode\n");
						}
						else {
							//under 2k timing game mode off run frame mode
							if ((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) <= 1920)
								&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) <= 1080)
								&& (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 0) && (Get_PANEL_VFLIP_ENABLE() == 0) ) {
								dvrif_i3ddma_set_compression_mode(I3DDMA_COMP_FRAME_MODE);
							}

							if (get_hdmi_vrr_4k60_mode()) {
								//vrr need always line mode, because separate even and odd line
								dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);
								dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, COMPRESSION_LINE_MODE);
							}
							else {
								dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);
							}

							if(get_hdmi_4k_hfr_mode()== HDMI_4K120_2_1) {
								if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
									dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, COMPRESSION_FRAME_MODE);
								}
 							}
							//rtd_pr_vsc_emerg("[crixus]compression frame mode\n");
						}

						//send RPC to video fw
						//drvif_memory_compression_rpc();//no need send rpc to video fw, keep 3-buffer when smooth toggle.

						zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY,0);//sync smooth toggle timing info

						//change line or frame mode for PQC
                    	if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))) {
							dvrif_memory_handler(SLR_MAIN_DISPLAY);
							vo_smoothtoggle_memory_alloc(SLR_MAIN_DISPLAY);//update m-domain buffer info to video fw
                    	}


					if(!get_scaler_qms_mode_flag())
					{//qms case does not change i3ddma buffer
						//I3DDMA and M-domain game mode
						//check config hdmi ivs src and vodma hw mode for hw_ctrl4
						drv_I3ddmaVodma_config_hdmi_ivs_src();
						if(drv_memory_get_game_mode() == _ENABLE) {
							//Dolby video or input fast case, do not set to single buffer
							if(is_game_mode_keep_buffer_mode() || (is_hdmi_dolby_vision_sink_led())
								 /*|| ((Scaler_Get_Display_Timing_Mode() == DISPLAY_MODE_FRAME_SYNC) && Scaler_Get_FreeRun_To_FrameSync_By_Reset_VODMA()) */
								) {
								drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
							}
							else {
								drv_I3ddmaVodma_SingleBuffer_GameMode(_ENABLE); //I3DDMA 1-buffer
							}
							//change M-domain to 1-buffer after iv2dv delay done
						}
						else {
							//I3DDMA 3 buffer
							drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
							//change M-domain to 3-buffer
							drv_memory_GameMode_Switch_TripleBuffer();
						}
                                        }
						//D-domain game mode
						if(drv_memory_get_game_mode() == _ENABLE) {
							drv_game_mode_timing_Dynamic(_ENABLE);
							//after timing fs lock, switch to 1-buffer
							if((vbe_disp_gamemode_use_fixlastline()==FALSE)
								&& (!Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))) {
								//if use game fll, switches to single buffer at fll tsk done.
								if(!((Get_DISPLAY_PANEL_TYPE() == P_LVDS_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI)))
									drv_memory_GameMode_Switch_SingleBuffer();
							}
							else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())) {
								//VRR Game mode change to single buffer directly
								if(!((Get_DISPLAY_PANEL_TYPE() == P_LVDS_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))) {
									drv_memory_GameMode_Switch_SingleBuffer();
								}
							}
							//rtd_pr_vsc_emerg("[crixus]Enter D-domain game mode!!!\n");
						}
						else {
							drv_game_mode_timing_Dynamic(_DISABLE);
							//rtd_pr_vsc_emerg("[crixus]Exit D-domain game mode!!!\n");
						}
						//MEMC game mode
						if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE) && (Get_DISPLAY_REFRESH_RATE() < 120)) {
							if(drv_memory_get_low_delay_game_mode_dynamic()==TRUE) {
								if(fw_get_vsc_GameMode() == FALSE) {
									vbe_disp_game_mode_memc_bypass(1);
									//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_ENABLE);
									fw_set_vsc_GameMode(1);
								}
							}
							else {
								if(fw_get_vsc_GameMode() == TRUE) {
									//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_DISABLE);
									// FixMe, 20190925
									Scaler_MEMC_Set_BlueScreen(1);//20180710, MEMC Jerry provide memc internal ptg to avoid frame blending switch from memc bypass to enable.
									vbe_disp_game_mode_memc_bypass(0);
									fw_set_vsc_GameMode(0);
								}
							}
						}
						//[WOSQRTK-12780] call MEMC low delay after force bg, to avoid video shake issue
						//need MEMC control bg to make sure bg is enable when memc index changing.
						Scaler_MEMC_Set_BlueScreen(1);
						//check disalbe NNSR for game mode
						{
							unsigned int width = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MEM_ACT_WID);
							unsigned int length = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MEM_ACT_LEN);
							if((width<=1920)&&(length<=1080))
								drvif_color_ultrazoom_config_scaling_up(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));
						}
						if(drv_memory_get_game_mode() == _ENABLE) {
							#ifndef CONFIG_MEMC_NOTSUPPORT
							rtd_pr_vsc_notice("[%s][%d][LowDelayMode] enable", __FUNCTION__, __LINE__);
							vpq_memc_set_lowDelayMode(_ENABLE);
							//trigger MEMC line mode and low delay
							Scaler_MEMC_Set_VpqLowDelayToMEMC_Flag(1);
							//MEMC line mode, set MEMC line delay to 0xa
							if(Scaler_MEMC_Lib_UltraLowDelayMode_Judge() && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)) {
								Scaler_set_MEMC_gamemode_lowdelay(_ENABLE);
							}
							#endif
						}
						else {
							#ifndef CONFIG_MEMC_NOTSUPPORT
							rtd_pr_vsc_notice("[%s][%d][LowDelayMode] disable", __FUNCTION__, __LINE__);
							vpq_memc_set_lowDelayMode(_DISABLE);
							//disable MEMC line mode and low delay
							Scaler_MEMC_Set_VpqLowDelayToMEMC_Flag(0);
							if(!Scaler_MEMC_Lib_UltraLowDelayMode_Judge() && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)) {
								Scaler_set_MEMC_gamemode_lowdelay(_DISABLE);
							}
							#endif
						}
#ifndef UT_flag
						//switch between line mode and frame mode need to wait frame delay done
						//20171018 pinyen add to fix ML3RTANDN-418
						if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))) {
							wait_game_mode_frame_delay_done();
						}
#endif // #ifndef UT_flag

#endif
						//Disable the game mode dynamic flag.
						DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;
						up(&GameMode_Check_Semaphore);

						rtd_pr_new_game_mode_emerg("[End]New game mode flow!!\n");
					}
					else if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_JPEG) {
						rtd_pr_new_game_mode_emerg("[Started]New game mode flow - VDEC!!\n");
						down(&GameMode_Check_Semaphore);
						//reset timeout tsk.
						smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
						//smooth_toggle_game_mode_check_cnt = 0;
						//set the game mode dynamic flag.
						down(&GameMode_SCALER_SYNC_Semaphore);
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
							DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
						}
						else {
							up(&GameMode_SCALER_SYNC_Semaphore);
							up(&GameMode_Check_Semaphore);
                            mutex_unlock(&gamemode_fixlastline_mutex);
							rtd_pr_vsc_err("\r\n### func:%s line:%d break####\r\n",__FUNCTION__,__LINE__);
							continue;
						}
						up(&GameMode_SCALER_SYNC_Semaphore);
#if 1
						//mute on
						game_mode_enable_mute_mask_ctrl();//enable game mode mask and mute on
#endif
						//Set timing free run
						if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE)
							&& (get_new_game_mode_vdec_memc_bypass_condition() == TRUE)
							&& ((Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) == 1)
							&& (Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) == 1))
							&& (drvif_scaler_get_display_mode() == DISPLAY_MODE_FRAME_SYNC)
							&& (Get_DISPLAY_REFRESH_RATE() < 120)) {
							//IoReg_ClearBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
							scaler_set_full_gatting_rpc(false);
							drivf_scaler_reset_freerun();
						}

						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
						//MEMC bypass
						zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY,0);//sync smooth toggle timing info
						if(get_new_game_mode_vdec_memc_bypass_condition() == TRUE) {
							if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE) && (Get_DISPLAY_REFRESH_RATE() < 120)) {
								if(drv_memory_get_low_delay_game_mode_dynamic()==TRUE) {
									if(fw_get_vsc_GameMode() == FALSE) {
										rtd_pr_new_game_mode_notice("[GameMode]VDEC condition: MEMC_BYPASS 1\n");
										vbe_disp_game_mode_memc_bypass(1);//no need control
										//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_ENABLE);
										fw_set_vsc_GameMode(1);
									}
								}
								else {
									if(fw_get_vsc_GameMode() == TRUE) {
										rtd_pr_new_game_mode_notice("[GameMode]VDEC condition: MEMC_BYPASS 0\n");
										//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_DISABLE);
										Scaler_MEMC_Set_BlueScreen(1);
										vbe_disp_game_mode_memc_bypass(0);//no need control
										fw_set_vsc_GameMode(0);
									}
								}
							}
						}

						//[WOSQRTK-12780] call MEMC low delay after force bg, to avoid video shake issue
						//need MEMC control bg to make sure bg is enable when memc index changing.
						Scaler_MEMC_Set_BlueScreen(1);
						if(drv_memory_get_game_mode_flag() == _ENABLE) {
							#ifndef CONFIG_MEMC_NOTSUPPORT
							rtd_pr_vsc_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
							vpq_memc_set_lowDelayMode(_ENABLE);
							//trigger MEMC line mode and low delay
							Scaler_MEMC_Set_VpqLowDelayToMEMC_Flag(1);
							if(Scaler_MEMC_Lib_UltraLowDelayMode_Judge() && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)) {
								Scaler_set_MEMC_gamemode_lowdelay(_ENABLE);
							}
							#endif
						}
						else {
							#ifndef CONFIG_MEMC_NOTSUPPORT
							rtd_pr_vsc_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
							vpq_memc_set_lowDelayMode(_DISABLE);
							//disable MEMC line mode and low delay
							Scaler_MEMC_Set_VpqLowDelayToMEMC_Flag(0);
							if(!Scaler_MEMC_Lib_UltraLowDelayMode_Judge() && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)) {
								Scaler_set_MEMC_gamemode_lowdelay(_DISABLE);
							}
							#endif
						}

						//Disable the game mode dynamic flag.
						DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;
						up(&GameMode_Check_Semaphore);
						rtd_pr_new_game_mode_emerg("[End]New game mode flow-VDEC!!\n");
					}
                mutex_unlock(&gamemode_fixlastline_mutex);
			}
		}
		if (freezing(current)) {
			try_to_freeze();
		}

		if (kthread_should_stop()){
			break;
		}
   	}

    rtd_pr_new_game_mode_debug("\r\n####new_game_mode_tsk: exit...####\n");
    //rtd_pr_vsc_emerg( "\r\n####new_game_mode_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

#ifndef UT_flag
static void create_new_game_mode_tsk(void)
{
    int err;
	if (new_game_mode_tsk_flag == FALSE) {
		p_new_game_mode_tsk = kthread_create(new_game_mode_tsk, NULL, "new_game_mode_tsk");

	    if (p_new_game_mode_tsk) {
			wake_up_process(p_new_game_mode_tsk);
			new_game_mode_tsk_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_new_game_mode_tsk);
		rtd_pr_vsc_debug("Unable to start new_game_mode_tsk (err_id = %d)./n", err);
	    }
	}
}

/* End
20170524 pinyen create new game mode tsk
*/

static void create_vsc_tsk(void)
{
	int err;
	if (vsc_tsk_running_flag == FALSE) {
		p_vsc_tsk = kthread_create(vsc_scaler_tsk, NULL, "vsc_tsk");

	    if (p_vsc_tsk) {
			wake_up_process(p_vsc_tsk);
			vsc_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_vsc_tsk);
	    	rtd_pr_vsc_debug("Unable to start create_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_vsc_tsk(void)
{
	int ret;
	if (vsc_tsk_running_flag) {
		if(p_vsc_tsk){
	 		ret = kthread_stop(p_vsc_tsk);
	 		if (!ret) {
	 			p_vsc_tsk = NULL;
	 			vsc_tsk_running_flag = FALSE;
				rtd_pr_vsc_debug("vsc_scaler_tsk thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_debug("vsc_scaler_tsk thread stopped already\n");
		}
	}
}
#endif // #ifndef UT_flag
static UINT8 enable_VRR_mode_dynamic = _DISABLE;
void drv_set_vrr_mode_dynamic(unsigned char enable){
    enable_VRR_mode_dynamic = enable;
}

unsigned char drv_get_vrr_mode_dynamic(void){
    return enable_VRR_mode_dynamic;
}

static UINT8 enable_freesync_mode_dynamic = _DISABLE;
void drv_set_freesync_mode_dynamic(unsigned char enable){
    enable_freesync_mode_dynamic = enable;
}

unsigned char drv_get_freesync_mode_dynamic(void){
    return enable_freesync_mode_dynamic;
}

static UINT8 enable_vrr_low_delay_mode_Dynamic = _DISABLE;
void drv_set_vrr_low_delay_mode_dynamic(unsigned char enable){
    enable_vrr_low_delay_mode_Dynamic = enable;
}

unsigned char drv_get_vrr_low_delay_mode_dynamic(void){
    return enable_vrr_low_delay_mode_Dynamic;
}
#ifndef UT_flag
static int variable_refresh_rate_tsk(void *p)//This task run variable_refresh_rate_tsk
{
//    int ret = 0;
    rtd_pr_vsc_debug("variable_refresh_rate_tsk()\n");
    //rtd_pr_vsc_emerg( "variable_refresh_rate_tsk()\n");
    current->flags &= ~PF_NOFREEZE;
    while (1)
    {
            msleep(10);//need to switch

        if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE && (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE)){

           if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			{
#if 0
                //vrr dynamic checking
				if(vbe_disp_get_VRR_timingMode_flag() == drvif_Hdmi_GetVRREnable())
				{

					//VRR low delay flow
					if(vbe_disp_get_VRR_ALLM_flag() != drv_get_vrr_low_delay_mode_dynamic()){
						drv_set_vrr_low_delay_mode_dynamic(_ENABLE);
						if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
							if(1/*vbe_disp_get_VRR_ALLM_flag()*/){
								//VRR low delay mode
								if(!((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))){
									//check smooth toggle already done
									Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
									dvrif_LowDelay_memory_handler(_ENABLE);
									rtd_pr_vsc_notice("###[VRR] enter VRR low delay mode, set to M-domain single buffer###\n");
								}
							}
							/*
							else{
								drv_set_vrr_low_delay_mode_dynamic(_DISABLE);
								dvrif_LowDelay_memory_handler(_DISABLE);
								rtd_pr_vsc_notice("###[VRR] exit VRR low delay mode, set to M-domain triple buffer###\n");
							}
							*/
						}
					}
				}
#endif
				if(vbe_disp_get_freesync_mode_flag() == drvif_Hdmi_GetAMDFreeSyncEnable())
				{
					//Freesync flow
					if(vbe_disp_get_freesync_mode_flag() != drv_get_freesync_mode_dynamic()){
						drv_set_freesync_mode_dynamic(_ENABLE);
						if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
							if(vbe_disp_get_freesync_mode_flag()){
								drv_set_vrr_low_delay_mode_dynamic(_ENABLE);
								// set edge smooth line mode
								//drvif_IESM_frontporch_set();
								if(!((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))){
									Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
									dvrif_LowDelay_memory_handler(_ENABLE);
									rtd_pr_vsc_notice("###[VRR] enter freesync_mode mode, set to M-domain single buffer###\n");
								}
							}
						}
					}
				}
			}
        }

        if (freezing(current))
        {
            try_to_freeze();
        }

        if (kthread_should_stop())
            break;
        }

    rtd_pr_vsc_debug("\r\n####variable_refresh_rate_tsk: exit...####\n");
    //rtd_pr_vsc_emerg( "\r\n####variable_refresh_rate_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static bool variable_refresh_rate_flag = FALSE;//Record variable_refresh_rate_tsk status. True: Task is running
static struct task_struct *p_variable_refresh_rate_tsk = NULL;

static void create_variable_refresh_rate_tsk(void)
{
    int err;
    if (variable_refresh_rate_flag == FALSE) {
        p_variable_refresh_rate_tsk = kthread_create(variable_refresh_rate_tsk, NULL, "variable_refresh_rate_tsk");

        if (p_variable_refresh_rate_tsk) {
            wake_up_process(p_variable_refresh_rate_tsk);
            variable_refresh_rate_flag = TRUE;
        } else {
            err = PTR_ERR(p_variable_refresh_rate_tsk);
        rtd_pr_vsc_debug("Unable to start variable_refresh_rate_tsk (err_id = %d)./n", err);
        }
    }
}
#endif // #ifndef UT_flag
void trigger_mute_on_by_isr(unsigned char display)
{//use spin lock for ISR
	unsigned long flags = 0;//for spin_lock_irqsave

	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
		wake_up(&FORCEBG_WAIT_QUEUE);
		//rtd_pr_vsc_notice("\r\n#### func:%s line:%d trigger mute off####\r\n",__FUNCTION__,__LINE__);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
		wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}

void trigger_mute_off_by_isr(unsigned char display, unsigned char no_delay)
{//use spin lock for ISR
	unsigned long flags = 0;//for spin_lock_irqsave

	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
		//rtd_pr_vsc_notice("\r\n#### func:%s line:%d trigger mute off####\r\n",__FUNCTION__,__LINE__);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}



void trigger_mute_off(unsigned char display, unsigned char no_delay)
{//trigger to call mute off flow at video_muteoff_tsk
	unsigned long flags = 0;//for spin_lock_irqsave
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}

unsigned char get_request_ForceBG_ctrl(unsigned char display)
{
	unsigned long flags = 0;//for spin_lock_irqsave
	unsigned char result = FALSE;
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		result = DbgSclrFlgTkr.Main_Request_ForceBG_ctrl;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		result = DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
	}
#endif
	return result;
}

#ifndef UT_flag
static bool forcebg_tsk_running_flag = FALSE;//Record forcebg_scaler_tsk status. True: Task is running
static struct task_struct *p_forcebg_tsk = NULL;

static int video_muteoff_tsk(void *p)
{//for disable forcebg
#define DEBUG_PRINT_CONTER 20
    unsigned int wait_av_sync_timeout;
    unsigned char vdec_mute_off_check = TRUE;//TRUE can mute off. FALSE can not mute off

	unsigned long flags;//for spin_lock_irqsave
	char main_debug_counter = DEBUG_PRINT_CONTER;//when the value is 0. print error message
	char sub_debug_counter = DEBUG_PRINT_CONTER;//when the value is 0. print error message
	rtd_pr_vsc_debug( "video_muteoff_tsk()\n");
	/*struct cpumask vsc_cpumask;
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);*/
#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif // #ifndef UT_flag
	while (1)
	{
#ifdef CONFIG_DUAL_CHANNEL
		wait_event_freezable_timeout(FORCEBG_WAIT_QUEUE, get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY) || get_request_ForceBG_ctrl(SLR_SUB_DISPLAY), 30);//Timeout is 300ms
#else
		wait_event_freezable_timeout(FORCEBG_WAIT_QUEUE, get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY), 30);//Timeout is 300ms
#endif

#ifdef CONFIG_DUAL_CHANNEL
		if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY) || get_request_ForceBG_ctrl(SLR_SUB_DISPLAY))
#else
		if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY))
#endif
		{
			if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY)) {
				spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
				DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = FALSE;
				spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
				{
					mute_control(SLR_MAIN_DISPLAY, TRUE);//mute on
				}
				else if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DOLBY))
				{
					mute_control(SLR_MAIN_DISPLAY, TRUE);//mute on for hdmi sink-led crc error
				}
				else if(Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, TRUE) == FALSE)
				{
					if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) ==  VSC_INPUTSRC_VDEC)
					{
						vdec_mute_off_check = TRUE;
						for(wait_av_sync_timeout = 30; wait_av_sync_timeout > 0 ; wait_av_sync_timeout--)
						{//wait av sync ready
							if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) !=  VSC_INPUTSRC_VDEC) || (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								|| (Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, FALSE) == TRUE))
							{
								vdec_mute_off_check = FALSE;
								break;
							}
							else if(get_vo_avsync_flag(0))
							{//av sync ready
								break;
							}
							msleep(10);
						}
						if(vdec_mute_off_check)
							mute_control(SLR_MAIN_DISPLAY, FALSE);
						else
						{
							rtd_pr_vsc_notice("#####[%s(%d)]vdec change, so can not mute off \n", __func__, __LINE__);
						}
					}
					else
						mute_control(SLR_MAIN_DISPLAY, FALSE);
				}
			}
#ifdef CONFIG_DUAL_CHANNEL
			if(get_request_ForceBG_ctrl(SLR_SUB_DISPLAY)) {
				spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
				DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = FALSE;
				spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
				{
					mute_control(SLR_SUB_DISPLAY, TRUE);//mute on
				}
				else if(Check_ForceBG_Mask_Enable(SLR_SUB_DISPLAY, TRUE) == FALSE)
				{
					mute_control(SLR_SUB_DISPLAY, FALSE);
				}
			}

#endif
		}
		if(!DbgSclrFlgTkr.Main_Request_ForceBG_ctrl && !Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, FALSE))
		{
			if(!main_debug_counter)
			{
				main_debug_counter = DEBUG_PRINT_CONTER;
				check_abnormal_mute_on_condition(SLR_MAIN_DISPLAY);//check and print abnormal condition
			}
			else
				main_debug_counter --;
		}
		else
		{
			main_debug_counter = DEBUG_PRINT_CONTER;
		}
#ifdef CONFIG_DUAL_CHANNEL
		if(!DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl && !Check_ForceBG_Mask_Enable(SLR_SUB_DISPLAY, FALSE))
		{
			if(!sub_debug_counter)
			{
				sub_debug_counter = DEBUG_PRINT_CONTER;
				check_abnormal_mute_on_condition(SLR_SUB_DISPLAY);//check and print abnormal condition
			}
			else
				sub_debug_counter --;
		}
		else
		{
			sub_debug_counter = DEBUG_PRINT_CONTER;
		}
#endif
		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
	}

	rtd_pr_vsc_debug( "\r\n####video_muteoff_tsk: exit...####\n");
	do_exit(0);
	return 0;
}



static void create_forcebg_tsk(void)
{
	int err;
	if (forcebg_tsk_running_flag == FALSE) {
		p_forcebg_tsk = kthread_create(video_muteoff_tsk, NULL, "forcebg_tsk");

	    if (p_forcebg_tsk) {
			wake_up_process(p_forcebg_tsk);
			forcebg_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_forcebg_tsk);
	    	rtd_pr_vsc_debug("Unable to start video_muteoff_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_forcebg_tsk(void)
{
	int ret;
	if (forcebg_tsk_running_flag) {
		if(p_forcebg_tsk){
	 		ret = kthread_stop(p_forcebg_tsk);
	 		if (!ret) {
	 			p_forcebg_tsk = NULL;
	 			forcebg_tsk_running_flag = FALSE;
				rtd_pr_vsc_debug("video_forcebg_tsk thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_debug("video_forcebg_tsk thread stopped already\n");
		}
	}
}

void isr_control_hdmi_avmute(unsigned char display)
{//hdmi av mute flow use
	unsigned char av_mute_status;
	if(Get_DisplayMode_Src(display) == VSC_INPUTSRC_HDMI)
	{
		av_mute_status = drvif_Hdmi_IsAvmute();
		if(av_mute_status)
		{
			if(!Get_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
			{
				set_display_forcebg_mask_by_isr(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, TRUE);
				trigger_mute_on_by_isr(display);
				//mute on
			}
		}
		else
		{
			if(Get_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
			{
				set_display_forcebg_mask_by_isr(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, FALSE);
				trigger_mute_off_by_isr(display, 1);//mute off
			}
		}
	}
}
#endif // #ifndef UT_flag

#define FLL_UZUDTG_VSYNC_LINE_DELAY 63
#define FLL_UZUDTG_WAIT_LINE_RANGE 20
#define FLL_LOWER_DOUNDARY_PERCENT 22//lower boundary is total line * 2.2%
#define FLL_UPPER_DOUNDARY_PERCENT 44 //upper boundary is total line * 4.4%
#ifndef UT_flag
static bool fix_lastline_tsk_running_flag = FALSE;//Record fixlastline_scaler_tsk status. True: Task is running
static struct task_struct *p_fix_lastline_tsk = NULL;
static bool localDimmingDemoCtrl_tsk_running_flag = FALSE;
static struct task_struct *p_localDimmingDemoCtrl_tsk	= NULL;

extern void drvif_scaler_set_frc2fsync_vtotal_protect_on_without_den_shift(void);
extern void drvif_scaler_set_fixlastline_vtotal_speedup_protect_on(void);
extern void drvif_scaler_set_frc2fsync_vtotal_protect_off(void);
extern void drvif_scaler_set_frc2fsync_recovery_vtotal(unsigned int u32_vtotal);


unsigned char vsc_decide_fixlastline_speedup_enable(void)
{
	unsigned char b_enable = 1;

	if(drvif_scaler_get_display_mode() == DISPLAY_MODE_FRAME_SYNC){
		b_enable = 0;
	}
	//if(Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) != 1){
	//	b_enable = 0;
	//}
	return b_enable;
}
/*
typedef struct{
	int  x;
	int  y;
}ORBIT_PIXEL_SHIFT_STRUCT;
*/
extern ORBIT_PIXEL_SHIFT_STRUCT vbe_disp_calculate_orbit_position(unsigned int MaxPixelShift, unsigned int MaxLineShift, unsigned int index);

static int localDimmingDemoCtrl_tsk(void *p)
{

	KADP_VIDEO_RECT_T outputRegion;

	outputRegion.x = 0;
	outputRegion.y = 0;
	outputRegion.w = 768;
	outputRegion.h = 2160;

	current->flags &= ~PF_NOFREEZE;

	while(1){

			latency_pattern_self_test_run();
/*
			if(vbe_disp_orbit_get_vo_overscan()==1 && !main_arc_change_flag){
				//vbe_disp_orbit_set_vo_overscan(0);
				if(!(IoReg_Read32(0xb8022288)&_BIT26)){
					vbe_disp_orbit_vo_overscan();
					vbe_disp_orbit_sub_overscan();
				}
			}
			if(vbe_disp_orbit_get_frc_overscan()==1 && !main_arc_change_flag){
				vbe_disp_orbit_set_frc_overscan(0);
				vbe_disp_orbit_frc_overscan();
				vbe_disp_orbit_sub_overscan();
			}
*/
			if(LocalDimmingDemoCtrlMode){
				rtk_hal_vsc_makeColoredVideo(1);

				do{
					outputRegion.x +=20;
					rtk_hal_vsc_SetOutputRegion(0, outputRegion, 0,0);
					if(outputRegion.x+outputRegion.w >= 3840){
						outputRegion.x=0;
					}
				}while(LocalDimmingDemoCtrlMode);

				rtk_hal_vsc_makeColoredVideo(0);
				outputRegion.x = 0;
				outputRegion.y = 0;
				outputRegion.w = 768;
				outputRegion.h = 2160;
			}

			if (freezing(current))
			{
				try_to_freeze();
			}
			if (kthread_should_stop()) {
				break;
			}
			msleep(10);

	}

	rtd_pr_vsc_debug( "\r\n####localDimmingDemoCtrl_tsk: exit...####\n");
	do_exit(0);
	return 0;

}
#endif // #ifndef UT_flag
unsigned char b_gamemode_force_framerate_lowdelay_mode = 0;
unsigned int u32_external_src_vfreq = 0;
unsigned int u32_external_src_backproch = 0;
unsigned int u32_gamemode_rerun_count = 0;

unsigned int scaler_vsc_get_gamemode_rerun_count(void)
{
    return u32_gamemode_rerun_count;
}

void scaler_vsc_reset_gamemode_rerun_count(void)
{
    u32_gamemode_rerun_count = 0;
}

void scaler_vsc_increase_gamemode_rerun_count(void)
{
    u32_gamemode_rerun_count++;
}


void scaler_vsc_set_external_src_vfreq(unsigned char display,   unsigned short vfreq)
{
    if(display == SLR_MAIN_DISPLAY)
        u32_external_src_vfreq = vfreq;
}

void scaler_vsc_set_external_src_backporch(unsigned char display, unsigned int backporch)
{
    if(display == SLR_MAIN_DISPLAY)
        u32_external_src_backproch = backporch;
}

unsigned int scaler_vsc_get_external_src_vfreq(void)
{
    return u32_external_src_vfreq;
}

unsigned int scaler_vsc_get_external_src_backporch(void)
{
    return u32_external_src_backproch;
}

static DEFINE_SPINLOCK(Decide_Game_Mode_Buffer_Mode_Spinlock);/*For scaler_vsc_set_gamemode_go_datafrc_mode ise*/
unsigned char b_gamemode_go_datafrc_mode = 0;
void scaler_vsc_set_gamemode_go_datafrc_mode(UINT8 bOnOff)
{//if bOnOff is true, game mode really to use dat frc mode. if false: use line buffer mode or not at game mode
	//int ret = -1;
	UINT8 ori_bOnOff = bOnOff;
	spin_lock(&Decide_Game_Mode_Buffer_Mode_Spinlock);
	if(bOnOff)
	{
		if((!drv_memory_get_low_delay_game_mode_dynamic()) || (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE))
		{
			bOnOff = 0;
		}
	}
	b_gamemode_go_datafrc_mode = bOnOff;
	spin_unlock(&Decide_Game_Mode_Buffer_Mode_Spinlock);

	rtd_pr_vsc_notice("function=%s, bOnOff=(%d -> %d) \n", __FUNCTION__, ori_bOnOff, bOnOff);
#if 0
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_GAMEMODE_FRC_ENABLE, bOnOff, 1))){
		rtd_pr_vsc_err("ret=%d, SCALERIOC_GAMEMODE_FRC_ENABLE RPC fail !!!\n", ret);
	}
#endif
}

UINT8 scaler_vsc_get_gamemode_go_datafrc_mode(void)
{//if bOnOff is true, game mode really to use dat frc mode. if false: use line buffer mode or not at game mode
	return b_gamemode_go_datafrc_mode;
}


void scaler_vsc_set_gamemode_force_framerate_lowdelay_mode(UINT8 bOnOff)
{
    int ret = -1;

    rtd_pr_vsc_notice("function=%s, bOnOff=%d \n", __FUNCTION__, bOnOff);
    b_gamemode_force_framerate_lowdelay_mode = bOnOff;

    if (0 != (ret = Scaler_SendRPC(SCALERIOC_GAMEMODE_FORCE_VO_FRAMERATE_FLAG, bOnOff, 1))){
        rtd_pr_vsc_err("ret=%d, SCALERIOC_GAMEMODE_FORCE_VO_FRAMERATE_FLAG RPC fail !!!\n", ret);
    }
}

UINT8 scaler_vsc_get_gamemode_force_framerate_lowdelay_mode(void)
{
    return b_gamemode_force_framerate_lowdelay_mode;
}

unsigned char b_adaptive_pst_lowdelay_mode = 0;
extern void drivf_scaler_reset_fraction_ratio(void);

void scaler_vsc_set_adaptive_pst_lowdelay_mode(UINT8 bOnOff)
{
//#ifdef CONFIG_MEMC_BYPASS
//        rtd_pr_vsc_notice("function=%s, memc by pass not to run\n", __FUNCTION__);
//        return;
//#else //CONFIG_MEMC_BYPASS
	int ret = -1;
	unsigned int targetLowBound = 0;
	extern unsigned int drvif_scaler_voFrameRateControl_get_lowBound(DISP_MODE flag_3d);
    SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
	if(get_MEMC_bypass_status_refer_platform_model() == TRUE) {
		rtd_pr_vsc_notice("function=%s, memc by pass not to run\n", __FUNCTION__);
		return;
	}
	rtd_pr_vsc_notice("function=%s, bOnOff=%d \n", __FUNCTION__, bOnOff);

	if((Get_DISPLAY_REFRESH_RATE() < 120)&&(Scaler_MEMC_GetMotionType() == VPQ_MEMC_TYPE_55_PULLDOWN) &&(fwif_color_get_cinema_mode_en() == 1)){ //tru-motion off + real cinema
		targetLowBound = DEFAULT_LOW_BOUND;
	}else{
		if ((get_vt_EnableFRCMode() != FALSE) &&(Get_DISPLAY_REFRESH_RATE() >= 120) && (pVOInfo->is2KCP == 1)) {
			targetLowBound = 99500;
		} else {
			targetLowBound = 49000;
		}
	}

	if((drvif_scaler_voFrameRateControl_get_lowBound(0)== targetLowBound) && (b_adaptive_pst_lowdelay_mode == bOnOff)
		&& !(bOnOff == 0 && scaler_vsc_get_keep_vo_framerate_control() == 0)){
		rtd_pr_vsc_notice("function=%s, no need update, return. \n", __FUNCTION__);
		return;
	}
	b_adaptive_pst_lowdelay_mode = bOnOff;

	drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));

#if 0	//[KTASKWBS-11949] This will cause Youtube 24Hz video garbage at playback start, mark it.
	if(bOnOff){
        down(&VBE_LowDelay_Semaphore);
		drivf_scaler_reset_fraction_ratio();
        up(&VBE_LowDelay_Semaphore);
	}
#endif
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_PST_RERUN_VO_FLAG, bOnOff, 1))){
		rtd_pr_vsc_err("ret=%d, SCALERIOC_PST_RERUN_VO_FLAG RPC fail !!!\n", ret);
	}
//#endif//CONFIG_MEMC_BYPASS
}
EXPORT_SYMBOL(scaler_vsc_set_adaptive_pst_lowdelay_mode);

UINT8 scaler_vsc_get_adaptive_pst_lowdelay_mode(void)
{
	return b_adaptive_pst_lowdelay_mode;
}

unsigned char b_force_pst_lowdelay_mode = 0;

void scaler_vsc_set_force_pst_lowdelay_mode(UINT8 bOnOff)
{
	rtd_pr_vsc_err("scaler_vsc_set_force_pst_lowdelay_mode = %d\n", bOnOff);
	b_force_pst_lowdelay_mode = bOnOff;
}
EXPORT_SYMBOL(scaler_vsc_set_force_pst_lowdelay_mode);

UINT8 scaler_vsc_get_force_pst_lowdelay_mode(void)
{
	return b_force_pst_lowdelay_mode;
}
unsigned char b_keep_vo_framerate_control = 0;

void scaler_vsc_set_keep_vo_framerate_control(UINT8 bOnOff)
{
    rtd_pr_vsc_err("scaler_vsc_set_keep_vo_framerate_control = %d\n", bOnOff);
    b_keep_vo_framerate_control = bOnOff;
}
EXPORT_SYMBOL(scaler_vsc_set_keep_vo_framerate_control);

UINT8 scaler_vsc_get_keep_vo_framerate_control(void)
{
    return b_keep_vo_framerate_control;
}

static UINT8 stVR360_block_mdomain_db_flag = 0;

void scaler_vsc_set_vr360_block_mdomain_doublebuffer(UINT8 bEnable)
{
	stVR360_block_mdomain_db_flag = bEnable;

}

UINT8 scaler_vsc_get_vr360_block_mdomain_doublebuffer(void)
{
	return stVR360_block_mdomain_db_flag;
}


void scaler_vsc_vr360_enter_datafs_proc(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS ddr_mainsubctrl_reg;
	mdomain_cap_cap_reg_doublbuffer_RBUS cap_reg_doublbuffer_reg;
	vodma_vodma_clkgen_RBUS vodma_vodma_clkgen_reg;
	mdomain_cap_cap_pq_cmp_RBUS mdomain_cap_cap_pq_cmp_reg;
	mdomain_disp_dispm_main_pq_decmp_RBUS mdomain_disp_dispm_main_pq_decmp_reg;
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	mdomain_cap_main_sdnr_cxxto64_RBUS mdomain_cap_main_sdnr_cxxto64_reg;
	mdomain_cap_smooth_tog_ctrl_0_RBUS mdomain_cap_smooth_tog_ctrl_0_reg;
	UINT32 count = 0x3ffffff;
	UINT8 record_422CAP_flag = 0;

	rtd_pr_vsc_notice("[%s] [line %d] \n", __FUNCTION__, __LINE__);

	record_422CAP_flag = Scaler_DispGetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP);

	scaler_vsc_set_vr360_block_mdomain_doublebuffer(TRUE);

	//timing free run
	drivf_scaler_reset_freerun();
	modestate_set_fll_running_flag(FALSE);
	Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, TRUE);

	Scaler_DispSetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP, FALSE);
    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
	Scaler_Set_Display_Timing_Mode(DISPLAY_MODE_FRAME_SYNC);
	IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg,_BIT14);  //close watch dog for data framesync flow
	vbe_disp_set_dtgM2uzu_lowdelay_mode(1);

	//enable full gating
	vodma_vodma_clkgen_reg.regValue = IoReg_Read32(VODMA_VODMA_CLKGEN_reg);
	vodma_vodma_clkgen_reg.en_fifo_full_gate = 1;
	IoReg_Write32(VODMA_VODMA_CLKGEN_reg, vodma_vodma_clkgen_reg.regValue);

	//enable m-domain double buffer
	cap_reg_doublbuffer_reg.regValue =IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_en=1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg, cap_reg_doublbuffer_reg.regValue);
	ddr_mainsubctrl_reg.regValue =IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	ddr_mainsubctrl_reg.disp1_double_enable=1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);


	fw_scalerdisplay_handler(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
	drvif_color_ultrazoom_config_scaling_up(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));
	dvrif_memory_setting_for_data_fs();
	drvif_memory_set_fs_display_fifo();
	dvrif_memory_comp_setting(FALSE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN), dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));

	//disable compression
	mdomain_cap_cap_pq_cmp_reg.regValue = IoReg_Read32(MDOMAIN_CAP_CAP_PQ_CMP_reg);
	mdomain_cap_cap_pq_cmp_reg.cmp_en = 0;
	IoReg_Write32(MDOMAIN_CAP_CAP_PQ_CMP_reg, mdomain_cap_cap_pq_cmp_reg.regValue);

	// Disable PQC clk
	mdomain_cap_smooth_tog_ctrl_0_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Smooth_tog_ctrl_0_reg);
	mdomain_cap_smooth_tog_ctrl_0_reg.in1_pqc_clken = 1; // 1: disable
	IoReg_Write32(MDOMAIN_CAP_Smooth_tog_ctrl_0_reg, mdomain_cap_smooth_tog_ctrl_0_reg.regValue);

	mdomain_disp_dispm_main_pq_decmp_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DISPM_MAIN_PQ_DECMP_reg);
	mdomain_disp_dispm_main_pq_decmp_reg.decmp_en = 0;
	IoReg_Write32(MDOMAIN_DISP_DISPM_MAIN_PQ_DECMP_reg, mdomain_disp_dispm_main_pq_decmp_reg.regValue);


	mdomain_disp_ddr_mainctrl_reg.regValue = 0;
	mdomain_disp_ddr_mainctrl_reg.main_source_sel = 3;
	mdomain_disp_ddr_mainctrl_reg.main_decompression_clk_en = 1;
	mdomain_disp_ddr_mainctrl_reg.main_in_format = 1;
	mdomain_disp_ddr_mainctrl_reg.main_bit_num = (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_10BIT)?1:0);
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, mdomain_disp_ddr_mainctrl_reg.regValue);
	mdomain_cap_main_sdnr_cxxto64_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Main_SDNR_cxxto64_reg);
	mdomain_cap_main_sdnr_cxxto64_reg.out_bit = Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT);
	mdomain_cap_main_sdnr_cxxto64_reg.sort_fmt = Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_422CAP) ? 0 : 1;
	IoReg_Write32(MDOMAIN_CAP_Main_SDNR_cxxto64_reg, mdomain_cap_main_sdnr_cxxto64_reg.regValue);
	IoReg_ClearBits(MDOMAIN_CAP_Cap_In1_enable_reg, MDOMAIN_CAP_Cap_In1_enable_in1_cap_enable_mask);
	IoReg_ClearBits(MDOMAIN_DISP_Disp_main_enable_reg,	MDOMAIN_DISP_Disp_main_enable_main_disp_en_mask);

	//M-domain DB_apply
	cap_reg_doublbuffer_reg.cap1_db_apply=1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg, cap_reg_doublbuffer_reg.regValue);
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);
	count = 0x3ffffff;
	while((ddr_mainsubctrl_reg.disp1_double_apply)&&--count){
		ddr_mainsubctrl_reg.regValue =IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	}

	// restore flags
	Scaler_DispSetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP, record_422CAP_flag);
	scaler_vsc_set_vr360_block_mdomain_doublebuffer(FALSE);
}

#define APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA 400

void scaler_vsc_vr360_enter_datafrc_proc(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS ddr_mainsubctrl_reg;
	mdomain_cap_cap_reg_doublbuffer_RBUS cap_reg_doublbuffer_reg;
	mdomain_cap_ddr_in1status_RBUS mdomain_cap_ddr_in1status_reg;
	mdomain_disp_ddr_mainprevstart_RBUS mdomain_ddr_mainprevstart_reg;
	mdomain_cap_ddr_in1ctrl_RBUS mdomain_cap_ddr_in1ctrl_reg;
//	mdomain_cap_cap_ddr_fifostatus_RBUS mdomain_cap_cap_ddr_fifostatus_reg;
	mdomain_disp_ddr_mainstatus_RBUS mdomain_disp_ddr_mainstatus_reg;
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	vgip_vgip_chn1_lc_RBUS vgip_vgip_chn1_lc_reg;
	UINT32 count = 0x3ffffff;

	rtd_pr_vsc_notice("[%s] [line %d] \n", __FUNCTION__, __LINE__);

	scaler_vsc_set_vr360_block_mdomain_doublebuffer(TRUE);

	Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);

	//enable m-cap double buffer
	cap_reg_doublbuffer_reg.regValue = IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_en = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);
	//enable m-disp double buffer
	ddr_mainsubctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	ddr_mainsubctrl_reg.disp1_double_enable = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg,ddr_mainsubctrl_reg.regValue);

	IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg,_BIT14);  //close watch dog for data framesync flow

	dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);

	dvrif_memory_handler(SLR_MAIN_DISPLAY);

	mdomain_ddr_mainprevstart_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainPreVStart_reg);
	mdomain_ddr_mainprevstart_reg.main_pre_rd_v_start = 17;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainPreVStart_reg, mdomain_ddr_mainprevstart_reg.regValue);
	//DIC recommand, db latch line = pre_read+2
	scaler_disp_dtg_set_db_latch_line(mdomain_ddr_mainprevstart_reg.main_pre_rd_v_start+2);

	mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	mdomain_disp_ddr_mainctrl_reg.main_double_en = 0;
	mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en = 0;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, mdomain_disp_ddr_mainctrl_reg.regValue);

	mdomain_cap_ddr_in1ctrl_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Ctrl_reg);
	mdomain_cap_ddr_in1ctrl_reg.in1_double_enable = 0;
	mdomain_cap_ddr_in1ctrl_reg.in1_v_flip_3buf_en = 0;
	IoReg_Write32(MDOMAIN_CAP_DDR_In1Ctrl_reg, mdomain_cap_ddr_in1ctrl_reg.regValue);

	IoReg_SetBits(MDOMAIN_CAP_Cap_In1_enable_reg, MDOMAIN_CAP_Cap_In1_enable_in1_cap_enable_mask);


	//apply m-cap double buffer
	cap_reg_doublbuffer_reg.cap1_db_apply = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);
	//apply m-disp double buffer
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);

	//wait above settings apply
	count = 0x3ffffff;
	while(count--){
		cap_reg_doublbuffer_reg.regValue = IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
		ddr_mainsubctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		if((cap_reg_doublbuffer_reg.cap1_db_apply == 0) && (ddr_mainsubctrl_reg.disp1_double_apply == 0))
			break;
	}

	// <<<====================	single buffer , compressio line mode //////////////////////////

	dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);

	count = 0x3ffffff;
	while(--count){
		vgip_vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
		if((vgip_vgip_chn1_lc_reg.ch1_line_cnt) < APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA)
			break;
	}

	dvrif_memory_handler(SLR_MAIN_DISPLAY);

	//switch to 3 buffers
	mdomain_cap_ddr_in1ctrl_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Ctrl_reg);
	mdomain_cap_ddr_in1ctrl_reg.in1_v_flip_3buf_en = 1;
	mdomain_cap_ddr_in1ctrl_reg.in1_double_enable = 1;
	IoReg_Write32(MDOMAIN_CAP_DDR_In1Ctrl_reg,mdomain_cap_ddr_in1ctrl_reg.regValue);

	cap_reg_doublbuffer_reg.regValue =IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_apply = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);

	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select, mdomain_disp_ddr_mainstatus_reg.main_block_select);

	count = 0x3ffffff;
	while((cap_reg_doublbuffer_reg.cap1_db_apply == 1) && (--count)){
		cap_reg_doublbuffer_reg.regValue = rtd_inl(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
//		if((count&0xfff)==0)
//			rtd_pr_vsc_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}
	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)--- apply cap 3 buf done (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));

	count = 0x3ffffff;
	while(--count){
		vgip_vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
		if((vgip_vgip_chn1_lc_reg.ch1_line_cnt) > APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA)
			break;
	}
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)--- check vgip protect (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));


	//change M-disp.
	mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	mdomain_disp_ddr_mainctrl_reg.main_double_en = 1;
	mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg,mdomain_disp_ddr_mainctrl_reg.regValue);
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg,ddr_mainsubctrl_reg.regValue);

	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);

	count = 0x3ffffff;
	while((ddr_mainsubctrl_reg.disp1_double_apply == 1) && (count--)){
		ddr_mainsubctrl_reg.regValue =rtd_inl(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
//		if((count&0xfff)==0)
//			rtd_pr_vsc_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}

//	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
//	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)---  Mdisp apply 3 buf done (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));

/*
	//check cap/disp block select is correct
	count = 0x3ffffff;
	mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
	mdomain_cap_cap_ddr_fifostatus_reg.in1_cap_last_wr_flag = 1;
	IoReg_Write32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg, mdomain_cap_cap_ddr_fifostatus_reg.regValue);

	mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
	while(!(mdomain_cap_cap_ddr_fifostatus_reg.in1_cap_last_wr_flag) && --count){
		mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
		if((count&0xfff)==0)
			rtd_pr_vsc_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}
	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
	rtd_pr_vsc_notice("[line:%d] cap/disp = (%d.%d) (count:%x)---  check write done frame 1 (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
																						count,
																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
*/
	scaler_vsc_set_vr360_block_mdomain_doublebuffer(FALSE);
}

#define NEW_FLL_SPEEDUP_BY_HW_MODE 1
#define NEW_FLL_PHASE_ERROR_THRESHOLD FLL_UZUDTG_WAIT_LINE_RANGE/2
#define NEW_FLL_24HZ_PHASE_ERROR_THRESHOLD FLL_UZUDTG_WAIT_LINE_RANGE*5/2
#define NEW_FLL_24HZ_PHASE_ERROR_ONE_FRAME 0x8c9

#define NEW_FLL_I2D_DLY_ADD_LINE_MAX 10
#define NEW_FLL_I2D_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX 21
#define NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX 900
#define NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX 450
#define NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX 0
#define NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX 450
#define NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX 200
#define NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX 0

#define NEW_FLL_FHD_I2D_2_5_DLY_ADD_LINE_MAX 450
#define NEW_FLL_FHD_I2D_2_5_DLY_SUB_LINE_MAX 0
#define NEW_FLL_FHD_I2D_1_2_30HZ_DLY_ADD_LINE_MAX 225
#define NEW_FLL_FHD_I2D_1_2_30HZ_DLY_SUB_LINE_MAX 0
#define NEW_FLL_FHD_I2D_1_2_25HZ_DLY_ADD_LINE_MAX 0
#define NEW_FLL_FHD_I2D_1_2_25HZ_DLY_SUB_LINE_MAX 225
#define NEW_FLL_FHD_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX 100
#define NEW_FLL_FHD_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX 0

#define NEW_FLL_HD_I2D_2_5_DLY_ADD_LINE_MAX 300
#define NEW_FLL_HD_I2D_2_5_DLY_SUB_LINE_MAX 0
#define NEW_FLL_HD_I2D_1_2_30HZ_DLY_ADD_LINE_MAX 150
#define NEW_FLL_HD_I2D_1_2_30HZ_DLY_SUB_LINE_MAX 0
#define NEW_FLL_HD_I2D_1_2_25HZ_DLY_ADD_LINE_MAX 0
#define NEW_FLL_HD_I2D_1_2_25HZ_DLY_SUB_LINE_MAX 150
#define NEW_FLL_WQHD_I2D_DLY_ADD_LINE_MAX 225
#define NEW_FLL_WQHD_I2D_DLY_SUB_LINE_MAX 0

unsigned char fix_last_line_need_break_condition(void)
{//retunr TRUE: break    Return False: no break
	if(get_scaler_stop_flag(SLR_MAIN_DISPLAY) == TRUE)
	{
		rtd_pr_vsc_notice("### FLL break for scaler stop flag##\n");
		return TRUE;
	}
	else if(DbgSclrFlgTkr.smoothtoggle_start_flag == TRUE)
	{
		rtd_pr_vsc_notice("### FLL break for smt trigger##\n");
		return TRUE;
	}
	else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
	{
		rtd_pr_vsc_notice("### FLL break for search state#\n");
		return TRUE;
	}
	else if(smooth_toggle_game_mode_check_cnt != st_game_mode_cmd_pre)
	{
		rtd_pr_vsc_notice("### FLL break for scaler_trigger smooth toggle in game mode# %d,%d\n",smooth_toggle_game_mode_check_cnt,st_game_mode_cmd_pre);
		return TRUE;
	}
	else if(disp_smooth_variable_setting_flag == _ENABLE)
	{
		rtd_pr_vsc_notice("### FLL break for running disp_smooth_variable_setting#\n");
		return TRUE;
	}
	else if(Scaler_get_film_mode_change_type() == 1)
	{
		rtd_pr_vsc_notice("### FLL break for film mode change type#\n");
		return TRUE;
	}
	else if(game_mode_cmd_check != game_mode_cmd_pre)
	{
		rtd_pr_vsc_notice("### FLL break for game mode cmd again# %d,%d\n",game_mode_cmd_check,game_mode_cmd_pre);
		return TRUE;
	}
	else if((DbgSclrFlgTkr.game_mode_dynamic_flag) || (drv_memory_get_low_delay_game_mode_dynamic() != drv_memory_get_game_mode_flag()))
	{
		rtd_pr_vsc_notice("### FLL break for waiting game mode ready#\n");
		return TRUE;
	}
	else if(modestate_decide_display_timing() != DISPLAY_MODE_NEW_FLL_MODE)
	{
		rtd_pr_vsc_notice("### FLL break for display timing mode isn't FLL#\n");
		return TRUE;
	}
    else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (get_force_i3ddma_enable(SLR_MAIN_DISPLAY) == FALSE) && drvif_get_hdmi_dp_force_framerate_flag())
	{//HDMI bypass i3ddma non-standard framerate need timing freerun
		rtd_pr_vsc_notice("### FLL break for non-standard framerate isn't FLL#\n");
		return TRUE;
	}
	return FALSE;
}

unsigned char bEnableI2DTracking_in_realcinema = 0;

void scaler_set_I2D_tracking_in_realcinema(unsigned char bEnable)
{
	bEnableI2DTracking_in_realcinema = bEnable;
}

unsigned char scaler_get_I2D_tracking_in_realcinema(void)
{
	return bEnableI2DTracking_in_realcinema;
}

unsigned char bEnableI2DFreq_UpdateInISR = 0;

void scaler_set_I2D_pwm_frequency_update_in_isr(unsigned char bEnable)
{
	bEnableI2DFreq_UpdateInISR = bEnable;
}

unsigned char scaler_get_I2D_pwm_frequency_update_in_isr(void)
{
	return bEnableI2DFreq_UpdateInISR;
}

unsigned char bEnableVRRFreq_UpdateInISR = 0;

void scaler_set_VRR_pwm_frequency_update_in_isr(unsigned char bEnable)
{
	bEnableVRRFreq_UpdateInISR = bEnable;
}

unsigned char scaler_get_VRR_pwm_frequency_update_in_isr(void)
{
	return bEnableVRRFreq_UpdateInISR;
}

unsigned char bEnableI2DTracking_in_slow_mode = 0;

void scaler_set_I2D_tracking_in_slow_mode(unsigned char bEnable)
{
	bEnableI2DTracking_in_slow_mode = bEnable;
}

unsigned char scaler_get_I2D_tracking_in_slow_mode(void)
{
	return bEnableI2DTracking_in_slow_mode;
}

unsigned char bEnableVoTrackingI3DDMA_Freq_UpdateInISR = 0;
void scaler_set_VoTrackingI3DDMA_frequency_update_in_isr(unsigned char bEnable)
{
	bEnableVoTrackingI3DDMA_Freq_UpdateInISR = bEnable;
}

unsigned char scaler_get_VoTrackingI3DDMA_frequency_update_in_isr(void)
{
	return bEnableVoTrackingI3DDMA_Freq_UpdateInISR;
}


unsigned int scaler_get_I2D_tracking_phase_error_threadhold(void)
{
	if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 495)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<505)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 595)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<605)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 994)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<1005)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 1191)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<1206)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 2395)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<2405)))
	{
		return NEW_FLL_PHASE_ERROR_THRESHOLD;
	}
	else
		return NEW_FLL_24HZ_PHASE_ERROR_THRESHOLD;
}

unsigned int scaler_check_I2D_lock_phase_done_condition(void)
{
	unsigned int result = 0;
	unsigned int remove = 0, multiple=0;
	ppoverlay_i2d_meas_phase_RBUS ppoverlay_i2d_meas_phase_reg;

	multiple = PPOVERLAY_uzudtg_fractional_fsync_get_uzudtg_multiple_vsync(IoReg_Read32(PPOVERLAY_uzudtg_fractional_fsync_reg))+1;
	remove = PPOVERLAY_uzudtg_fractional_fsync_get_uzudtg_remove_half_ivs_mode(IoReg_Read32(PPOVERLAY_uzudtg_fractional_fsync_reg))+1;

	ppoverlay_i2d_meas_phase_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg);
	if(ppoverlay_i2d_meas_phase_reg.i2d_phase_err < scaler_get_I2D_tracking_phase_error_threadhold()){
		result = 1;
	}else if((remove==5)&&(multiple==2)){
		if(ppoverlay_i2d_meas_phase_reg.i2d_phase_err >= NEW_FLL_24HZ_PHASE_ERROR_ONE_FRAME){
			if((ppoverlay_i2d_meas_phase_reg.i2d_phase_err-NEW_FLL_24HZ_PHASE_ERROR_ONE_FRAME)<NEW_FLL_24HZ_PHASE_ERROR_THRESHOLD){
				rtd_pr_vsc_notice("[%s][%d] phase_err:%d \n",__FUNCTION__,__LINE__,ppoverlay_i2d_meas_phase_reg.i2d_phase_err);
				result = 1;
			}
		}
	}
	return result;
}

void scaler_pwm_frequency_update_by_dvs(void)
{
	unsigned int frameRates = 0;
	unsigned int dvs_xtal = 0;
	unsigned int vtotal = 0;

	dvs_xtal = PPOVERLAY_DVS_cnt_get_dvs_cnt(IoReg_Read32(PPOVERLAY_DVS_cnt_reg));
	frameRates = 2700000000UL / dvs_xtal;
	vtotal = Get_DISPLAY_CLOCK_TYPICAL() / ((Get_DISP_HORIZONTAL_TOTAL()/100)*frameRates);
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
	rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(vtotal-1)*100, 2, FALSE);
#endif
}

unsigned int scaler_get_I2D_tracking_vtotal_by_frameidx(unsigned char frameIdx)
{
	unsigned int vtotal = 0;

	if(!frameIdx)
		return 0;

	switch(frameIdx){
		case 1:
			vtotal = PPOVERLAY_I2D_MEAS_0_get_i2d_tune_res0(IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg));
			break;
		case 2:
			vtotal = PPOVERLAY_I2D_MEAS_0_get_i2d_tune_res1(IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg));
			break;
		case 3:
			vtotal = PPOVERLAY_I2D_MEAS_1_get_i2d_tune_res2(IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg));
			break;
		case 4:
			vtotal = PPOVERLAY_I2D_MEAS_1_get_i2d_tune_res3(IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg));
			break;
		case 5:
			vtotal = PPOVERLAY_I2D_MEAS_2_get_i2d_tune_res4(IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg));
			break;
		case 6:
			vtotal = PPOVERLAY_I2D_MEAS_2_get_i2d_tune_res5(IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg));
			break;
		case 7:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res6(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
			break;
		case 8:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res7(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
			break;
		default:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res7(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
	}
	return vtotal;
}

unsigned char pre_I2D_frameIdx=0;

void scaler_set_I2D_previous_frameIdx(unsigned char frameIdx)
{
#if 0	//debug by gpio trigger
	{
		IoReg_SetBits(0xb8060238, _BIT23|_BIT22|_BIT21|_BIT20);
		IoReg_Write32(0xb8061104, _BIT30|_BIT0);//GPIO

		if(frameIdx){
			IoReg_Write32(0xb806110c, _BIT30|_BIT0);//high
		}else{
			IoReg_Write32(0xb806110c, _BIT30);//low
		}
	}
#endif
	pre_I2D_frameIdx = frameIdx;
	rtd_pr_vsc_notice("[I2D]scaler_set_I2D_previous_frameIdx =%d\n", frameIdx);
}

unsigned char scaler_get_I2D_previous_frameIdx(void)
{
	return pre_I2D_frameIdx;
}

void scaler_I2D_pwm_frequency_update(void)
{
	if(PPOVERLAY_I2D_CTRL_1_get_i2d_sw_go(IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg))==1){
		unsigned char cur_FrameIdx = (PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)));

		if(cur_FrameIdx!=0){
			unsigned int vtotal = 0;
			scaler_set_I2D_previous_frameIdx(cur_FrameIdx);
			vtotal = scaler_get_I2D_tracking_vtotal_by_frameidx(cur_FrameIdx);
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
			rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),vtotal*100, 2, FALSE);
#endif
			rtd_pr_vsc_notice("[I2D][T]frameIdx=%d,vtotal=%x\n", PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)),vtotal);
		}else if(scaler_get_I2D_previous_frameIdx()!=0){
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
			unsigned int vtotal = PPOVERLAY_DV_total_get_dv_total(IoReg_Read32(PPOVERLAY_DV_total_reg));
			rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),vtotal*100, 2, FALSE);
#endif
			scaler_set_I2D_previous_frameIdx(0);
			rtd_pr_vsc_notice("[I2D][F]frameIdx=%d\n", PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)));
		}
	}
}

void scaler_set_I2D_dly_offset(void)
{
	ppoverlay_i2d_ctrl_1_RBUS ppoverlay_i2d_ctrl_1_reg;
    ppoverlay_dv_total_RBUS dv_total_reg;
	ppoverlay_i2d_ctrl_1_reg.regValue = 0;

    if(scaler_get_I2D_tracking_in_slow_mode() == 1)
    {

		if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 		//24hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245)){
	        if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
				//24hz to 60hz
	            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
	            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
	        }
		}else{
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
        }
    }else{
	   if((get_panel_res() == PANEL_RES_FHD)||(get_panel_res() == PANEL_RES_HD)) {
      	 if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 		//24hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245)){
            if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
				if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
					//24hz to 60hz
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
				}else{
					//24hz to 120hz
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
				}
            }else{
				if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
					//24hz to 60hz
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX;
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX;
				}else{
					//24hz to 120hz
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX;
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX;
				}
            }
        }
		else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 245) && 		//25hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 255)){
			//25hz to 50hz or 25hz to 100hz
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX;
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX;
		}
		else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 295) && 		//30hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 305))
		{
			//30hz to 60hz or 30hz to 120hz
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX;
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX;
		}
        else{  //50/60hz case
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
        }
    }
#ifndef UT_flag
	else if(get_panel_res() == PANEL_RES_WQHD){
		ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_WQHD_I2D_DLY_ADD_LINE_MAX;
		ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_WQHD_I2D_DLY_SUB_LINE_MAX;
	}
#endif // #ifndef UT_flag
	else if((get_panel_res() == PANEL_RES_UHD)||(get_panel_res() == PANEL_RES_8K)){
	    if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 		//24hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245)){
				if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
					if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
						//24hz to 60hz
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
					}
					else {
						//24hz to 120hz
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
					}
				}
				else {
					if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2) {
						//24hz to 60hz
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX;
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX;
					}
					else {
						//24hz to 120hz
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX;
						ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX;
					}
				}
		}
		else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 245) && 		//25hz
				(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 255)) {
				//25hz to 50hz or 25hz to 100hz
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX;
				ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX;
                dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
                if((dv_total_reg.dv_total + 1 - ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max) < Get_PANEL_DISP_VERTICAL_TOTAL_60Hz_MIN())
                {
                    ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = dv_total_reg.dv_total + 1 - Get_PANEL_DISP_VERTICAL_TOTAL_60Hz_MIN();
                }
		}
		else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 295) && 		//30hz
				(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 305)) {
			//30hz to 60hz or 30hz to 120hz
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX;
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX;
		}
		else {  //50/60hz case
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
		}
	}
    }
	IoReg_Write32(PPOVERLAY_I2D_CTRL_1_reg, ppoverlay_i2d_ctrl_1_reg.regValue);
	rtd_pr_vsc_notice("scaler_set_I2D_dly_offset = %x \n", IoReg_Read32(PPOVERLAY_I2D_CTRL_1_reg));
}

unsigned char scaler_judge_mdomain_switch_single_buffer(void)
{
    unsigned int outputFrameRate = 0;
    unsigned int intputFrameRate = 0;
    unsigned int removeRatio = 0;
    unsigned int multipleRatio = 0;

    ppoverlay_dtg_m_remove_input_vsync_RBUS ppoverlay_dtg_m_remove_input_vsync_reg;
    ppoverlay_dtg_m_multiple_vsync_RBUS ppoverlay_dtg_m_multiple_vsync_reg;

    ppoverlay_dtg_m_multiple_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_multiple_vsync_reg);
    ppoverlay_dtg_m_remove_input_vsync_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_M_Remove_input_vsync_reg);
    removeRatio = ppoverlay_dtg_m_remove_input_vsync_reg.remove_half_ivs_mode2+1;
    multipleRatio = ppoverlay_dtg_m_multiple_vsync_reg.dtg_m_multiple_vsync+1;

    if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
    {
        intputFrameRate = Get_Input_vfreq_by_HDMI_ori_vfreq();
    }
    else
    {
        intputFrameRate = Get_Input_vfreq_by_vsync_cnt();
    }

    outputFrameRate = get_outputFramerate(intputFrameRate, removeRatio, multipleRatio);

    if(intputFrameRate > outputFrameRate)
    {
        return 0;
    }

    return 1;
}

static int fixlast_line_tsk(void *p)
{
 //   struct cpumask vsc_cpumask;
	static UINT8 checkStableCnt=0;
	unsigned int count2 = 0x3fffff;
	unsigned int ch1_line_cnt_lower = 0;
	unsigned int ch1_line_cnt_upper = 0;
	//ppoverlay_dtg_frame_cnt1_RBUS dtg_frame_cnt1_reg;
	//ppoverlay_new_meas0_linecnt_real_RBUS ppoverlay_new_meas0_linecnt_real_reg;
#ifndef NEW_FLL_SPEEDUP_BY_HW_MODE
	vgip_vgip_chn1_lc_RBUS vgip_chn1_lc_reg;
	UINT32 timeout=0;
	ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;
	ppoverlay_uzudtg_dv_total_RBUS uzudtg_dv_total_reg;
#endif
	unsigned int vtotal = 0;
	unsigned int uzudtg_line_lower = FLL_UZUDTG_VSYNC_LINE_DELAY;
	unsigned int uzudtg_line_upper = FLL_UZUDTG_VSYNC_LINE_DELAY + FLL_UZUDTG_WAIT_LINE_RANGE;
#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE
	ppoverlay_dv_total_RBUS dv_total_reg;
	ppoverlay_i2d_ctrl_0_RBUS ppoverlay_i2d_ctrl_0_reg;
	ppoverlay_i2d_ctrl_1_RBUS ppoverlay_i2d_ctrl_1_reg;
	UINT32 lineDelay = 0;
#endif

#ifndef CONFIG_HW_SUPPORT_MEMC
		//unsigned short input_framerate = 0;
#endif

	rtd_pr_vsc_debug("fixlast_line_tsk()\n");
/*
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
*/
#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif // #ifndef UT_flag

	while (1)
	{
#if 1
		if(IoReg_Read32(VGIP_VGIP_VBISLI_reg)&_BIT18){
			extern void gamemode_delaytime_print_msg(void);
			gamemode_delaytime_print_msg();
			drv_framesync_on_fixlastline_phaseErr_verify();
			msleep(20);
			IoReg_ClearBits(VGIP_VGIP_VBISLI_reg, _BIT18);
		}
		//for fixlastline phaseErr realtime debug
		//drv_framesync_on_fixlastline_phaseErr_verify();
#ifndef UT_flag
//#ifdef UZU_60_24_MEMC_BYPASS_ENABLE
		if(IoReg_Read32(VGIP_VGIP_VBISLI_reg)&_BIT25) {
			extern void drivf_scaler_set_memc_bypass(void);
			drivf_scaler_set_memc_bypass();
			msleep(20);
			IoReg_ClearBits(VGIP_VGIP_VBISLI_reg, _BIT25);
		}
//#endif
#endif // #ifndef UT_flag
		down(get_scaler_fll_running_semaphore());

		if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)&& (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE)){
#ifndef CONFIG_HW_SUPPORT_MEMC
			//input_framerate = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
#endif
			//down(&GameMode_Check_Semaphore);

			if(modestate_get_fll_running_flag()){
				if(checkStableCnt> 2){
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
					if (scaler_DumpCRC_Config.enable == 1) {
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						drivf_scaler_reset_freerun();
					}
#endif
					if((modestate_decide_display_timing() == DISPLAY_MODE_NEW_FLL_MODE) &&
						(drvif_scaler_get_display_mode() != DISPLAY_MODE_NEW_FLL_MODE)){

                        //if game mode run, can not update dvtotal
                        if(mutex_trylock(&gamemode_fixlastline_mutex) == 0)
                        {
                            up(get_scaler_fll_running_semaphore());
                            msleep(10);
                            continue;//wait game mode done
                        }
                        framesync_fixlastline_set_precision_vtotal();
                        mutex_unlock(&gamemode_fixlastline_mutex);

						//down(&VSC_Semaphore);
						//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
						vtotal = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN);
						ch1_line_cnt_lower = vtotal - (vtotal * FLL_LOWER_DOUNDARY_PERCENT / 1000);//lower boundary is total line * 2.2%
						ch1_line_cnt_upper = (vtotal * FLL_UPPER_DOUNDARY_PERCENT / 1000);//upper boundary is total line's 4.4%
						rtd_pr_vsc_debug("\n ch1_line_cnt_lower = %d, ch1_line_cnt_upper = %d\n", ch1_line_cnt_lower, ch1_line_cnt_upper);

						if((/*(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC)||*/(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_JPEG)) &&
							(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)== FALSE)){
							//change to FLL
							rtd_pr_vsc_notice("### set fll new mode 1.###\n");
							framesync_lastlinefinetune_at_new_mode();
							//modestate_set_display_timing(0);
							drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
							modestate_set_fll_running_flag(FALSE);
							checkStableCnt=0;
						}
                        else if((drv_memory_get_game_mode() == TRUE)&&(vbe_disp_gamemode_use_fixlastline()==TRUE)){
							//check smooth toggle already done
							Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE
							//reset speedup_vtotal
								drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
								drvif_scaler_enable_frc2fsync_HW_speedup_vtotal(FALSE);

							//get game mode line delay
							lineDelay = drv_framesync_get_gamemode_iv2dv_linedelay();
							//AV Gamemode need increase iv2pv delay to avoid hw noise
							//if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)){
								//drv_AV_GameMode_reset_iv2pv_delay(lineDelay);
							//}

							//					 i2d_delay_lower |	 |i2d_delay_upper
							//		IVS 					 |---------------------------|
							//		DVS   |-----------------|-----------------|

							dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);

							// FLL sync point parameters.
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_new_mode_en = 0; //use i2d old mode
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 1; //continuous mode
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = (lineDelay-FLL_UZUDTG_WAIT_LINE_RANGE);
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = lineDelay;
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							Scaler_wait_for_input_one_frame(SLR_MAIN_DISPLAY);//after adjusting i2d upper lower, need wait 1 frame to make phase error change
							// speed up direction and capability (about 2Hz variations)
							// 594M / (4400*58) = 2327, 2327-2250 ~= 80
							ppoverlay_i2d_ctrl_1_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_1_reg);
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
							if (scaler_DumpCRC_Config.enable == 1) {
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX;
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX;
							} else
#endif
							{
								//set I2D hw tracking offset
								scaler_set_I2D_dly_offset();
							}
							//control localdimming freq. offset
							IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1+NEW_FLL_I2D_DLY_ADD_LINE_MAX)/2)-1)<<19); // repeat local dimming vsync
							//control pwm freq. offset
							if(scaler_get_I2D_tracking_in_slow_mode() == 1){
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
							}else{
								if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 		//24hz
									(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245))
								{
	                                if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
										rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
	                                    scaler_set_I2D_tracking_in_realcinema(FALSE);
	                                }else{
										scaler_set_I2D_previous_frameIdx(0);
									    scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
	                                }
								}else if(((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ)>245)&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 255)) ||
			  							((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ)>295)&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 305)))
								{
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
								}else{
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
								}
							}
							if(!fix_last_line_need_break_condition()){
							    //add new feature, need set this bit for vtotal update.
								ppoverlay_display_timing_ctrl1_RBUS ppoverlay_display_timing_ctrl1_reg;
								ppoverlay_display_timing_ctrl1_reg.regValue = IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg);
								ppoverlay_display_timing_ctrl1_reg.mdtg_line_cnt_sync = 1;
								IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, ppoverlay_display_timing_ctrl1_reg.regValue);
								//enable FLL speed up by hw
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 1;
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								//wait i2d enable
								msleep(10);
							}

							count2 = 300;
							while(count2){
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
          							rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								if(scaler_check_I2D_lock_phase_done_condition()){
									//check right phase and enable fixlastline
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//Disable I2D
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(FALSE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//change to 1-buffer after iv2dv done @Crixus 20170527
#if 0//ndef CONFIG_HW_SUPPORT_MEMC	//Eric@20180621 all framerate can support m domain single buffer without memc
									if(input_framerate >= 490)//50 60 framerate can support m domain single buffer without memc

#endif
									{//50 60 framerate can support m domain single buffer without memc
										down(&GameMode_Check_Semaphore);
										//avoid run smoothtoggle after scaler
										if(fix_last_line_need_break_condition()){
											modestate_set_fll_running_flag(FALSE);
											up(&GameMode_Check_Semaphore);
											break;
										}
#ifndef UT_flag
                                        if(scaler_judge_mdomain_switch_single_buffer())
                                        {
                                            drv_memory_GameMode_Switch_SingleBuffer();
                                        }
#endif // #ifndef UT_flag
										up(&GameMode_Check_Semaphore);
									}
									checkStableCnt=0;
									rtd_pr_vsc_notice("### set fll new mode 3. (count=%d)(phase_err=%d)###\n", count2,PPOVERLAY_I2D_MEAS_phase_get_i2d_phase_err(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)));
									break;

								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _DISABLE){
									rtd_pr_vsc_notice("[FLL]game mode enable exit\n");
									//recovery
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								msleep(10);
								count2--;
							}

							if(count2==0){
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //continuous mode
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								rtd_pr_vsc_notice("func=%s, line=%d, timeout\n", __FUNCTION__, __LINE__);
								rtd_pr_vsc_notice("fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
									IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
							}

#else
							if(vsc_decide_fixlastline_speedup_enable() == TRUE){
								ppoverlay_dv_total_RBUS dv_total_reg;
								fwif_color_safe_od_enable(0);
								dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
								drvif_scaler_set_frc2fsync_recovery_vtotal(dv_total_reg.dv_total+1);
								rtd_pr_vsc_notice("fll set recovery vtotal = %x", dv_total_reg.dv_total+1);
								drvif_scaler_set_fixlastline_vtotal_speedup_protect_on();
								rtd_pr_vsc_notice("func=%s, line=%d\n", __FUNCTION__, __LINE__);
							}

							count2 = 0xa0000;

							while(count2){
								if(drv_framesync_check_iv2dv_phaseErr_on_fixlastline()==TRUE){
									//check right phase and enable fixlastline
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//wait speed up vtotal done
									timeout = 0x3fffff;
									new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
									while((new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt!=uzudtg_dv_total_reg.uzudtg_dv_total)&&(timeout--)){
										new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
									}
									if(timeout==0){
										rtd_pr_vsc_emerg("[drv_framesync_check_iv2dv_phaseErr_on_fixlastline] wait timeout. \n");
									}
									//recovory origin vtotal done
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									//change to 1-buffer after iv2dv done @Crixus 20170527
#ifndef CONFIG_HW_SUPPORT_MEMC
									if(input_framerate >= 490)//50 60 framerate can support m domain single buffer without memc

#endif
									{//50 60 framerate can support m domain single buffer without memc
											down(&GameMode_Check_Semaphore);
										drv_memory_GameMode_Switch_SingleBuffer();
											up(&GameMode_Check_Semaphore);
									}
									checkStableCnt=0;
									rtd_pr_vsc_notice("### set fll new mode 3.###\n");
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _DISABLE){
									rtd_pr_vsc_emerg( "[FLL]game mode Exit\n");
									//recovery
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}


								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}
								count2--;
							}
							if(count2 == 0){
								rtd_pr_vsc_notice("count timeout !!!\n");
								//rtd_pr_vsc_emerg("count timeout !!!\n");
								if(vsc_decide_fixlastline_speedup_enable() == TRUE){
									drvif_scaler_set_frc2fsync_vtotal_protect_off();
									fwif_color_safe_od_enable(1);
								}
							}
#endif

                        }else
						{
#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE
                            drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
                            drvif_scaler_enable_frc2fsync_HW_speedup_vtotal(FALSE);

							//			  i2d_delay_lower | |i2d_delay_upper
							//		IVS 					|---------------------------|
							//		DVS   |-----------------|-----------------|

							dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
							// FLL sync point parameters.
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							//ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //one-time mode
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_new_mode_en = 0; //use i2d old mode
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 1; //continuous mode
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = dv_total_reg.dv_total-uzudtg_line_upper;
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = dv_total_reg.dv_total-uzudtg_line_lower;
							//AV source normal mode 50Hz need fine tune i2d_dly
							//if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)){
								//if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 495) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 505)){
									//ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = dv_total_reg.dv_total-uzudtg_line_upper - 752;
									//ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = dv_total_reg.dv_total-uzudtg_line_lower - 752;
								//}
							//}
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							Scaler_wait_for_input_one_frame(SLR_MAIN_DISPLAY);	//after adjusting i2d upper lower, need wait 1 frame to make phase error change
							// speed up direction and capability (about 2Hz variations)
							// 594M / (4400*58) = 2327, 2327-2250 ~= 80
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
							if (scaler_DumpCRC_Config.enable == 1) {
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX;
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX;
							} else
#endif
							{
								//set I2D hw tracking offset
								scaler_set_I2D_dly_offset();
							}
							//control localdimming freq. offset
							IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1+NEW_FLL_I2D_DLY_ADD_LINE_MAX)/2)-1)<<19); // repeat local dimming vsync
							//control pwm freq. offset
							if(scaler_get_I2D_tracking_in_slow_mode() == 1){
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
							}else{
								if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 235) && 		//24hz
									(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 245))
								{
	                                if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
										rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
	                                    scaler_set_I2D_tracking_in_realcinema(FALSE);
	                                }else{
										scaler_set_I2D_previous_frameIdx(0);
									    scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
	                                }
								}else if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>245)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 255)) ||
			  							((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>295)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 305)))
								{
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
								}else{
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
								}
							}
							if(!fix_last_line_need_break_condition()){
								//mark2 add new feature, need set this bit for vtotal update.
								ppoverlay_display_timing_ctrl1_RBUS ppoverlay_display_timing_ctrl1_reg;
								ppoverlay_display_timing_ctrl1_reg.regValue = IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg);
								ppoverlay_display_timing_ctrl1_reg.mdtg_line_cnt_sync = 1;
								IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, ppoverlay_display_timing_ctrl1_reg.regValue);
								//enable FLL speed up by hw
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 1;
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								//wait i2d enable
								msleep(10);
							}

							count2 = 300;
							while(count2){
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									break;
								}
								if(scaler_check_I2D_lock_phase_done_condition()){
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//modestate_set_display_timing(0);
									//Disable I2D
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(FALSE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);

									checkStableCnt=0;
									//change to FLL
									rtd_pr_vsc_notice("### [HW] set fll new mode 1. (count=%d) ###\n", count2);
									//rtd_pr_vsc_emerg("\n new_meas1_linecnt_real_reg.uzudtg_line_cnt_rt = %x\n", IoReg_Read32(0xb8028258));
									//rtd_pr_vsc_emerg("\n vgip_chn1_lc_reg.ch1_line_cnt = %x\n", IoReg_Read32(0xb8022234));
									rtd_pr_vsc_notice("\n fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
										IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _ENABLE){
									rtd_pr_vsc_notice("[FLL]game mode enable break\n");
									//recovery
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									rtd_pr_vsc_notice("FUNC:%s, break due to scaler stop\n", __FUNCTION__);
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}
								msleep(10);
								count2--;
							}

							if(count2==0){
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //continuous mode
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								//control localdimming freq. offset
								IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
								//control pwm freq. offset
#if IS_ENABLED(CONFIG_RTK_KDRV_PWM)
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
								rtd_pr_vsc_notice("func=%s, line=%d, timeout\n", __FUNCTION__, __LINE__);
								rtd_pr_vsc_notice("fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
									IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
							}

#else
							count2 = 0x3fffff;
							/*speedup*/
							if(vsc_decide_fixlastline_speedup_enable() == TRUE){
								ppoverlay_dv_total_RBUS dv_total_reg;
								fwif_color_safe_od_enable(0);
								dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
								drvif_scaler_set_frc2fsync_recovery_vtotal(dv_total_reg.dv_total+1);
								rtd_pr_vsc_notice("fll set recovery vtotal = %x", dv_total_reg.dv_total+1);
								drvif_scaler_set_fixlastline_vtotal_speedup_protect_on();
								rtd_pr_vsc_notice("func=%s, line=%d\n", __FUNCTION__, __LINE__);
							}
							while(count2){
								new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
								vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
								/*wait uzu dtg Vsync and wait the vgip line cnt*/
								if(((new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt >= uzudtg_line_lower) && (new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt < uzudtg_line_upper))
								&& ((vgip_chn1_lc_reg.ch1_line_cnt >= ch1_line_cnt_lower) || (vgip_chn1_lc_reg.ch1_line_cnt <= ch1_line_cnt_upper))){
									/*recover*/
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									framesync_lastlinefinetune_at_new_mode();
									//modestate_set_display_timing(0);
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									modestate_set_fll_running_flag(FALSE);
									checkStableCnt=0;
									//change to FLL
									rtd_pr_vsc_notice("### set fll new mode 1.###\n");

									//rtd_pr_vsc_emerg("\n new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt = %d\n", new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt);
									//rtd_pr_vsc_emerg("\n vgip_chn1_lc_reg.ch1_line_cnt = %d\n", vgip_chn1_lc_reg.ch1_line_cnt);
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _ENABLE){
									rtd_pr_vsc_notice("[FLL]game mode enable break\n");
									//recovery
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									rtd_pr_vsc_notice("FUNC:%s, break due to scaler stop\n", __FUNCTION__);
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}
								count2--;
							}
							//rtd_pr_vsc_emerg("count2 = %d\n", count2);

							if(count2 == 0){
								rtd_pr_vsc_notice("count timeout !!!\n");
								//rtd_pr_vsc_emerg("count timeout !!!\n");
								if(vsc_decide_fixlastline_speedup_enable() == TRUE){
									drvif_scaler_set_frc2fsync_vtotal_protect_off();
									fwif_color_safe_od_enable(1);
								}
							}
#endif
						}
						//up(&VSC_Semaphore);
					}
				}
				else{
					checkStableCnt++;
				}
			}else{
								//down(&VSC_Semaphore);
#if 0
				if(get_vo_camera_flow_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))!=1){
					if ((vbe_disp_get_adaptivestream_fs_mode() == 1) &&
						(Get_DISPLAY_PANEL_TYPE() != P_VBY1_TO_HDMI) &&
						(Get_DISPLAY_PANEL_TYPE() != P_VBY1_TO_LVDS_TO_HDMI)) {
						if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){

							pr_emerg("[fll]drvif_scaler_get_display_mode=%d\n", drvif_scaler_get_display_mode());
	                        fwif_color_safe_od_enable(0);
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							fwif_color_safe_od_enable(1);
						}
					}
				}
#endif
            checkStableCnt = 0;
			}
			//up(&GameMode_Check_Semaphore);
		}else{
			checkStableCnt = 0;
		}
		up(get_scaler_fll_running_semaphore());
#endif

		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
		msleep(10);
	}

	rtd_pr_vsc_debug( "\r\n####fixlast_line_tsk: exit...####\n");
	do_exit(0);
	return 0;
}

#ifndef UT_flag
static void create_fixlast_line_tsk(void)
{
	int err;
	if (fix_lastline_tsk_running_flag == FALSE) {
		p_fix_lastline_tsk = kthread_create(fixlast_line_tsk, NULL, "fix_lastline_tsk");

	    if (p_fix_lastline_tsk) {
			wake_up_process(p_fix_lastline_tsk);
			fix_lastline_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_fix_lastline_tsk);
	    	rtd_pr_vsc_debug("Unable to start fixlast_line_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_fix_lastline_tsk(void)
{
	int ret;
	if (fix_lastline_tsk_running_flag) {
		if(p_fix_lastline_tsk){
	 		ret = kthread_stop(p_fix_lastline_tsk);
	 		if (!ret) {
	 			p_fix_lastline_tsk = NULL;
	 			fix_lastline_tsk_running_flag = FALSE;
				rtd_pr_vsc_debug("fixlast_line_tsk thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_debug("fixlast_line_tsk thread stopped already\n");
		}
	}
}

static void create_localDimmingDemoCtrl_tsk(void)
{
	int err;
	if (localDimmingDemoCtrl_tsk_running_flag == FALSE) {
		p_localDimmingDemoCtrl_tsk = kthread_create(localDimmingDemoCtrl_tsk, NULL, "localDimmingDemoCtrl_tsk");

	    if (p_localDimmingDemoCtrl_tsk) {
			wake_up_process(p_localDimmingDemoCtrl_tsk);
			localDimmingDemoCtrl_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_localDimmingDemoCtrl_tsk);
	    	rtd_pr_vsc_debug("Unable to start localDimmingDemoCtrl_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_localDimmingDemoCtrl_tsk(void)
{
	int ret;
	if (localDimmingDemoCtrl_tsk_running_flag) {
		if(p_localDimmingDemoCtrl_tsk){
	 		ret = kthread_stop(p_localDimmingDemoCtrl_tsk);
	 		if (!ret) {
	 			p_localDimmingDemoCtrl_tsk = NULL;
	 			localDimmingDemoCtrl_tsk_running_flag = FALSE;
				rtd_pr_vsc_debug("localDimmingDemoCtrl_tsk thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_debug("localDimmingDemoCtrl_tsk thread stopped already\n");
		}
	}
}
#endif // #ifndef UT_flag

void game_mode_set_ignore_cmd_check(unsigned char enable)
{
	game_mode_ignore_cmd_check = enable;
}

unsigned char Scaler_Get_Display_Timing_Mode(void)
{
	return scaler_timing_mode_setting;
}

void Scaler_Set_Display_Timing_Mode(unsigned char timing_mode)
{
	scaler_timing_mode_setting = timing_mode;
}

static bool game_mode_unmute_tsk_running_flag = FALSE;
static struct task_struct *p_game_mode_unmute_tsk = NULL;
extern void Scaler_wait_for_frc2fs_hw_lock_done(unsigned char display);

static int game_mode_unmute_tsk(void *p)
{
	static UINT8 checkStableCnt = 0;//wait game mode does not switch
	static UINT32 scaler_game_mode_cmd_pre = 0;//save last game mode switch action command

	static UINT8 CheckST_StableCnt = 0;//wait game mode does not switch
	static UINT32 ST_game_mode_cmd_pre = 0;//save last smooth toggle action command
	unsigned int cmd_check_cnt = 0;//local use to assign current game mode switch number
	unsigned int st_cmd_check_cnt = 0;//local use to assign current smooth toggle run number
	ppoverlay_uzudtg_control1_RBUS uzudtg_control1_reg;
	ppoverlay_memcdtg_control3_RBUS memcdtg_control3_reg;
	ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
	unsigned int game_mode_wait_timeout = 40;//400ms
	rtd_pr_vsc_debug("game_mode_unmute_tsk()\n");
/*
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
*/
#ifndef UT_flag
	current->flags &= ~PF_NOFREEZE;
#endif // #ifndef UT_flag
	while (1)
	{
#if 0
		if(game_mode_unmute_tsk_pending != _low_power_tsk_no_pending)
		{
			if(game_mode_unmute_tsk_pending == _low_power_tsk_request_pending)
				game_mode_unmute_tsk_pending = _low_power_tsk_pending_finish;
			msleep(10); //wait 100ms
			if (freezing(current))
			{
				try_to_freeze();
			}
			continue;
		}
#endif
		cmd_check_cnt = game_mode_cmd_check;//record current command number. Check whether there is new command
		st_cmd_check_cnt = smooth_toggle_game_mode_check_cnt;//record current smooth toggle command number. Check whether there is new command
		//Game mode cmd checking flow @Cixus 20161204
		if ((Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode) == TRUE)
			&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			&& (drv_memory_get_low_delay_game_mode_dynamic() == drv_memory_get_game_mode_flag())) {
			memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
			game_mode_wait_timeout = 40;
			if((get_vt_EnableFRCMode() != FALSE) && Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) && drv_memory_get_low_delay_game_mode_dynamic() &&
				memc_mux_ctrl_reg.memc_outmux_sel==0){
				//rtd_pr_vsc_notice("[GAME MODE] HDMI wait game mode ready  %d\n",game_mode_wait_timeout);
				uzudtg_control1_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_control1_reg);
				memcdtg_control3_reg.regValue = IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg);
				while(game_mode_wait_timeout--){
					if((uzudtg_control1_reg.dtgm2uzuvs_line == 0) && (memcdtg_control3_reg.dtgm2goldenpostvs_line == 0)){
						break;
					}
					memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
					if (memc_mux_ctrl_reg.memc_outmux_sel!=0) {
						break;
					}
					uzudtg_control1_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_control1_reg);
					memcdtg_control3_reg.regValue = IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg);
					//wait 10ms
					msleep(10);
				}
				//rtd_pr_vsc_notice("[GAME MODE] HDMI wait game mode done  %d\n",game_mode_wait_timeout);
				if(game_mode_wait_timeout == 0)
					rtd_pr_vsc_notice("[GAME MODE] game mode wait golden vsync timeout = %d\n",game_mode_wait_timeout);
			}
			down(&GameMode_Check_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
				checkStableCnt = 0;//for debounce
				scaler_game_mode_cmd_pre = cmd_check_cnt;
				up(&GameMode_Check_Semaphore);
				rtd_pr_vsc_info("## game mode active break after gmae mode finish. not active ##\r\n");
				continue;
			}
			//after scaler flow, do not check cmd to reduce mute time
			if(game_mode_ignore_cmd_check == _ENABLE){//the case no need debounce after scaler
				if(DbgSclrFlgTkr.game_mode_dynamic_flag == FALSE){
					game_mode_ignore_cmd_check = _DISABLE;
					game_mode_cmd_pre = cmd_check_cnt;	//Update game_mode_cmd_pre to avoid fll task break.
					st_game_mode_cmd_pre = st_cmd_check_cnt;
					//smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
					//set to timing fsync after game mode done

					if(Scaler_Get_Display_Timing_Mode() == DISPLAY_MODE_FRAME_SYNC){//timing sync
						modestate_set_fll_running_flag(FALSE);
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						Scaler_wait_for_LCM_done();
						rtd_pr_vsc_emerg( "After game mode set to timing sync after scaler!\n");
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)){
							//VDEC 2k1k use original flow, framesync with gatting
							if(!vbe_get_VDEC4K_run_datafs_without_gatting_condition()){
								//scaler_set_full_gatting_rpc(true);
								scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
								rtd_pr_vsc_emerg( "[VDEC] game mode Enable Gating after scaler!\n");
							}
							else
								rtd_pr_vsc_emerg( "[VDEC] game mode Force Don't enable Gating after scaler\n");
						}
						else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)){
							//scaler_set_full_gatting_rpc(true);
							scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
							rtd_pr_vsc_emerg( "[HDMI]game mode Enable Gating after scaler!\n");
						}
#else
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))
						{
							//scaler_set_full_gatting_rpc(true);
							scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
							rtd_pr_vsc_emerg( "game mode Enable Gating after scaler!\n");
						}
						else if((((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
							|| drv_memory_get_game_mode()) && (get_new_game_mode_condition())){
							// check video lowdelay condition by get_new_game_mode_condition,
							// because it is the real condition to decide video path can enter game mode
							//For data frc and timing sync in lowdelay mode case, need to set M-domain single buffer
							drv_memory_GameMode_Switch_SingleBuffer();
						}
#endif
					}
#if 0
					else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
						modestate_set_fll_running_flag(_DISABLE);
						fwif_color_safe_od_enable(0);
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						Scaler_Set_Display_Timing_Mode(DISPLAY_MODE_FRAME_SYNC);
						fwif_color_safe_od_enable(1);
						rtd_pr_vsc_notice("[%s][line:%d] HDMI game mode run timing fs.\n", __FUNCTION__, __LINE__);
					}
#endif
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
					/*K3LG-1445:sync crixus,willlin,qiangzhou,when gamemode re run scaler,open forcebg need check scaler status active*/
					if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);
					}
					rtd_pr_vsc_emerg( "after scaler do not check timeout, game mode unmute!!\n");
				}
			}
			else{
				if(checkStableCnt < 30){
					if(scaler_game_mode_cmd_pre != cmd_check_cnt){
						rtd_pr_vsc_emerg( " game mode new cmd again (%d %d) reset!!\n", scaler_game_mode_cmd_pre, cmd_check_cnt);
						checkStableCnt = 0;
						scaler_game_mode_cmd_pre = cmd_check_cnt;
					}
					else{
						checkStableCnt++;
					}
					//rtd_pr_vsc_emerg("[crixus]checkStableCnt = %d\n", checkStableCnt);
				}
				else{
					if((DbgSclrFlgTkr.game_mode_dynamic_flag == FALSE) && (scaler_game_mode_cmd_pre == cmd_check_cnt)){
						//game_mode_cmd_check = 0;	//Eric@20181113 No need to clear here, to avoid race condition
						game_mode_cmd_pre = cmd_check_cnt;	//Eric@20181113 No need to clear here, to avoid race condition
						checkStableCnt = 0;

						//set to timing fsync after game mode done
						if(Scaler_Get_Display_Timing_Mode() == DISPLAY_MODE_FRAME_SYNC){//timing sync
							modestate_set_fll_running_flag(FALSE);
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							Scaler_wait_for_LCM_done();
							rtd_pr_vsc_emerg( "After game mode set to timing sync after game mode command debounce!\n");
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)){
								//VDEC 2k1k use original flow, framesync with gatting
								if(!vbe_get_VDEC4K_run_datafs_without_gatting_condition()){
									//scaler_set_full_gatting_rpc(true);
									scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
									rtd_pr_vsc_emerg( "[VDEC] game mode Enable Gating after game mode command debounce!\n");
								}
								else
									rtd_pr_vsc_emerg( "[VDEC] game mode Force Don't enable Gating after game mode command debounce\n");
							}
							else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)){
								//scaler_set_full_gatting_rpc(true);
								scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
								rtd_pr_vsc_emerg( "[HDMI]game mode Enable Gating after game mode command debounce!\n");
							}
#else
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))
							{
								//scaler_set_full_gatting_rpc(true);
								scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
								rtd_pr_vsc_emerg( "game mode Enable Gating after game mode command debounce!\n");
								if(drv_memory_get_game_mode()==FALSE){
									game_mode_resume_i3_vo_sw_mode();	//use i3/vo sw mode to keep 2 buf distance.
									rtd_pr_vsc_emerg( "leave game mode, resume i3 sw mode.\n");
								}
							}
							else if((((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
								|| drv_memory_get_game_mode()) && (get_new_game_mode_condition())){
								// check video lowdelay condition by get_new_game_mode_condition,
								// because it is the real condition to decide video path can enter game mode
								//For data frc and timing sync in lowdelay mode case, need to set M-domain single buffer
								drv_memory_GameMode_Switch_SingleBuffer();
							}
#endif
						}
#if 0
						else if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
							modestate_set_fll_running_flag(_DISABLE);
							fwif_color_safe_od_enable(0);
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							Scaler_Set_Display_Timing_Mode(DISPLAY_MODE_FRAME_SYNC);
							fwif_color_safe_od_enable(1);
							rtd_pr_vsc_notice("[%s][line:%d] HDMI game mode run timing fs.\n", __FUNCTION__, __LINE__);
						}
#endif
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);

						/*K3LG-1445:sync crixus,willlin,qiangzhou,when gamemode re run scaler,open forcebg need check scaler status active*/
						if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);
						}
						rtd_pr_vsc_emerg("game mode unmute after game mode command debounce!!\n");
					}
					else{
						if(scaler_game_mode_cmd_pre != cmd_check_cnt){
							rtd_pr_vsc_emerg( " game mode new cmd again (%d %d) reset!!\n", scaler_game_mode_cmd_pre, cmd_check_cnt);
							checkStableCnt = 0;
						}
						rtd_pr_vsc_emerg(" Need to wait game mode done!!\n");
					}

				}
			}
			up(&GameMode_Check_Semaphore);
		}

		//check smooth toggle done
		if(smooth_toggle_game_mode_timeout_trigger_flag){
			down(&GameMode_Check_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
				CheckST_StableCnt = 0;
				ST_game_mode_cmd_pre = st_cmd_check_cnt;
				smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
				up(&GameMode_Check_Semaphore);
				rtd_pr_vsc_info("## game mode active resume break afte ST case. not active##\r\n");
				continue;
			}
			//rtd_pr_vsc_emerg("[crixus]ST CheckST_StableCnt = %d\n", CheckST_StableCnt);
			//rtd_pr_vsc_emerg("[crixus]ST ST_game_mode_cmd_pre = %d\n", ST_game_mode_cmd_pre);
			//rtd_pr_vsc_emerg("[crixus]ST smooth_toggle_game_mode_check_cnt = %d\n", smooth_toggle_game_mode_check_cnt);
			if(CheckST_StableCnt < 100){
				if(ST_game_mode_cmd_pre != st_cmd_check_cnt){
					rtd_pr_vsc_emerg("game mode ST new cmd again!! reset!! (%d %d) \n", ST_game_mode_cmd_pre, st_cmd_check_cnt);
					CheckST_StableCnt = 0;
					ST_game_mode_cmd_pre = st_cmd_check_cnt;
				}
				else{
					CheckST_StableCnt++;
					//rtd_pr_vsc_emerg("[crixus]ST CheckST_StableCnt = %d\n", CheckST_StableCnt);
				}
			}
			else{
				//reture to game mode setting
				if(drv_memory_get_game_mode()){
					smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
					st_game_mode_cmd_pre = st_cmd_check_cnt;
					CheckST_StableCnt = 0;
					if((vbe_disp_gamemode_use_fixlastline()==TRUE) && !((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))){
						zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY,0);//sync smooth toggle timing info
						rtd_pr_vsc_emerg( "After game mode set to timing fll after ST!\n");
						drv_game_mode_disp_smooth_variable_setting(GAME_MODE_NEW_FLL);
					}else{
						//-> iv2dv delay -> frc2fsync  -> single buffer
						//update the iv2dv delay
						if(!Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)){
							drv_GameMode_iv2dv_delay(_ENABLE);
						}

						//set to timing fsync after game mode done
						if(Scaler_Get_Display_Timing_Mode() == DISPLAY_MODE_FRAME_SYNC){//timing sync
							modestate_set_fll_running_flag(FALSE);
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							Scaler_wait_for_LCM_done();
							rtd_pr_vsc_emerg( "After game mode set to timing sync after ST!\n");
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)){
								//VDEC 2k1k use original flow, framesync with gatting
								if(!vbe_get_VDEC4K_run_datafs_without_gatting_condition()){
									//scaler_set_full_gatting_rpc(true);
									scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
									rtd_pr_vsc_emerg( "[VDEC] game mode Enable Gating after ST!\n");
								}
								else
									rtd_pr_vsc_emerg( "[VDEC] game mode Force Don't enable Gating after ST\n");
							}
							else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)){
								//scaler_set_full_gatting_rpc(true);
								scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
								rtd_pr_vsc_emerg( "[HDMI]game mode Enable Gating after ST!\n");
							}

							if((Get_DISPLAY_REFRESH_RATE() == 120) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())){
								drv_memory_GameMode_Switch_SingleBuffer();
							}
#else
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))
							{
								//scaler_set_full_gatting_rpc(true);
								scaler_data_frame_sync_enable_gatting(Get_DisplayMode_Src(SLR_MAIN_DISPLAY));
								rtd_pr_vsc_emerg( "game mode Enable Gating after ST!\n");
							}
							else if(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
								|| drv_memory_get_game_mode()){
								//For data frc and timing sync in lowdelay mode case, need to set M-domain single buffer
								drv_memory_GameMode_Switch_SingleBuffer();
							}
#endif
						}
#if 0
						else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
							modestate_set_fll_running_flag(_DISABLE);
							fwif_color_safe_od_enable(0);
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							Scaler_Set_Display_Timing_Mode(DISPLAY_MODE_FRAME_SYNC);
							fwif_color_safe_od_enable(1);
							rtd_pr_vsc_notice("[%s][line:%d] HDMI game mode run timing fs.\n", __FUNCTION__, __LINE__);
						}
#endif
					}
					//change to 1-buffer after iv2dv delay done
					rtd_pr_vsc_emerg("ST game mode resume done!!\n");
				}
			}
			up(&GameMode_Check_Semaphore);
		}
		else{
			if(st_game_mode_cmd_pre != st_cmd_check_cnt){
				down(&GameMode_Check_Semaphore);
				st_game_mode_cmd_pre = st_cmd_check_cnt;
				up(&GameMode_Check_Semaphore);
			}
		}


		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
		msleep(10);
	}

	rtd_pr_vsc_debug( "\r\n####game_mode_unmute_tsk: exit...####\n");
	do_exit(0);
	return 0;
}
#ifndef UT_flag
static void create_game_mode_unmute_tsk(void)
{
	int err;
	if (game_mode_unmute_tsk_running_flag == FALSE) {
		p_game_mode_unmute_tsk = kthread_create(game_mode_unmute_tsk, NULL, "game_mode_unmute_tsk");

	    if (p_game_mode_unmute_tsk) {
			wake_up_process(p_game_mode_unmute_tsk);
			game_mode_unmute_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_game_mode_unmute_tsk);
	    	rtd_pr_vsc_debug("Unable to start game_mode_unmute_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_game_mode_unmute_tsk(void)
{
	int ret;
	if (game_mode_unmute_tsk_running_flag) {
		if(p_game_mode_unmute_tsk){
	 		ret = kthread_stop(p_game_mode_unmute_tsk);
	 		if (!ret) {
	 			p_game_mode_unmute_tsk = NULL;
	 			game_mode_unmute_tsk_running_flag = FALSE;
				rtd_pr_vsc_debug("game_mode_unmute_tsk thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_debug("game_mode_unmute_tsk thread stopped already\n");
		}
	}
}
#endif // #ifndef UT_flag

#ifdef BRING_UP_AUTO_FLOW/*This is only for bring up use demoap*/
#ifdef AUTO_BRINGUP_SOURCE
void vsc_source_bringup_force_connect(void)
{//force connect ADC source
	KADP_VSC_INPUT_SRC_INFO_T InputsourceInfo = {KADP_VSC_INPUTSRC_MAXN, 0 , 0};
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		return;
	}
#ifdef CONFIG_DUAL_CHANNEL
	if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		return;
	}
#endif

	switch(AUTO_BRINGUP_SOURCE)
	{
		case _SRC_YPBPR:
		case _SRC_VGA:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_ADC;
		break;

		case _SRC_TV:
		case _SRC_CVBS:
		case _SRC_SV:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_AVD;
		break;

		case _SRC_HDMI:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_HDMI;
		break;

		case _SRC_VO:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_VDEC;
		break;

		default:
			break;

	}

	rtk_hal_vsc_initialize();
	if(InputsourceInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		rtk_hal_vsc_open(VIDEO_WID_0);
		rtk_hal_vsc_Connect(VIDEO_WID_0, InputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
		rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
	}

#ifdef CONFIG_DUAL_CHANNEL
	switch(AUTO_BRINGUP_SOURCE_SUB)
	{
		case _SRC_YPBPR:
		case _SRC_VGA:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_ADC;
		break;

		case _SRC_TV:
		case _SRC_CVBS:
		case _SRC_SV:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_AVD;
		break;

		case _SRC_HDMI:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_HDMI;
		break;

		case _SRC_VO:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_VDEC;
		break;

		default:
			return;
	}
	rtk_hal_vsc_open(VIDEO_WID_1);
	rtk_hal_vsc_Connect(VIDEO_WID_1, InputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
#endif
}
#endif

unsigned char bringup_verify_timing_ready(unsigned char source)
{
	StructDisplayInfo *timing_info = NULL;
	switch(source)
	{
		case KADP_VSC_INPUTSRC_ADC:
		#ifdef CONFIG_SUPPORT_SRC_ADC
			timing_info = Get_ADC_Dispinfo();
			if((timing_info->IPH_ACT_WID_PRE == 0) || (timing_info->IPV_ACT_LEN_PRE == 0) || (timing_info->IHFreq == 0) || (timing_info->IVFreq == 0))
				return FALSE;
			else
		#endif
				return TRUE;

		break;

		case KADP_VSC_INPUTSRC_AVD:
			timing_info = Get_AVD_ScalerDispinfo();
			if((timing_info->IPH_ACT_WID_PRE == 0) || (timing_info->IPV_ACT_LEN_PRE == 0) || (timing_info->IHFreq == 0) || (timing_info->IVFreq == 0))
				return FALSE;
			else
				return TRUE;

		break;

		case KADP_VSC_INPUTSRC_HDMI:
			if((Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID) == 0) || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVHEIGHT) == 0)
				 || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHFREQ) == 0) || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVFREQ) == 0)
			)
				return FALSE;
			else
				return TRUE;
		break;

		default:
			return FALSE;
	}
}

static bool bring_up_vsc_running_flag = FALSE;
static struct task_struct *p_bring_up_vsc_tsk = NULL;

unsigned char rtk_bring_up_connect(void)
{/*This is for source check signal stable or not. Must be _MODE_STATE_ACTIVE*/
	VIDEO_RECT_T  inregion = {0, 0, 0, 0};
	KADP_VIDEO_RECT_T outregion = {0, 0, 0, 0};
	static int flag = 0;

	if(flag == 0)
	{
#ifdef CONFIG_DUAL_CHANNEL
		flag = 1;
#endif
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_MAXN)
		{
			return false;
		}
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC || DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_JPEG)
		{
			down(get_vo_infosemaphore());
			if(get_vo_change_flag(DisplayModeInputInfo.resourceIndex))
			{
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE,  _MODE_STATE_SEARCH);
			}
			else
			{
				up(get_vo_infosemaphore());
				return false;
			}
			up(get_vo_infosemaphore());
		}

		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_SEARCH)
		{
			//rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}

		switch(DisplayModeInputInfo.type)
		{
			case KADP_VSC_INPUTSRC_ADC:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_ADC)){
					rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_AVD:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_AVD)){
					rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_HDMI:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_HDMI))
					return false;
				break;

			default:

				break;

		}
		inregion.w = 3840;/*default*/
		inregion.h = 2160;/*default*/
		outregion.w = _DISP_WID;
		outregion.h = _DISP_LEN;
		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, inregion, inregion);
		//rtk_hal_vsc_SetInputRegion(KADP_VIDEO_WID_0, inregion);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, outregion, 0, 0);
		return rtk_hal_vsc_SetWinBlank(VIDEO_WID_0, 0, KADP_VIDEO_DDI_WIN_COLOR_BLACK);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		flag = 0;
		if(Sub_DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_MAXN)
		{
			//rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
			//rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}

		switch(Sub_DisplayModeInputInfo.type)
		{
			case KADP_VSC_INPUTSRC_ADC:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_ADC)){
					rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_AVD:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_AVD)){
					rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_HDMI:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_HDMI))
					return false;
				break;

			default:

				break;

		}

		inregion.w = 3840;/*default*/
		inregion.h = 2160;/*default*/
		outregion.w = _DISP_WID/2;
		outregion.h = _DISP_LEN/2;
		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, inregion, inregion);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, outregion, 0, 0);
		return rtk_hal_vsc_SetWinBlank(VIDEO_WID_1, 0, KADP_VIDEO_DDI_WIN_COLOR_BLACK);
	}
#else
	return TRUE;

#endif
}

static int bring_up_vsc_tsk(void *p)
{/* only for bring up test */
    rtd_pr_vsc_debug("bring_up_vsc_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
    	msleep(1000);
#ifdef AUTO_BRINGUP_SOURCE
		vsc_source_bringup_force_connect();
#endif

#ifdef CONFIG_DUAL_CHANNEL
		if ((DbgSclrFlgTkr.OuputDisplayMode == TRUE) || (DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)){
			//rtd_pr_vsc_emerg( "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			rtk_bring_up_connect();
		}
#else
		if (DbgSclrFlgTkr.OuputDisplayMode == TRUE)
			rtk_bring_up_connect();
#endif
		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
         	break;
      	}
    }

    rtd_pr_vsc_debug("\r\n####bring_up_vsc_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_bring_up_vsc_tsk(void)
{
	int err;
	if (bring_up_vsc_running_flag == FALSE) {
		p_bring_up_vsc_tsk = kthread_create(bring_up_vsc_tsk, NULL, "bring_up_vsc_tsk");

	    if (p_bring_up_vsc_tsk) {
			wake_up_process(p_bring_up_vsc_tsk);
			bring_up_vsc_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_bring_up_vsc_tsk);
	    	rtd_pr_vsc_debug("Unable to start bring_up_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_bring_up_vsc_tsk(void)
{
	int ret;
	if (bring_up_vsc_running_flag) {
		if(p_bring_up_vsc_tsk){
	 		ret = kthread_stop(p_bring_up_vsc_tsk);
	 		if (!ret) {
	 			p_bring_up_vsc_tsk = NULL;
	 			bring_up_vsc_running_flag = FALSE;
				rtd_pr_vsc_debug("bring_up_vsc_tsk thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_debug("bring_up_vsc_tsk thread stopped already\n");
		}
	}
}
#endif// #ifdef BRING_UP_AUTO_FLOW/*This is only for bring up use demoap*/



#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
static bool arc_tsk_running_flag = FALSE;//for arc control tsk
static struct task_struct *p_arc_control_tsk = NULL;//for arc control tsk


static void update_arc_cmd_to_ring_buffer_sharemem(unsigned char display, KADP_VIDEO_RECT_T inregion, KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion,SCALER_VSC_INPUT_REGION_TYPE inputregion_type)
{//update ara parameter to sharememory. for SCALERIOC_MAIN_INPUT_OUTPUT_BUFFER_INFO and SCALERIOC_SUB_INPUT_OUTPUT_BUFFER_INFO
	INPUT_OUTPUT_RINGBUFFER_INFO_T *p_ring_buffer_addr;
	unsigned short updateindex;
	unsigned char overflow_status = FALSE;

#ifdef WIN_DELAY_CALLBACK_PROFILE
	gCallback_profile.OutputRegion.x = outregion.x;
	gCallback_profile.OutputRegion.y = outregion.y;
	gCallback_profile.OutputRegion.w = outregion.w;
	gCallback_profile.OutputRegion.h = outregion.h;
	gCallback_profile._90k_cnt = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
	gCallback_profile.uzulcnt = PPOVERLAY_new_meas2_linecnt_real_get_uzudtg_dly_line_cnt_rt(IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg));
#endif

	if(display == SLR_MAIN_DISPLAY)
	{
		p_ring_buffer_addr = (INPUT_OUTPUT_RINGBUFFER_INFO_T *)Scaler_GetShareMemVirAddr(SCALERIOC_MAIN_INPUT_OUTPUT_BUFFER_INFO);
		if(((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE) == Scaler_ChangeUINT16Endian(p_ring_buffer_addr->read_idx))
		{//over flow case
			updateindex = Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx);
			overflow_status = TRUE;
		}
		else
			updateindex = ((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE);
		//update input region
		p_ring_buffer_addr->in_out_data[updateindex].input_x = Scaler_ChangeUINT16Endian(inregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].input_y = Scaler_ChangeUINT16Endian(inregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].input_w = Scaler_ChangeUINT16Endian(inregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].input_h = Scaler_ChangeUINT16Endian(inregion.h);

		//update output region
		p_ring_buffer_addr->in_out_data[updateindex].output_x = Scaler_ChangeUINT16Endian(outregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].output_y = Scaler_ChangeUINT16Endian(outregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].output_w = Scaler_ChangeUINT16Endian(outregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].output_h = Scaler_ChangeUINT16Endian(outregion.h);

		//update original input. input resolution
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_w = Scaler_ChangeUINT16Endian(originalInput.w);
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_h = Scaler_ChangeUINT16Endian(originalInput.h);

		p_ring_buffer_addr->in_out_data[updateindex].inputregion_type = Scaler_ChangeUINT16Endian(inputregion_type);

		p_ring_buffer_addr->write_idx = Scaler_ChangeUINT16Endian(updateindex);

		if(overflow_status)
			rtd_pr_vsc_err("\r\n#### update_arc_cmd_to_ring_buffer_sharemem over flow main path####\r\n");

	}
#ifdef CONFIG_DUAL_CHANNEL
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_SUPPORT_SUB
	else if(display == SLR_SUB_DISPLAY)
	{
		p_ring_buffer_addr = (INPUT_OUTPUT_RINGBUFFER_INFO_T *)Scaler_GetShareMemVirAddr(SCALERIOC_SUB_INPUT_OUTPUT_BUFFER_INFO);
		if(((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE) == Scaler_ChangeUINT16Endian(p_ring_buffer_addr->read_idx))
		{//over flow case
			updateindex = Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx);
			overflow_status = TRUE;
		}
		else
			updateindex = ((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE);
		//update input region
		p_ring_buffer_addr->in_out_data[updateindex].input_x = Scaler_ChangeUINT16Endian(inregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].input_y = Scaler_ChangeUINT16Endian(inregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].input_w = Scaler_ChangeUINT16Endian(inregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].input_h = Scaler_ChangeUINT16Endian(inregion.h);

		//update output region
		p_ring_buffer_addr->in_out_data[updateindex].output_x = Scaler_ChangeUINT16Endian(outregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].output_y = Scaler_ChangeUINT16Endian(outregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].output_w = Scaler_ChangeUINT16Endian(outregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].output_h = Scaler_ChangeUINT16Endian(outregion.h);

		//update original input. input resolution
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_w = Scaler_ChangeUINT16Endian(originalInput.w);
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_h = Scaler_ChangeUINT16Endian(originalInput.h);

		p_ring_buffer_addr->in_out_data[updateindex].inputregion_type = Scaler_ChangeUINT16Endian(inputregion_type);

		p_ring_buffer_addr->write_idx = Scaler_ChangeUINT16Endian(updateindex);
		if(overflow_status)
			rtd_pr_vsc_err("\r\n#### update_arc_cmd_to_ring_buffer_sharemem over flow sub path####\r\n");
	}
#endif
#endif
}


#ifndef UT_flag
static int arc_control_tsk(void *p)//control new input parameter
{/* for new input hal */
	KADP_VSC_ROTATE_T local_main_rotate_type_parm;//for new input output. /for main path
	VIDEO_RECT_T local_main_inregion_parm;//for new input output. main path ap parameter
	VIDEO_RECT_T local_main_originalInput_parm;//for new input output. main path ap input resolution parameter
	KADP_VIDEO_RECT_T local_main_outregion_parm;//for new input output. main path ap input resolution parameter
#ifdef CONFIG_DUAL_CHANNEL
	VIDEO_RECT_T local_sub_inregion_parm;//for new input output. sub path ap parameter
	VIDEO_RECT_T local_sub_originalInput_parm;//for new input output. sub path ap input resolution parameter
	KADP_VIDEO_RECT_T local_sub_outregion_parm;//for new input output. sub path ap input resolution parameter
#endif

    rtd_pr_vsc_debug("arc_control_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
#ifdef CONFIG_DUAL_CHANNEL
		wait_event_freezable(ARC_CONTROL_WAIT_QUEUE, main_arc_change_flag || sub_arc_change_flag);
#else
		wait_event_freezable(ARC_CONTROL_WAIT_QUEUE, main_arc_change_flag);
#endif
		if(main_arc_change_flag)
		{
			unsigned long flags;//for spin_lock_irqsave
			spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
			local_main_rotate_type_parm = ap_main_rotate_type_parm;//copy rotate type

			//copy input region
			local_main_inregion_parm.x = ap_main_inregion_parm.x;
			local_main_inregion_parm.y = ap_main_inregion_parm.y;
			local_main_inregion_parm.w = ap_main_inregion_parm.w;
			local_main_inregion_parm.h = ap_main_inregion_parm.h;

            //copy original input. input source resolution
			local_main_originalInput_parm.x = ap_main_originalInput_parm.x;
			local_main_originalInput_parm.y = ap_main_originalInput_parm.y;
			local_main_originalInput_parm.w = ap_main_originalInput_parm.w;
			local_main_originalInput_parm.h = ap_main_originalInput_parm.h;

			//copy output region
			local_main_outregion_parm.x = ap_main_outregion_parm.x;
			local_main_outregion_parm.y = ap_main_outregion_parm.y;
			local_main_outregion_parm.w = ap_main_outregion_parm.w;
			local_main_outregion_parm.h = ap_main_outregion_parm.h;
			main_arc_change_flag = FALSE;
			spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);


#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			//rotate part
			down(&SetMainOutPutRegion_Semaphore);
			main_rotate_mode_pre = main_rotate_mode;
			main_rotate_mode = (DIRECT_VO_FRAME_ORIENTATION)local_main_rotate_type_parm;
			up(&SetMainOutPutRegion_Semaphore);
#endif
			virtual_w = true_wide;//magnify and livezoom use
			virtual_h = true_high;//magnify and livezoom use
			if((vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_AUTO_MODE|| vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_oled_orbit_enable)
			{
                vbe_disp_orbit_set_vo_overscan_state(1);
                rtd_pr_vsc_info("vbe_disp_orbit_set_vo_overscan_state enable\n");
			}
			rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, local_main_inregion_parm, local_main_originalInput_parm);
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, local_main_outregion_parm, virtual_w, virtual_h);
		}
#ifdef CONFIG_DUAL_CHANNEL
		if(sub_arc_change_flag)
		{
			unsigned long flags;//for spin_lock_irqsave
			spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
			//copy input region
			local_sub_inregion_parm.x = ap_sub_inregion_parm.x;
			local_sub_inregion_parm.y = ap_sub_inregion_parm.y;
			local_sub_inregion_parm.w = ap_sub_inregion_parm.w;
			local_sub_inregion_parm.h = ap_sub_inregion_parm.h;

            //copy original input. input source resolution
			local_sub_originalInput_parm.x = ap_sub_originalInput_parm.x;
			local_sub_originalInput_parm.y = ap_sub_originalInput_parm.y;
			local_sub_originalInput_parm.w = ap_sub_originalInput_parm.w;
			local_sub_originalInput_parm.h = ap_sub_originalInput_parm.h;

			//copy output region
			local_sub_outregion_parm.x = ap_sub_outregion_parm.x;
			local_sub_outregion_parm.y = ap_sub_outregion_parm.y;
			local_sub_outregion_parm.w = ap_sub_outregion_parm.w;
			local_sub_outregion_parm.h = ap_sub_outregion_parm.h;
			sub_arc_change_flag = FALSE;
			spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);

			virtual_w = true_wide;//magnify and livezoom use
			virtual_h = true_high;//magnify and livezoom use

			rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, local_sub_inregion_parm, local_sub_originalInput_parm);
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, local_sub_outregion_parm, virtual_w, virtual_h);
		}
#endif
		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
         	break;
      	}
    }

    rtd_pr_vsc_debug("\r\n####arc_control_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_arc_control_tsk(void)
{
	int err;
	if (arc_tsk_running_flag == FALSE) {
		p_arc_control_tsk = kthread_create(arc_control_tsk, NULL, "arc_control_tsk");

	    if (p_arc_control_tsk) {
			wake_up_process(p_arc_control_tsk);
			arc_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_arc_control_tsk);
	    	rtd_pr_vsc_err("Unable to start arc_control_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_arc_control_tsk(void)
{
	int ret;
	if (arc_tsk_running_flag) {
		if(p_arc_control_tsk){
	 		ret = kthread_stop(p_arc_control_tsk);
	 		if (!ret) {
	 			p_arc_control_tsk = NULL;
	 			arc_tsk_running_flag = FALSE;
				rtd_pr_vsc_err("arc_control_tsk thread stopped\n");
	 		}
		}else{
			rtd_pr_vsc_err("arc_control_tsk thread stopped already\n");
		}
	}
}
#endif // #ifndef UT_flag
#endif // #ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task

/******************** debug task start****************************/
static unsigned char vsc_status_debug_tsk_flag = FALSE;
static struct task_struct *p_vsc_status_debug_tsk = NULL;

extern struct semaphore VPQ_DM_DMA_TBL_Semaphore;
static int vsc_status_debug_tsk(void *p)
{/* only for bring up test */
    unsigned int debug_print_count = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
    rtd_pr_vsc_debug("vsc_status_debug_tsk()\n");
#ifndef UT_flag
    current->flags &= ~PF_NOFREEZE;
#endif
    while (1)
    {
        wait_event_freezable_timeout(DEBUGTSK_WAIT_QUEUE, 0, 20);//Timeout is 100ms


        if(drvif_wait_timeout_check_by_counter(debug_print_count, 20000))//20 seconds
        {
            struct semaphore* p_force_bg_semaphore;
            struct semaphore* p_di_semaphore;
            struct semaphore* p_fll_semaphore;
            struct semaphore* p_vo_semaphore;
            p_force_bg_semaphore = get_forcebg_semaphore();
            p_di_semaphore = get_DI_semaphore();
            p_fll_semaphore = get_scaler_fll_running_semaphore();
            p_vo_semaphore = get_vo_infosemaphore();
            rtd_pr_vsc_info(" [debug]src:(%d %d) \n", Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY));
            rtd_pr_vsc_info(" [debug]Semaphore 1 status(%d %d %d %d) \n", VSC_Semaphore.count,  GameMode_SCALER_SYNC_Semaphore.count, DM_HDR_Semaphore.count, DATA_ACCESS_DEBUG_Semaphore.count);
            rtd_pr_vsc_info(" [debug]Semaphore 2 status(%d %d %d %d) \n", Force_Run_Idma_Semaphore.count, Low_Delay_Semaphore.count, Double_buffer_Semaphore.count, GameMode_Check_Semaphore.count);
            rtd_pr_vsc_info(" [debug]Semaphore 3 status(%d %d %d %d) \n", VBE_LowDelay_Semaphore.count, HDR_Setting_Semaphore.count, Orbit_algo_Semaphore.count, set_vsc_film_mode_semaphore.count);
            rtd_pr_vsc_info(" [debug]Semaphore 4 status(%d %d %d %d) \n", SetMainOutPutRegion_Semaphore.count, Main_ResetMode_Semaphore.count, new_input_output_main_sem.count, VPQ_DM_DMA_TBL_Semaphore.count);
            if(p_force_bg_semaphore && p_di_semaphore && p_fll_semaphore && p_vo_semaphore)
            {
                rtd_pr_vsc_info(" [debug]Semaphore 5 status(%d %d %d %d) \n", p_force_bg_semaphore->count, p_di_semaphore->count, p_fll_semaphore->count, p_vo_semaphore->count);
            }
            debug_print_count = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
        }

        check_bsp_error_event(Main_Mute_Time_Abnormal, FALSE);
        check_bsp_error_event(Sub_Mute_Time_Abnormal, FALSE);
        if (freezing(current))
        {
            try_to_freeze();
            debug_print_count = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
        }
        if (kthread_should_stop()) {
            break;
        }
    }

    rtd_pr_vsc_debug("\r\n####vsc_status_debug_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static int create_vsc_status_debug_tsk(void)
{
    int ret = 0;
    if (vsc_status_debug_tsk_flag == FALSE) {
        p_vsc_status_debug_tsk = kthread_create(vsc_status_debug_tsk, NULL, "vsc_status_debug_tsk");

        if (p_vsc_status_debug_tsk) {
            wake_up_process(p_vsc_status_debug_tsk);
            vsc_status_debug_tsk_flag = TRUE;
        } else {
            ret = -1;
            rtd_pr_vsc_debug("Unable to start vsc_status_debug_tsk. kthread_create fail./n");
        }
    }
    return ret;
}

static int delete_vsc_status_debug_tsk(void)
{
    int ret = 0;
    if (vsc_status_debug_tsk_flag) {
        if(p_vsc_status_debug_tsk){
            ret = kthread_stop(p_vsc_status_debug_tsk);
            if (!ret) {
                p_vsc_status_debug_tsk = NULL;
                vsc_status_debug_tsk_flag = FALSE;
                rtd_pr_vsc_debug("vsc_status_debug_tsk thread stopped\n");
            }
        }else{
            rtd_pr_vsc_debug("vsc_status_debug_tsk thread stopped already\n");
        }
    }
    return ret;
}
/******************** debug task end****************************/
#ifndef UT_flag
struct file_operations vsc_fops= {
	.owner =    THIS_MODULE,
	.open  =    vsc_open,
	.release =  vsc_release,
	.read  =    vsc_read,
	.write = 	vsc_write,
	.unlocked_ioctl =    vsc_ioctl,
#if defined(CONFIG_COMPAT) && defined(CONFIG_ARM64)
      .compat_ioctl = vsc_compat_ioctl,
#endif
	.poll  =    vsc_poll,
};

#ifdef CONFIG_DUMP_REGISTER
static bool dump_register_vsc_running_flag = FALSE;
static struct task_struct *p_dump_register_vsc_tsk = NULL;
extern void register_dump_test(void);
extern void register_dump_data_to_file(void);
static int dump_register_vsc_tsk(void *p)
{
    rtd_pr_vsc_debug("dump_register_vsc_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
		msleep(200);
	//rtd_pr_vsc_emerg("dump_register_vsc_tsk\n");
#ifdef CONFIG_DUMP_REGISTER
		register_dump_test();
		register_dump_data_to_file();
		//rtd_pr_vsc_emerg("test_vsc_tsk********\n");
		//rtd_pr_vsc_emerg("test_vsc_tsk********\n");
#endif

		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
			break;
		}
	}

    rtd_pr_vsc_debug("\r\n####dump_register_vsc_tsk: exit...####\n");
    do_exit(0);
    return 0;
}
static void create_dump_register_vsc_tsk(void)
{
	int err;
	if (dump_register_vsc_running_flag == FALSE) {
		p_dump_register_vsc_tsk = kthread_create(dump_register_vsc_tsk, NULL, "dump_register_vsc_tsk");

	    if (p_dump_register_vsc_tsk) {
			wake_up_process(p_dump_register_vsc_tsk);
			dump_register_vsc_running_flag = TRUE;
	    } else {
			err = PTR_ERR(p_dump_register_vsc_tsk);
			rtd_pr_vsc_debug("Unable to start dump_register_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}
static void delete_dump_register_vsc_tsk(void)
{
	int ret;
	if (dump_register_vsc_running_flag) {
		if(p_dump_register_vsc_tsk){
			ret = kthread_stop(p_dump_register_vsc_tsk);
			if (!ret) {
				p_dump_register_vsc_tsk = NULL;
				dump_register_vsc_running_flag = FALSE;
				rtd_pr_vsc_debug("dump_register_vsc_tsk thread stopped\n");
			}
		}else{
			rtd_pr_vsc_debug("dump_register_vsc_tsk thread stopped already\n");
		}
	}
}
#endif

int vsc_major   = VSC_MAJOR;
int vsc_minor   = 0 ;
int vsc_nr_devs = VSC_NR_DEVS;

module_param(vsc_major, int, S_IRUGO);
module_param(vsc_minor, int, S_IRUGO);
module_param(vsc_nr_devs, int, S_IRUGO);


static struct class *vsc_class = NULL;
static struct platform_device *vsc_platform_devs = NULL;

#ifdef CONFIG_PM
static const struct dev_pm_ops vsc_pm_ops =
{
	.suspend    = vsc_suspend,
	.resume     = vsc_resume,
#ifdef CONFIG_HIBERNATION
	.freeze 	= vsc_suspend,
	.thaw		= vsc_resume_std,
	.poweroff	= vsc_suspend,
	.restore	= vsc_resume_std,
#endif

};
#endif

static struct platform_driver vsc_device_driver = {
    .driver = {
        .name       = VSC_DEVICE_NAME,
        .bus        = &platform_bus_type,
#ifdef CONFIG_PM
	.pm 		= &vsc_pm_ops,
#endif

    },
} ;


static char *vsc_devnode(struct device *dev, umode_t *mode)
{
	*mode = 0666;
	return NULL;
}

#if IS_ENABLED(CONFIG_RTK_KDRV_DC_MEMORY_TRASH_DETCTER)
static void sb2_i3ddma_debug_info(void)
{
	dcmt_trap_info trap_info;
	//check trash module
	if(!isDcmtTrap("TVSB2_I3DDMA"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		rtd_pr_vsc_err("not TVSB2_I3DDMA module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_I3DDMA module trashed somewhere!\n");

	// i3ddma setting
	rtd_pr_vsc_err("i3ddma setting 0xb8025810=%x\n", IoReg_Read32(H3DDMA_I3DDMA_enable_reg));
	// i3ddma status
	rtd_pr_vsc_err("Cap_Status 0xb8025838=%x\n", IoReg_Read32(H3DDMA_I3DDMA_BIST_RM_1_reg));

	//Cap_BoundaryAddr & start address
	rtd_pr_vsc_err("Cap0_BoundaryAddr_up 0xb8025B04=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_up_reg));
	rtd_pr_vsc_err("Cap0_BoundaryAddr_low 0xb8025B08=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_low_reg));
	rtd_pr_vsc_err("Cap0_BoundaryAddr1_up 0xb80258D0=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_up_1_reg));
	rtd_pr_vsc_err("Cap0_BoundaryAddr1_low 0xb80258D4=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_low_1_reg));
	rtd_pr_vsc_err("Cap0_BoundaryAddr2_up 0xb80258D8=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_up_2_reg));
	rtd_pr_vsc_err("Cap0_BoundaryAddr2_low 0xb80258DC=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_low_2_reg));
	rtd_pr_vsc_err("Cap0_BoundaryAddr3_up 0xb80258E0=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_up_3_reg));
	rtd_pr_vsc_err("Cap0_BoundaryAddr3_low 0xb80258E4=%x\n", IoReg_Read32(H3DDMA_CAP0_CTI_DMA_WR_Rule_check_low_3_reg));

	rtd_pr_vsc_err("Cap0_L0_Start 0xb8025B20=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_0_reg));
	rtd_pr_vsc_err("Cap0_R0_Start 0xb8025B30=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_r0_reg));
	rtd_pr_vsc_err("Cap0_L1_Start 0xb8025B24=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_1_reg));
	rtd_pr_vsc_err("Cap0_R1_Start 0xb8025B34=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_r1_reg));
	rtd_pr_vsc_err("Cap0_L2_Start 0xb8025B28=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_2_reg));
	rtd_pr_vsc_err("Cap0_R2_Start 0xb8025B38=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_r2_reg));
	rtd_pr_vsc_err("Cap0_L3_Start 0xb8025B2C=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_3_reg));
	rtd_pr_vsc_err("Cap0_R3_Start 0xb8025B3C=%x\n", IoReg_Read32(H3DDMA_CAP0_WR_DMA_num_bl_wrap_addr_r3_reg));

	//md setting & start address
	rtd_pr_vsc_err("cap3_cap_Status 0xB8025DE8=%x\n", IoReg_Read32(H3DDMA_CAP3_Cap_Status_reg));
	rtd_pr_vsc_err("md_m1_Start 0xB8025DA0=%x\n", IoReg_Read32(H3DDMA_CAP3_WR_DMA_num_bl_wrap_addr_0_reg));
	rtd_pr_vsc_err("md_m2_Start 0xB8025DA4=%x\n", IoReg_Read32(H3DDMA_CAP3_WR_DMA_num_bl_wrap_addr_1_reg));
	rtd_pr_vsc_err("md_m3_Start 0xB8025DA8=%x\n", IoReg_Read32(H3DDMA_CAP3_WR_DMA_num_bl_wrap_addr_2_reg));
	rtd_pr_vsc_err("md_m4_Start 0xB8025DAC=%x\n", IoReg_Read32(H3DDMA_CAP3_WR_DMA_num_bl_wrap_addr_3_reg));

	return;
}

static void sb2_di_debug_info(void)
{
	dcmt_trap_info trap_info;
	unsigned int i = 0;
	//check trash module
	if(!isDcmtTrap("TVSB2_DIW"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		rtd_pr_vsc_err("not TVSB2_DIW module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_DIW module trashed somewhere!\n");
	rtd_pr_vsc_err("0xb8024000=%x\n", IoReg_Read32(DI_IM_DI_CONTROL_reg));
	rtd_pr_vsc_err("0xb8024538=%x\n", IoReg_Read32(DI_db_reg_ctl_reg));

	for (i = DI_DI_DATMemoryStartAdd1_reg; i <=DI_DI1_WRRD_BoundaryAdd_Status_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	return;
}

static void sb2_m_cap_debug_info(void)
{
	dcmt_trap_info trap_info;
	unsigned int i = 0;
	//check trash module
	if(!isDcmtTrap("TVSB2_M_CAP"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		rtd_pr_vsc_err("not TVSB2_M_CAP module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_M_CAP module trashed somewhere!\n");

	//m-cap address and control
	for (i = MDOMAIN_CAP_DDR_In1WTLVL_Num_reg; i <=MDOMAIN_CAP_Cap_In1_enable_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}

	// Double buffer
	rtd_pr_vsc_err("Double buffer 0xb802726c=%x\n", IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg));

	// Boundary down limit
	rtd_pr_vsc_err("Boundary down limit 0xb8027278=%x\n", IoReg_Read32(MDOMAIN_CAP_CapMain_BoundaryAddr1_reg));
	// Boundary up limit
	rtd_pr_vsc_err("Boundary up limit 0xb802727c=%x\n", IoReg_Read32(MDOMAIN_CAP_CapMain_BoundaryAddr2_reg));

	// Boundary status
	rtd_pr_vsc_err("Boundary status 0xb8027280=%x\n", IoReg_Read32(MDOMAIN_CAP_DI1Cap_WRRD_BoundaryAdd_Status_reg));

	return;
}


static void sb2_vo1_y_debug_info(void)
{
	dcmt_trap_info trap_info;
	//check trash module
	if(!isDcmtTrap("TVSB2_VO1_Y"))
	{
		rtd_pr_vsc_err("not TVSB2_VO1_Y module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	rtd_pr_vsc_err("TVSB2_VO1_Y module trashed somewhere!\n");

	rtd_pr_vsc_err("VODMA_V1_DCFG 0xb8005000=%x\n", IoReg_Read32(VODMA_VODMA_V1_DCFG_reg));
	rtd_pr_vsc_err("VODMA_REG_DB_CTRL 0xb8005010=%x\n", IoReg_Read32(VODMA_VODMA_REG_DB_CTRL_reg));
	rtd_pr_vsc_err("VODMA_V1_DSIZE 0xb8005020=%x\n", IoReg_Read32(VODMA_VODMA_V1_DSIZE_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L1 0xb8005024=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L1_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R1 0xb8005028=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_R1_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L2 0xb800502C=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L2_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R2 0xb8005030=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_R2_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L3 0xb8005034=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L3_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R3 0xb8005038=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_R3_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_L4 0xb800503C=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L4_reg));
	rtd_pr_vsc_err("VODMA_V1_SEQ_3D_R4 0xb8005040=%x\n", IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_R4_reg));
	rtd_pr_vsc_err("VODMA_TaBSbS_merge 0xb80050E0=%x\n", IoReg_Read32(VODMA_VODMA_ACCESSDATA_CLR_reg));
	rtd_pr_vsc_err("VODMA_TaBSbS_SEQ 0xb80050E4=%x\n", IoReg_Read32(VODMA_VODMA_V1VGIP_INTPOS_reg));
	rtd_pr_vsc_err("VODMA_3D_CS_1 0xb80050C4=%x\n", IoReg_Read32(VODMA_VODMA_ACCESSDATA_CTRL_reg));
	rtd_pr_vsc_err("VODMA_3D_CS_2 0xb80050C8=%x\n", IoReg_Read32(VODMA_VODMA_ACCESSDATA_Y1_reg));
	rtd_pr_vsc_err("VODMA_dma_option 0xb80050DC=%x\n", IoReg_Read32(VODMA_VODMA_ACCESSDATA_C4_reg));
	rtd_pr_vsc_err("DECOMP_CTRL0 0xb8005100=%x\n", IoReg_Read32(VODMA_VODMA_LD_Rule_check_low_Y_reg));
	rtd_pr_vsc_err("DECOMP_PIC_SET 0xb8005118=%x\n", IoReg_Read32(VODMA_VODMA_LD_addcmd_wrap_status1_Y_reg));
	rtd_pr_vsc_err("DECOMP_READ_Y 0xb800511C=%x\n", IoReg_Read32(VODMA_VODMA_LD_addcmd_wrap_status2_Y_reg));
	rtd_pr_vsc_err("DECOMP_READ_C 0xb8005120=%x\n", IoReg_Read32(VODMA_VODMA_LD_Rule_check_up_C_reg));
	rtd_pr_vsc_err("DECOMP_X_WID_Y 0xb8005124=%x\n", IoReg_Read32(VODMA_VODMA_LD_Rule_check_low_C_reg));
	rtd_pr_vsc_err("DECOMP_X_WID_C 0xb8005128=%x\n", IoReg_Read32(VODMA_VODMA_LD_Ctrl_C_reg));
	rtd_pr_vsc_err("vodma_i2rnd 0xb8005200=%x\n", IoReg_Read32(VODMA_DECOMP_CTRL0_reg));

	return;
}

static void memc_debug_info(void)
{
#ifdef CONFIG_MEMC_NOTSUPPORT // for code size reduce, when MEMC_BYPASS
		return;
#else

	dcmt_trap_info trap_info;
	unsigned int i = 0;

	//check trash module
	if(!isDcmtTrap("MEMC"))
	{
		rtd_pr_vsc_err("not MEMC module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)

	//Me_uplimit_addr
	rtd_pr_vsc_err("ME up Limit 0xb809E0B4=%x\n", IoReg_Read32(DBUS_WRAPPER_Me_uplimit_addr_reg));
	//Me_downlimit_addr
	rtd_pr_vsc_err("ME down Limit 0xb809E0B8=%x\n", IoReg_Read32(DBUS_WRAPPER_Me_downlimit_addr_reg));

	rtd_pr_vsc_err("ME_SHRE_WR low Limit 0xb809b790=%x\n", IoReg_Read32(ME_SHARE_DMA_ME_DMA_WR_Rule_check_low_reg));
	rtd_pr_vsc_err("ME_SHRE_RD low Limit 0xb809b7dc=%x\n", IoReg_Read32(ME_SHARE_DMA_ME_DMA_RD_Rule_check_low_reg));
	rtd_pr_vsc_err("ME_SHRE_WR up Limit 0xb809b78c=%x\n", IoReg_Read32(ME_SHARE_DMA_ME_DMA_WR_Rule_check_up_reg));
	rtd_pr_vsc_err("ME_SHRE_RD up Limit 0xb809b7d8=%x\n", IoReg_Read32(ME_SHARE_DMA_ME_DMA_RD_Rule_check_up_reg));

	rtd_pr_vsc_err("MV_INFO_WR low Limit 0xb809b790=%x\n", IoReg_Read32(MVINFO_DMA_MVINFO_WR_Rule_check_low_reg));
	rtd_pr_vsc_err("MV_INFO_RD low Limit 0xb809b7dc=%x\n", IoReg_Read32(MVINFO_DMA_MVINFO_RD_Rule_check_low_reg));
	rtd_pr_vsc_err("MV_INFO_WR up Limit 0xb809b78c=%x\n", IoReg_Read32(MVINFO_DMA_MVINFO_WR_Rule_check_up_reg));
	rtd_pr_vsc_err("MV_INFO_RD up Limit 0xb809b7d8=%x\n", IoReg_Read32(MVINFO_DMA_MVINFO_RD_Rule_check_up_reg));

	IoReg_ClearBits(MC_DMA_MC_WDMA_DB_CTRL_reg,_BIT1);
	IoReg_ClearBits(MC_DMA_MC_RDMA_DB_CTRL_reg,_BIT1);
	IoReg_ClearBits(PQC_PQDC_MC_PQ_DECMP_DB_CTRL_reg,_BIT1);
	IoReg_ClearBits(PQC_PQDC_MC_PQ_CMP_DB_CTRL_reg,_BIT1);
	IoReg_ClearBits(LBMC_LBMC_EC_reg,_BIT1);

	// DMA enable
	rtd_pr_vsc_err("DMA_enable 0xb8099460[0]=%x\n", IoReg_Read32(MC_DMA_MC_LF_DMA_WR_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb80994dc[0]=%x\n", IoReg_Read32(MC_DMA_MC_HF_DMA_WR_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809ae1c[0]=%x\n", IoReg_Read32(MC_DMA_MC_LF_I_DMA_RD_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809ae3c[0]=%x\n", IoReg_Read32(MC_DMA_MC_HF_I_DMA_RD_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809ae5c[0]=%x\n", IoReg_Read32(MC_DMA_MC_LF_P_DMA_RD_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809ae7c[0]=%x\n", IoReg_Read32(MC_DMA_MC_HF_P_DMA_RD_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809B720[0:1]=%x\n", IoReg_Read32(ME_SHARE_DMA_KME_WR_client_en_reg)&0x3);
	rtd_pr_vsc_err("DMA_enable 0xb809B794[0]=%x\n", IoReg_Read32(ME_SHARE_DMA_ME_DMA_WR_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809B7b0[0:1]=%x\n", IoReg_Read32(ME_SHARE_DMA_KME_RD_client_en_reg)&0x3);
	rtd_pr_vsc_err("DMA_enable 0xb809B7E0[0]=%x\n", IoReg_Read32(ME_SHARE_DMA_ME_DMA_RD_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809B128[0]=%x\n", IoReg_Read32(MVINFO_DMA_MVINFO_WR_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809B174[0]=%x\n", IoReg_Read32(MVINFO_DMA_MVINFO_RD_Ctrl_reg)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c038[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME_00_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c040[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME_01_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c048[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME_02_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c050[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME_03_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c070[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME_04_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c090[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME_05_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c098[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME06AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c0a0[20]=%x\n", (IoReg_Read32(KME_DM_TOP0_KME_07_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c114[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_14_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c11c[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_1C_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c138[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_38_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c140[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_40_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c15c[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_5C_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c164[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_64_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c180[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_80_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c188[20]=%x\n", (IoReg_Read32(KME_DM_TOP1_KME_DM_TOP1_88_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c210[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV01_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c224[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV02_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c228[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV03_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c244[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV04_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c260[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV05_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c264[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV06_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c268[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV07_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c26c[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV08_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c270[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV09_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c274[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV10_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c278[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV11_AGENT_reg)>>20)&0x1);
	rtd_pr_vsc_err("DMA_enable 0xb809c28c[20]=%x\n", (IoReg_Read32(KME_DM_TOP2_MV12_AGENT_reg)>>20)&0x1);

	// Double buffer - MC_WDMA
	rtd_pr_vsc_err("Db_MC_WDMA 0xb80994F0=%x\n", IoReg_Read32(MC_DMA_MC_WDMA_DB_CTRL_reg));
	// Double buffer - MC_RDMA
	rtd_pr_vsc_err("Db_MC_RDMA 0xb809AEA8=%x\n", IoReg_Read32(MC_DMA_MC_RDMA_DB_CTRL_reg));

	// Double buffer - DECOMP_DB
	rtd_pr_vsc_err("Db_MC_RDMA 0xb8099850=%x\n", IoReg_Read32(PQC_PQDC_MC_PQ_DECMP_DB_CTRL_reg));
	// Double buffer - COMP_DB
	rtd_pr_vsc_err("Db_MC_RDMA 0xb8099268=%x\n", IoReg_Read32(PQC_PQDC_MC_PQ_CMP_DB_CTRL_reg));
	// Double buffer - LBMC_DB
	rtd_pr_vsc_err("Db_MC_RDMA 0xb80999ec=%x\n", IoReg_Read32(LBMC_LBMC_EC_reg));

	// Double buffer - LBMC_PC_check
	rtd_pr_vsc_err("PC_mode_check 0xb8099924=%x\n", IoReg_Read32(LBMC_LBMC_24_reg));

	//MC_LF_W uplimit_addr
	rtd_pr_vsc_err("MC_LF_W up limit 0xb8099458=%x\n", IoReg_Read32(MC_DMA_MC_LF_DMA_WR_Rule_check_up_reg));
	//MC_LF_W downlimit_addr
	rtd_pr_vsc_err("MC_LF_W down limit 0xb809945C=%x\n", IoReg_Read32(MC_DMA_MC_LF_DMA_WR_Rule_check_low_reg));
	//MC_HF_W uplimit_addr
	rtd_pr_vsc_err("MC_HF_W up limit 0xb80994D0=%x\n", IoReg_Read32(MC_DMA_MC_HF_DMA_WR_Rule_check_up_reg));
	//MC_HF_W downlimit_addr
	rtd_pr_vsc_err("MC_HF_W down limit 0xb80994D8=%x\n", IoReg_Read32(MC_DMA_MC_HF_DMA_WR_Rule_check_low_reg));
	//MC_LF_I_R uplimit_addr
	rtd_pr_vsc_err("MC_LF_I_R up limit 0xb809AE14=%x\n", IoReg_Read32(MC_DMA_MC_LF_I_DMA_RD_Rule_check_up_reg));
	//MC_LF_I_R downlimit_addr
	rtd_pr_vsc_err("MC_LF_I_R down limit 0xb809AE18=%x\n", IoReg_Read32(MC_DMA_MC_LF_I_DMA_RD_Rule_check_low_reg));
	//MC_HF_I_R uplimit_addr
	rtd_pr_vsc_err("MC_HF_I_R up limit 0xb809AE34=%x\n", IoReg_Read32(MC_DMA_MC_HF_I_DMA_RD_Rule_check_up_reg));
	//MC_HF_I_R downlimit_addr
	rtd_pr_vsc_err("MC_HF_I_R down limit 0xb809AE38=%x\n", IoReg_Read32(MC_DMA_MC_HF_I_DMA_RD_Rule_check_low_reg));
	//MC_LF_P_R uplimit_addr
	rtd_pr_vsc_err("MC_LF_P_R up limit 0xb809AE54=%x\n", IoReg_Read32(MC_DMA_MC_LF_P_DMA_RD_Rule_check_up_reg));
	//MC_LF_P_R downlimit_addr
	rtd_pr_vsc_err("MC_LF_P_R down limit 0xb809AE58=%x\n", IoReg_Read32(MC_DMA_MC_LF_P_DMA_RD_Rule_check_low_reg));
	//MC_HF_P_R uplimit_addr
	rtd_pr_vsc_err("MC_HF_P_R up limit 0xb809AE74=%x\n", IoReg_Read32(MC_DMA_MC_HF_P_DMA_RD_Rule_check_up_reg));
	//MC_HF_P_R downlimit_addr
	rtd_pr_vsc_err("MC_HF_P_R down limit 0xb809AE78=%x\n", IoReg_Read32(MC_DMA_MC_HF_P_DMA_RD_Rule_check_low_reg));

	//b8099414~b8099450 (LF_WDMA)
	for (i = MC_DMA_MC_LF_WDMA_MSTART0_reg; i <=MC_DMA_MC_LF_WDMA_MEND7_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b8099484~b80994C0 (HF_WDMA)
	for (i = MC_DMA_MC_HF_WDMA_MSTART0_reg; i <=MC_DMA_MC_HF_WDMA_MEND7_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c000~b809c02c
	for (i = KME_DM_TOP0_KME_00_START_ADDRESS0_reg; i <=KME_DM_TOP0_KME_00_END_ADDRESS5_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c27c~b809c288
	for (i = KME_DM_TOP2_KME_00_START_ADDRESS6_reg; i <=KME_DM_TOP2_KME_00_END_ADDRESS7_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c100~b809c10c
	for (i = KME_DM_TOP1_KME_DM_TOP1_00_reg; i <=KME_DM_TOP1_KME_DM_TOP1_0C_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c124~b809c130
	for (i = KME_DM_TOP1_KME_DM_TOP1_24_reg; i <=KME_DM_TOP1_KME_DM_TOP1_30_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c148~b809c154
	for (i = KME_DM_TOP1_KME_DM_TOP1_48_reg; i <=KME_DM_TOP1_KME_DM_TOP1_54_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c16c~b809c178
	for (i = KME_DM_TOP1_KME_DM_TOP1_6C_reg; i <=KME_DM_TOP1_KME_DM_TOP1_78_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c200~b809c204
	for (i = KME_DM_TOP2_MV01_START_ADDRESS0_reg; i <=KME_DM_TOP2_MV01_END_ADDRESS0_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c214~b809c218
	for (i = KME_DM_TOP2_MV02_START_ADDRESS11_reg; i <=KME_DM_TOP2_MV02_END_ADDRESS0_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c22c~b809c230
	for (i = KME_DM_TOP2_MV04_START_ADDRESS1_reg; i <=KME_DM_TOP2_MV04_END_ADDRESS0_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c22c~b809c238
	for (i = KME_DM_TOP2_MV04_START_ADDRESS1_reg; i <=KME_DM_TOP2_MV04_END_ADDRESS1_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c0d8~b809c0dc
	for (i = KME_DM_TOP0_MV04_START_ADDRESS2_reg; i <=KME_DM_TOP0_MV04_END_ADDRESS2_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809c248~b809c254
	for (i = KME_DM_TOP2_MV05_START_ADDRESS0_reg; i <=KME_DM_TOP2_MV05_END_ADDRESS1_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809b70c~b809b718
	for (i = ME_SHARE_DMA_ME1_WDMA0_MSTART0_reg; i <=ME_SHARE_DMA_ME1_WDMA0_MEND1_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}
	//b809b728~b809b73c
	for (i = ME_SHARE_DMA_ME1_WDMA1_MSTART0_reg; i <=ME_SHARE_DMA_ME1_WDMA1_MEND2_reg; i=i+4)
	{
		rtd_pr_vsc_err("%x=%x\n", i, IoReg_Read32(i));
	}

	IoReg_SetBits(MC_DMA_MC_WDMA_DB_CTRL_reg,_BIT1);
	IoReg_SetBits(MC_DMA_MC_RDMA_DB_CTRL_reg,_BIT1);
	IoReg_SetBits(PQC_PQDC_MC_PQ_DECMP_DB_CTRL_reg,_BIT1);
	IoReg_SetBits(PQC_PQDC_MC_PQ_CMP_DB_CTRL_reg,_BIT1);
	IoReg_SetBits(LBMC_LBMC_EC_reg,_BIT1);
#endif
}

#endif
/******************DCMT declare callback func******************/
DCMT_DEBUG_INFO_DECLARE(sb2_di_mdscpu, sb2_di_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_m_cap_mdscpu, sb2_m_cap_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info);
DCMT_DEBUG_INFO_DECLARE(memc_mdscpu, memc_debug_info);

int vsc_init_module(void)
{
	int result;
  	int devno;
	dev_t dev = 0;
    mdomain_cap_smooth_tog_ctrl_0_RBUS mdomain_cap_smooth_tog_ctrl_0_reg;

#if IS_ENABLED(CONFIG_RTK_KDRV_DC_MEMORY_TRASH_DETCTER)
	/******************DCMT register callback func in init flow******************/
	DCMT_DEBUG_INFO_REGISTER(sb2_di_mdscpu, sb2_di_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_di_mdscpu,sb2_di_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_m_cap_mdscpu, sb2_m_cap_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_m_cap_mdscpu, sb2_m_cap_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(memc_mdscpu, memc_debug_info);
	rtd_pr_vsc_debug("DCMT_DEBUG_INFO_REGISTER(memc_mdscpu, memc_debug_info)\n");
#endif
	rtd_pr_vsc_debug("\n\n\n\n *****************  vsc init module  *********************\n\n\n\n");
	if (vsc_major) {
		dev = MKDEV(vsc_major, vsc_minor);
		result = register_chrdev_region(dev, vsc_nr_devs, VSC_DEVICE_NAME);
	} else {
		result = alloc_chrdev_region(&dev, vsc_minor, vsc_nr_devs,VSC_DEVICE_NAME);
		vsc_major = MAJOR(dev);
	}
	if (result < 0) {
		rtd_pr_vsc_debug(KERN_WARNING "vsc: can't get major %d\n", vsc_major);
		return result;
	}

	rtd_pr_vsc_debug("vsc init module major number = %d\n", vsc_major);

	vsc_class = class_create(THIS_MODULE,VSC_DEVICE_NAME);

	if (IS_ERR(vsc_class))
	{
		rtd_pr_vsc_debug("scalevsc: can not create class...\n");
		result = PTR_ERR(vsc_class);
		goto fail_class_create;
	}

	vsc_class->devnode = (void *)vsc_devnode;

	vsc_platform_devs = platform_device_register_simple(VSC_DEVICE_NAME, -1, NULL, 0);

	if((result = platform_driver_register(&vsc_device_driver)) != 0){
		rtd_pr_vsc_debug("scalevsc: can not register platform driver...\n");
		result = -ENOMEM;
		goto fail_platform_driver_register;
	}

    devno = MKDEV(vsc_major, vsc_minor);
    cdev_init(&vsc_cdev, &vsc_fops);
    vsc_cdev.owner = THIS_MODULE;
   	vsc_cdev.ops = &vsc_fops;
	result = cdev_add (&vsc_cdev, devno, 1);
	if (result<0)
	{
		rtd_pr_vsc_debug("scalevsc: can not add character device...\n");
		goto fail_cdev_init;
	}

    device_create(vsc_class, NULL, MKDEV(vsc_major, 0), NULL, VSC_DEVICE_NAME);
   	sema_init(&VSC_Semaphore, 1);
	sema_init(&SetMainOutPutRegion_Semaphore, 1);
	sema_init(&Main_ResetMode_Semaphore, 1);
	sema_init(&DM_HDR_Semaphore, 1);
	sema_init(&Force_Run_Idma_Semaphore, 1);
	sema_init(&Low_Delay_Semaphore, 1);
	sema_init(&Memc_Realcinema_Semaphore, 1);
	sema_init(&Iv2dv_Slow_Tuning_Semaphore, 1);
	sema_init(&VPQ_ld_running_Semaphore, 1);
	sema_init(&VPQ_DeXC_MEM_Semaphore, 1);
	sema_init(&Double_buffer_Semaphore, 1);
	sema_init(&GameMode_Check_Semaphore, 1);
	sema_init(&muteoff_cb_sem, 1);
    sema_init(&HDMI_4K120_MEMORY_PROTECTION_Semaphore, 1);////For 4k120 se buffer protection
	sema_init(&GameMode_SCALER_SYNC_Semaphore, 1);//initial GameMode_SCALER_SYNC_Semaphore
	//sema_init(&delay_info_cb_sem, 1);
	sema_init(&set_vsc_film_mode_semaphore, 1);
	sema_init(&DATA_ACCESS_DEBUG_Semaphore, 1);//initial DATA_ACCESS_DEBUG_Semaphore
	sema_init(&SUB_DATA_ACCESS_DEBUG_Semaphore, 1);//initial DATA_ACCESS_DEBUG_Semaphore
    mutex_init(&gamemode_fixlastline_mutex);
	main_mdomain_ctrl_semaphore_init();//init Main_Mdomain_ctrl_Semaphore
#ifdef CONFIG_SUPPORT_SRC_ADC
	init_scaler_verifymode_semaphore();//initial scaler verify mode ctrl related semaphore
#endif
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	init_dolby_vision_dm_path_sem();
#endif

#ifdef CONFIG_HDR_SDR_SEAMLESS
	sema_init(&HDR_Setting_Semaphore, 1);

#ifdef CONFIG_HDR_SDR_SEAMLESS
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	initial_i3ddma_reg_Semaphore();//init i3ddma_reg_Semaphore
#endif
#endif

#endif
#ifdef CONFIG_DUAL_CHANNEL
	sema_init(&SetSubOutPutRegion_Semaphore, 1);
	sema_init(&Sub_ResetMode_Semaphore, 1);
#endif
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
	sema_init(&Orbit_algo_Semaphore, 1);
#endif
	sema_init	(&I2RND_Semaphore, 1);
	sema_init(&vsc_src_verify_num_ctrl_sem, 1);//initial the Semaphore for vsc source verify
	sema_init	(&I2RND_display_Semaphore, 1);
	forcebg_semaphore_init();//Init force semaphore
	DI_semaphore_init();//Init force semaphore
	initial_sub_window_ctrl_semaphore();//initial sub window ctrl semaphore

	DbgSclrFlgTkr.VSC_Device_Init_Done = TRUE;
	PcbSource_Init();
	drvif_memory_init();
	create_vsc_tsk();/*Create VSC task*/
	/*Panel_LVDS_To_Hdmi_Converter_Parameter();*/
#ifdef BRING_UP_AUTO_FLOW
	create_bring_up_vsc_tsk();/*Create bring up vsc tsk*/
#endif
	create_forcebg_tsk();//Create forcebg task
	create_fixlast_line_tsk(); //Create fix last line tsk
	create_localDimmingDemoCtrl_tsk();
	create_game_mode_unmute_tsk(); //Create game mode unmute tsk
	create_variable_refresh_rate_tsk();
#ifdef CONFIG_DUMP_REGISTER
	create_dump_register_vsc_tsk();
#endif
#ifdef CONFIG_SUPPORT_SRC_ADC
	create_scaler_verify_tsk();//creat scaler verify task
#endif
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
	create_arc_control_tsk();//create arc control tsk
#endif
#ifdef ENABLE_SMOOTHTOGGLE_TEST
	create_smt_test_tsk();
#endif
	create_vsc_status_debug_tsk();//for debug using
	create_film_mode_change_task();
	create_hdmi_4k120_se_task();

#if 1//FIXME @Crixus for K3L bringup
	IoReg_Write32(SYS_REG_SYS_CLKEN2_reg, _BIT24 | _BIT25 | _BIT0);
 	IoReg_Write32(SYS_REG_SYS_SRST2_reg, _BIT24 | _BIT25 | _BIT0);
#endif

#ifdef BRING_UP_K4L_TEST
       create_new_game_mode_tsk();//20170524 pinyen create new game mode tsk
#endif

	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
	// dump Scaler frame CRC info
	rtkscaler_dump_init();
#endif

sema_init(&new_input_output_main_sem, 1);//for main path new input out ap parameter semaphore
#ifdef CONFIG_DUAL_CHANNEL
sema_init(&new_input_output_sub_sem, 1);//for sub path new input out ap parameter semaphore
#endif
    sema_init(&vsc_initial_ctrl_semaphore, 1);//for call  rtk_hal_vsc_initialize use

    //pm_runtime_forbid(&vsc_platform_devs->dev);
	//pm_runtime_set_active(&vsc_platform_devs->dev);//runtime PM to set active
	//pm_runtime_enable(&vsc_platform_devs->dev);//enable runtime PM
#ifdef CONFIG_RTK_LOW_POWER_MODE
	rtk_lpm_add_device(&vsc_platform_devs->dev);
#endif

    mdomain_cap_smooth_tog_ctrl_0_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Smooth_tog_ctrl_0_reg);
	mdomain_cap_smooth_tog_ctrl_0_reg.in2_pqc_clken = 0; // 1: disable
	IoReg_Write32(MDOMAIN_CAP_Smooth_tog_ctrl_0_reg, mdomain_cap_smooth_tog_ctrl_0_reg.regValue);

	return 0;	//success

fail_cdev_init:
	platform_driver_unregister(&vsc_device_driver);
fail_platform_driver_register:
	platform_device_unregister(vsc_platform_devs);
	vsc_platform_devs = NULL;
	class_destroy(vsc_class);
fail_class_create:
	vsc_class = NULL;
	unregister_chrdev_region(vsc_devno, 1);
	return result;
}



void __exit vsc_cleanup_module(void)
{
	dev_t devno = MKDEV(vsc_major, vsc_minor);
	rtd_pr_vsc_debug("rtice clean module vsc_major = %d\n", vsc_major);
	delete_vsc_tsk();/*Delete VSC task*/
	delete_forcebg_tsk();
	delete_fix_lastline_tsk();
	delete_localDimmingDemoCtrl_tsk();
	delete_game_mode_unmute_tsk();
	delete_film_mode_change_task();
	delete_hdmi_4k120_se_task();
	delete_vsc_status_debug_tsk();
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
	delete_arc_control_tsk();//delete arc control tsk
#endif

#ifdef BRING_UP_AUTO_FLOW
	delete_bring_up_vsc_tsk();/*Delete bring up vsc tsk*/
#endif
#ifdef CONFIG_DUMP_REGISTER
	delete_dump_register_vsc_tsk();
#endif
#ifdef ENABLE_SMOOTHTOGGLE_TEST
	delete_smt_test_tsk();
#endif

  	device_destroy(vsc_class, MKDEV(vsc_major, 0));
  	class_destroy(vsc_class);
	vsc_class = NULL;
	cdev_del(&vsc_cdev);
   	/* device driver removal */
	if(vsc_platform_devs) {
		platform_device_unregister(vsc_platform_devs);
		vsc_platform_devs = NULL;
	}
  	platform_driver_unregister(&vsc_device_driver);
	/* cleanup_module is never called if registering failed */
	unregister_chrdev_region(devno, vsc_nr_devs);
	DbgSclrFlgTkr.VSC_Device_Init_Done = FALSE;
	drvif_memory_release();
}
struct semaphore* get_vsc_semaphore(void)
{
	return &VSC_Semaphore;
}
struct semaphore* get_force_i3ddma_semaphore(void)
{
	return &Force_Run_Idma_Semaphore;
}

unsigned char Get_AVD_display(unsigned char display)
{

	if (Get_DisplayMode_Src(display) == VSC_INPUTSRC_AVD)
		return TRUE;
	else
		return FALSE;
}


unsigned char VSC_Check_AVD_Connected(void)
{
	if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD
	  ||Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void fw_scalerip_set_di_gamemode_flag(unsigned char bflag)
{
	if(DbgSclrFlgTkr.DI_low_delay_flag != bflag) {

		down(&Low_Delay_Semaphore);
		DbgSclrFlgTkr.DI_low_delay_flag = bflag;
		up(&Low_Delay_Semaphore);

	}
}


unsigned char fw_scalerip_get_di_gamemode_flag(void)
{
	return DbgSclrFlgTkr.DI_low_delay_flag;
}
#endif // #ifndef UT_flag
void fw_set_vsc_GameMode(unsigned char b_vscGameMode_OnOff)
{
	enable_VSC_GameMode = b_vscGameMode_OnOff;
}

unsigned char fw_get_vsc_GameMode(void)
{
	return enable_VSC_GameMode;
}
#ifndef UT_flag
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO

unsigned int ORBIT_TIME = 180;//default 3min
static unsigned char orbit_shift_index=0;
static unsigned char start_orbit_algo=FALSE;

/*api which have protect by forcebg_semaphore*/
void Scaler_start_orbit_algo(unsigned char b_enable)
{

//	if((b_enable != start_orbit_algo)&&(b_enable)){
//		Scaler_reset_orbit();
//	}
	rtd_pr_vsc_debug("start_orbit_algo(%d)\n", b_enable);
	start_orbit_algo = b_enable;
}

unsigned char Scaler_get_orbit_algo_status(void)
{
	if(vbe_disp_get_orbit()== TRUE)
		return start_orbit_algo;
	else
		return FALSE;
}
/*api which have protect by forcebg_semaphore*/
void Scaler_reset_orbit(void)
{
	rtd_pr_vsc_debug("Scaler_reset_orbit\n");

	down(&Orbit_algo_Semaphore);
	orbit_shift_index = 0;
	vbe_disp_orbit_position_update(0xff, 0); // force update

	if (!OrbitTimerList.function)
		Scaler_Orbit_Timer_Init();

	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
	up(&Orbit_algo_Semaphore);
}

void force_change_orbit_timer_time(void)
{
	down(&Orbit_algo_Semaphore);
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
	up(&Orbit_algo_Semaphore);
}
void OrbitTimer_Info_update(unsigned char force_update)
{//orbit timer inof update
    //down(&Orbit_algo_Semaphore);
    if(!force_update)
	{
		if(Scaler_get_orbit_algo_status() == TRUE){
			if(orbit_shift_index < vbe_disp_orbit_get_max_table_index()){
				orbit_shift_index++;
			}else{
				orbit_shift_index=0;
			}
		}else{
			orbit_shift_index=0;
		}
	}
	vbe_disp_orbit_position_update(orbit_shift_index,force_update);
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);;
}

void ScalerForceUpdateOrbit(unsigned char force_update)
{//timer unit is 10 ms
    unsigned long flags;//for spin_lock_irqsave
    spin_lock_irqsave(&orbit_timer_update_spinlock, flags);
    //saler_need_wait_orbit_ready = TRUE;
    OrbitTimer_Info_update(force_update);
    spin_unlock_irqrestore(&orbit_timer_update_spinlock, flags);

    rtd_pr_vsc_debug("ScalerForceUpdateOrbit\n");
}
unsigned char ScalerCheckOrbitFinish(void)
{
    SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
    orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
    if(!(orbit_shift_info->active_state))
        return TRUE;
    else
        return FALSE;
}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
void OrbitTimer(struct timer_list *t)
#else
void OrbitTimer()
#endif
{
    unsigned long flags;//for spin_lock_irqsave
    rtd_pr_vsc_debug("OrbitTimer\n");

    //down(&Orbit_algo_Semaphore);

    spin_lock_irqsave(&orbit_timer_update_spinlock, flags);
    OrbitTimer_Info_update(0);
    spin_unlock_irqrestore(&orbit_timer_update_spinlock, flags);
    //up(&Orbit_algo_Semaphore);
    //OrbitTimerList.expires = jiffies + HZ;
    //add_timer(&OrbitTimerList);
}


void Scaler_Orbit_Timer_Init(void)
{
	rtd_pr_vsc_debug("Scaler_Orbit_Timer_Init\n");

	g_ucTimerInitCount++;

	if (timer_pending(&OrbitTimerList))
	{
		rtd_pr_vsc_emerg("Error! Scaler_Orbit_Timer_Init more than twice. g_ucTimerInitCount=%d\n", g_ucTimerInitCount);
		dump_stack();

		return;
	}

	BUG_ON(timer_pending(&OrbitTimerList));

#if 0
	/* timer init*/
	init_timer(&OrbitTimerList);
	OrbitTimerList.data = ((unsigned long) 0);
	OrbitTimerList.function = (void *)OrbitTimer;
	OrbitTimerList.expires = jiffies + ORBIT_TIME*HZ;
	/*add timer*/
	add_timer(&OrbitTimerList);
#else
	/** If only 1 instance is allowed, using mod_timer().
	 * Otherwise, add_timer() will trap the occurance of racing,
	 * with built-in timer_pending() check.
	 **/
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);

    if(Get_DISPLAY_PANEL_OLED_TYPE()
            && (Get_DISPLAY_PANEL_CUSTOM_INDEX() != VBY_ONE_PANEL_KONKA_OLED_4K2K_120HZ_1S_16L))
    {
        HAL_VBE_DISP_OLED_SetOrbit(_ENABLE, _VBE_PANEL_ORBIT_JUSTSCAN_MODE);
    }
#endif
}

void Scaler_Orbit_Timer_Delete(void)
{
	rtd_pr_vsc_debug("Scaler_Orbit_Timer_Delete\n");
	/* delete timer */
	del_timer_sync(&OrbitTimerList);
}
#endif


//this is for verify mode used
static KADP_VSC_INPUT_SRC_INFO_T RecordModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};//record ap connect source for verify mode used
static unsigned char RecordVscInitdone_Flag = FALSE;
void verify_source_force_connect(void)
{//force connect ADC source
	KADP_VSC_INPUT_SRC_INFO_T verifyInputsourceInfo = {KADP_VSC_INPUTSRC_ADC, 0 , 0};
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		RecordModeInputInfo = DisplayModeInputInfo;
		rtk_hal_vsc_Disconnect(VIDEO_WID_0, DisplayModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
		rtk_hal_vsc_close(VIDEO_WID_0);
	}
	if(VscInitdone_Flag == FALSE)
	{
		RecordVscInitdone_Flag = FALSE;
		rtk_hal_vsc_initialize();
	}
	else
		RecordVscInitdone_Flag = TRUE;
	rtk_hal_vsc_open(VIDEO_WID_0);
	rtk_hal_vsc_Connect(VIDEO_WID_0, verifyInputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
}

void source_restore_from_verify_source(void)
{
	rtk_hal_vsc_Disconnect(VIDEO_WID_0, DisplayModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	rtk_hal_vsc_close(VIDEO_WID_0);
	//if(RecordVscInitdone_Flag == FALSE)
		//rtk_hal_vsc_uninitialize();
	if(RecordModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		rtk_hal_vsc_open(VIDEO_WID_0);
		rtk_hal_vsc_Connect(VIDEO_WID_0, RecordModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	}
}



//20171018 pinyen add to fix ML3RTANDN-418
void wait_game_mode_frame_delay_done(void)
{
       /*enter or exit game mode need to wait buffer write done to avoid garbage happen after unmute screen*/

       unsigned char game_mode_wait_frame = 1;// wait 1 frame to avoid gargabe happen when buffer switch
       rtd_pr_vsc_notice("[GameMode][M-doamin]wait buffer write done!!\n");

       //Update the M-domain last done
       drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, game_mode_wait_frame, TRUE);//game mode wait
}

#define SCALER_FRAMEDELAY_GAMEMODE_60 120  // 0.12 frame
#define SCALER_FRAMEDELAY_GAMEMODE_24 200  // 0.2 frame
#define PQ_HDMI_FRAMEDELAY_GAMEMODE 200    // 0.2 frame
#define PQ_VDEC_FRAMEDELAY_GAMEMODE 1000    // 1 frame
#define PQ_HDMI_FRAMEDELAY_NON_GAMEMODE_3A 1000 // 1 frame
#define PQ_HDMI_FRAMEDELAY_NON_GAMEMODE_5A 2000 // 2 frame
#define PQ_VDEC_FRAMEDELAY_NON_GAMEMODE_3A 1000 // 2 frame
#define PQ_VDEC_FRAMEDELAY_NON_GAMEMODE_5A 2000 // 2 frame
#endif // #ifndef UT_flag
extern unsigned char Scaler_MEMC_GetAVSyncDelay(void);
static unsigned int scaler_force_update_video_latency_flag = 0;

void scaler_set_force_update_video_latency(unsigned int bOnOff)
{
	scaler_force_update_video_latency_flag= bOnOff;
	rtd_pr_vsc_notice("[%s]force update video latency evnet = %d \n", __FUNCTION__, scaler_force_update_video_latency_flag);
}

unsigned int scaler_get_force_update_video_latency(void)
{
	return scaler_force_update_video_latency_flag;
}
#ifndef UT_flag
unsigned int rtk_scaler_get_lowdelay_value(void)
{
	unsigned int u32_voVtotal = 0;
	unsigned int u32_voHtotal = 0;
	unsigned int u32_idomain_freq = 0;
	unsigned int u32_idomain_framePeriod = 0;
	unsigned int u32_idomain_frameDelay = 0;
	unsigned int u32_iv2dv_delay = 0;
	unsigned int u32_iv2pv_delay = 0;
	unsigned int u32_golden_vsync_delay = 0;
	unsigned int u32_disp_dvsta_delay = 0;
	unsigned int u32_sfg_line_delay = 1;
	unsigned int u32_dvtotal = 0;
	unsigned int u32_ddomain_freq = 0;
	unsigned int u32_ddomain_framePeriod = 0;
	unsigned int u32_ddomain_frameDelay = 0;
	unsigned int u32_final_frameDelay = 0;
	unsigned int u32_ddomainToidomain_frameDelay = 0;

    // i domain delay
	u32_voVtotal = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN);
	u32_voHtotal = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN);
	u32_idomain_freq = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
	if(u32_idomain_freq == 0){
		rtd_pr_vsc_notice("[%s][ERROR] u32_idomain_freq = %d \n", __FUNCTION__, u32_idomain_freq);
		return 0xFFFFFFFF;
	}
	if(u32_voHtotal){
		u32_iv2pv_delay = (VODMA_VODMA_PVS0_Gen_get_iv2pv_dly(IoReg_Read32(VODMA_VODMA_PVS0_Gen_reg)))/u32_voHtotal;
	}else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_voHtotal=0 \n");
		return 0xFFFFFFFF;
	}

	rtd_pr_vsc_notice("[lowdelay]u32_iv2pv_delay = %d (lines)\n", u32_iv2pv_delay);
	//Game mode calculate iv2dv phase error
	u32_iv2dv_delay = drv_GameMode_decided_iv2dv_delay_new_mode();
	//if compression enable, need to add margin. @Crixus 20170605
	if(dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY))
		u32_iv2dv_delay = drv_GameMode_iv2dv_delay_compress_margin(u32_iv2dv_delay);
	rtd_pr_vsc_notice("[lowdelay]u32_iv2dv_delay = %d (lines)\n", u32_iv2dv_delay);

	if(u32_voVtotal){
		u32_idomain_frameDelay = ((u32_iv2pv_delay+u32_iv2dv_delay)*1000)/u32_voVtotal;
	}else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_voVtotal=0 \n");
		return 0xFFFFFFFF;
	}

	//d domain delay
	u32_golden_vsync_delay = PPOVERLAY_MEMCDTG_CONTROL3_get_dtgm2goldenpostvs_line(IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg));
	u32_disp_dvsta_delay = PPOVERLAY_DV_DEN_Start_End_get_dv_den_sta(IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg));
	u32_dvtotal = PPOVERLAY_DV_total_get_dv_total(IoReg_Read32(PPOVERLAY_DV_total_reg))+1;
	u32_ddomain_freq =Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DTG_MASTER_V_FREQ);
	if(Get_DISPLAY_REFRESH_RATE() >= 120){
		if(u32_ddomain_freq < 144)
			u32_ddomain_freq = u32_ddomain_freq*2;
	}
	if(u32_dvtotal){
		u32_ddomain_frameDelay = ((u32_golden_vsync_delay+u32_disp_dvsta_delay+u32_sfg_line_delay)*1000)/u32_dvtotal;
	}

	if(u32_idomain_freq)
		u32_idomain_framePeriod = (10000000/u32_idomain_freq);	//ms * 1000000
	else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_idomain_framePeriod=0 \n");
		return 0xFFFFFFFF;
	}

	if(u32_ddomain_freq)
		u32_ddomain_framePeriod = 1000000/u32_ddomain_freq;
	else{
		rtd_pr_vsc_notice("[lowdelay]Error! u32_ddomain_freq=0 \n");
		return 0xFFFFFFFF;
	}

	if(u32_idomain_framePeriod && u32_dvtotal)
		u32_ddomainToidomain_frameDelay = (u32_ddomain_frameDelay *
		(u32_ddomain_framePeriod*u32_voVtotal))/ (u32_idomain_framePeriod*u32_dvtotal);

	u32_final_frameDelay = u32_idomain_frameDelay + u32_ddomainToidomain_frameDelay;

	rtd_pr_vsc_notice("[lowdelay] i=%d, d=%d , d2i=%d (0.001 frames)\n", u32_idomain_frameDelay,u32_ddomain_frameDelay, u32_ddomainToidomain_frameDelay);

	rtd_pr_vsc_notice("[lowdelay] final %d (0.001 frames)\n", u32_final_frameDelay);

	return u32_final_frameDelay; //unit : i domian delay framea * 1000
}

unsigned int rtk_scaler_calc_current_video_path_latency(void)
{
		unsigned char b_gamemode = 0;
		unsigned int u32_mdomainFrameBuf_delay = 0;
		unsigned int u32_scalerFrameBuf_delay = 0;
		unsigned int u32_pqFrameBuf_delay = 0;
		//unsigned int u32_totalVideoPathFrame_delay = 0;
		unsigned int u32_scaler_delaytime = 0;
		unsigned int u32_pq_delaytime = 0;
		unsigned int u32_totalVideoPath_delaytime = 0;
		unsigned int u32_inputFramePeriod = 0;
		unsigned int u32_i3dmaFrameBuf_delay = 0;
		static unsigned int print_count = 0;
		mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
		//vodma_vodma_i2rnd_fifo_th_RBUS vodma_vodma_i2rnd_fifo_th_Reg;
		unsigned int u32_vfreq = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
		b_gamemode = drv_memory_get_low_delay_game_mode_dynamic() && get_new_game_mode_condition();
		//vodma_vodma_i2rnd_fifo_th_Reg.regValue = IoReg_Read32(VODMA_vodma_i2rnd_fifo_th_reg);
		mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
		//i3ddma check buffer num
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_VDEC)||(Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_JPEG)){
			u32_i3dmaFrameBuf_delay = 0;
		}else{
			if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY) == TRUE){
				//go through i3ddma
				if(VODMA_VODMA_V1_SEQ_3D_L1_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L1_reg)) ==
					VODMA_VODMA_V1_SEQ_3D_L2_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L2_reg))){
					//i3ddma single buffer
					u32_i3dmaFrameBuf_delay = 0;
				}else{
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))
						u32_i3dmaFrameBuf_delay = 2000; // hdmi run timing fsync, use i3/vo tracking, 2 buffer
					else
						u32_i3dmaFrameBuf_delay = 1000;
				}
			}else{
				u32_i3dmaFrameBuf_delay = 0;
			}
		}
#else
	#if defined (CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT) || defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)))
	#endif
	{
		if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY) == TRUE){
			//go through i3ddma
			if(VODMA_VODMA_V1_SEQ_3D_L1_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L1_reg)) ==
				VODMA_VODMA_V1_SEQ_3D_L2_get_st_adr(IoReg_Read32(VODMA_VODMA_V1_SEQ_3D_L2_reg))){
				//i3ddma single buffer
				u32_i3dmaFrameBuf_delay = 0;
			}else{
				u32_i3dmaFrameBuf_delay = 1000;
			}
		}else{
			u32_i3dmaFrameBuf_delay = 0;
		}
	}
#endif
		//mdomain buffer number
		if(MDOMAIN_DISP_Disp_main_enable_get_main_disp_en(IoReg_Read32(MDOMAIN_DISP_Disp_main_enable_reg))){
			//mdomain enable
			if(mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en){
				u32_mdomainFrameBuf_delay = (mdomain_disp_ddr_mainctrl_reg.main_cap2disp_distance)*1000;
			}else{
				if(mdomain_disp_ddr_mainctrl_reg.main_double_en){
					u32_mdomainFrameBuf_delay = 1000;
				}else{
					u32_mdomainFrameBuf_delay = 0;
				}
			}
		}else{
			//mdomain disable
			u32_mdomainFrameBuf_delay = 0;
		}
		if(b_gamemode){
			if(get_new_game_mode_condition()){
				//rtd_pr_vsc_notice("[calc_latency] game mode condition\n");

				if(((u32_vfreq > 235) && (u32_vfreq < 255)) ||
				   ((u32_vfreq > 295) && (u32_vfreq < 305)))
				{
#ifdef CONFIG_FORCE_RUN_I3DDMA
					//24/25/30hz
					if(u32_i3dmaFrameBuf_delay!=0){
						rtd_pr_vsc_notice("[WARN][%d] i3dma not single buffer.(%d)\n", __LINE__,u32_i3dmaFrameBuf_delay);
					}
#endif
					if(u32_mdomainFrameBuf_delay!=0){
						rtd_pr_vsc_notice("[WARN][%d] mdomain not single buffer.(%d)\n", __LINE__,u32_mdomainFrameBuf_delay);
					}else{
						u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_24;
					}
				}else if(((u32_vfreq > 475) && (u32_vfreq < 485)) ||
						 ((u32_vfreq > 495) && (u32_vfreq < 505)) ||
						 ((u32_vfreq > 595) && (u32_vfreq < 605)) ||
						 ((u32_vfreq > 995) && (u32_vfreq< 1005)) ||
						 ((u32_vfreq > 1195) && (u32_vfreq < 1205)))
				{
#ifdef CONFIG_FORCE_RUN_I3DDMA					//48/50/60hz
					if(u32_i3dmaFrameBuf_delay!=0){
						rtd_pr_vsc_notice("[WARN][%d] i3dma not single buffer.(%d)\n", __LINE__,u32_i3dmaFrameBuf_delay);
					}
#endif
					if(u32_mdomainFrameBuf_delay!=0){
						rtd_pr_vsc_notice("[WARN][%d] mdomain not single buffer.(%d)\n", __LINE__,u32_mdomainFrameBuf_delay);
					}else{
						u32_mdomainFrameBuf_delay = rtk_scaler_get_lowdelay_value();
						if(u32_mdomainFrameBuf_delay == 0xffffffff)
							rtd_pr_vsc_err("[calc_latency]ERR!! rtk_scaler_get_lowdelay_value error.\n");
							//error handle
							return 0;
					}
				}
	/*
				// 120Hz VRR panel
				if((Get_DISPLAY_REFRESH_RATE() >= 120) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) &&
					(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())&& ( Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_DISP_LEN)== _DISP_LEN))
				{
					if(vbe_disp_get_VRR_device_max_framerate()> 1190){ // VRR 120hz
						u32_mdomainFrameBuf_delay = rtk_scaler_get_lowdelay_value();
						if(u32_mdomainFrameBuf_delay == 0xffffffff)
							u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_60;
					}else{	// VRR 60hz
						u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_24;
					}

				}
	*/
			}
			else{
				if(u32_mdomainFrameBuf_delay == 0){
					// data fsync scaler delay
					u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_60;
				}
			}

		}
		else{	// non game mode
			//rtd_pr_vsc_notice("[calc_latency] non game mode condition\n");

			if(u32_mdomainFrameBuf_delay == 0){
				// data fsync scaler delay
				u32_mdomainFrameBuf_delay = SCALER_FRAMEDELAY_GAMEMODE_60;
			}

		}

		// PQ delay
		if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE)){	 //interlace
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_VDEC)||(Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_JPEG)){
				if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>960)
					u32_pqFrameBuf_delay = PQ_VDEC_FRAMEDELAY_NON_GAMEMODE_3A;		//3A
				else
					u32_pqFrameBuf_delay = PQ_VDEC_FRAMEDELAY_NON_GAMEMODE_5A; //5A
			}else{
				if(b_gamemode && get_new_game_mode_condition())
					u32_pqFrameBuf_delay = PQ_HDMI_FRAMEDELAY_GAMEMODE;
				else{
					if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>960)
						u32_pqFrameBuf_delay = PQ_HDMI_FRAMEDELAY_NON_GAMEMODE_3A;
					else
						u32_pqFrameBuf_delay = PQ_HDMI_FRAMEDELAY_NON_GAMEMODE_5A;
					}
			}
		}else{
			u32_pqFrameBuf_delay = 0;
		}

		u32_scalerFrameBuf_delay = u32_mdomainFrameBuf_delay + u32_i3dmaFrameBuf_delay;
		//u32_totalVideoPathFrame_delay = u32_scalerFrameBuf_delay + u32_pqFrameBuf_delay;

		if(u32_vfreq){
			u32_inputFramePeriod = 100000/u32_vfreq;
		}else{
			rtd_pr_vsc_err("[calc_latency]ERR!! SLR_INPUT_V_FREQ cannot be zero.\n");
			return 0;
		}

		//rouding
		if(((u32_scalerFrameBuf_delay*u32_inputFramePeriod)%1000)>=500){
			u32_scaler_delaytime = (u32_scalerFrameBuf_delay*u32_inputFramePeriod)/1000+1;
		}else{
			u32_scaler_delaytime = (u32_scalerFrameBuf_delay*u32_inputFramePeriod)/1000;
		}
		//rouding
		if(((u32_pqFrameBuf_delay*u32_inputFramePeriod)%1000)>=500){
			u32_pq_delaytime = (u32_pqFrameBuf_delay*u32_inputFramePeriod)/1000+1;
		}else{
			u32_pq_delaytime = (u32_pqFrameBuf_delay*u32_inputFramePeriod)/1000;
		}
		//rtd_pr_vsc_notice("[calc_latency] delay	  : %d,%d,%d (0.1ms)\n", u32_i3dmaFrameBuf_delay, u32_mdomainFrameBuf_delay,u32_scalerFrameBuf_delay);
		//rtd_pr_vsc_notice("[calc_latency] iframePeriod: %d,%d (0.1ms)\n", u32_vfreq,u32_inputFramePeriod);
		//rtd_pr_vsc_notice("[calc_latency] scaler	  : %d (0.1ms)\n", u32_scaler_delaytime);
		//rtd_pr_vsc_notice("[calc_latency] pq		  : %d (0.1ms)\n", u32_pq_delaytime);
//#ifndef CONFIG_MEMC_BYPASS
		if(get_MEMC_bypass_status_refer_platform_model() == FALSE){
			//rtd_pr_vsc_notice("[calc_latency] memc		  : %d (0.1ms)\n", Scaler_MEMC_GetAVSyncDelay());
			u32_totalVideoPath_delaytime = u32_scaler_delaytime + u32_pq_delaytime + Scaler_MEMC_GetAVSyncDelay();
			rtd_pr_vsc_notice("[calc_latency] totalVideoDelayTime:%d (0.1ms)\n", u32_totalVideoPath_delaytime);
		}
		else {
//#else
			u32_totalVideoPath_delaytime = u32_scaler_delaytime + u32_pq_delaytime;
			if(print_count>=50){
				rtd_pr_vsc_notice("[calc_latency] iframePeriod: %d (0.1ms)\n", u32_inputFramePeriod);
				rtd_pr_vsc_notice("[calc_latency] scaler      : %d (0.1ms)\n", u32_scaler_delaytime);
				rtd_pr_vsc_notice("[calc_latency] pq          : %d (0.1ms)\n", u32_pq_delaytime);
#ifndef CONFIG_MEMC_NOTSUPPORT
				rtd_pr_vsc_notice("[calc_latency] memc        : %d (0.1ms)\n", Scaler_Vpqmemcdev_MEMC_GetAVSyncDelay());
#else
				rtd_pr_vsc_notice("[calc_latency] memc        : %d (0.1ms)\n", 0);
#endif
				rtd_pr_vsc_notice("[calc_latency] totalVideoDelayTime:%d (0.1ms)\n", u32_totalVideoPath_delaytime);
				print_count = 0;
			}else{
				print_count++;
			}
//#endif
		}
		return u32_totalVideoPath_delaytime;
}

unsigned int rtk_hal_vsc_scaler_check_video_delay(VIDEO_WID_T wid, unsigned int *current_video_delay)
{
	unsigned char forcebg_status = 1;
	unsigned char timinglock_status = 0;
	unsigned char fsync_en = (PPOVERLAY_Display_Timing_CTRL1_get_disp_fsync_en(IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg)));
	unsigned char fsync_ok_status = (PPOVERLAY_Display_Timing_CTRL1_get_disp_fsync_en(IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg)));
	unsigned char fll_status = (PPOVERLAY_Display_Timing_CTRL1_get_disp_fix_last_line_new(IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg)));

	forcebg_status = PPOVERLAY_Main_Display_Control_RSV_get_m_force_bg(IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg));
	timinglock_status = (fsync_en && fsync_ok_status) || fll_status;

	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
		*current_video_delay = 0;//no active return no delay
		return TRUE;
	}
	if((wid == SLR_MAIN_DISPLAY)&&(forcebg_status == 0)&& timinglock_status){	//disable forcebg
		*current_video_delay = rtk_scaler_calc_current_video_path_latency();
	}
	return TRUE;
}

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
// Dump VO frame CRC info to file
#ifndef CONFIG_KDRIVER_USE_NEW_COMMON

static int rtkscaler_dumpcrc_thread(void *arg)
{
	unsigned long magic, size, wr, rd;
	unsigned char *wrPtr, *rdPtr, *basePtr, *limitPtr;

	for (;;) {
		if (kthread_should_stop()) break;
		if (scalerfile_DumpCRC != 0 && scaler_DumpCRC_Config.enable) {
			SCALER_DUMP_BUFFER_HEADER *header;
			header = (SCALER_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
			magic = ntohl(header->magic) ;
			size  = ntohl(header->size) ;
			rd    = ntohl(header->rd) ;
			wr    = ntohl(header->wr) ;
			wrPtr = (unsigned char *)(scaler_g_pDumpCRC.Memory + wr - scaler_g_pDumpCRC.PhyAddr); /* make virtual address */
			rdPtr = (unsigned char *)(scaler_g_pDumpCRC.Memory + rd - scaler_g_pDumpCRC.PhyAddr); /* make virtual address */
			basePtr  = (unsigned char *)(scaler_g_pDumpCRC.Memory + sizeof(SCALER_DUMP_BUFFER_HEADER));
			size -= sizeof(SCALER_DUMP_BUFFER_HEADER);
			limitPtr = basePtr+ size;

                #if 0 // TEST
                    static unsigned long last_wr=0;
                    if(last_wr != wr){
                        rtd_pr_vsc_notice("[vo] Header %x, m=%x size=%x r(%x) w(%x)\n", (unsigned int)header, (unsigned int)magic, (unsigned int)size, (unsigned int)rd, (unsigned int)wr);
                        rtd_pr_vsc_notice("[vo] Ptr w(%x) r(%x) b(%x) (%x), offset=%x\n", (unsigned int)wrPtr, (unsigned int)rdPtr, (unsigned int)basePtr, (unsigned int)limitPtr, (unsigned int)f_offset_dumpcrc);
                        last_wr = wr;
                    }
                #endif

			if (wrPtr < rdPtr) {
				wrPtr = wrPtr + size;
			}

			if (wrPtr > rdPtr) {
				if (wrPtr > limitPtr) {
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, rdPtr, limitPtr -rdPtr) ;
					f_offset_dumpcrc += limitPtr -rdPtr ;
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, basePtr, wrPtr - limitPtr) ;
					f_offset_dumpcrc += wrPtr - limitPtr ;
				}
				else {
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, rdPtr, wrPtr - rdPtr) ;
					f_offset_dumpcrc += wrPtr - rdPtr ;
				}
				header->rd = htonl(wr) ;
                #if 0 // TEST
                         rtd_pr_vsc_notice("[vo] f_offset_dumpcrc=%x\n", (unsigned int)f_offset_dumpcrc);
                #endif
			}
		}

		msleep(100); /* sleep 10 ms */
	}

	/* rtd_pr_vsc_debug("rtkvdec_dumpes_thread break\n"); */
	rtd_pr_vsc_err("rtkscaler_dumpcrc_thread break\n");
	return 0;
}
#endif

#ifdef CONFIG_RTK_8KCODEC_INTERFACE
#include "kernel/rtk_codec_interface.h"
extern struct rtk_codec_interface *rtk_8k;
unsigned char send_srnn_real_size_to_slave(unsigned int ulWid, unsigned int ulLen)
{
    CODEC_SRNN_REAL_SIZE codeSrnnRealSize = {0, 0};

    codeSrnnRealSize.len = ulLen;
    codeSrnnRealSize.wid = ulWid;

    if(rtk_8k != NULL)
    {
        rtk_8k->vsc->R8K_VSC_SetSrnnRealSize(codeSrnnRealSize);
    }

    return 0;
}
#endif

static void rtkscaler_dump_init(void)
{
#ifndef CONFIG_ANDROID
	unsigned char default_file_name3[30] = "/tmp/video_dumpscalercrc.bin" ;
#else
	unsigned char default_file_name3[36] = "/data/data/video_dumpscalercrc.bin" ;
#endif

	scaler_DumpCRC_Config.enable = 0 ;
	scaler_DumpCRC_Config.mem_size = DUMP_ES_SIZE ;

#ifndef CONFIG_ANDROID
	memset((void *)scaler_DumpCRC_Config.file_name, '\0', FILE_NAME_SIZE );
	memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)default_file_name3, 21);
#else
	memset((void *)scaler_DumpCRC_Config.file_name, '\0', 27 + 1 );
	memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)default_file_name3, 27);
#endif

	scaler_g_pDumpCRC.Memory = scaler_g_pDumpCRC.PhyAddr = scaler_g_pDumpCRC.VirtAddr = 0 ;
	scaler_g_pDumpCRC_Send.Memory = scaler_g_pDumpCRC_Send.PhyAddr = scaler_g_pDumpCRC_Send.VirtAddr = 0 ;
}



int rtkscaler_dumpCRC_enable(const char *pattern, int length)
{
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	//unsigned long return_value ;
#endif
#ifndef CONFIG_KDRIVER_USE_NEW_COMMON
	VO_DUMP_BUFFER_HEADER *header;
	unsigned long vir_addr = 0;
#endif


	if (length > FILE_NAME_SIZE - 1) {
		rtd_pr_vsc_warn("rtkscaler: file name is too long(<%d).\n", FILE_NAME_SIZE - 1);
		return 0;
	}
	else if (length > 0) {
		memset((void *)scaler_DumpCRC_Config.file_name, '\0', length+1);
		memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)pattern, length);
	}

	rtd_pr_vsc_notice("rtkscaler: dumpes_file_name(%s)\n", scaler_DumpCRC_Config.file_name);

	if (scaler_DumpCRC_Config.enable) {
		rtd_pr_vsc_notice("rtkscaler: es dump already enable!\n");
		return 0 ;
	}

	scalerfile_DumpCRC = file_open((char *)(scaler_DumpCRC_Config.file_name), O_TRUNC | O_RDWR | O_CREAT,0x755) ;
	if (scalerfile_DumpCRC == 0) {
		rtd_pr_vsc_err("[%s %d]open log file fail\n",__FUNCTION__,__LINE__);
		return -ENOMEM;
	}

	/* allocate debug memory */
#ifndef CONFIG_KDRIVER_USE_NEW_COMMON
	  //#FixMe, 20190912
	vir_addr = (unsigned long)dvr_malloc_uncached_specific(sizeof(VO_RPC_DEBUG_MEMORY)+256, GFP_DCU1_LIMIT, (void **)(&scaler_g_pDumpCRC_Send.Memory));

	if (!vir_addr) {
		rtd_pr_vsc_err("[%s %d]alloc debug memory fail\n",__FUNCTION__,__LINE__);
		return -ENOMEM;
	}

	scaler_g_pDumpCRC_Send.PhyAddr = (unsigned long)dvr_to_phys((void*)vir_addr);
	scaler_g_pDumpCRC_Send.VirtAddr = vir_addr ;
	rtd_pr_vsc_notice("Alloc DVOCRCME v(%lx) p(%lx) vn(%lx)\n", vir_addr, scaler_g_pDumpCRC_Send.PhyAddr, scaler_g_pDumpCRC_Send.Memory);

	if ((scalerfile_DumpCRC != 0) && (scaler_DumpCRC_Config.mem_size > 0)) {
		/* alocate dump memory */
		vir_addr = (unsigned long)dvr_malloc_uncached_specific(scaler_DumpCRC_Config.mem_size, GFP_DCU1_LIMIT, (void **)(&scaler_g_pDumpCRC.Memory));
		if (!vir_addr) {
			vir_addr = scaler_g_pDumpCRC_Send.VirtAddr ;
			dvr_free((void*)vir_addr);
			rtd_pr_vsc_err("[%s %d]alloc debug memory fail\n",__FUNCTION__,__LINE__);
			return -ENOMEM;
		}
		scaler_g_pDumpCRC.PhyAddr = (unsigned long)dvr_to_phys((void*)vir_addr);
		scaler_g_pDumpCRC.VirtAddr = vir_addr ;

		rtd_pr_vsc_notice("Alloc DUMPVOME v(%lx) p(%lx) vn(%lx)\n", vir_addr, scaler_g_pDumpCRC.PhyAddr, scaler_g_pDumpCRC.Memory);

		/* setup dump es ring buffer header */
		header = (VO_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
		header->magic = htonl(0xdeadcafe) ;
		header->size = htonl(scaler_DumpCRC_Config.mem_size) ;
		header->rd = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(VO_DUMP_BUFFER_HEADER)) ;
		header->wr = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(VO_DUMP_BUFFER_HEADER)) ;

		*(unsigned long *)scaler_g_pDumpCRC_Send.Memory = htonl(scaler_g_pDumpCRC.PhyAddr) ;

		rtd_pr_vsc_notice("[scaler] Header %lx, m=%x size=%x r(%x) w(%x)\n", (unsigned long)header, header->magic, header->size, header->rd, header->wr);
	}
	else {
		rtd_pr_vsc_notice("rtkscaler: no allocate debug dump ring buffer!\n");
		return 0 ;
	}

	rtkscaler_dumpcrc_tsk = kthread_create(rtkscaler_dumpcrc_thread, &data, "rtkscaler_dumpcrc_thread");
	if (IS_ERR(rtkscaler_dumpcrc_tsk)) {
		rtkscaler_dumpcrc_tsk = NULL;
		return -1 ;
	}
	wake_up_process(rtkscaler_dumpcrc_tsk);

	scaler_DumpCRC_Config.enable = 1 ;
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	// FixMe, 20190920
	#if 0
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo, (unsigned long)scaler_g_pDumpCRC_Send.PhyAddr, _ENABLE, &return_value)){
            rtd_pr_vsc_err("rtkscaler: VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo fail %ld\n", return_value);
            rtkscaler_dumpCRC_disable();
            return -1;
       }
	#endif
#endif
#endif //CONFIG_KDRIVER_USE_NEW_COMMON
	return 0;
}


void rtkscaler_dumpCRC_disable(void)
{
#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	//unsigned long return_value ;
#endif
	int ret = 0;
	unsigned long vir_addr ;
	SCALER_DUMP_BUFFER_HEADER *header;

	if (!scaler_DumpCRC_Config.enable) {
		rtd_pr_vsc_notice("rtkvo: es dump not enable!\n");
		return ;
	}

	scaler_DumpCRC_Config.enable = 0 ;
	/* setup debug dump ring buffer header */
	header = (SCALER_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
	header->magic = htonl(0xdeadcafe) ;
	header->size = htonl(16) ;
	header->rd = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(SCALER_DUMP_BUFFER_HEADER)) ;
	header->wr = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(SCALER_DUMP_BUFFER_HEADER)) ;
	*(unsigned long *)scaler_g_pDumpCRC_Send.Memory = htonl(scaler_g_pDumpCRC.PhyAddr) ;

#if IS_ENABLED(CONFIG_RTK_KDRV_RPC)
	// FixMe, 20190920
	#if 0
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo, 0, 0, &return_value))
		rtd_pr_vsc_err("rtkscaler: VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo fail %ld\n", return_value);
	#endif
#endif
	if(rtkscaler_dumpcrc_tsk){
		ret = kthread_stop(rtkscaler_dumpcrc_tsk);
		if (!ret){
			rtd_pr_vsc_debug("rtkscaler dumpes thread stopped\n");
			rtkscaler_dumpcrc_tsk = NULL;
		}
	}else{
		rtd_pr_vsc_debug("rtkscaler dumpes thread stopped already\n");
	}
	f_offset_dumpcrc = 0 ;
	if (scaler_g_pDumpCRC.PhyAddr) {
		vir_addr = scaler_g_pDumpCRC.VirtAddr;
		dvr_free((void*)vir_addr);
		scaler_g_pDumpCRC.Memory = scaler_g_pDumpCRC.PhyAddr = scaler_g_pDumpCRC.VirtAddr = 0 ;
	}

	if (scaler_g_pDumpCRC_Send.PhyAddr) {
		vir_addr = scaler_g_pDumpCRC_Send.VirtAddr;
		dvr_free((void*)vir_addr);
		scaler_g_pDumpCRC_Send.Memory = scaler_g_pDumpCRC_Send.PhyAddr = scaler_g_pDumpCRC_Send.VirtAddr = 0 ;
	}

	if (scalerfile_DumpCRC)
		file_close(scalerfile_DumpCRC) ;
	scalerfile_DumpCRC = 0 ;
}
#endif

unsigned char Scaler_check_orbit_store_mode(void)
{
    SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
    orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);

    if(orbit_shift_info->shift_range_x == 64 && orbit_shift_info->shift_range_y == 32)
        return TRUE;
    else
        return FALSE;
}

#ifdef CONFIG_SUPPORT_SCALER_MODULE
// the module init/exit will be moved to scaler_module.c if scaler was built as a kernel module
#else
module_init(vsc_init_module);
module_exit(vsc_cleanup_module);
#endif
#endif // #ifndef UT_flag
